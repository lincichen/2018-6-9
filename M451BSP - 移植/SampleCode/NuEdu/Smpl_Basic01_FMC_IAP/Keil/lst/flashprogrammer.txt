; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\flashprogrammer.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\flashprogrammer.d --cpu=Cortex-M4.fp --apcs=interwork -L6969W -I..\..\..\..\Library\Device\Nuvoton\M451Series\Include -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\Library\NuEdu\inc -I.\zmodem -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -DDEBUG_ENABLE_SEMIHOST --omf_browse=.\obj\flashprogrammer.crf zmodem\FlashProgrammer.c]
                          THUMB

                          AREA ||i.putsec||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  putsec PROC
;;;104     */
;;;105    int putsec(char *buf, unsigned int n)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;106    {
;;;107    #if  1 //测试开关
;;;108    	unsigned int j;
;;;109    	unsigned int RamSource;
;;;110    	if(1 == ZmodemReceiveType){
000004  4f1d              LDR      r7,|L1.124|
000006  f04f3eff          MOV      lr,#0xffffffff
00000a  683a              LDR      r2,[r7,#0]  ; ZmodemReceiveType
00000c  2a01              CMP      r2,#1
00000e  d133              BNE      |L1.120|
;;;111    		//接收文件不能超过“FLASH空间256K - 引导程序空间15K = 应用程序空间496K，即0x40000-0x3c00=0x3c400”，否则会破坏FLASH其他数据
;;;112    //		if(rxbytes + n > 0x3c400)
;;;113    //			return ZMODEMERROR;
;;;114    		
;;;115    		RamSource = (uint32_t)buf;
;;;116    		for (j = 0; j < n; j += 4){
000010  2300              MOVS     r3,#0
000012  4694              MOV      r12,r2                ;110
000014  4c1a              LDR      r4,|L1.128|
000016  e02b              B        |L1.112|
                  |L1.24|
;;;117            	//判断是否到了新的一页起始处，此时擦除STM32内部FLASH另一新页
;;;118    			if(0 == (FlashDestination) % STM32_FLASH_PAGE_SIZE){
000018  687a              LDR      r2,[r7,#4]  ; FlashDestination
00001a  0555              LSLS     r5,r2,#21
00001c  d116              BNE      |L1.76|
00001e  2522              MOVS     r5,#0x22
000020  60e5              STR      r5,[r4,#0xc]
000022  6062              STR      r2,[r4,#4]
000024  f8c4c010          STR      r12,[r4,#0x10]
                  |L1.40|
000028  6925              LDR      r5,[r4,#0x10]
00002a  2d00              CMP      r5,#0
00002c  d1fc              BNE      |L1.40|
00002e  6825              LDR      r5,[r4,#0]
000030  066d              LSLS     r5,r5,#25
000032  d50b              BPL      |L1.76|
000034  6820              LDR      r0,[r4,#0]
000036  f0400040          ORR      r0,r0,#0x40
00003a  6020              STR      r0,[r4,#0]
00003c  4674              MOV      r4,lr
;;;119    				if (FMC_Erase(FlashDestination)) {
;;;120                printf("Erase failed on 0x%x\n", FlashDestination);
00003e  a011              ADR      r0,|L1.132|
000040  6879              LDR      r1,[r7,#4]  ; FlashDestination
000042  f7fffffe          BL       __2printf
;;;121                return -1;
000046  4620              MOV      r0,r4
                  |L1.72|
;;;122            }
;;;123    			}
;;;124    			/* Program the data received into STM32F10x Flash */
;;;125    			
;;;126    			FMC_Write(FlashDestination, *(uint32_t*)RamSource);
;;;127          if (*(uint32_t *)FlashDestination != *(uint32_t *)RamSource){
;;;128    				/* 比较失败，STM32内部FLASH字编程出错，End session */
;;;129    					return ZMODEMERROR;
;;;130    			}      
;;;131    			//下一编程位置和下一编程数据
;;;132          FlashDestination += 4;
;;;133          RamSource += 4;
;;;134        }
;;;135    	}else{
;;;136    		//错误文件标识
;;;137    		return ZMODEMERROR;
;;;138    	}	
;;;139    #endif
;;;140    	return ZMODEMOK;
;;;141    ////		unsigned int j;
;;;142    //// 		unsigned int RamSource;
;;;143    ////		static uint32_t FlashDestination=0x00004000;
;;;144    ////		RamSource = (uint32_t)buf;
;;;145    ////		for (j = 0; j < n; j += 4){
;;;146    ////        	//判断是否到了新的一页起始处，此时擦除STM32内部FLASH另一新页
;;;147    ////			if(0 == (FlashDestination) % STM32_FLASH_PAGE_SIZE){
;;;148    ////				if (FMC_Erase(FlashDestination)) {
;;;149    ////            printf("Erase failed on 0x%x\n", FlashDestination);
;;;150    ////            return -1;
;;;151    ////        }
;;;152    ////			}
;;;153    ////			/* Program the data received into STM32F10x Flash */
;;;154    ////			
;;;155    ////			FMC_Write(FlashDestination, *(uint32_t*)RamSource);
;;;156    ////      if (*(uint32_t *)FlashDestination != *(uint32_t *)RamSource){
;;;157    ////				/* 比较失败，STM32内部FLASH字编程出错，End session */
;;;158    ////					return ZMODEMERROR;
;;;159    ////			}
;;;160    ////	
;;;161    ////			printf("\n\r\n\r%x\n\r\n\r", *(uint32_t *)FlashDestination);
;;;162    ////			//下一编程位置和下一编程数据
;;;163    ////      FlashDestination += 4;
;;;164    ////      RamSource += 4;
;;;165    ////		
;;;166    ////		}
;;;167    ////		return ZMODEMOK;
;;;168    }
000048  e8bd81f0          POP      {r4-r8,pc}
                  |L1.76|
00004c  2621              MOVS     r6,#0x21
00004e  6805              LDR      r5,[r0,#0]
000050  60e6              STR      r6,[r4,#0xc]
000052  6062              STR      r2,[r4,#4]
000054  60a5              STR      r5,[r4,#8]
000056  f8c4c010          STR      r12,[r4,#0x10]
                  |L1.90|
00005a  6925              LDR      r5,[r4,#0x10]
00005c  2d00              CMP      r5,#0
00005e  d1fc              BNE      |L1.90|
000060  6815              LDR      r5,[r2,#0]            ;127
000062  6806              LDR      r6,[r0,#0]            ;127
000064  42b5              CMP      r5,r6                 ;127
000066  d107              BNE      |L1.120|
000068  1d12              ADDS     r2,r2,#4              ;127
00006a  1d00              ADDS     r0,r0,#4              ;132
00006c  1d1b              ADDS     r3,r3,#4              ;132
00006e  607a              STR      r2,[r7,#4]            ;132  ; FlashDestination
                  |L1.112|
000070  428b              CMP      r3,r1                 ;116
000072  d3d1              BCC      |L1.24|
000074  2000              MOVS     r0,#0                 ;140
000076  e7e7              B        |L1.72|
                  |L1.120|
000078  4670              MOV      r0,lr                 ;137
00007a  e7e5              B        |L1.72|
;;;169    
                          ENDP

                  |L1.124|
                          DCD      ||area_number.13||
                  |L1.128|
                          DCD      0x4000c000
                  |L1.132|
000084  45726173          DCB      "Erase failed on 0x%x\n",0
000088  65206661
00008c  696c6564
000090  206f6e20
000094  30782578
000098  0a00    
00009a  00                DCB      0
00009b  00                DCB      0

                          AREA ||i.readline||, CODE, READONLY, ALIGN=2

                  readline PROC
;;;76      */
;;;77     int readline(unsigned int timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;78     {
;;;79     	uint8_t temp;
;;;80     	
;;;81     	do{
;;;82     		if(UART_Read(UART0,&temp, 1)){
000004  f8df9044          LDR      r9,|L2.76|
000008  4f11              LDR      r7,|L2.80|
00000a  4604              MOV      r4,r0                 ;78
00000c  f04f0805          MOV      r8,#5                 ;78
000010  2600              MOVS     r6,#0                 ;78
000012  f04f25e0          MOV      r5,#0xe000e000        ;78
                  |L2.22|
000016  2201              MOVS     r2,#1
000018  4669              MOV      r1,sp
00001a  4648              MOV      r0,r9
00001c  f7fffffe          BL       UART_Read
000020  b118              CBZ      r0,|L2.42|
;;;83     			return temp & 0x000000FF;
000022  f89d0000          LDRB     r0,[sp,#0]
                  |L2.38|
;;;84     		}else{
;;;85     			/* 缓冲区为空，则触发数据接收 */
;;;86     			CLK_SysTickDelay(10);
;;;87     			timeout--;
;;;88     		}		
;;;89     
;;;90     	}while(timeout);//是否有定时溢出产生
;;;91     
;;;92     	return ZMODEMTIMEOUT;
;;;93     }
000026  e8bd83f8          POP      {r3-r9,pc}
                  |L2.42|
00002a  6838              LDR      r0,[r7,#0]  ; CyclesPerUs
00002c  eb000080          ADD      r0,r0,r0,LSL #2
000030  0040              LSLS     r0,r0,#1
000032  6168              STR      r0,[r5,#0x14]
000034  61ae              STR      r6,[r5,#0x18]
000036  f8c58010          STR      r8,[r5,#0x10]
                  |L2.58|
00003a  6928              LDR      r0,[r5,#0x10]
00003c  03c0              LSLS     r0,r0,#15
00003e  d5fc              BPL      |L2.58|
000040  612e              STR      r6,[r5,#0x10]
000042  1e64              SUBS     r4,r4,#1
000044  d1e7              BNE      |L2.22|
000046  1ea0              SUBS     r0,r4,#2              ;92
000048  e7ed              B        |L2.38|
;;;94     
                          ENDP

00004a  0000              DCW      0x0000
                  |L2.76|
                          DCD      0x40070000
                  |L2.80|
                          DCD      CyclesPerUs

                          AREA ||i.zmputchar||, CODE, READONLY, ALIGN=2

                  zmputchar PROC
;;;48      */
;;;49     void zmputchar(char c)
000000  b508              PUSH     {r3,lr}
;;;50     {
;;;51     	uint8_t data;
;;;52     
;;;53     	data = c;
;;;54     	UART_Write(UART0,&data,1);
000002  2201              MOVS     r2,#1
000004  f88d0000          STRB     r0,[sp,#0]            ;53
000008  4669              MOV      r1,sp
00000a  4802              LDR      r0,|L3.20|
00000c  f7fffffe          BL       UART_Write
;;;55     }
000010  bd08              POP      {r3,pc}
;;;56     
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40070000

                          AREA ||i.zmputs||, CODE, READONLY, ALIGN=2

                  zmputs PROC
;;;59      */
;;;60     void zmputs(char *str)
000000  b510              PUSH     {r4,lr}
;;;61     {
000002  0004              MOVS     r4,r0
000004  d008              BEQ      |L4.24|
;;;62     	if(0 == str) return;
;;;63     	UART_Write(UART0,(uint8_t *)str,strlen(str));					 
000006  f7fffffe          BL       strlen
00000a  4621              MOV      r1,r4
00000c  4602              MOV      r2,r0
00000e  e8bd4010          POP      {r4,lr}
000012  4802              LDR      r0,|L4.28|
000014  f7ffbffe          B.W      UART_Write
                  |L4.24|
;;;64     
;;;65     }
000018  bd10              POP      {r4,pc}
;;;66     #if 0//test
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      0x40070000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ZmodemUsbRevBuff
                          %        40960

                          AREA ||area_number.7||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.7||, ||.bss||
                  Rx_BUF_boot
                          %        16384

                          AREA ||.data||, DATA, ALIGN=2

                  ZmodemUsbRevCnt
                          DCD      0x00000000

                          AREA ||area_number.10||, DATA, ALIGN=2

                          EXPORTAS ||area_number.10||, ||.data||
                  ZmodemUsbInInx
                          DCD      0x00000000

                          AREA ||area_number.11||, DATA, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.data||
                  ZmodemUsbOutInx
                          DCD      0x00000000

                          AREA ||area_number.12||, DATA, ALIGN=2

                          EXPORTAS ||area_number.12||, ||.data||
                  UsbTransferComplete
                          DCD      0x00000000

                          AREA ||area_number.13||, DATA, ALIGN=2

                          EXPORTAS ||area_number.13||, ||.data||
                  ZmodemReceiveType
                          DCD      0x00000000
                  FlashDestination
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "zmodem\\FlashProgrammer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_FlashProgrammer_c_84162985____REV16|
#line 114 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_FlashProgrammer_c_84162985____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_FlashProgrammer_c_84162985____REVSH|
#line 128
|__asm___17_FlashProgrammer_c_84162985____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
