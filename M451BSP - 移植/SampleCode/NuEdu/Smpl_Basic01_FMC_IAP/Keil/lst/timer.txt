; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\timer.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\timer.d --cpu=Cortex-M4.fp --apcs=interwork -L6969W -I..\..\..\..\Library\Device\Nuvoton\M451Series\Include -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\Library\NuEdu\inc -I.\zmodem -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -DDEBUG_ENABLE_SEMIHOST --omf_browse=.\obj\timer.crf ..\..\..\..\Library\StdDriver\src\timer.c]
                          THUMB

                          AREA ||i.TIMER_Close||, CODE, READONLY, ALIGN=1

                  TIMER_Close PROC
;;;89       */
;;;90     void TIMER_Close(TIMER_T *timer)
000000  2100              MOVS     r1,#0
;;;91     {
;;;92         timer->CTL = 0;
000002  6001              STR      r1,[r0,#0]
;;;93         timer->EXTCTL = 0;
000004  6141              STR      r1,[r0,#0x14]
;;;94     }
000006  4770              BX       lr
;;;95     
                          ENDP


                          AREA ||i.TIMER_Delay||, CODE, READONLY, ALIGN=2

                  TIMER_Delay PROC
;;;107      */
;;;108    void TIMER_Delay(TIMER_T *timer, uint32_t u32Usec)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;109    {
000004  460c              MOV      r4,r1
000006  4605              MOV      r5,r0
;;;110        uint32_t u32Clk = TIMER_GetModuleClock(timer);
000008  f7fffffe          BL       TIMER_GetModuleClock
;;;111        uint32_t u32Prescale = 0, delay = (SystemCoreClock / u32Clk) + 1;
00000c  4922              LDR      r1,|L2.152|
00000e  2200              MOVS     r2,#0
000010  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
;;;112        uint32_t u32Cmpr, u32NsecPerTick;
;;;113    
;;;114        // Clear current timer configuration/
;;;115        timer->CTL = 0;
000012  602a              STR      r2,[r5,#0]
000014  fbb1f1f0          UDIV     r1,r1,r0              ;111
;;;116        timer->EXTCTL = 0;
000018  616a              STR      r2,[r5,#0x14]
;;;117    
;;;118        if(u32Clk <= 1000000)    // min delay is 1000 us if timer clock source is <= 1 MHz
00001a  4b20              LDR      r3,|L2.156|
00001c  1c49              ADDS     r1,r1,#1
00001e  4298              CMP      r0,r3
000020  d805              BHI      |L2.46|
;;;119        {
;;;120            if(u32Usec < 1000)
000022  f44f767a          MOV      r6,#0x3e8
000026  42b4              CMP      r4,r6
000028  d205              BCS      |L2.54|
;;;121                u32Usec = 1000;
00002a  4634              MOV      r4,r6
00002c  e006              B        |L2.60|
                  |L2.46|
;;;122            if(u32Usec > 1000000)
;;;123                u32Usec = 1000000;
;;;124        }
;;;125        else
;;;126        {
;;;127            if(u32Usec < 100)
00002e  2c64              CMP      r4,#0x64
000030  d201              BCS      |L2.54|
;;;128                u32Usec = 100;
000032  2464              MOVS     r4,#0x64
000034  e002              B        |L2.60|
                  |L2.54|
;;;129            if(u32Usec > 1000000)
000036  429c              CMP      r4,r3
000038  d900              BLS      |L2.60|
;;;130                u32Usec = 1000000;
00003a  461c              MOV      r4,r3
                  |L2.60|
;;;131        }
;;;132    
;;;133        if(u32Clk <= 1000000)
;;;134        {
;;;135            u32Prescale = 0;
;;;136            u32NsecPerTick = 1000000000 / u32Clk;
00003c  4e18              LDR      r6,|L2.160|
00003e  4298              CMP      r0,r3                 ;133
000040  d916              BLS      |L2.112|
;;;137            u32Cmpr = (u32Usec * 1000) / u32NsecPerTick;
;;;138        }
;;;139        else
;;;140        {
;;;141            if(u32Clk > 64000000)
000042  4f18              LDR      r7,|L2.164|
000044  42b8              CMP      r0,r7
000046  d902              BLS      |L2.78|
;;;142            {
;;;143                u32Prescale = 7;    // real prescaler value is 8
000048  2207              MOVS     r2,#7
;;;144                u32Clk >>= 3;
00004a  08c0              LSRS     r0,r0,#3
00004c  e00a              B        |L2.100|
                  |L2.78|
;;;145            }
;;;146            else if(u32Clk > 32000000)
00004e  4f16              LDR      r7,|L2.168|
000050  42b8              CMP      r0,r7
000052  d902              BLS      |L2.90|
;;;147            {
;;;148                u32Prescale = 3;    // real prescaler value is 4
000054  2203              MOVS     r2,#3
;;;149                u32Clk >>= 2;
000056  0880              LSRS     r0,r0,#2
000058  e004              B        |L2.100|
                  |L2.90|
;;;150            }
;;;151            else if(u32Clk > 16000000)
00005a  4f14              LDR      r7,|L2.172|
00005c  42b8              CMP      r0,r7
00005e  d901              BLS      |L2.100|
;;;152            {
;;;153                u32Prescale = 1;    // real prescaler value is 2
000060  2201              MOVS     r2,#1
;;;154                u32Clk >>= 1;
000062  0840              LSRS     r0,r0,#1
                  |L2.100|
;;;155            }
;;;156    
;;;157            if(u32Usec < 250)
000064  2cfa              CMP      r4,#0xfa
000066  d203              BCS      |L2.112|
;;;158            {
;;;159                u32Cmpr = (u32Usec * u32Clk) / 1000000;
000068  4344              MULS     r4,r0,r4
00006a  fbb4f0f3          UDIV     r0,r4,r3
00006e  e006              B        |L2.126|
                  |L2.112|
;;;160            }
;;;161            else
;;;162            {
;;;163                u32NsecPerTick = 1000000000 / u32Clk;
000070  fbb6f0f0          UDIV     r0,r6,r0
;;;164                u32Cmpr = (u32Usec * 1000) / u32NsecPerTick;
000074  f44f737a          MOV      r3,#0x3e8
000078  435c              MULS     r4,r3,r4
00007a  fbb4f0f0          UDIV     r0,r4,r0
                  |L2.126|
;;;165            }
;;;166        }
;;;167    
;;;168        timer->CMP = u32Cmpr;
00007e  6068              STR      r0,[r5,#4]
;;;169        timer->CTL = TIMER_CTL_CNTEN_Msk | TIMER_ONESHOT_MODE | u32Prescale;
000080  f0424080          ORR      r0,r2,#0x40000000
000084  6028              STR      r0,[r5,#0]
;;;170    
;;;171        // When system clock is faster than timer clock, it is possible timer active bit cannot set in time while we check it.
;;;172        // And the while loop below return immediately, so put a tiny delay here allowing timer start counting and raise active flag.
;;;173        for(; delay > 0; delay--)
000086  b111              CBZ      r1,|L2.142|
                  |L2.136|
;;;174        {
;;;175            __NOP();
000088  bf00              NOP      
00008a  1e49              SUBS     r1,r1,#1
00008c  d1fc              BNE      |L2.136|
                  |L2.142|
;;;176        }
;;;177    
;;;178        while(timer->CTL & TIMER_CTL_ACTSTS_Msk);
00008e  6828              LDR      r0,[r5,#0]
000090  0180              LSLS     r0,r0,#6
000092  d4fc              BMI      |L2.142|
;;;179    }
000094  e8bd81f0          POP      {r4-r8,pc}
;;;180    
                          ENDP

                  |L2.152|
                          DCD      SystemCoreClock
                  |L2.156|
                          DCD      0x000f4240
                  |L2.160|
                          DCD      0x3b9aca00
                  |L2.164|
                          DCD      0x03d09000
                  |L2.168|
                          DCD      0x01e84800
                  |L2.172|
                          DCD      0x00f42400

                          AREA ||i.TIMER_DisableCapture||, CODE, READONLY, ALIGN=1

                  TIMER_DisableCapture PROC
;;;214      */
;;;215    void TIMER_DisableCapture(TIMER_T *timer)
000000  6941              LDR      r1,[r0,#0x14]
;;;216    {
;;;217        timer->EXTCTL &= ~TIMER_EXTCTL_CAPEN_Msk;
000002  f0210108          BIC      r1,r1,#8
000006  6141              STR      r1,[r0,#0x14]
;;;218    }
000008  4770              BX       lr
;;;219    
                          ENDP


                          AREA ||i.TIMER_DisableEventCounter||, CODE, READONLY, ALIGN=1

                  TIMER_DisableEventCounter PROC
;;;248      */
;;;249    void TIMER_DisableEventCounter(TIMER_T *timer)
000000  6801              LDR      r1,[r0,#0]
;;;250    {
;;;251        timer->CTL &= ~TIMER_CTL_EXTCNTEN_Msk;
000002  f0217180          BIC      r1,r1,#0x1000000
000006  6001              STR      r1,[r0,#0]
;;;252    }
000008  4770              BX       lr
;;;253    
                          ENDP


                          AREA ||i.TIMER_EnableCapture||, CODE, READONLY, ALIGN=1

                  TIMER_EnableCapture PROC
;;;198      */
;;;199    void TIMER_EnableCapture(TIMER_T *timer, uint32_t u32CapMode, uint32_t u32Edge)
000000  6943              LDR      r3,[r0,#0x14]
;;;200    {
;;;201    
;;;202        timer->EXTCTL = (timer->EXTCTL & ~(TIMER_EXTCTL_CAPFUNCS_Msk | TIMER_EXTCTL_CAPEDGE_Msk)) |
000002  f0230316          BIC      r3,r3,#0x16
000006  430b              ORRS     r3,r3,r1
000008  4313              ORRS     r3,r3,r2
00000a  f0430108          ORR      r1,r3,#8
00000e  6141              STR      r1,[r0,#0x14]
;;;203                        u32CapMode | u32Edge | TIMER_EXTCTL_CAPEN_Msk;
;;;204    }
000010  4770              BX       lr
;;;205    
                          ENDP


                          AREA ||i.TIMER_EnableEventCounter||, CODE, READONLY, ALIGN=1

                  TIMER_EnableEventCounter PROC
;;;233      */
;;;234    void TIMER_EnableEventCounter(TIMER_T *timer, uint32_t u32Edge)
000000  6942              LDR      r2,[r0,#0x14]
;;;235    {
;;;236        timer->EXTCTL = (timer->EXTCTL & ~TIMER_EXTCTL_CNTPHASE_Msk) | u32Edge;
000002  f0220201          BIC      r2,r2,#1
000006  430a              ORRS     r2,r2,r1
000008  6142              STR      r2,[r0,#0x14]
;;;237        timer->CTL |= TIMER_CTL_EXTCNTEN_Msk;
00000a  6801              LDR      r1,[r0,#0]
00000c  f0417180          ORR      r1,r1,#0x1000000
000010  6001              STR      r1,[r0,#0]
;;;238    }
000012  4770              BX       lr
;;;239    
                          ENDP


                          AREA ||i.TIMER_GetModuleClock||, CODE, READONLY, ALIGN=2

                  TIMER_GetModuleClock PROC
;;;263      */
;;;264    uint32_t TIMER_GetModuleClock(TIMER_T *timer)
000000  b510              PUSH     {r4,lr}
;;;265    {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;266        uint32_t u32Src;
;;;267        const uint32_t au32Clk[] = {__HXT, __LXT, 0, 0, 0, __LIRC, 0, __HIRC};
000006  2220              MOVS     r2,#0x20
000008  4914              LDR      r1,|L7.92|
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       __aeabi_memcpy4
;;;268    
;;;269        if(timer == TIMER0)
000010  4913              LDR      r1,|L7.96|
;;;270            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR0SEL_Msk) >> CLK_CLKSEL1_TMR0SEL_Pos;
000012  0388              LSLS     r0,r1,#14
000014  428c              CMP      r4,r1                 ;269
000016  d104              BNE      |L7.34|
000018  f8d00214          LDR      r0,[r0,#0x214]
00001c  f3c02002          UBFX     r0,r0,#8,#3
000020  e012              B        |L7.72|
                  |L7.34|
;;;271        else if(timer == TIMER1)
000022  490f              LDR      r1,|L7.96|
000024  3120              ADDS     r1,r1,#0x20
000026  428c              CMP      r4,r1
000028  d104              BNE      |L7.52|
;;;272            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR1SEL_Msk) >> CLK_CLKSEL1_TMR1SEL_Pos;
00002a  f8d00214          LDR      r0,[r0,#0x214]
00002e  f3c03002          UBFX     r0,r0,#12,#3
000032  e009              B        |L7.72|
                  |L7.52|
;;;273        else if(timer == TIMER2)
000034  490b              LDR      r1,|L7.100|
;;;274            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR2SEL_Msk) >> CLK_CLKSEL1_TMR2SEL_Pos;
;;;275        else  // Timer 3
;;;276            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR3SEL_Msk) >> CLK_CLKSEL1_TMR3SEL_Pos;
000036  f8d00214          LDR      r0,[r0,#0x214]
00003a  428c              CMP      r4,r1                 ;273
00003c  d102              BNE      |L7.68|
00003e  f3c04002          UBFX     r0,r0,#16,#3          ;274
000042  e001              B        |L7.72|
                  |L7.68|
000044  f3c05002          UBFX     r0,r0,#20,#3
                  |L7.72|
;;;277    
;;;278        if(u32Src == 2)
000048  2802              CMP      r0,#2
00004a  d003              BEQ      |L7.84|
;;;279        {
;;;280            return (SystemCoreClock);
;;;281        }
;;;282    
;;;283        return (au32Clk[u32Src]);
00004c  f85d0020          LDR      r0,[sp,r0,LSL #2]
                  |L7.80|
;;;284    }
000050  b008              ADD      sp,sp,#0x20
000052  bd10              POP      {r4,pc}
                  |L7.84|
000054  4804              LDR      r0,|L7.104|
000056  6800              LDR      r0,[r0,#0]            ;280  ; SystemCoreClock
000058  e7fa              B        |L7.80|
;;;285    
                          ENDP

00005a  0000              DCW      0x0000
                  |L7.92|
                          DCD      ||.constdata||
                  |L7.96|
                          DCD      0x40050000
                  |L7.100|
                          DCD      0x40051000
                  |L7.104|
                          DCD      SystemCoreClock

                          AREA ||i.TIMER_Open||, CODE, READONLY, ALIGN=2

                  TIMER_Open PROC
;;;43       */
;;;44     uint32_t TIMER_Open(TIMER_T *timer, uint32_t u32Mode, uint32_t u32Freq)
000000  b570              PUSH     {r4-r6,lr}
;;;45     {
000002  4614              MOV      r4,r2
000004  460e              MOV      r6,r1
000006  4605              MOV      r5,r0
;;;46         uint32_t u32Clk = TIMER_GetModuleClock(timer);
000008  f7fffffe          BL       TIMER_GetModuleClock
;;;47         uint32_t u32Cmpr = 0, u32Prescale = 0;
00000c  2100              MOVS     r1,#0
;;;48     
;;;49         // Fastest possible timer working freq is (u32Clk / 2). While cmpr = 2, pre-scale = 0.
;;;50         if(u32Freq > (u32Clk / 2))
00000e  ebb40f50          CMP      r4,r0,LSR #1
000012  d901              BLS      |L8.24|
;;;51         {
;;;52             u32Cmpr = 2;
000014  2202              MOVS     r2,#2
000016  e012              B        |L8.62|
                  |L8.24|
;;;53         }
;;;54         else
;;;55         {
;;;56             if(u32Clk > 64000000)
000018  4a0d              LDR      r2,|L8.80|
00001a  4290              CMP      r0,r2
00001c  d902              BLS      |L8.36|
;;;57             {
;;;58                 u32Prescale = 7;    // real prescaler value is 8
00001e  2107              MOVS     r1,#7
;;;59                 u32Clk >>= 3;
000020  08c0              LSRS     r0,r0,#3
000022  e00a              B        |L8.58|
                  |L8.36|
;;;60             }
;;;61             else if(u32Clk > 32000000)
000024  4a0b              LDR      r2,|L8.84|
000026  4290              CMP      r0,r2
000028  d902              BLS      |L8.48|
;;;62             {
;;;63                 u32Prescale = 3;    // real prescaler value is 4
00002a  2103              MOVS     r1,#3
;;;64                 u32Clk >>= 2;
00002c  0880              LSRS     r0,r0,#2
00002e  e004              B        |L8.58|
                  |L8.48|
;;;65             }
;;;66             else if(u32Clk > 16000000)
000030  4a09              LDR      r2,|L8.88|
000032  4290              CMP      r0,r2
000034  d901              BLS      |L8.58|
;;;67             {
;;;68                 u32Prescale = 1;    // real prescaler value is 2
000036  2101              MOVS     r1,#1
;;;69                 u32Clk >>= 1;
000038  0840              LSRS     r0,r0,#1
                  |L8.58|
;;;70             }
;;;71     
;;;72             u32Cmpr = u32Clk / u32Freq;
00003a  fbb0f2f4          UDIV     r2,r0,r4
                  |L8.62|
;;;73         }
;;;74     
;;;75         timer->CTL = u32Mode | u32Prescale;
00003e  430e              ORRS     r6,r6,r1
000040  602e              STR      r6,[r5,#0]
;;;76         timer->CMP = u32Cmpr;
000042  606a              STR      r2,[r5,#4]
000044  1c49              ADDS     r1,r1,#1
;;;77     
;;;78         return(u32Clk / (u32Cmpr * (u32Prescale + 1)));
000046  434a              MULS     r2,r1,r2
000048  fbb0f0f2          UDIV     r0,r0,r2
;;;79     }
00004c  bd70              POP      {r4-r6,pc}
;;;80     
                          ENDP

00004e  0000              DCW      0x0000
                  |L8.80|
                          DCD      0x03d09000
                  |L8.84|
                          DCD      0x01e84800
                  |L8.88|
                          DCD      0x00f42400

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00b71b00
                          DCD      0x00008000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00002710
                          DCD      0x00000000
                          DCD      0x01518000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\timer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_5bec749a____REV16|
#line 114 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_timer_c_5bec749a____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_5bec749a____REVSH|
#line 128
|__asm___7_timer_c_5bec749a____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
