; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\ap0_main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\ap0_main.d --cpu=Cortex-M4.fp --apcs=interwork -L6969W -I..\..\..\..\Library\Device\Nuvoton\M451Series\Include -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\Library\NuEdu\inc -I.\zmodem -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -DDEBUG_ENABLE_SEMIHOST --omf_browse=.\obj\ap0_main.crf ..\ap0_main.c]
                          THUMB

                          AREA ||i.FMC_Erase||, CODE, READONLY, ALIGN=2

                  FMC_Erase PROC
;;;309     */
;;;310    static __INLINE int32_t FMC_Erase(uint32_t u32Addr)
000000  490a              LDR      r1,|L1.44|
;;;311    {
;;;312        FMC->ISPCMD = FMC_ISPCMD_PAGE_ERASE;
000002  2222              MOVS     r2,#0x22
000004  60ca              STR      r2,[r1,#0xc]
;;;313        FMC->ISPADDR = u32Addr;
000006  6048              STR      r0,[r1,#4]
;;;314        FMC->ISPTRG = 0x1;
000008  2001              MOVS     r0,#1
00000a  6108              STR      r0,[r1,#0x10]
                  |L1.12|
;;;315    #if ISBEN
;;;316        __ISB();
;;;317    #endif
;;;318        while(FMC->ISPTRG);
00000c  6908              LDR      r0,[r1,#0x10]
00000e  2800              CMP      r0,#0
000010  d1fc              BNE      |L1.12|
;;;319    
;;;320        /* Check ISPFF flag to know whether erase OK or fail. */
;;;321        if(FMC->ISPCTL & FMC_ISPCTL_ISPFF_Msk)
000012  6808              LDR      r0,[r1,#0]
000014  0640              LSLS     r0,r0,#25
000016  d506              BPL      |L1.38|
;;;322        {
;;;323            FMC->ISPCTL |= FMC_ISPCTL_ISPFF_Msk;
000018  6808              LDR      r0,[r1,#0]
00001a  f0400040          ORR      r0,r0,#0x40
00001e  6008              STR      r0,[r1,#0]
;;;324            return -1;
000020  f04f30ff          MOV      r0,#0xffffffff
;;;325        }
;;;326        return 0;
;;;327    }
000024  4770              BX       lr
                  |L1.38|
000026  2000              MOVS     r0,#0                 ;326
000028  4770              BX       lr
;;;328    
                          ENDP

00002a  0000              DCW      0x0000
                  |L1.44|
                          DCD      0x4000c000

                          AREA ||i.FMC_Write||, CODE, READONLY, ALIGN=2

                  FMC_Write PROC
;;;234     */
;;;235    static __INLINE void FMC_Write(uint32_t u32Addr, uint32_t u32Data)
000000  4a05              LDR      r2,|L2.24|
;;;236    {
;;;237        FMC->ISPCMD = FMC_ISPCMD_PROGRAM;
000002  2321              MOVS     r3,#0x21
000004  60d3              STR      r3,[r2,#0xc]
;;;238        FMC->ISPADDR = u32Addr;
000006  6050              STR      r0,[r2,#4]
;;;239        FMC->ISPDAT = u32Data;
000008  6091              STR      r1,[r2,#8]
;;;240        FMC->ISPTRG = 0x1;
00000a  2001              MOVS     r0,#1
00000c  6110              STR      r0,[r2,#0x10]
                  |L2.14|
;;;241    #if ISBEN
;;;242        __ISB();
;;;243    #endif
;;;244        while(FMC->ISPTRG);
00000e  6910              LDR      r0,[r2,#0x10]
000010  2800              CMP      r0,#0
000012  d1fc              BNE      |L2.14|
;;;245    }
000014  4770              BX       lr
;;;246    
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      0x4000c000

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;57     #define PLL_CLOCK           72000000
;;;58     void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;59     {
;;;60     	  
;;;61           /*---------------------------------------------------------------------------------------------------------*/
;;;62         /* Init System Clock                                                                                       */
;;;63         /*---------------------------------------------------------------------------------------------------------*/
;;;64         /* Unlock protected registers */
;;;65         SYS_UnlockReg();
000002  f7fffffe          BL       SYS_UnlockReg
;;;66     	
;;;67         /* Enable Internal RC 22.1184MHz clock */
;;;68         CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       CLK_EnableXtalRC
;;;69     
;;;70         /* Waiting for Internal RC clock ready */
;;;71         CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00000c  2010              MOVS     r0,#0x10
00000e  f7fffffe          BL       CLK_WaitClockReady
;;;72     
;;;73         /* Switch HCLK clock source to Internal RC and HCLK source divide 1 */
;;;74         CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
000012  2100              MOVS     r1,#0
000014  2007              MOVS     r0,#7
000016  f7fffffe          BL       CLK_SetHCLK
;;;75     
;;;76         /* Enable external XTAL 12MHz clock */
;;;77         CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       CLK_EnableXtalRC
;;;78     
;;;79         /* Waiting for external XTAL clock ready */
;;;80         CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
000020  2001              MOVS     r0,#1
000022  f7fffffe          BL       CLK_WaitClockReady
;;;81     
;;;82         /* Set core clock as PLL_CLOCK from PLL */
;;;83         CLK_SetCoreClock(PLL_CLOCK);
000026  4812              LDR      r0,|L3.112|
000028  f7fffffe          BL       CLK_SetCoreClock
;;;84     		  
;;;85     		/* Update System Core Clock */
;;;86         /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock and CycylesPerUs automatically. */
;;;87         SystemCoreClockUpdate();
00002c  f7fffffe          BL       SystemCoreClockUpdate
;;;88     		
;;;89         /* Enable module clock */
;;;90         CLK_EnableModuleClock(UART0_MODULE);
000030  4c10              LDR      r4,|L3.116|
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       CLK_EnableModuleClock
;;;91     		CLK_EnableModuleClock(TMR0_MODULE);
000038  4d0f              LDR      r5,|L3.120|
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       CLK_EnableModuleClock
;;;92     
;;;93         /* Select module clock source as HXT and UART module clock divider as 1 */
;;;94         CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UARTSEL_HXT, CLK_CLKDIV0_UART(1));
000040  2200              MOVS     r2,#0
000042  4611              MOV      r1,r2
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       CLK_SetModuleClock
;;;95     		CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_HXT, 0);
00004a  2200              MOVS     r2,#0
00004c  4611              MOV      r1,r2
00004e  4628              MOV      r0,r5
000050  f7fffffe          BL       CLK_SetModuleClock
;;;96     		
;;;97         /*---------------------------------------------------------------------------------------------------------*/
;;;98         /* Init I/O Multi-function                                                                                 */
;;;99         /*---------------------------------------------------------------------------------------------------------*/
;;;100        /* Set PD multi-function pins for UART0 RXD(PD.6) and TXD(PD.1) */
;;;101        SYS->GPD_MFPL &= ~(SYS_GPD_MFPL_PD6MFP_Msk | SYS_GPD_MFPL_PD1MFP_Msk);
000054  06a0              LSLS     r0,r4,#26
000056  6c81              LDR      r1,[r0,#0x48]
000058  4a08              LDR      r2,|L3.124|
00005a  4011              ANDS     r1,r1,r2
00005c  6481              STR      r1,[r0,#0x48]
;;;102        SYS->GPD_MFPL |= (SYS_GPD_MFPL_PD6MFP_UART0_RXD | SYS_GPD_MFPL_PD1MFP_UART0_TXD);
00005e  6c81              LDR      r1,[r0,#0x48]
000060  4a07              LDR      r2,|L3.128|
000062  4311              ORRS     r1,r1,r2
000064  6481              STR      r1,[r0,#0x48]
000066  2100              MOVS     r1,#0
000068  f8c01100          STR      r1,[r0,#0x100]
;;;103    		
;;;104        /* Lock protected registers */
;;;105        SYS_LockReg();
;;;106    }
00006c  bd70              POP      {r4-r6,pc}
;;;107    
                          ENDP

00006e  0000              DCW      0x0000
                  |L3.112|
                          DCD      0x044aa200
                  |L3.116|
                          DCD      0x57803d10
                  |L3.120|
                          DCD      0x5e800002
                  |L3.124|
                          DCD      0xf0ffff0f
                  |L3.128|
                          DCD      0x03000030

                          AREA ||i.SYS_UnlockReg||, CODE, READONLY, ALIGN=1

                  SYS_UnlockReg PROC
;;;922      */
;;;923    __STATIC_INLINE void SYS_UnlockReg(void)
000000  2159              MOVS     r1,#0x59
;;;924    {
000002  b510              PUSH     {r4,lr}
;;;925        do
;;;926        {
;;;927            SYS->REGLCTL = 0x59;
000004  0788              LSLS     r0,r1,#30
;;;928            SYS->REGLCTL = 0x16;
000006  2216              MOVS     r2,#0x16
;;;929            SYS->REGLCTL = 0x88;
000008  2388              MOVS     r3,#0x88
                  |L4.10|
00000a  f8c01100          STR      r1,[r0,#0x100]        ;927
00000e  f8c02100          STR      r2,[r0,#0x100]        ;928
000012  f8c03100          STR      r3,[r0,#0x100]
;;;930        }
;;;931        while(SYS->REGLCTL == 0);
000016  f8d04100          LDR      r4,[r0,#0x100]
00001a  2c00              CMP      r4,#0
00001c  d0f5              BEQ      |L4.10|
;;;932    }
00001e  bd10              POP      {r4,pc}
;;;933    
                          ENDP


                          AREA ||i.TMR0_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR0_IRQHandler PROC
;;;27     
;;;28     void TMR0_IRQHandler(void)
000000  4803              LDR      r0,|L5.16|
000002  6881              LDR      r1,[r0,#8]
000004  f0210102          BIC      r1,r1,#2
000008  f0410101          ORR      r1,r1,#1
00000c  6081              STR      r1,[r0,#8]
;;;29     {
;;;30         static uint32_t sec = 1;
;;;31     //    printf("%d sec\n", sec++);
;;;32     //    LED_On(sec);
;;;33     
;;;34         // clear timer interrupt flag
;;;35         TIMER_ClearIntFlag(TIMER0);
;;;36     
;;;37     }
00000e  4770              BX       lr
;;;38     #ifdef __ARMCC_VERSION
                          ENDP

                  |L5.16|
                          DCD      0x40050000

                          AREA ||i.Timer0_Init||, CODE, READONLY, ALIGN=2

                  Timer0_Init PROC
;;;107    
;;;108    void Timer0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;109    {
;;;110        // Give a dummy target frequency here. Will over write capture resolution with macro
;;;111        TIMER_Open(TIMER0, TIMER_PERIODIC_MODE, 11);
000002  4c0a              LDR      r4,|L6.44|
000004  220b              MOVS     r2,#0xb
000006  f04f6100          MOV      r1,#0x8000000
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       TIMER_Open
000010  6820              LDR      r0,[r4,#0]
000012  f0405000          ORR      r0,r0,#0x20000000
000016  6020              STR      r0,[r4,#0]
000018  4905              LDR      r1,|L6.48|
00001a  2001              MOVS     r0,#1
00001c  f8c10100          STR      r0,[r1,#0x100]
000020  6820              LDR      r0,[r4,#0]
000022  f0404080          ORR      r0,r0,#0x40000000
000026  6020              STR      r0,[r4,#0]
;;;112    
;;;113        // Enable timer interrupt
;;;114        TIMER_EnableInt(TIMER0);
;;;115        NVIC_EnableIRQ(TMR0_IRQn);
;;;116    
;;;117        // Start Timer 0
;;;118        TIMER_Start(TIMER0);    
;;;119    }
000028  bd10              POP      {r4,pc}
;;;120    
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0x40050000
                  |L6.48|
                          DCD      0xe000e004

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                  UART0_Init PROC
;;;120    
;;;121    void UART0_Init()
000000  b510              PUSH     {r4,lr}
;;;122    {
;;;123        /*---------------------------------------------------------------------------------------------------------*/
;;;124        /* Init UART                                                                                               */
;;;125        /*---------------------------------------------------------------------------------------------------------*/
;;;126        /* Reset UART module */
;;;127        SYS_ResetModule(UART0_RST);
000002  4805              LDR      r0,|L7.24|
000004  f7fffffe          BL       SYS_ResetModule
;;;128    
;;;129        /* Configure UART0 and set UART0 baud rate */
;;;130        UART_Open(UART0, 115200);
000008  e8bd4010          POP      {r4,lr}
00000c  f44f31e1          MOV      r1,#0x1c200
000010  4802              LDR      r0,|L7.28|
000012  f7ffbffe          B.W      UART_Open
;;;131    }
;;;132    
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      0x04000010
                  |L7.28|
                          DCD      0x40070000

                          AREA ||i.load_image_to_flash||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  load_image_to_flash PROC
;;;216    
;;;217    int  load_image_to_flash(uint32_t image_base, uint32_t image_limit, uint32_t flash_addr, uint32_t max_size)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;218    {
000004  4691              MOV      r9,r2
000006  000e              MOVS     r6,r1
000008  4607              MOV      r7,r0
00000a  d004              BEQ      |L8.22|
;;;219        uint32_t   i, j, u32Data, u32ImageSize, *pu32Loader;
;;;220    
;;;221        u32ImageSize = image_limit;
;;;222        if (u32ImageSize == 0) {
;;;223            printf("  ERROR: Loader Image is 0 bytes!\n");
;;;224            return -1;
;;;225        }
;;;226    
;;;227        if (u32ImageSize > max_size) {
00000c  429e              CMP      r6,r3
00000e  d906              BLS      |L8.30|
;;;228            printf("  ERROR: Loader Image is larger than %d KBytes!\n", max_size/1024);
000010  0a99              LSRS     r1,r3,#10
000012  a034              ADR      r0,|L8.228|
;;;229            return -1;
000014  e014              B        |L8.64|
                  |L8.22|
000016  a040              ADR      r0,|L8.280|
000018  f7fffffe          BL       __2printf
00001c  e050              B        |L8.192|
                  |L8.30|
;;;230        }
;;;231    
;;;232        printf("Program image to flash address 0x%x...", flash_addr);
00001e  4611              MOV      r1,r2
000020  a046              ADR      r0,|L8.316|
000022  f7fffffe          BL       __2printf
;;;233        pu32Loader = (uint32_t *)image_base;
;;;234        for (i = 0; i < u32ImageSize; i += FMC_FLASH_PAGE_SIZE) {
000026  2500              MOVS     r5,#0
;;;235            if (FMC_Erase(flash_addr + i)) {
;;;236                printf("Erase failed on 0x%x\n", flash_addr + i);
;;;237                return -1;
;;;238            }
;;;239    
;;;240            for (j = 0; j < FMC_FLASH_PAGE_SIZE; j += 4) {
000028  f44f6b00          MOV      r11,#0x800
00002c  e01a              B        |L8.100|
                  |L8.46|
00002e  eb090005          ADD      r0,r9,r5              ;235
000032  4680              MOV      r8,r0                 ;235
000034  f7fffffe          BL       FMC_Erase
000038  b128              CBZ      r0,|L8.70|
00003a  eb090105          ADD      r1,r9,r5              ;236
00003e  a049              ADR      r0,|L8.356|
                  |L8.64|
000040  f7fffffe          BL       __2printf
000044  e03c              B        |L8.192|
                  |L8.70|
000046  2400              MOVS     r4,#0
000048  46da              MOV      r10,r11
                  |L8.74|
;;;241                FMC_Write(flash_addr + i + j, pu32Loader[(i + j) / 4]);
00004a  1928              ADDS     r0,r5,r4
00004c  f0200003          BIC      r0,r0,#3
000050  5839              LDR      r1,[r7,r0]
000052  eb080004          ADD      r0,r8,r4
000056  f7fffffe          BL       FMC_Write
00005a  1d24              ADDS     r4,r4,#4
00005c  4554              CMP      r4,r10                ;240
00005e  d3f4              BCC      |L8.74|
000060  f5056500          ADD      r5,r5,#0x800          ;240
                  |L8.100|
000064  42b5              CMP      r5,r6                 ;234
000066  d3e2              BCC      |L8.46|
;;;242            }
;;;243        }
;;;244        printf("OK.\n");
000068  a044              ADR      r0,|L8.380|
00006a  f7fffffe          BL       __2printf
;;;245    
;;;246        printf("Verify ...");
00006e  a045              ADR      r0,|L8.388|
000070  f7fffffe          BL       __2printf
;;;247    
;;;248        /* Verify loader */
;;;249        for (i = 0; i < u32ImageSize; i += FMC_FLASH_PAGE_SIZE) {
000074  2500              MOVS     r5,#0
000076  4846              LDR      r0,|L8.400|
000078  e02d              B        |L8.214|
                  |L8.122|
;;;250            for (j = 0; j < FMC_FLASH_PAGE_SIZE; j += 4) {
00007a  2400              MOVS     r4,#0
00007c  46a4              MOV      r12,r4
00007e  eb090305          ADD      r3,r9,r5              ;235
000082  f04f0a01          MOV      r10,#1                ;235
                  |L8.134|
;;;251                u32Data = FMC_Read(flash_addr + i + j);
000086  1919              ADDS     r1,r3,r4
000088  f8c0c00c          STR      r12,[r0,#0xc]
00008c  6041              STR      r1,[r0,#4]
00008e  f8c0c008          STR      r12,[r0,#8]
000092  f8c0a010          STR      r10,[r0,#0x10]
                  |L8.150|
000096  6901              LDR      r1,[r0,#0x10]
000098  2900              CMP      r1,#0
00009a  d1fc              BNE      |L8.150|
00009c  6882              LDR      r2,[r0,#8]
;;;252                if (u32Data != pu32Loader[(i+j)/4]) {
00009e  1929              ADDS     r1,r5,r4
0000a0  f0210803          BIC      r8,r1,#3
0000a4  f8578008          LDR      r8,[r7,r8]
0000a8  4590              CMP      r8,r2
0000aa  d00d              BEQ      |L8.200|
;;;253                    printf("data mismatch on 0x%x, [0x%x], [0x%x]\n", flash_addr + i + j, u32Data, pu32Loader[(i+j)/4]);
0000ac  1928              ADDS     r0,r5,r4
0000ae  f0200003          BIC      r0,r0,#3
0000b2  583b              LDR      r3,[r7,r0]
0000b4  eb090005          ADD      r0,r9,r5
0000b8  1901              ADDS     r1,r0,r4
0000ba  a036              ADR      r0,|L8.404|
0000bc  f7fffffe          BL       __2printf
                  |L8.192|
;;;254                    return -1;
0000c0  f04f30ff          MOV      r0,#0xffffffff
                  |L8.196|
;;;255                }
;;;256    
;;;257                if (i + j >= u32ImageSize)
;;;258                    break;
;;;259            }
;;;260        }
;;;261        printf("OK.\n");
;;;262        return 0;
;;;263    }
0000c4  e8bd9ff0          POP      {r4-r12,pc}
                  |L8.200|
0000c8  42b1              CMP      r1,r6                 ;257
0000ca  d202              BCS      |L8.210|
0000cc  1d24              ADDS     r4,r4,#4              ;257
0000ce  455c              CMP      r4,r11                ;250
0000d0  d3d9              BCC      |L8.134|
                  |L8.210|
0000d2  f5056500          ADD      r5,r5,#0x800          ;250
                  |L8.214|
0000d6  42b5              CMP      r5,r6                 ;249
0000d8  d3cf              BCC      |L8.122|
0000da  a028              ADR      r0,|L8.380|
0000dc  f7fffffe          BL       __2printf
0000e0  2000              MOVS     r0,#0                 ;262
0000e2  e7ef              B        |L8.196|
;;;264    int psec(char *buf, unsigned int n)
                          ENDP

                  |L8.228|
0000e4  20204552          DCB      "  ERROR: Loader Image is larger than %d KBytes!\n",0
0000e8  524f523a
0000ec  204c6f61
0000f0  64657220
0000f4  496d6167
0000f8  65206973
0000fc  206c6172
000100  67657220
000104  7468616e
000108  20256420
00010c  4b427974
000110  6573210a
000114  00      
000115  00                DCB      0
000116  00                DCB      0
000117  00                DCB      0
                  |L8.280|
000118  20204552          DCB      "  ERROR: Loader Image is 0 bytes!\n",0
00011c  524f523a
000120  204c6f61
000124  64657220
000128  496d6167
00012c  65206973
000130  20302062
000134  79746573
000138  210a00  
00013b  00                DCB      0
                  |L8.316|
00013c  50726f67          DCB      "Program image to flash address 0x%x...",0
000140  72616d20
000144  696d6167
000148  6520746f
00014c  20666c61
000150  73682061
000154  64647265
000158  73732030
00015c  7825782e
000160  2e2e00  
000163  00                DCB      0
                  |L8.356|
000164  45726173          DCB      "Erase failed on 0x%x\n",0
000168  65206661
00016c  696c6564
000170  206f6e20
000174  30782578
000178  0a00    
00017a  00                DCB      0
00017b  00                DCB      0
                  |L8.380|
00017c  4f4b2e0a          DCB      "OK.\n",0
000180  00      
000181  00                DCB      0
000182  00                DCB      0
000183  00                DCB      0
                  |L8.388|
000184  56657269          DCB      "Verify ...",0
000188  6679202e
00018c  2e2e00  
00018f  00                DCB      0
                  |L8.400|
                          DCD      0x4000c000
                  |L8.404|
000194  64617461          DCB      "data mismatch on 0x%x, [0x%x], [0x%x]\n",0
000198  206d6973
00019c  6d617463
0001a0  68206f6e
0001a4  20307825
0001a8  782c205b
0001ac  30782578
0001b0  5d2c205b
0001b4  30782578
0001b8  5d0a00  
0001bb  00                DCB      0

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;136    unsigned char RECV[2048] = {0};
;;;137    int32_t main (void)
000000  b53e              PUSH     {r1-r5,lr}
;;;138    {
;;;139        int             cbs;
;;;140        uint32_t        au32Config[2];
;;;141        uint32_t        au32Version[2];
;;;142        volatile int    loop;
;;;143    		uint8_t Qhuan;
;;;144        /* Init System, IP clock and multi-function I/O */
;;;145        SYS_Init();
000002  f7fffffe          BL       SYS_Init
;;;146        /* Init UART to 115200-8n1 for print message */
;;;147        UART0_Init();
000006  f7fffffe          BL       UART0_Init
;;;148    		Timer0_Init();
00000a  f7fffffe          BL       Timer0_Init
;;;149        /* Enable FMC ISP function */
;;;150        SYS_UnlockReg();
00000e  f7fffffe          BL       SYS_UnlockReg
;;;151    
;;;152        FMC_Open();
000012  f7fffffe          BL       FMC_Open
;;;153    		
;;;154        FMC_ReadConfig(au32Config, 2);
000016  2102              MOVS     r1,#2
000018  a801              ADD      r0,sp,#4
00001a  f7fffffe          BL       FMC_ReadConfig
;;;155        cbs = (au32Config[0] >> 6) & 0x3;
;;;156    //    printf("Config0 = 0x%x, Config1 = 0x%x, CBS=%d\n", au32Config[0], au32Config[1], cbs);
;;;157    //    printf("Boot loader program running on APROM\n");
;;;158    
;;;159    //    au32Version[0] = FMC_Read(USER_AP0_ENTRY+0x1000);
;;;160    //		send_Zmodem("test.txt",11);
;;;161    			for(;;)
;;;162    			{
;;;163    				printf("\n请使用hypertrm进行文件接收或发送\n");
;;;164    				printf("\n请选择功能\n1：接收文件（test.txt）\n2: 发送文件\n");
;;;165    				UART_Read(UART0,&Qhuan,1);
00001e  4c10              LDR      r4,|L9.96|
                  |L9.32|
000020  a010              ADR      r0,|L9.100|
000022  f7fffffe          BL       __2printf
000026  a018              ADR      r0,|L9.136|
000028  f7fffffe          BL       __2printf
00002c  2201              MOVS     r2,#1
00002e  4669              MOV      r1,sp
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       UART_Read
;;;166    				if(Qhuan == '1'||Qhuan == '2')
000036  f89d1000          LDRB     r1,[sp,#0]
00003a  2931              CMP      r1,#0x31
00003c  d002              BEQ      |L9.68|
00003e  2932              CMP      r1,#0x32
000040  d1ee              BNE      |L9.32|
000042  e007              B        |L9.84|
                  |L9.68|
;;;167    					break;
;;;168    			}
;;;169    			if(Qhuan == '1')
;;;170    				send_Zmodem("test.txt",11);
000044  210b              MOVS     r1,#0xb
000046  a01d              ADR      r0,|L9.188|
000048  f7fffffe          BL       send_Zmodem
;;;171    //		RZ_InitReceiver();
;;;172    			if(Qhuan == '2')
00004c  f89d0000          LDRB     r0,[sp,#0]
000050  2832              CMP      r0,#0x32
000052  d102              BNE      |L9.90|
                  |L9.84|
;;;173    				get_Zmodem(RECV);
000054  481c              LDR      r0,|L9.200|
000056  f7fffffe          BL       get_Zmodem
                  |L9.90|
;;;174    #if 0
;;;175    		while(1){	
;;;176    		//	printf("\n是否更新APP1请输入 y or n？\n");
;;;177    			while(1){
;;;178    				printf("\n是否更新APP1请输入 y or n？\n");	
;;;179    				UART_Read(UART0,&Qhuan,1);
;;;180    				if(Qhuan=='y'){
;;;181    				//	printf("this is a test\n");
;;;182    					FMC_EnableAPUpdate();
;;;183    					ZmodemReceiveFiles();					
;;;184    				  FMC_DisableAPUpdate();
;;;185    				  while (!IsDebugFifoEmpty()){};
;;;186    				}else if(Qhuan=='n'){
;;;187    						break;	
;;;188    				}
;;;189    ////				FMC_EnableAPUpdate();
;;;190    ////					psec(bbs,4);
;;;191    ////				FMC_DisableAPUpdate();
;;;192    ////				while (!IsDebugFifoEmpty()){};
;;;193    			}
;;;194    			printf("\n\nDo you want to branch AP1?(Yes/No)\n");
;;;195    			au32Version[1] = FMC_Read(USER_AP1_ENTRY+0x1000);
;;;196    			while(1){
;;;197    				UART_Read(UART0,&Qhuan,1);
;;;198    				if(Qhuan=='y'){
;;;199    					printf("Version Check\n");
;;;200    					printf("Version for AP1:0x%x\n",au32Version[1]);							
;;;201    					printf("Jumps to AP1\n");	
;;;202    						BranchTo(USER_AP1_ENTRY);
;;;203    					
;;;204    				}else if(Qhuan=='n'){
;;;205    					break;
;;;206    				}
;;;207    				
;;;208    					
;;;209    			}
;;;210        printf("Don't find any program on APROM\n");
;;;211    	    
;;;212      } 
;;;213    #endif		
;;;214    }
00005a  2000              MOVS     r0,#0
00005c  bd3e              POP      {r1-r5,pc}
;;;215    
                          ENDP

00005e  0000              DCW      0x0000
                  |L9.96|
                          DCD      0x40070000
                  |L9.100|
000064  0ac7ebca          DCB      "\n",199,235,202,185,211,195,"hypertrm",189,248,208,208,206
000068  b9d3c368
00006c  79706572
000070  74726dbd
000074  f8d0d0ce
000078  c4bcfebd          DCB      196,188,254,189,211,202,213,187,242,183,162,203,205,"\n",0
00007c  d3cad5bb
000080  f2b7a2cb
000084  cd0a00  
000087  00                DCB      0
                  |L9.136|
000088  0ac7ebd1          DCB      "\n",199,235,209,161,212,241,185,166,196,220,"\n1",163,186
00008c  a1d4f1b9
000090  a6c4dc0a
000094  31a3ba  
000097  bdd3cad5          DCB      189,211,202,213,206,196,188,254,163,168,"test.txt",163,169
00009b  cec4bcfe
00009f  a3a87465
0000a3  73742e74
0000a7  7874a3a9
0000ab  0a323a20          DCB      "\n2: ",183,162,203,205,206,196,188,254,"\n",0
0000af  b7a2cbcd
0000b3  cec4bcfe
0000b7  0a00    
0000b9  00                DCB      0
0000ba  00                DCB      0
0000bb  00                DCB      0
                  |L9.188|
0000bc  74657374          DCB      "test.txt",0
0000c0  2e747874
0000c4  00      
0000c5  00                DCB      0
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L9.200|
                          DCD      ||.bss||

                          AREA ||i.psec||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  psec PROC
;;;263    }
;;;264    int psec(char *buf, unsigned int n)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;265    {
000004  460f              MOV      r7,r1
000006  4604              MOV      r4,r0
;;;266    		unsigned int j;
;;;267     		unsigned int RamSource;
;;;268    		static uint32_t FlashDestination=0x00004000;
;;;269    		RamSource = (uint32_t)buf;
;;;270    		for (j = 0; j < n; j += 4){
000008  2500              MOVS     r5,#0
;;;271            	//判断是否到了新的一页起始处，此时擦除STM32内部FLASH另一新页
;;;272    			if(0 == (FlashDestination) % STM32_FLASH_PAGE_SIZE){
;;;273    				if (FMC_Erase(FlashDestination)) {
;;;274                printf("Erase failed on 0x%x\n", FlashDestination);
;;;275                return -1;
00000a  f04f38ff          MOV      r8,#0xffffffff
00000e  4e12              LDR      r6,|L10.88|
000010  e01e              B        |L10.80|
                  |L10.18|
000012  6830              LDR      r0,[r6,#0]            ;272  ; FlashDestination
000014  0541              LSLS     r1,r0,#21             ;272
000016  d107              BNE      |L10.40|
000018  f7fffffe          BL       FMC_Erase
00001c  b120              CBZ      r0,|L10.40|
00001e  a00f              ADR      r0,|L10.92|
000020  6831              LDR      r1,[r6,#0]            ;274  ; FlashDestination
000022  f7fffffe          BL       __2printf
000026  e008              B        |L10.58|
                  |L10.40|
;;;276            }
;;;277    			}
;;;278    			/* Program the data received into STM32F10x Flash */
;;;279    			
;;;280    			FMC_Write(FlashDestination, *(uint32_t*)RamSource);
000028  6821              LDR      r1,[r4,#0]
00002a  6830              LDR      r0,[r6,#0]  ; FlashDestination
00002c  f7fffffe          BL       FMC_Write
;;;281          if (*(uint32_t *)FlashDestination != *(uint32_t *)RamSource){
000030  6830              LDR      r0,[r6,#0]  ; FlashDestination
000032  6801              LDR      r1,[r0,#0]
000034  6820              LDR      r0,[r4,#0]
000036  4281              CMP      r1,r0
000038  d002              BEQ      |L10.64|
                  |L10.58|
;;;282    				/* 比较失败，STM32内部FLASH字编程出错，End session */
;;;283    					return ZMODEMERROR;
00003a  4640              MOV      r0,r8
                  |L10.60|
;;;284    			}
;;;285    	
;;;286    			printf("\n\r\n\r%x\n\r\n\r", *(uint32_t *)FlashDestination);
;;;287    			//下一编程位置和下一编程数据
;;;288          FlashDestination += 4;
;;;289          RamSource += 4;
;;;290    		
;;;291    		}
;;;292    		return 0;
;;;293    }
00003c  e8bd81f0          POP      {r4-r8,pc}
                  |L10.64|
000040  a00c              ADR      r0,|L10.116|
000042  f7fffffe          BL       __2printf
000046  6830              LDR      r0,[r6,#0]            ;288  ; FlashDestination
000048  1d24              ADDS     r4,r4,#4              ;288
00004a  1d00              ADDS     r0,r0,#4              ;288
00004c  1d2d              ADDS     r5,r5,#4              ;288
00004e  6030              STR      r0,[r6,#0]            ;288  ; FlashDestination
                  |L10.80|
000050  42bd              CMP      r5,r7                 ;270
000052  d3de              BCC      |L10.18|
000054  2000              MOVS     r0,#0                 ;292
000056  e7f1              B        |L10.60|
;;;294    
                          ENDP

                  |L10.88|
                          DCD      ||area_number.15||
                  |L10.92|
00005c  45726173          DCB      "Erase failed on 0x%x\n",0
000060  65206661
000064  696c6564
000068  206f6e20
00006c  30782578
000070  0a00    
000072  00                DCB      0
000073  00                DCB      0
                  |L10.116|
000074  0a0d0a0d          DCB      "\n\r\n\r%x\n\r\n\r",0
000078  25780a0d
00007c  0a0d00  
00007f  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  RECV
                          %        2048

                          AREA ||.data||, DATA, ALIGN=0

                  bbs
000000  11121314          DCB      0x11,0x12,0x13,0x14

                          AREA ||area_number.15||, DATA, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.data||
                  FlashDestination
                          DCD      0x00004000

;*** Start embedded assembler ***

#line 1 "..\\ap0_main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_ap0_main_c_bbs____REV16|
#line 114 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_ap0_main_c_bbs____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_ap0_main_c_bbs____REVSH|
#line 128
|__asm___10_ap0_main_c_bbs____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP
	AREA ||ei.__set_SP||, group =|__set_SP|, CODE
	THUMB
	EXPORT |__set_SP|
#line 39 "..\\ap0_main.c"
|__set_SP| PROC
#line 40

 MSR MSP, r0
 BX lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
