L 1 "..\..\..\..\Library\StdDriver\src\clk.c"
N/**************************************************************************//**
N * @file     clk.c
N * @version  V3.00
N * $Revision: 35 $
N * $Date: 15/08/11 10:26a $
N * @brief    M451 series CLK driver source file
N *
N * @note
N * Copyright (C) 2014~2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N
N#include "M451Series.h"
L 1 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 1
N/******************************************************************************
N * @file     M451Series.h
N * @version  V3.10
N * $Revision: 179 $
N * $Date: 15/09/04 3:45p $
N * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File for M451 Series MCU
N *
N * @note
N * Copyright (C) 2014~2015 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N
N
N/**
N  \mainpage Introduction
N  *
N  *
N  * This user manual describes the usage of M451 Series MCU device driver
N  *
N  * <b>Disclaimer</b>
N  *
N  * The Software is furnished "AS IS", without warranty as to performance or results, and
N  * the entire risk as to performance or results is assumed by YOU. Nuvoton disclaims all
N  * warranties, express, implied or otherwise, with regard to the Software, its use, or
N  * operation, including without limitation any and all warranties of merchantability, fitness
N  * for a particular purpose, and non-infringement of intellectual property rights.
N  *
N  * <b>Copyright Notice</b>
N  *
N  * Copyright (C) 2014~2015 Nuvoton Technology Corp. All rights reserved.
N  */
N
N/**
N  * \page PG_REV Revision History
N  *
N  * <b>Revision 3.01.001</b>
N  * \li Added Nu-LB-M451, NuEdu and USB device sample code.
N  * \li Added a lacking macro SYS_IS_LVR_RST() to SYS driver.
N  * \li Added a sample code DAC_PDMA_ScatterGather_PWMTrigger to use PDMA scatter gather mode and trigger DAC by PWM.
N  * \li Added counter type constant definitions: PWM_UP_COUNTER, PWM_DOWN_COUNTER, and PWM_UP_DOWN_COUNTER.
N  * \li Added DAC_PDMA_PWMTrigger sample code to use PDMA and trigger DAC by PWM.
N  * \li Added a sample code EADC_PDMA_PWM_Trigger to trigger EADC with PWM and copy result by PDMA.
N  * \li Added a new function to control systick and select systick clock source CLK_EnableSysTick() and CLK_DisableSysTick() in CLK driver.
N  * \li Added 'NMIEN' and 'NMISTS' control registers to M451Series.h for NMI control.
N  * \li Added PDMA_ScatterGather_PingPongBuffer sample code to create ping-pong buffer with PDMA scatter gather mode.
N  * \li Added 'PE_DRVCTL' register of GPIO to M451Series.h for GPIO driving strength control.
N  * \li Added a sample code PWM_PDMA_Capture to transfer PWM capture data by PDMA.
N  * \li Added SCLIB_ActivateDelay API for initial SC with non-standard H/W design in SC driver
N  * \li Fixed the bug of EADC_IS_INT_FLAG_OV() that accesses the incorrect register.
N  * \li Fixed the bug of EADC_IS_SAMPLE_MODULE_OV() that accesses the incorrect register. 
N  * \li Fixed the bug of EADC_SetExtendSampleTime() for position shift error in EADC driver.
N  * \li Fixed the bug of EADC_SetTriggerDelayTime() for position shift error in EADC driver.
N  * \li Fixed the bug of PWM_ENABLE_OUTPUT_INVERTER () that output inverter function cannot be disabled.
N  * \li Fixed the bug of PWM_MASK_OUTPUT() in PWM driver that mask function cannot be disabled.
N  * \li Fixed CAN_STATUS_LEC_Msk from 0x03 to 0x07.
N  * \li Fixed the bug of CLK_SysTickDelay() that COUNTFLAG may not be cleared in CLK driver.
N  * \li Fixed CTL and PINCTL regsiter synchronize issue by waiting synchronized ready flag in SC driver.
N  * \li Fixed DAC_SetDelayTime() calculation error in DAC driver because the dac->TCTL only used 10 bits, not 14 bits.
N  * \li Fixed EADC_CMP_ADCMPIE_DISABLE definition error. 
N  * \li Fixed EADC_CMP_ADCMPIE_DISABLE definition error. 
N  * \li Fixed IAR entry point from __iar_program_start to Reset_Handler
N  * \li Fixed PWM_ConfigOutputChannel() return value bug in PWM driver.
N  * \li Fixed the bug of PWM_ConfigSyncPhase() that cannot configure synchronized source for channel2~5.
N  * \li Fixed SC_SET_STOP_BIT_LEN definition error.
N  * \li Fixed SCUART baudrate return error in SCUART_Open and SCUART_SetLineConfig API of SCUART driver.
N  * \li Fixed SCUART_PARITY_NONE/SCUART_PARITY_EVEN/SCUART_PARITY_ODD definition bug in SCUART driver.
N  * \li Fixed u32DataWidth setting error by sc->UARTCTL in SCUART_SetLineConfig API of SCUART driver.
N  * \li Fixed SMBD_Enable constant value definition error in I2C driver.
N  * \li Fixed the problem that MSC device detection is aborted due to REQUEST_SENSE command not ready.
N  * \li Fixed UART clock setting bug in UART_Open(), UART_SetLine_Config() and UART_SelectIrDAMode() of UART driver.
N  * \li Improved compatibility of USBH driver for pen driver.
N  * \li Improved EADC_ConfigSampleModule() to support rising and falling trigger at the same time.
N  * \li Improved EBI_SRAM sample code to add PDMA data transfer with EBI.
N  * \li Improved SC driver to support more than one SC port.
N  * \li Improved USBH driver to support composite HID devices
N  * \li Improved USBD driver to support more USB device sample code.
N  * \li Modified I2C_STOP() from #define to inline and add waiting STO bit clear to 0 . This modified is safe for next START coming soon.
N  * \li Removed CRC clock enabled in CRC_Open(). User should enable CRC clock in system initialization before any CRC operation.
N  * \li Removed FMC_ReadDID() in FMC driver. This function was no longer supported.
N  * \li Removed I2C_CTL_STA_STO_SI and I2C_CTL_STA_STO_SI_AA definitions to avoid STOP and START write to control bit at the same time.
N  *
N  * <b>Revision 3.00.005</b>
N  * \li Fixed EADC_CTL_DMOF_STRAIGHT_BINARY and EADC_CTL_DMOF_TWOS_COMPLEMENT definition error in EADC driver.
N  * \li Fixed EADC_FALLING_EDGE_TRIGGER definition error in EADC driver.
N  * \li Fixed EADC_RISING_EDGE_TRIGGER definition error in EADC driver.
N  * \li Fixed UART transmit data bug in UART_TEST_HANDLE() of UART_TxRxFunction sample code.
N  * \li Fixed the data missing bug when BULK IN transfer is end by max packet size packet at last packet in USBD_VCOM sample code.
N  * \li Fixed program user configuration area without erase in USBD_MassStorage_DataFlash sample code.
N  * \li Fixed the bug of switching HCLK to HIRC before enabling PLL in CLK_SetCoreClock() of CLK driver.
N  * \li Fixed isochronous transfer bugs of USB Host library.
N  * \li Fixed Clear Modem Status Interrupt flag bug in UART_ClearIntFlag() of UART driver.
N  * \li Fixed the time-out flag clear bug in I2C_ClearTimeoutFlag() of I2C driver.
N  * \li Replaced PERIOD0~5 with PERIOD[6] in PWM_T, and modified PERIOD bit field constant definition in M451Series.h.
N  * \li Replaced CMPDAT0~5 with CMPDAT0[6] in PWM_T, and modified CMPDAT bit field constant definition in M451Series.h.
N  * \li Replaced CNT0~5 with CNT[6] in PWM_T, and modified CNT bit field constant definition in M451Series.h.
N  * \li Replaced PBUF0~5 with PBUF[6] in PWM_T, and modified PBUF bit field constant definition in M451Series.h.
N  * \li Replaced CMPBUF0~5 with CMPBUF[6] in PWM_T, and modified CMPBUF bit field constant definition in M451Series.h.
N  * \li Replaced CURSCAT0~CURSCAT11 with CURSCAT[12] in PDMA_T of M451Series.h.
N  * \li Modified CLK_WaitClockReady() time-out to about 300 ms in CLK driver.
N  * \li Updated USB USBD_MassStorage_DataFlash sample code and USB Driver to pass USB-IF MSC test. (The MassStorage size must be greater than 64 KB; otherwise, Command Set test will fail in MSC test).
N  * \li Replaced old HID library file (open source) with Nuvoton HID library in USB Host library. 
N  * \li Added USBH_Audio_Class and USBH_UAC_HID sample code for USB Host to support UAC + HID device.
N  *
N  * <b>Revision 3.00.004</b>
N  * \li Fixed the time-out from 5 ms to 300 ms in CLK_WaitClockReady() of CLK driver.
N  * \li Fixed the bug of UART_ClearIntFlag() in UART driver to only clear one flag at one time.
N  * \li Fixed the missing parameter, UART clock source LXT, for CLK_SetModuleClock() in UART driver.
N  * \li Fixed the bug of clearing data and CTS wake-up flag to clear one flag at one time in UART1_IRQHandler() of UART_Wakeup sample code.
N  * \li Fixed the bug of RS485_HANDLE() in the UART_RS485_Slave sample code to only clear one flag at one time.
N  * \li Fixed the bug of clearing auto baud rate detect finished and time-out flag to clear one flag at one time in AutoBaudRate_RxTest() of UART_AutoBaudRate_Slave sample code.
N  * \li Fixed NVIC_EnableIRQ() to NVIC_DisableIRQ() after chip wake-up in I2C_Wakeup_Slave sample code.
N  * \li Fixed multi-function setting error of SC CD pin in USBD_CCID sample code.
N  * \li Fixed PD.7 (Headphone output control pin) output mode configuration in WAU8822_Setup() of USBD_Audio_NAU8822 sample code.
N  * \li Fixed wrong CLK_WaitClockReady parameter in I2C_GCMode_Slave sample code.
N  * \li Fixed UART data transfer bug of USBD_VCOM sample code.
N  * \li Updated CLK driver to avoid HIRC force enabled in CLK_SetHCLK() and CLK_SetCoreClock().
N  * \li Updated USBD driver to pass USB-IF MSC test.
N  * \li Updated USBD_MassStorage_DataFlash sample code to pass USB-IF MSC test.
N  * \li Updated driver of VCOM for win8 certification in USBD_VCOM sample code.
N  * \li Added HID Media key supporting in USBD_Audio_HID_NAU8822 sample code.
N  * \li Added new sample code USBH_UAC_HID of USB Host to support UAC + HID device.
N  * \li Added new sample code USBH_Audio_Class to support USB audio class device (UAC).
N  *
N  * <b>Revision 3.00.003</b>
N  * \li Added USBD_Audio_HID_NAU8822 sample code.
N  *
N  * <b>Revision 3.00.002</b>
N  * \li Fixed serial number code in device descriptor.
N  * \li Fixed EBI_Open API did not perform u32CSActiveLevel parameters to set CS pin polar.
N  * \li Fixed SMBus bus time-out and Clock Lo time-out API.
N  * \li Fixed I2C0,1 IP reset of SYS_IPRST1.
N  * \li Fixed include path of CMSIS.
N  * \li Fixed SPI_CLR_UNIT_TRANS_INT_FLAG( ) definition.
N  * \li Fixed USBD_INT_WAKEUP definition.
N  * \li Modified USBD driver to support USB remote wake-up function.
N  *
N  * <b>Revision 3.00.001</b>
N  * \li Initial Release.
N*/
N
N#ifndef __M451SERIES_H__
N#define __M451SERIES_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/******************************************************************************/
N/*                Processor and Core Peripherals                              */
N/******************************************************************************/
N/** @addtogroup CMSIS Device CMSIS Definitions
N  Configuration of the Cortex-M4 Processor and Core Peripherals
N  @{
N*/
N
N/*
N * ==========================================================================
N * ---------- Interrupt Number Definition -----------------------------------
N * ==========================================================================
N */
N
Ntypedef enum IRQn
N{
N    /******  Cortex-M4 Processor Exceptions Numbers ***************************************************/
N    NonMaskableInt_IRQn           = -14,      /*!<  2 Non Maskable Interrupt                        */
N    MemoryManagement_IRQn         = -12,      /*!<  4 Memory Management Interrupt                   */
N    BusFault_IRQn                 = -11,      /*!<  5 Bus Fault Interrupt                           */
N    UsageFault_IRQn               = -10,      /*!<  6 Usage Fault Interrupt                         */
N    SVCall_IRQn                   = -5,       /*!< 11 SV Call Interrupt                             */
N    DebugMonitor_IRQn             = -4,       /*!< 12 Debug Monitor Interrupt                       */
N    PendSV_IRQn                   = -2,       /*!< 14 Pend SV Interrupt                             */
N    SysTick_IRQn                  = -1,       /*!< 15 System Tick Interrupt                         */
N
N    /******  M451 Specific Interrupt Numbers ********************************************************/
N
N    BOD_IRQn                      = 0,        /*!< Brown Out detection Interrupt                    */
N    IRC_IRQn                      = 1,        /*!< Internal RC Interrupt                            */
N    PWRWU_IRQn                    = 2,        /*!< Power Down Wake Up Interrupt                     */
N    RAMPE_IRQn                    = 3,        /*!< SRAM parity check failed Interrupt               */
N    CKFAIL_IRQn                   = 4,        /*!< Clock failed Interrupt                           */
N    RTC_IRQn                      = 6,        /*!< Real Time Clock Interrupt                        */
N    TAMPER_IRQn                   = 7,        /*!< Tamper detection Interrupt                       */
N    WDT_IRQn                      = 8,        /*!< Watchdog Timer Interrupt                         */
N    WWDT_IRQn                     = 9,        /*!< Window Watchdog Timer Interrupt                  */
N    EINT0_IRQn                    = 10,       /*!< External Input 0 Interrupt                       */
N    EINT1_IRQn                    = 11,       /*!< External Input 1 Interrupt                       */
N    EINT2_IRQn                    = 12,       /*!< External Input 2 Interrupt                       */
N    EINT3_IRQn                    = 13,       /*!< External Input 3 Interrupt                       */
N    EINT4_IRQn                    = 14,       /*!< External Input 4 Interrupt                       */
N    EINT5_IRQn                    = 15,       /*!< External Input 5 Interrupt                       */
N    GPA_IRQn                      = 16,       /*!< GPIO Port A Interrupt                            */
N    GPB_IRQn                      = 17,       /*!< GPIO Port B Interrupt                            */
N    GPC_IRQn                      = 18,       /*!< GPIO Port C Interrupt                            */
N    GPD_IRQn                      = 19,       /*!< GPIO Port D Interrupt                            */
N    GPE_IRQn                      = 20,       /*!< GPIO Port E Interrupt                            */
N    GPF_IRQn                      = 21,       /*!< GPIO Port F Interrupt                            */
N    SPI0_IRQn                     = 22,       /*!< SPI0 Interrupt                                   */
N    SPI1_IRQn                     = 23,       /*!< SPI1 Interrupt                                   */
N    BRAKE0_IRQn                   = 24,       /*!< BRAKE0 Interrupt                                 */
N    PWM0P0_IRQn                   = 25,       /*!< PWM0P0 Interrupt                                 */
N    PWM0P1_IRQn                   = 26,       /*!< PWM0P1 Interrupt                                 */
N    PWM0P2_IRQn                   = 27,       /*!< PWM0P2 Interrupt                                 */
N    BRAKE1_IRQn                   = 28,       /*!< BRAKE1 Interrupt                                 */
N    PWM1P0_IRQn                   = 29,       /*!< PWM1P0 Interrupt                                 */
N    PWM1P1_IRQn                   = 30,       /*!< PWM1P1 Interrupt                                 */
N    PWM1P2_IRQn                   = 31,       /*!< PWM1P2 Interrupt                                 */
N    TMR0_IRQn                     = 32,       /*!< Timer 0 Interrupt                                */
N    TMR1_IRQn                     = 33,       /*!< Timer 1 Interrupt                                */
N    TMR2_IRQn                     = 34,       /*!< Timer 2 Interrupt                                */
N    TMR3_IRQn                     = 35,       /*!< Timer 3 Interrupt                                */
N    UART0_IRQn                    = 36,       /*!< UART 0 Interrupt                                 */
N    UART1_IRQn                    = 37,       /*!< UART 1 Interrupt                                 */
N    I2C0_IRQn                     = 38,       /*!< I2C 0 Interrupt                                  */
N    I2C1_IRQn                     = 39,       /*!< I2C 1 Interrupt                                  */
N    PDMA_IRQn                     = 40,       /*!< Peripheral DMA Interrupt                         */
N    DAC_IRQn                      = 41,       /*!< DAC Interrupt                                    */
N    ADC00_IRQn                    = 42,       /*!< ADC0 Source 0 Interrupt                          */
N    ADC01_IRQn                    = 43,       /*!< ADC0 Source 1 Interrupt                          */
N    ACMP01_IRQn                   = 44,       /*!< Analog Comparator 0 and 1 Interrupt              */
N    ADC02_IRQn                    = 46,       /*!< ADC0 Source 2 Interrupt                          */
N    ADC03_IRQn                    = 47,       /*!< ADC0 Source 3 Interrupt                          */
N    UART2_IRQn                    = 48,       /*!< UART2 Interrupt                                  */
N    UART3_IRQn                    = 49,       /*!< UART3 Interrupt                                  */
N    SPI2_IRQn                     = 51,       /*!< SPI2 Interrupt                                   */
N    USBD_IRQn                     = 53,       /*!< USB device Interrupt                             */
N    USBH_IRQn                     = 54,       /*!< USB host Interrupt                               */
N    USBOTG_IRQn                   = 55,       /*!< USB OTG Interrupt                                */
N    CAN0_IRQn                     = 56,       /*!< CAN0 Interrupt                                   */
N    SC0_IRQn                      = 58,       /*!< Smart Card 0 Interrupt                           */
N    TK_IRQn                       = 63        /*!< Touch Key Interrupt                              */
N} IRQn_Type;
N
N
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N/* Configuration of the Cortex-M# Processor and Core Peripherals */
N#define __CM4_REV                 0x0201    /*!< Core Revision r2p1                               */
N#define __NVIC_PRIO_BITS          4         /*!< Number of Bits used for Priority Levels          */
N#define __Vendor_SysTickConfig    0         /*!< Set to 1 if different SysTick Config is used     */
N#define __MPU_PRESENT             1         /*!< MPU present or not                               */
N#define __FPU_PRESENT             1         /*!< FPU present or not                               */
N
N/*@}*/ /* end of group CMSIS */
N
N#include "core_cm4.h"                       /* Cortex-M4 processor and core peripherals           */
L 1 "..\..\..\..\Library\CMSIS\Include\core_cm4.h" 1
N/**************************************************************************//**
N * @file     core_cm4.h
N * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
N * @version  V3.01
N * @date     22. March 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#ifndef __CORE_CM4_H_GENERIC
N#define __CORE_CM4_H_GENERIC
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex_M4
N  @{
N */
N
N/*  CMSIS CM4 definitions */
N#define __CM4_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
N#define __CM4_CMSIS_VERSION_SUB   (0x01)                                   /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16) | \
N                                    __CM4_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16) |                                     __CM4_CMSIS_VERSION_SUB          )      
N
N#define __CORTEX_M                (0x04)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not. For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.
N*/
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 1L
N    #if (__FPU_PRESENT == 1)
X    #if (1 == 1)
N      #define __FPU_USED       1
N    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
N    #endif
N  #else
S    #define __FPU_USED         0
N  #endif
N
N#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI_VFP_SUPPORT__
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
L 1 "C:\Keil_v5\ARM\ARMCC\bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 180721 $
N * Checkin $Date: 2013-06-24 09:41:57 +0100 (Mon, 24 Jun 2013) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5040049
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
N
L 154 "..\..\..\..\Library\CMSIS\Include\core_cm4.h" 2
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 "..\..\..\..\Library\CMSIS\Include\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V3.01
N * @date     06. March 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5040049 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N
N
N/** \brief  Rotate Right in unsigned value (32 bit)
N
N    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N
N    \param [in]    value  Value to rotate
N    \param [in]    value  Number of Bits to rotate
N    \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x04) >= 0x03)
N
N/** \brief  Reverse bit order of value
N
N    This function reverses the bit order of the given value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __RBIT                            __rbit
N
N
N/** \brief  LDR Exclusive (8 bit)
N
N    This function performs a exclusive LDR command for 8 bit value.
N
N    \param [in]    ptr  Pointer to data
N    \return             value of type uint8_t at (*ptr)
N */
N#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
N
N
N/** \brief  LDR Exclusive (16 bit)
N
N    This function performs a exclusive LDR command for 16 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint16_t at (*ptr)
N */
N#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
N
N
N/** \brief  LDR Exclusive (32 bit)
N
N    This function performs a exclusive LDR command for 32 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint32_t at (*ptr)
N */
N#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
N
N
N/** \brief  STR Exclusive (8 bit)
N
N    This function performs a exclusive STR command for 8 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXB(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  STR Exclusive (16 bit)
N
N    This function performs a exclusive STR command for 16 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXH(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  STR Exclusive (32 bit)
N
N    This function performs a exclusive STR command for 32 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXW(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  Remove the exclusive lock
N
N    This function removes the exclusive lock which is created by LDREX.
N
N */
N#define __CLREX                           __clrex
N
N
N/** \brief  Signed Saturate
N
N    This function saturates a signed value.
N
N    \param [in]  value  Value to be saturated
N    \param [in]    sat  Bit position to saturate to (1..32)
N    \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/** \brief  Unsigned Saturate
N
N    This function saturates an unsigned value.
N
N    \param [in]  value  Value to be saturated
N    \param [in]    sat  Bit position to saturate to (0..31)
N    \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/** \brief  Count leading zeros
N
N    This function counts the number of leading zeros of a data value.
N
N    \param [in]  value  Value to count the leading zeros
N    \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Rotate Right in unsigned value (32 bit)
S
S    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
S
S    \param [in]    value  Value to rotate
S    \param [in]    value  Number of Bits to rotate
S    \return               Rotated value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
S{
S
S  __ASM volatile ("ror %0, %0, %1" : "+r" (op1) : "r" (op2) );
S  return(op1);
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint8_t result;
S
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint16_t result;
S
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
S{
S  uint8_t result;
S
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 155 "..\..\..\..\Library\CMSIS\Include\core_cm4.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 "..\..\..\..\Library\CMSIS\Include\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V3.01
N * @date     06. March 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5040049 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get IPSR Register
N
N    This function returns the content of the IPSR Register.
N
N    \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x04) >= 0x03)
N
N/** \brief  Enable FIQ
N
N    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
N    Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/** \brief  Disable FIQ
N
N    This function disables FIQ interrupts by setting the F-bit in the CPSR.
N    Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/** \brief  Get Base Priority
N
N    This function returns the current value of the Base Priority register.
N
N    \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/** \brief  Set Base Priority
N
N    This function assigns the given value to the Base Priority register.
N
N    \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xff);
N}
N
N
N/** \brief  Get Fault Mask
N
N    This function returns the current value of the Fault Mask register.
N
N    \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/** \brief  Set Fault Mask
N
N    This function assigns the given value to the Fault Mask register.
N
N    \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1);
N}
N
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N#if       (__CORTEX_M == 0x04)
X#if       ((0x04) == 0x04)
N
N/** \brief  Get FPSCR
N
N    This function returns the current value of the Floating Point Status/Control register.
N
N    \return               Floating Point Status/Control register value
N */
N__STATIC_INLINE uint32_t __get_FPSCR(void)
Xstatic __inline uint32_t __get_FPSCR(void)
N{
N#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
X#if (1 == 1) && (1 == 1)
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  return(__regfpscr);
N#else
S   return(0);
N#endif
N}
N
N
N/** \brief  Set FPSCR
N
N    This function assigns the given value to the Floating Point Status/Control register.
N
N    \param [in]    fpscr  Floating Point Status/Control value to set
N */
N__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
Xstatic __inline void __set_FPSCR(uint32_t fpscr)
N{
N#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
X#if (1 == 1) && (1 == 1)
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  __regfpscr = (fpscr);
N#endif
N}
N
N#endif /* (__CORTEX_M == 0x04) */
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) );
S}
S
S
S/** \brief  Get IPSR Register
S
S    This function returns the content of the IPSR Register.
S
S    \return               IPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) );
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) );
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) );
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) );
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N#endif /* __CORE_CMFUNC_H */
L 156 "..\..\..\..\Library\CMSIS\Include\core_cm4.h" 2
N#include <core_cm4_simd.h>               /* Compiler specific SIMD Intrinsics               */
L 1 "..\..\..\..\Library\CMSIS\Include\core_cm4_simd.h" 1
N/**************************************************************************//**
N * @file     core_cm4_simd.h
N * @brief    CMSIS Cortex-M4 SIMD Header File
N * @version  V3.01
N * @date     06. March 2012
N *
N * @note
N * Copyright (C) 2010-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#ifndef __CORE_CM4_SIMD_H
N#define __CORE_CM4_SIMD_H
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N ******************************************************************************/
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
N#define __SADD8                           __sadd8
N#define __QADD8                           __qadd8
N#define __SHADD8                          __shadd8
N#define __UADD8                           __uadd8
N#define __UQADD8                          __uqadd8
N#define __UHADD8                          __uhadd8
N#define __SSUB8                           __ssub8
N#define __QSUB8                           __qsub8
N#define __SHSUB8                          __shsub8
N#define __USUB8                           __usub8
N#define __UQSUB8                          __uqsub8
N#define __UHSUB8                          __uhsub8
N#define __SADD16                          __sadd16
N#define __QADD16                          __qadd16
N#define __SHADD16                         __shadd16
N#define __UADD16                          __uadd16
N#define __UQADD16                         __uqadd16
N#define __UHADD16                         __uhadd16
N#define __SSUB16                          __ssub16
N#define __QSUB16                          __qsub16
N#define __SHSUB16                         __shsub16
N#define __USUB16                          __usub16
N#define __UQSUB16                         __uqsub16
N#define __UHSUB16                         __uhsub16
N#define __SASX                            __sasx
N#define __QASX                            __qasx
N#define __SHASX                           __shasx
N#define __UASX                            __uasx
N#define __UQASX                           __uqasx
N#define __UHASX                           __uhasx
N#define __SSAX                            __ssax
N#define __QSAX                            __qsax
N#define __SHSAX                           __shsax
N#define __USAX                            __usax
N#define __UQSAX                           __uqsax
N#define __UHSAX                           __uhsax
N#define __USAD8                           __usad8
N#define __USADA8                          __usada8
N#define __SSAT16                          __ssat16
N#define __USAT16                          __usat16
N#define __UXTB16                          __uxtb16
N#define __UXTAB16                         __uxtab16
N#define __SXTB16                          __sxtb16
N#define __SXTAB16                         __sxtab16
N#define __SMUAD                           __smuad
N#define __SMUADX                          __smuadx
N#define __SMLAD                           __smlad
N#define __SMLADX                          __smladx
N#define __SMLALD                          __smlald
N#define __SMLALDX                         __smlaldx
N#define __SMUSD                           __smusd
N#define __SMUSDX                          __smusdx
N#define __SMLSD                           __smlsd
N#define __SMLSDX                          __smlsdx
N#define __SMLSLD                          __smlsld
N#define __SMLSLDX                         __smlsldx
N#define __SEL                             __sel
N#define __QADD                            __qadd
N#define __QSUB                            __qsub
N
N#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
N                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
N
N#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
N                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
N
N
N/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
N
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
S#include <cmsis_iar.h>
S
S/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
S
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
S#include <cmsis_ccs.h>
S
S/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
S
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("sadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("ssub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("usub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("sadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("ssub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("usub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("sasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("ssax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("usax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USAD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("usad8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USADA8(uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S
S  __ASM volatile ("usada8 %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S#define __SSAT16(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT16(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S#define __USAT16(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT16(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UXTB16(uint32_t op1)
S{
S  uint32_t result;
S
S  __ASM volatile ("uxtb16 %0, %1" : "=r" (result) : "r" (op1));
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UXTAB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uxtab16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SXTB16(uint32_t op1)
S{
S  uint32_t result;
S
S  __ASM volatile ("sxtb16 %0, %1" : "=r" (result) : "r" (op1));
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SXTAB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("sxtab16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUAD  (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("smuad %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUADX (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("smuadx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLAD (uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S
S  __ASM volatile ("smlad %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLADX (uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S
S  __ASM volatile ("smladx %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S#define __SMLALD(ARG1,ARG2,ARG3) \
S({ \
S  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((uint64_t)(ARG3) >> 32), __ARG3_L = (uint32_t)((uint64_t)(ARG3) & 0xFFFFFFFFUL); \
S  __ASM volatile ("smlald %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
S  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
S })
X#define __SMLALD(ARG1,ARG2,ARG3) ({   uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((uint64_t)(ARG3) >> 32), __ARG3_L = (uint32_t)((uint64_t)(ARG3) & 0xFFFFFFFFUL);   __ASM volatile ("smlald %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) );   (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L);  })
S
S#define __SMLALDX(ARG1,ARG2,ARG3) \
S({ \
S  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((uint64_t)(ARG3) >> 32), __ARG3_L = (uint32_t)((uint64_t)(ARG3) & 0xFFFFFFFFUL); \
S  __ASM volatile ("smlaldx %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
S  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
S })
X#define __SMLALDX(ARG1,ARG2,ARG3) ({   uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((uint64_t)(ARG3) >> 32), __ARG3_L = (uint32_t)((uint64_t)(ARG3) & 0xFFFFFFFFUL);   __ASM volatile ("smlaldx %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) );   (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L);  })
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUSD  (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("smusd %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUSDX (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("smusdx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLSD (uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S
S  __ASM volatile ("smlsd %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLSDX (uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S
S  __ASM volatile ("smlsdx %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S#define __SMLSLD(ARG1,ARG2,ARG3) \
S({ \
S  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((ARG3) >> 32), __ARG3_L = (uint32_t)((ARG3) & 0xFFFFFFFFUL); \
S  __ASM volatile ("smlsld %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
S  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
S })
X#define __SMLSLD(ARG1,ARG2,ARG3) ({   uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((ARG3) >> 32), __ARG3_L = (uint32_t)((ARG3) & 0xFFFFFFFFUL);   __ASM volatile ("smlsld %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) );   (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L);  })
S
S#define __SMLSLDX(ARG1,ARG2,ARG3) \
S({ \
S  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((ARG3) >> 32), __ARG3_L = (uint32_t)((ARG3) & 0xFFFFFFFFUL); \
S  __ASM volatile ("smlsldx %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
S  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
S })
X#define __SMLSLDX(ARG1,ARG2,ARG3) ({   uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((ARG3) >> 32), __ARG3_L = (uint32_t)((ARG3) & 0xFFFFFFFFUL);   __ASM volatile ("smlsldx %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) );   (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L);  })
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SEL  (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("sel %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qadd %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qsub %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S#define __PKHBT(ARG1,ARG2,ARG3) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \
S  __ASM ("pkhbt %0, %1, %2, lsl %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  ); \
S  __RES; \
S })
X#define __PKHBT(ARG1,ARG2,ARG3) ({                            uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2);   __ASM ("pkhbt %0, %1, %2, lsl %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  );   __RES;  })
S
S#define __PKHTB(ARG1,ARG2,ARG3) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \
S  if (ARG3 == 0) \
S    __ASM ("pkhtb %0, %1, %2" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2)  ); \
S  else \
S    __ASM ("pkhtb %0, %1, %2, asr %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  ); \
S  __RES; \
S })
X#define __PKHTB(ARG1,ARG2,ARG3) ({                            uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2);   if (ARG3 == 0)     __ASM ("pkhtb %0, %1, %2" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2)  );   else     __ASM ("pkhtb %0, %1, %2, asr %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  );   __RES;  })
S
S/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
S
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S
S/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
S/* not yet supported */
S/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
S
S
N#endif
N
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CORE_CM4_SIMD_H */
N
N#ifdef __cplusplus
S}
N#endif
L 157 "..\..\..\..\Library\CMSIS\Include\core_cm4.h" 2
N
N#endif /* __CORE_CM4_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM4_H_DEPENDANT
N#define __CORE_CM4_H_DEPENDANT
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM4_REV
S    #define __CM4_REV               0x0000
S    #warning "__CM4_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __FPU_PRESENT
S    #define __FPU_PRESENT             0
S    #warning "__FPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          4
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N/*@} end of group Cortex_M4 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N  - Core FPU Register
N ******************************************************************************/
N/** \defgroup CMSIS_core_register Defines and Type Definitions
N    \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_CORE  Status and Control Registers
N    \brief  Core Register type definitions.
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N#if (__CORTEX_M != 0x04)
X#if ((0x04) != 0x04)
S    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N#else
N    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
N    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N#endif
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N#if (__CORTEX_M != 0x04)
X#if ((0x04) != 0x04)
S    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N#else
N    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
N    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N#endif
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N    \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[8];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[8];                  
N       uint32_t RESERVED0[24];
N  __IO uint32_t ICER[8];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register         */
X  volatile uint32_t ICER[8];                  
N       uint32_t RSERVED1[24];
N  __IO uint32_t ISPR[8];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register          */
X  volatile uint32_t ISPR[8];                  
N       uint32_t RESERVED2[24];
N  __IO uint32_t ICPR[8];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register        */
X  volatile uint32_t ICPR[8];                  
N       uint32_t RESERVED3[24];
N  __IO uint32_t IABR[8];                 /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register           */
X  volatile uint32_t IABR[8];                  
N       uint32_t RESERVED4[56];
N  __IO uint8_t  IP[240];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240];                  
N       uint32_t RESERVED5[644];
N  __O  uint32_t STIR;                    /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register     */
X  volatile  uint32_t STIR;                     
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0                                          /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL << NVIC_STIR_INTID_Pos)            /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB     System Control Block (SCB)
N    \brief      Type definitions for the System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N  __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register                          */
X  volatile uint32_t VTOR;                     
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N  __IO uint8_t  SHP[12];                 /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12];                  
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N  __IO uint32_t CFSR;                    /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register                    */
X  volatile uint32_t CFSR;                     
N  __IO uint32_t HFSR;                    /*!< Offset: 0x02C (R/W)  HardFault Status Register                             */
X  volatile uint32_t HFSR;                     
N  __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register                           */
X  volatile uint32_t DFSR;                     
N  __IO uint32_t MMFAR;                   /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register                      */
X  volatile uint32_t MMFAR;                    
N  __IO uint32_t BFAR;                    /*!< Offset: 0x038 (R/W)  BusFault Address Register                             */
X  volatile uint32_t BFAR;                     
N  __IO uint32_t AFSR;                    /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register                       */
X  volatile uint32_t AFSR;                     
N  __I  uint32_t PFR[2];                  /*!< Offset: 0x040 (R/ )  Processor Feature Register                            */
X  volatile const  uint32_t PFR[2];                   
N  __I  uint32_t DFR;                     /*!< Offset: 0x048 (R/ )  Debug Feature Register                                */
X  volatile const  uint32_t DFR;                      
N  __I  uint32_t ADR;                     /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register                            */
X  volatile const  uint32_t ADR;                      
N  __I  uint32_t MMFR[4];                 /*!< Offset: 0x050 (R/ )  Memory Model Feature Register                         */
X  volatile const  uint32_t MMFR[4];                  
N  __I  uint32_t ISAR[5];                 /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register                   */
X  volatile const  uint32_t ISAR[5];                  
N       uint32_t RESERVED0[5];
N  __IO uint32_t CPACR;                   /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register                   */
X  volatile uint32_t CPACR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Registers Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Registers Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N    \brief      Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/** \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N       uint32_t RESERVED0[1];
N  __I  uint32_t ICTR;                    /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register      */
X  volatile const  uint32_t ICTR;                     
N  __IO uint32_t ACTLR;                   /*!< Offset: 0x008 (R/W)  Auxiliary Control Register              */
X  volatile uint32_t ACTLR;                    
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0                                          /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL << SCnSCB_ICTR_INTLINESNUM_Pos)      /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N#define SCnSCB_ACTLR_DISOOFP_Pos            9                                          /*!< ACTLR: DISOOFP Position */
N#define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: DISOOFP Mask */
N
N#define SCnSCB_ACTLR_DISFPCA_Pos            8                                          /*!< ACTLR: DISFPCA Position */
N#define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: DISFPCA Mask */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2                                          /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1                                          /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0                                          /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL << SCnSCB_ACTLR_DISMCYCINT_Pos)        /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N    \brief      Type definitions for the System Timer Registers.
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N    \brief      Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/** \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __O  union
X  volatile  union
N  {
N    __O  uint8_t    u8;                  /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit                   */
X    volatile  uint8_t    u8;                   
N    __O  uint16_t   u16;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit                  */
X    volatile  uint16_t   u16;                  
N    __O  uint32_t   u32;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit                  */
X    volatile  uint32_t   u32;                  
N  }  PORT [32];                          /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers               */
N       uint32_t RESERVED0[864];
N  __IO uint32_t TER;                     /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register                 */
X  volatile uint32_t TER;                      
N       uint32_t RESERVED1[15];
N  __IO uint32_t TPR;                     /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register              */
X  volatile uint32_t TPR;                      
N       uint32_t RESERVED2[15];
N  __IO uint32_t TCR;                     /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register                */
X  volatile uint32_t TCR;                      
N       uint32_t RESERVED3[29];                                  
N  __O  uint32_t IWR;                     /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register            */
X  volatile  uint32_t IWR;                      
N  __I  uint32_t IRR;                     /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register             */
X  volatile const  uint32_t IRR;                      
N  __IO uint32_t IMCR;                    /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register     */
X  volatile uint32_t IMCR;                     
N       uint32_t RESERVED4[43];                                  
N  __O  uint32_t LAR;                     /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register                  */
X  volatile  uint32_t LAR;                      
N  __I  uint32_t LSR;                     /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register                  */
X  volatile const  uint32_t LSR;                      
N       uint32_t RESERVED5[6];                                   
N  __I  uint32_t PID4;                    /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                     
N  __I  uint32_t PID5;                    /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                     
N  __I  uint32_t PID6;                    /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                     
N  __I  uint32_t PID7;                    /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                     
N  __I  uint32_t PID0;                    /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                     
N  __I  uint32_t PID1;                    /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                     
N  __I  uint32_t PID2;                    /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                     
N  __I  uint32_t PID3;                    /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                     
N  __I  uint32_t CID0;                    /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                     
N  __I  uint32_t CID1;                    /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                     
N  __I  uint32_t CID2;                    /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                     
N  __I  uint32_t CID3;                    /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                     
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFUL << ITM_TPR_PRIVMASK_Pos)                /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16                                             /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10                                             /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL << ITM_TCR_ITMENA_Pos)                    /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1UL << ITM_IWR_ATVALIDM_Pos)                  /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1UL << ITM_IRR_ATREADYM_Pos)                  /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1UL << ITM_IMCR_INTEGRATION_Pos)              /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL << ITM_LSR_Present_Pos)                   /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N    \brief      Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/** \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  Control Register                          */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t CYCCNT;                  /*!< Offset: 0x004 (R/W)  Cycle Count Register                      */
X  volatile uint32_t CYCCNT;                   
N  __IO uint32_t CPICNT;                  /*!< Offset: 0x008 (R/W)  CPI Count Register                        */
X  volatile uint32_t CPICNT;                   
N  __IO uint32_t EXCCNT;                  /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register         */
X  volatile uint32_t EXCCNT;                   
N  __IO uint32_t SLEEPCNT;                /*!< Offset: 0x010 (R/W)  Sleep Count Register                      */
X  volatile uint32_t SLEEPCNT;                 
N  __IO uint32_t LSUCNT;                  /*!< Offset: 0x014 (R/W)  LSU Count Register                        */
X  volatile uint32_t LSUCNT;                   
N  __IO uint32_t FOLDCNT;                 /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register         */
X  volatile uint32_t FOLDCNT;                  
N  __I  uint32_t PCSR;                    /*!< Offset: 0x01C (R/ )  Program Counter Sample Register           */
X  volatile const  uint32_t PCSR;                     
N  __IO uint32_t COMP0;                   /*!< Offset: 0x020 (R/W)  Comparator Register 0                     */
X  volatile uint32_t COMP0;                    
N  __IO uint32_t MASK0;                   /*!< Offset: 0x024 (R/W)  Mask Register 0                           */
X  volatile uint32_t MASK0;                    
N  __IO uint32_t FUNCTION0;               /*!< Offset: 0x028 (R/W)  Function Register 0                       */
X  volatile uint32_t FUNCTION0;                
N       uint32_t RESERVED0[1];
N  __IO uint32_t COMP1;                   /*!< Offset: 0x030 (R/W)  Comparator Register 1                     */
X  volatile uint32_t COMP1;                    
N  __IO uint32_t MASK1;                   /*!< Offset: 0x034 (R/W)  Mask Register 1                           */
X  volatile uint32_t MASK1;                    
N  __IO uint32_t FUNCTION1;               /*!< Offset: 0x038 (R/W)  Function Register 1                       */
X  volatile uint32_t FUNCTION1;                
N       uint32_t RESERVED1[1];
N  __IO uint32_t COMP2;                   /*!< Offset: 0x040 (R/W)  Comparator Register 2                     */
X  volatile uint32_t COMP2;                    
N  __IO uint32_t MASK2;                   /*!< Offset: 0x044 (R/W)  Mask Register 2                           */
X  volatile uint32_t MASK2;                    
N  __IO uint32_t FUNCTION2;               /*!< Offset: 0x048 (R/W)  Function Register 2                       */
X  volatile uint32_t FUNCTION2;                
N       uint32_t RESERVED2[1];
N  __IO uint32_t COMP3;                   /*!< Offset: 0x050 (R/W)  Comparator Register 3                     */
X  volatile uint32_t COMP3;                    
N  __IO uint32_t MASK3;                   /*!< Offset: 0x054 (R/W)  Mask Register 3                           */
X  volatile uint32_t MASK3;                    
N  __IO uint32_t FUNCTION3;               /*!< Offset: 0x058 (R/W)  Function Register 3                       */
X  volatile uint32_t FUNCTION3;                
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28                                          /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27                                          /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26                                          /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25                                          /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24                                          /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22                                          /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21                                          /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20                                          /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19                                          /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18                                          /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17                                          /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16                                          /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12                                          /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10                                          /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9                                          /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5                                          /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1                                          /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0                                          /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL << DWT_CTRL_CYCCNTENA_Pos)           /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0                                          /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL << DWT_CPICNT_CPICNT_Pos)           /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0                                          /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL << DWT_EXCCNT_EXCCNT_Pos)           /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0                                          /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL << DWT_SLEEPCNT_SLEEPCNT_Pos)       /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0                                          /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL << DWT_LSUCNT_LSUCNT_Pos)           /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0                                          /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL << DWT_FOLDCNT_FOLDCNT_Pos)         /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0                                          /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL << DWT_MASK_MASK_Pos)               /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24                                          /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16                                          /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12                                          /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10                                          /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9                                          /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8                                          /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7                                          /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5                                          /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0                                          /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL << DWT_FUNCTION_FUNCTION_Pos)        /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N    \brief      Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/** \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IO uint32_t SSPSR;                   /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register     */
X  volatile uint32_t SSPSR;                    
N  __IO uint32_t CSPSR;                   /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                    
N       uint32_t RESERVED0[2];
N  __IO uint32_t ACPR;                    /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                     
N       uint32_t RESERVED1[55];
N  __IO uint32_t SPPR;                    /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                     
N       uint32_t RESERVED2[131];
N  __I  uint32_t FFSR;                    /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                     
N  __IO uint32_t FFCR;                    /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                     
N  __I  uint32_t FSCR;                    /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                     
N       uint32_t RESERVED3[759];
N  __I  uint32_t TRIGGER;                 /*!< Offset: 0xEE8 (R/ )  TRIGGER */
X  volatile const  uint32_t TRIGGER;                  
N  __I  uint32_t FIFO0;                   /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                    
N  __I  uint32_t ITATBCTR2;               /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;                
N       uint32_t RESERVED4[1];
N  __I  uint32_t ITATBCTR0;               /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;                
N  __I  uint32_t FIFO1;                   /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                    
N  __IO uint32_t ITCTRL;                  /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                   
N       uint32_t RESERVED5[39];
N  __IO uint32_t CLAIMSET;                /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                 
N  __IO uint32_t CLAIMCLR;                /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                 
N       uint32_t RESERVED7[8];
N  __I  uint32_t DEVID;                   /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                    
N  __I  uint32_t DEVTYPE;                 /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                  
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0                                          /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL << TPI_ACPR_PRESCALER_Pos)        /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0                                          /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL << TPI_SPPR_TXMODE_Pos)              /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3                                          /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2                                          /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1                                          /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0                                          /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL << TPI_FFSR_FlInProg_Pos)            /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8                                          /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1                                          /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0                                          /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL << TPI_TRIGGER_TRIGGER_Pos)          /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27                                          /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24                                          /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16                                          /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8                                          /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0                                          /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL << TPI_FIFO0_ETM0_Pos)              /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY_Pos           0                                          /*!< TPI ITATBCTR2: ATREADY Position */
N#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL << TPI_ITATBCTR2_ATREADY_Pos)        /*!< TPI ITATBCTR2: ATREADY Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27                                          /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24                                          /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16                                          /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8                                          /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0                                          /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL << TPI_FIFO1_ITM0_Pos)              /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY_Pos           0                                          /*!< TPI ITATBCTR0: ATREADY Position */
N#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL << TPI_ITATBCTR0_ATREADY_Pos)        /*!< TPI ITATBCTR0: ATREADY Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0                                          /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x1UL << TPI_ITCTRL_Mode_Pos)              /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11                                          /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10                                          /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9                                          /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6                                          /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5                                          /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0                                          /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL << TPI_DEVID_NrTraceInput_Pos)      /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_SubType_Pos             0                                          /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL << TPI_DEVTYPE_SubType_Pos)          /*!< TPI DEVTYPE: SubType Mask */
N
N#define TPI_DEVTYPE_MajorType_Pos           4                                          /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if (__MPU_PRESENT == 1)
X#if (1 == 1)
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
N    \brief      Type definitions for the Memory Protection Unit (MPU)
N  @{
N */
N
N/** \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register                              */
X  volatile const  uint32_t TYPE;                     
N  __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register                           */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register                     */
X  volatile uint32_t RNR;                      
N  __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register               */
X  volatile uint32_t RBAR;                     
N  __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register         */
X  volatile uint32_t RASR;                     
N  __IO uint32_t RBAR_A1;                 /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register       */
X  volatile uint32_t RBAR_A1;                  
N  __IO uint32_t RASR_A1;                 /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                  
N  __IO uint32_t RBAR_A2;                 /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register       */
X  volatile uint32_t RBAR_A2;                  
N  __IO uint32_t RASR_A2;                 /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                  
N  __IO uint32_t RBAR_A3;                 /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register       */
X  volatile uint32_t RBAR_A3;                  
N  __IO uint32_t RASR_A3;                 /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                  
N} MPU_Type;
N
N/* MPU Type Register */
N#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register */
N#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register */
N#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register */
N#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register */
N#define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: ATTRS.XN Position */
N#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
N
N#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: ATTRS.AP Position */
N#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: ATTRS.TEX Position */
N#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
N
N#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: ATTRS.S Position */
N#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
N
N#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: ATTRS.C Position */
N#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
N
N#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: ATTRS.B Position */
N#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
N
N#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL << MPU_RASR_ENABLE_Pos)                   /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif
N
N
N#if (__FPU_PRESENT == 1)
X#if (1 == 1)
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_FPU     Floating Point Unit (FPU)
N    \brief      Type definitions for the Floating Point Unit (FPU)
N  @{
N */
N
N/** \brief  Structure type to access the Floating Point Unit (FPU).
N */
Ntypedef struct
N{
N       uint32_t RESERVED0[1];
N  __IO uint32_t FPCCR;                   /*!< Offset: 0x004 (R/W)  Floating-Point Context Control Register               */
X  volatile uint32_t FPCCR;                    
N  __IO uint32_t FPCAR;                   /*!< Offset: 0x008 (R/W)  Floating-Point Context Address Register               */
X  volatile uint32_t FPCAR;                    
N  __IO uint32_t FPDSCR;                  /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Control Register        */
X  volatile uint32_t FPDSCR;                   
N  __I  uint32_t MVFR0;                   /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0                       */
X  volatile const  uint32_t MVFR0;                    
N  __I  uint32_t MVFR1;                   /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1                       */
X  volatile const  uint32_t MVFR1;                    
N} FPU_Type;
N
N/* Floating-Point Context Control Register */
N#define FPU_FPCCR_ASPEN_Pos                31                                             /*!< FPCCR: ASPEN bit Position */
N#define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCCR: ASPEN bit Mask */
N
N#define FPU_FPCCR_LSPEN_Pos                30                                             /*!< FPCCR: LSPEN Position */
N#define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCCR: LSPEN bit Mask */
N
N#define FPU_FPCCR_MONRDY_Pos                8                                             /*!< FPCCR: MONRDY Position */
N#define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCCR: MONRDY bit Mask */
N
N#define FPU_FPCCR_BFRDY_Pos                 6                                             /*!< FPCCR: BFRDY Position */
N#define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCCR: BFRDY bit Mask */
N
N#define FPU_FPCCR_MMRDY_Pos                 5                                             /*!< FPCCR: MMRDY Position */
N#define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCCR: MMRDY bit Mask */
N
N#define FPU_FPCCR_HFRDY_Pos                 4                                             /*!< FPCCR: HFRDY Position */
N#define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCCR: HFRDY bit Mask */
N
N#define FPU_FPCCR_THREAD_Pos                3                                             /*!< FPCCR: processor mode bit Position */
N#define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCCR: processor mode active bit Mask */
N
N#define FPU_FPCCR_USER_Pos                  1                                             /*!< FPCCR: privilege level bit Position */
N#define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCCR: privilege level bit Mask */
N
N#define FPU_FPCCR_LSPACT_Pos                0                                             /*!< FPCCR: Lazy state preservation active bit Position */
N#define FPU_FPCCR_LSPACT_Msk               (1UL << FPU_FPCCR_LSPACT_Pos)                  /*!< FPCCR: Lazy state preservation active bit Mask */
N
N/* Floating-Point Context Address Register */
N#define FPU_FPCAR_ADDRESS_Pos               3                                             /*!< FPCAR: ADDRESS bit Position */
N#define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCAR: ADDRESS bit Mask */
N
N/* Floating-Point Default Status Control Register */
N#define FPU_FPDSCR_AHP_Pos                 26                                             /*!< FPDSCR: AHP bit Position */
N#define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDSCR: AHP bit Mask */
N
N#define FPU_FPDSCR_DN_Pos                  25                                             /*!< FPDSCR: DN bit Position */
N#define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDSCR: DN bit Mask */
N
N#define FPU_FPDSCR_FZ_Pos                  24                                             /*!< FPDSCR: FZ bit Position */
N#define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDSCR: FZ bit Mask */
N
N#define FPU_FPDSCR_RMode_Pos               22                                             /*!< FPDSCR: RMode bit Position */
N#define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDSCR: RMode bit Mask */
N
N/* Media and FP Feature Register 0 */
N#define FPU_MVFR0_FP_rounding_modes_Pos    28                                             /*!< MVFR0: FP rounding modes bits Position */
N#define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR0: FP rounding modes bits Mask */
N
N#define FPU_MVFR0_Short_vectors_Pos        24                                             /*!< MVFR0: Short vectors bits Position */
N#define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR0: Short vectors bits Mask */
N
N#define FPU_MVFR0_Square_root_Pos          20                                             /*!< MVFR0: Square root bits Position */
N#define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR0: Square root bits Mask */
N
N#define FPU_MVFR0_Divide_Pos               16                                             /*!< MVFR0: Divide bits Position */
N#define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR0: Divide bits Mask */
N
N#define FPU_MVFR0_FP_excep_trapping_Pos    12                                             /*!< MVFR0: FP exception trapping bits Position */
N#define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR0: FP exception trapping bits Mask */
N
N#define FPU_MVFR0_Double_precision_Pos      8                                             /*!< MVFR0: Double-precision bits Position */
N#define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR0: Double-precision bits Mask */
N
N#define FPU_MVFR0_Single_precision_Pos      4                                             /*!< MVFR0: Single-precision bits Position */
N#define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR0: Single-precision bits Mask */
N
N#define FPU_MVFR0_A_SIMD_registers_Pos      0                                             /*!< MVFR0: A_SIMD registers bits Position */
N#define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL << FPU_MVFR0_A_SIMD_registers_Pos)      /*!< MVFR0: A_SIMD registers bits Mask */
N
N/* Media and FP Feature Register 1 */
N#define FPU_MVFR1_FP_fused_MAC_Pos         28                                             /*!< MVFR1: FP fused MAC bits Position */
N#define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR1: FP fused MAC bits Mask */
N
N#define FPU_MVFR1_FP_HPFP_Pos              24                                             /*!< MVFR1: FP HPFP bits Position */
N#define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR1: FP HPFP bits Mask */
N
N#define FPU_MVFR1_D_NaN_mode_Pos            4                                             /*!< MVFR1: D_NaN mode bits Position */
N#define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR1: D_NaN mode bits Mask */
N
N#define FPU_MVFR1_FtZ_mode_Pos              0                                             /*!< MVFR1: FtZ mode bits Position */
N#define FPU_MVFR1_FtZ_mode_Msk             (0xFUL << FPU_MVFR1_FtZ_mode_Pos)              /*!< MVFR1: FtZ mode bits Mask */
N
N/*@} end of group CMSIS_FPU */
N#endif
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N    \brief      Type definitions for the Core Debug Registers
N  @{
N */
N
N/** \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register    */
X  volatile uint32_t DHCSR;                    
N  __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register        */
X  volatile  uint32_t DCRSR;                    
N  __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register            */
X  volatile uint32_t DCRDR;                    
N  __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                    
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register */
N#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register */
N#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_core_base     Core Definitions
N    \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M4 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address  */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address                   */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address                   */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address                   */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address            */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address               */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                  */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address  */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct           */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct           */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct           */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct    */
N
N#if (__MPU_PRESENT == 1)
X#if (1 == 1)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit             */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit             */
N#endif
N
N#if (__FPU_PRESENT == 1)
X#if (1 == 1)
N  #define FPU_BASE          (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit                */
N  #define FPU               ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit                */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N    \brief      Functions that manage interrupts and exceptions via the NVIC.
N    @{
N */
N
N/** \brief  Set Priority Grouping
N
N  The function sets the priority grouping field using the required unlock sequence.
N  The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N  Only values from 0..7 are used.
N  In case of a conflict between priority grouping and available
N  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N
N    \param [in]      PriorityGroup  Priority grouping field.
N */
N__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
X  reg_value &= ~((0xFFFFUL << 16) | (7UL << 8));              
N  reg_value  =  (reg_value                                 |
N                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FA << 16) |
N                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/** \brief  Get Priority Grouping
N
N  The function reads the priority grouping field from the NVIC Interrupt Controller.
N
N    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
X  return ((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) >> 8);    
N}
N
N
N/** \brief  Enable External Interrupt
N
N    The function enables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
N  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F));  
N}
N
N
N/** \brief  Disable External Interrupt
N
N    The function disables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    The function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not pending.
N    \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    The function sets the pending bit of an external interrupt.
N
N    \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    The function clears the pending bit of an external interrupt.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Get Active Interrupt
N
N    The function reads the active register in NVIC and returns the active bit.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not active.
N    \return             1  Interrupt status is active.
N */
N__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
X  return((uint32_t)((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    The function sets the priority of an interrupt.
N
N    \note The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N    \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - 4)) & 0xff); }  
N  else {
N    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[(uint32_t)(IRQn)] = ((priority << (8 - 4)) & 0xff);    }         
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    The function reads the priority of an interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N
N    \param [in]   IRQn  Interrupt number.
N    \return             Interrupt Priority. Value is aligned automatically to the implemented
N                        priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M  system interrupts */
X    return((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - 4)));  }  
N  else {
N    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[(uint32_t)(IRQn)]           >> (8 - 4)));  }  
N}
N
N
N/** \brief  Encode Priority
N
N    The function encodes the priority for an interrupt with the given priority group,
N    preemptive priority value, and subpriority value.
N    In case of a conflict between priority grouping and available
N    priority bits (__NVIC_PRIO_BITS), the samllest possible priority group is set.
N
N    \param [in]     PriorityGroup  Used priority group.
N    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N    \param [in]       SubPriority  Subpriority value (starting from 0).
N    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 4) ? 4 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 4) < 7) ? 0 : PriorityGroupTmp - 7 + 4;
N
N  return (
N           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
N           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
N         );
N}
N
N
N/** \brief  Decode Priority
N
N    The function decodes an interrupt priority value with a given priority group to
N    preemptive priority value and subpriority value.
N    In case of a conflict between priority grouping and available
N    priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N
N    \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N    \param [in]     PriorityGroup  Used priority group.
N    \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N    \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 4) ? 4 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 4) < 7) ? 0 : PriorityGroupTmp - 7 + 4;
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
N  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
N}
N
N
N/** \brief  System Reset
N
N    The function initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                     /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                     
N                                                                  buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FA << 16)      |
N                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                 (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);                   /* Keep priority group unchanged */
X                 (1UL << 2));                    
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0xF);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N    \brief      Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
N    Counter is in free running mode to generate periodic interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts.
N
N    \return          0  Function succeeded.
N    \return          1  Function failed.
N
N    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N    must contain a vendor-specific implementation of this function.
N
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
X  if (ticks > (0xFFFFFFUL << 0))  return (1);             
N
N  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (ticks & (0xFFFFFFUL << 0)) - 1;       
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1<<4) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_core_DebugFunctions ITM Functions
N    \brief   Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters.                         */
N#define                 ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/** \brief  ITM Send Character
N
N    The function transmits a character via the ITM channel 0, and
N    \li Just returns when no debugger is connected that has booked the output.
N    \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N
N    \param [in]     ch  Character to transmit.
N
N    \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if ((ITM->TCR & ITM_TCR_ITMENA_Msk)                  &&      /* ITM enabled */
X  if ((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL << 0))                  &&       
N      (ITM->TER & (1UL << 0)        )                    )     /* ITM Port #0 enabled */
X      (((ITM_Type *) (0xE0000000UL) )->TER & (1UL << 0)        )                    )      
N  {
N    while (ITM->PORT[0].u32 == 0);
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0].u32 == 0);
N    ITM->PORT[0].u8 = (uint8_t) ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0].u8 = (uint8_t) ch;
N  }
N  return (ch);
N}
N
N
N/** \brief  ITM Receive Character
N
N    The function inputs a character via the external variable \ref ITM_RxBuffer.
N
N    \return             Received character.
N    \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void) {
Xstatic __inline int32_t ITM_ReceiveChar (void) {
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer != 0x5AA55AA5) {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5;        
N  }
N
N  return (ch);
N}
N
N
N/** \brief  ITM Check Character
N
N    The function checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N
N    \return          0  No character available.
N    \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void) {
Xstatic __inline int32_t ITM_CheckChar (void) {
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer == 0x5AA55AA5) {
N    return (0);                                 /* no character available */
N  } else {
N    return (1);                                 /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N#endif /* __CORE_CM4_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N#ifdef __cplusplus
S}
N#endif
L 249 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N#include "system_M451Series.h"              /* M451 System include file                           */
L 1 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\system_M451Series.h" 1
N/******************************************************************************
N * @file     system_M451Series.h
N * @version  V0.10
N * $Revision: 7 $
N * $Date: 15/09/02 10:02a $
N * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File for M451 Series MCU
N *
N * @note
N * Copyright (C) 2013~2015 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N
N#ifndef __SYSTEM_M451SERIES_H__
N#define __SYSTEM_M451SERIES_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include <stdint.h>
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Macro Definition                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N#ifndef DEBUG_PORT
N# define DEBUG_PORT      UART0       /*!< Select Debug Port which is used for retarget.c to output debug message to UART */
N#endif
N
N
N/*----------------------------------------------------------------------------
N  Define clocks
N *----------------------------------------------------------------------------*/
N
N#define __HSI       (12000000UL)    /*!< PLL default output is 72MHz */
N#define __HXT       (12000000UL)    /*!< External Crystal Clock Frequency     */
N#define __LXT       (32768UL)       /*!< External Crystal Clock Frequency 32.768KHz */
N#define __HIRC      (22118400UL)    /*!< Internal 22M RC Oscillator Frequency */
N#define __LIRC      (10000UL)       /*!< Internal 10K RC Oscillator Frequency */
N#define __SYS_OSC_CLK     (    ___HSI)    /* Main oscillator frequency        */
N
N
N#define __SYSTEM_CLOCK    (1*__HXT)
N
Nextern uint32_t SystemCoreClock;     /*!< System Clock Frequency (Core Clock)  */
Nextern uint32_t CyclesPerUs;         /*!< Cycles per micro second              */
Nextern uint32_t PllClock;            /*!< PLL Output Clock Frequency           */
N
N
N/**
N * Initialize the system
N *
N * @param  None
N * @return None
N *
N * @brief  Setup the microcontroller system.
N *         Initialize the System and update the SystemCoreClock variable.
N */
Nextern void SystemInit(void);
N
N/**
N * Update SystemCoreClock variable
N *
N * @param  None
N * @return None
N *
N * @brief  Updates the SystemCoreClock with current core Clock
N *         retrieved from cpu registers.
N */
Nextern void SystemCoreClockUpdate(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __SYSTEM_M451SERIES_H__ */
N/*** (C) COPYRIGHT 2013~2015 Nuvoton Technology Corp. ***/
L 250 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N#include <stdint.h>
N
N
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N
N/** @addtogroup REGISTER Control Register
N
N  @{
N
N*/
N
N
N/*---------------------- Analog Comparator Controller -------------------------*/
N/**
N    @addtogroup ACMP Analog Comparator Controller(ACMP)
N    Memory Mapped Structure for ACMP Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var ACMP_T::CTL
N * Offset: 0x00  Analog Comparator 0 Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ACMPEN    |Comparator Enable Bit
N * |        |          |0 = Comparator 0 Disabled.
N * |        |          |1 = Comparator 0 Enabled.
N * |[1]     |ACMPIE    |Comparator Interrupt Enable Bit
N * |        |          |0 = Comparator 0 interrupt Disabled.
N * |        |          |1 = Comparator 0 interrupt Enabled.
N * |        |          |If WKEN (ACMP_CTL0[16]) is set to 1, the wake-up interrupt function will be enabled as well.
N * |[2]     |HYSEN     |Comparator Hysteresis Enable Bit
N * |        |          |0 = Comparator 0 hysteresis Disabled.
N * |        |          |1 = Comparator 0 hysteresis Enabled.
N * |[3]     |ACMPOINV  |Comparator Output Inverse
N * |        |          |0 = Comparator 0 output inverse Disabled.
N * |        |          |1 = Comparator 0 output inverse Enabled.
N * |[5:4]   |NEGSEL    |Comparator Negative Input Selection
N * |        |          |00 = ACMP0_N pin.
N * |        |          |01 = Internal comparator reference voltage (CRV).
N * |        |          |10 = Band-gap voltage.
N * |        |          |11 = DAC output.
N * |[7:6]   |POSSEL    |Comparator Positive Input Selection
N * |        |          |00 = Input from ACMP0_P0.
N * |        |          |01 = Input from ACMP0_P1.
N * |        |          |10 = Input from ACMP0_P2.
N * |        |          |11 = Input from ACMP0_P3.
N * |[9:8]   |INTPOL    |Interrupt Condition Polarity Selection
N * |        |          |ACMPIF0 will be set to 1 when comparator output edge condition is detected.
N * |        |          |00 = Rising edge or falling edge.
N * |        |          |01 = Rising edge.
N * |        |          |10 = Falling edge.
N * |        |          |11 = Reserved.
N * |[12]    |OUTSEL    |Comparator Output Select
N * |        |          |0 = Comparator 0 output to ACMP0_O pin is unfiltered comparator output.
N * |        |          |1 = Comparator 0 output to ACMP0_O pin is from filter output.
N * |[15:13] |FILTSEL   |Comparator Output Filter Count Selection
N * |        |          |000 = Filter function is Disabled.
N * |        |          |001 = ACMP0 output is sampled 1 consecutive PCLK.
N * |        |          |010 = ACMP0 output is sampled 2 consecutive PCLKs.
N * |        |          |011 = ACMP0 output is sampled 4 consecutive PCLKs.
N * |        |          |100 = ACMP0 output is sampled 8 consecutive PCLKs.
N * |        |          |101 = ACMP0 output is sampled 16 consecutive PCLKs.
N * |        |          |110 = ACMP0 output is sampled 32 consecutive PCLKs.
N * |        |          |111 = ACMP0 output is sampled 64 consecutive PCLKs.
N * |[16]    |WKEN      |Power Down Wake-Up Enable Bit
N * |        |          |0 = Wake-up function Disabled.
N * |        |          |1 = Wake-up function Enabled.
N * ---------------------------------------------------------------------------------------------------
N * Offset: 0x04  Analog Comparator 1 Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ACMPEN    |Comparator Enable Bit
N * |        |          |0 = Comparator 1 Disabled.
N * |        |          |1 = Comparator 1 Enabled.
N * |[1]     |ACMPIE    |Comparator Interrupt Enable Bit
N * |        |          |0 = Comparator 1 interrupt Disabled.
N * |        |          |1 = Comparator 1 interrupt Enabled.
N * |        |          |If WKEN (ACMP_CTL1[16]) is set to 1, the wake-up interrupt function will be enabled as well.
N * |[2]     |HYSEN     |Comparator Hysteresis Enable Bit
N * |        |          |0 = Comparator 1 hysteresis Disabled.
N * |        |          |1 = Comparator 1 hysteresis Enabled.
N * |[3]     |ACMPOINV  |Comparator Output Inverse Control
N * |        |          |0 = Comparator 1 output inverse Disabled.
N * |        |          |1 = Comparator 1 output inverse Enabled.
N * |[5:4]   |NEGSEL    |Comparator Negative Input Selection
N * |        |          |00 = ACMP1_N pin.
N * |        |          |01 = Internal comparator reference voltage (CRV).
N * |        |          |10 = Band-gap voltage.
N * |        |          |11 = DAC output.
N * |[7:6]   |POSSEL    |Comparator Positive Input Selection
N * |        |          |00 = Input from ACMP1_P0.
N * |        |          |01 = Input from ACMP1_P1.
N * |        |          |10 = Input from ACMP1_P2.
N * |        |          |11 = Input from ACMP1_P3.
N * |[9:8]   |INTPOL    |Interrupt Condition Polarity Selection
N * |        |          |ACMPIF1 will be set to 1 when comparator output edge condition is detected.
N * |        |          |00 = Rising edge or falling edge.
N * |        |          |01 = Rising edge.
N * |        |          |10 = Falling edge.
N * |        |          |11 = Reserved.
N * |[12]    |OUTSEL    |Comparator Output Select
N * |        |          |0 = Comparator 1 output to ACMP1_O pin is unfiltered comparator output.
N * |        |          |1 = Comparator 1 output to ACMP1_O pin is from filter output.
N * |[15:13] |FILTSEL   |Comparator Output Filter Count Selection
N * |        |          |000 = Filter function is Disabled.
N * |        |          |001 = ACMP1 output is sampled 1 consecutive PCLK.
N * |        |          |010 = ACMP1 output is sampled 2 consecutive PCLKs.
N * |        |          |011 = ACMP1 output is sampled 4 consecutive PCLKs.
N * |        |          |100 = ACMP1 output is sampled 8 consecutive PCLKs.
N * |        |          |101 = ACMP1 output is sampled 16 consecutive PCLKs.
N * |        |          |110 = ACMP1 output is sampled 32 consecutive PCLKs.
N * |        |          |111 = ACMP1 output is sampled 64 consecutive PCLKs.
N * |[16]    |WKEN      |Power Down Wakeup Enable Bit
N * |        |          |0 = Wake-up function Disabled.
N * |        |          |1 = Wake-up function Enabled.
N * @var ACMP_T::STATUS
N * Offset: 0x08  Analog Comparator Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ACMPIF0   |Comparator 0 Interrupt Flag
N * |        |          |This bit is set by hardware when the edge condition defined by INTPOL (ACMP_CTL0[9:8]) is detected on comparator 0 output.
N * |        |          |This will generate an interrupt if ACMPIE (ACMP_CTL0[1]) is set to 1.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[1]     |ACMPIF1   |Comparator 1 Interrupt Flag
N * |        |          |This bit is set by hardware when the edge condition defined by INTPOL (ACMP_CTL1[9:8]) is detected on comparator 1 output.
N * |        |          |This will cause an interrupt if ACMPIE (ACMP_CTL1[1]) is set to 1.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[4]     |ACMPO0    |Comparator 0 Output
N * |        |          |Synchronized to the PCLK to allow reading by software.
N * |        |          |Cleared when the comparator 0 is disabled, i.e. ACMPEN (ACMP_CTL0[0]) is cleared to 0.
N * |[5]     |ACMPO1    |Comparator 1 Output
N * |        |          |Synchronized to the PCLK to allow reading by software.
N * |        |          |Cleared when the comparator 1 is disabled, i.e. ACMPEN (ACMP_CTL1[0]) is cleared to 0.
N * |[8]     |WKIF0     |Comparator 0 Power Down Wake-Up Interrupt Flag
N * |        |          |This bit will be set to 1 when ACMP0 wake-up interrupt event occurs.
N * |        |          |0 = No power down wake-up occurred.
N * |        |          |1 = Power down wake-up occurred.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[9]     |WKIF1     |Comparator 1 Power Down Wake-Up Interrupt Flag
N * |        |          |This bit will be set to 1 when ACMP1 wake-up interrupt event occurs.
N * |        |          |0 = No power down wake-up occurred.
N * |        |          |1 = Power down wake-up occurred.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * @var ACMP_T::VREF
N * Offset: 0x0C  Analog Comparator Reference Voltage Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |CRVCTL    |Comparator Reference Voltage Setting
N * |        |          |CRV = CRV source voltage * (1/6+CRVCTL/24).
N * |[6]     |CRVSSEL   |CRV Source Voltage Selection
N * |        |          |0 = VDDA is selected as CRV source voltage.
N * |        |          |1 = The reference voltage defined by SYS_VREFCTL register is selected as CRV source voltage.
N */
N
N    __IO uint32_t CTL[2];        /* Offset: 0x00  Analog Comparator Control Register                                 */
X    volatile uint32_t CTL[2];         
N    __IO uint32_t STATUS;        /* Offset: 0x08  Analog Comparator Status Register                                  */
X    volatile uint32_t STATUS;         
N    __IO uint32_t VREF;          /* Offset: 0x0C  Analog Comparator Reference Voltage Control Register               */
X    volatile uint32_t VREF;           
N
N} ACMP_T;
N
N
N
N/**
N    @addtogroup ACMP_CONST ACMP Bit Field Definition
N    Constant Definitions for ACMP Controller
N@{ */
N
N#define ACMP_CTL_ACMPEN_Pos              (0)                                               /*!< ACMP_T::CTL: ACMPEN Position             */
N#define ACMP_CTL_ACMPEN_Msk              (0x1ul << ACMP_CTL_ACMPEN_Pos)                    /*!< ACMP_T::CTL: ACMPEN Mask                 */
N
N#define ACMP_CTL_ACMPIE_Pos              (1)                                               /*!< ACMP_T::CTL: ACMPIE Position             */
N#define ACMP_CTL_ACMPIE_Msk              (0x1ul << ACMP_CTL_ACMPIE_Pos)                    /*!< ACMP_T::CTL: ACMPIE Mask                 */
N
N#define ACMP_CTL_HYSEN_Pos               (2)                                               /*!< ACMP_T::CTL: HYSEN Position              */
N#define ACMP_CTL_HYSEN_Msk               (0x1ul << ACMP_CTL_HYSEN_Pos)                     /*!< ACMP_T::CTL: HYSEN Mask                  */
N
N#define ACMP_CTL_ACMPOINV_Pos            (3)                                               /*!< ACMP_T::CTL: ACMPOINV Position           */
N#define ACMP_CTL_ACMPOINV_Msk            (0x1ul << ACMP_CTL_ACMPOINV_Pos)                  /*!< ACMP_T::CTL: ACMPOINV Mask               */
N
N#define ACMP_CTL_NEGSEL_Pos              (4)                                               /*!< ACMP_T::CTL: NEGSEL Position             */
N#define ACMP_CTL_NEGSEL_Msk              (0x3ul << ACMP_CTL_NEGSEL_Pos)                    /*!< ACMP_T::CTL: NEGSEL Mask                 */
N
N#define ACMP_CTL_POSSEL_Pos              (6)                                               /*!< ACMP_T::CTL: POSSEL Position             */
N#define ACMP_CTL_POSSEL_Msk              (0x3ul << ACMP_CTL_POSSEL_Pos)                    /*!< ACMP_T::CTL: POSSEL Mask                 */
N
N#define ACMP_CTL_INTPOL_Pos              (8)                                               /*!< ACMP_T::CTL: INTPOL Position             */
N#define ACMP_CTL_INTPOL_Msk              (0x3ul << ACMP_CTL_INTPOL_Pos)                    /*!< ACMP_T::CTL: INTPOL Mask                 */
N
N#define ACMP_CTL_OUTSEL_Pos              (12)                                              /*!< ACMP_T::CTL: OUTSEL Position             */
N#define ACMP_CTL_OUTSEL_Msk              (0x1ul << ACMP_CTL_OUTSEL_Pos)                    /*!< ACMP_T::CTL: OUTSEL Mask                 */
N
N#define ACMP_CTL_FILTSEL_Pos             (13)                                              /*!< ACMP_T::CTL: FILTSEL Position            */
N#define ACMP_CTL_FILTSEL_Msk             (0x7ul << ACMP_CTL_FILTSEL_Pos)                   /*!< ACMP_T::CTL: FILTSEL Mask                */
N
N#define ACMP_CTL_WKEN_Pos                (16)                                              /*!< ACMP_T::CTL: WKEN Position               */
N#define ACMP_CTL_WKEN_Msk                (0x1ul << ACMP_CTL_WKEN_Pos)                      /*!< ACMP_T::CTL: WKEN Mask                   */
N
N#define ACMP_STATUS_ACMPIF0_Pos          (0)                                               /*!< ACMP_T::STATUS: ACMPIF0 Position         */
N#define ACMP_STATUS_ACMPIF0_Msk          (0x1ul << ACMP_STATUS_ACMPIF0_Pos)                /*!< ACMP_T::STATUS: ACMPIF0 Mask             */
N
N#define ACMP_STATUS_ACMPIF1_Pos          (1)                                               /*!< ACMP_T::STATUS: ACMPIF1 Position         */
N#define ACMP_STATUS_ACMPIF1_Msk          (0x1ul << ACMP_STATUS_ACMPIF1_Pos)                /*!< ACMP_T::STATUS: ACMPIF1 Mask             */
N
N#define ACMP_STATUS_ACMPO0_Pos           (4)                                               /*!< ACMP_T::STATUS: ACMPO0 Position          */
N#define ACMP_STATUS_ACMPO0_Msk           (0x1ul << ACMP_STATUS_ACMPO0_Pos)                 /*!< ACMP_T::STATUS: ACMPO0 Mask              */
N
N#define ACMP_STATUS_ACMPO1_Pos           (5)                                               /*!< ACMP_T::STATUS: ACMPO1 Position          */
N#define ACMP_STATUS_ACMPO1_Msk           (0x1ul << ACMP_STATUS_ACMPO1_Pos)                 /*!< ACMP_T::STATUS: ACMPO1 Mask              */
N
N#define ACMP_STATUS_WKIF0_Pos            (8)                                               /*!< ACMP_T::STATUS: WKIF0 Position           */
N#define ACMP_STATUS_WKIF0_Msk            (0x1ul << ACMP_STATUS_WKIF0_Pos)                  /*!< ACMP_T::STATUS: WKIF0 Mask               */
N
N#define ACMP_STATUS_WKIF1_Pos            (9)                                               /*!< ACMP_T::STATUS: WKIF1 Position           */
N#define ACMP_STATUS_WKIF1_Msk            (0x1ul << ACMP_STATUS_WKIF1_Pos)                  /*!< ACMP_T::STATUS: WKIF1 Mask               */
N
N#define ACMP_VREF_CRVCTL_Pos             (0)                                               /*!< ACMP_T::VREF: CRVCTL Position            */
N#define ACMP_VREF_CRVCTL_Msk             (0xful << ACMP_VREF_CRVCTL_Pos)                   /*!< ACMP_T::VREF: CRVCTL Mask                */
N
N#define ACMP_VREF_CRVSSEL_Pos            (6)                                               /*!< ACMP_T::VREF: CRVSSEL Position           */
N#define ACMP_VREF_CRVSSEL_Msk            (0x1ul << ACMP_VREF_CRVSSEL_Pos)                  /*!< ACMP_T::VREF: CRVSSEL Mask               */
N
N/**@}*/ /* ACMP_CONST */
N/**@}*/ /* end of ACMP register group */
N
N
N/*---------------------- Enhanced Analog to Digital Converter -------------------------*/
N/**
N    @addtogroup Enhanced Analog to Digital Converter(EADC)
N    Memory Mapped Structure for EADC Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var EADC_T::DAT
N * Offset: 0x00-0x48  A/D Data Register n for Sample Module n, n=0~18
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |RESULT    |A/D Conversion Result
N * |        |          |This field contains 12 bits conversion result.
N * |        |          |When DMOF (EADC_CTL[9]) is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT[11:0] and zero will be filled in RESULT[15:12].
N * |        |          |When DMOF (EADC_CTL[9]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT[11:0] and signed bits to will be filled in RESULT[15:12].
N * |[16]    |OV        |Overrun Flag
N * |        |          |If converted data in RESULT[11:0] has not been read before new conversion result is loaded to this register, OV is set to 1.
N * |        |          |0 = Data in RESULT[11:0] is recent conversion result.
N * |        |          |1 = Data in RESULT[11:0] is overwrite.
N * |        |          |Note: It is cleared by hardware after EADC_DAT register is read.
N * |[17]    |VALID     |Valid Flag
N * |        |          |This bit is set to 1 when corresponding sample module channel analog input conversion is completed and cleared by hardware after EADC_DAT register is read.
N * |        |          |0 = Data in RESULT[11:0] bits is not valid.
N * |        |          |1 = Data in RESULT[11:0] bits is valid.
N * @var EADC_T::CURDAT
N * Offset: 0x4C  EADC PDMA Current Transfer Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[17:0]  |CURDAT    |ADC PDMA Current Transfer Data Register
N * |        |          |This register is a shadow register of EADC_DATn (n=0~18) for PDMA support.
N * |        |          |This is a read only register.
N * @var EADC_T::CTL
N * Offset: 0x50  A/D Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ADCEN     |A/D Converter Enable Bit
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |        |          |Note: Before starting A/D conversion function, this bit should be set to 1.
N * |        |          |Clear it to 0 to disable A/D converter analog circuit power consumption.
N * |[1]     |ADCRST    |ADC A/D Converter Control Circuits Reset
N * |        |          |0 = No effect.
N * |        |          |1 = Cause ADC control circuits reset to initial state, but not change the ADC registers value.
N * |        |          |Note: ADCRST bit remains 1 during ADC reset, when ADC reset end, the ADCRST bit is automatically cleared to 0.
N * |[2]     |ADCIEN0   |Specific Sample Module A/D ADINT0 Interrupt Enable Bit
N * |        |          |The A/D converter generates a conversion end ADIF0 (EADC_STATUS2[0]) upon the end of specific sample module A/D conversion.
N * |        |          |If ADCIEN0 bit is set then conversion end interrupt request ADINT0 is generated.
N * |        |          |0 = Specific sample module A/D ADINT0 interrupt function Disabled.
N * |        |          |1 = Specific sample module A/D ADINT0 interrupt function Enabled.
N * |[3]     |ADCIEN1   |Specific Sample Module A/D ADINT1 Interrupt Enable Bit
N * |        |          |The A/D converter generates a conversion end ADIF1 (EADC_STATUS2[1]) upon the end of specific sample module A/D conversion.
N * |        |          |If ADCIEN1 bit is set then conversion end interrupt request ADINT1 is generated.
N * |        |          |0 = Specific sample module A/D ADINT1 interrupt function Disabled.
N * |        |          |1 = Specific sample module A/D ADINT1 interrupt function Enabled.
N * |[4]     |ADCIEN2   |Specific Sample Module A/D ADINT2 Interrupt Enable Bit
N * |        |          |The A/D converter generates a conversion end ADIF2 (EADC_STATUS2[2]) upon the end of specific sample module A/D conversion.
N * |        |          |If ADCIEN2 bit is set then conversion end interrupt request ADINT2 is generated.
N * |        |          |0 = Specific sample module A/D ADINT2 interrupt function Disabled.
N * |        |          |1 = Specific sample module A/D ADINT2 interrupt function Enabled.
N * |[5]     |ADCIEN3   |Specific Sample Module A/D ADINT3 Interrupt Enable Bit
N * |        |          |The A/D converter generates a conversion end ADIF3 (EADC_STATUS2[3]) upon the end of specific sample module A/D conversion.
N * |        |          |If ADCIEN3 bit is set then conversion end interrupt request ADINT3 is generated.
N * |        |          |0 = Specific sample module A/D ADINT3 interrupt function Disabled.
N * |        |          |1 = Specific sample module A/D ADINT3 interrupt function Enabled.
N * |[8]     |DIFFEN    |Differential Analog Input Mode Enable Bit
N * |        |          |0 = Single-end analog input mode.
N * |        |          |1 = Differential analog input mode.
N * |[9]     |DMOF      |ADC Differential Input Mode Output Format
N * |        |          |0 = A/D conversion result will be filled in RESULT (EADC_DATn[15:0] , n= 0 ~18) with unsigned format.
N * |        |          |1 = A/D conversion result will be filled in RESULT (EADC_DATn[15:0] , n= 0 ~18) with 2'complement format.
N * |[11]    |PDMAEN    |PDMA Transfer Enable Bit
N * |        |          |When A/D conversion is completed, the converted data is loaded into EADC_DATn (n: 0 ~ 18) register, user can enable this bit to generate a PDMA data transfer request.
N * |        |          |0 = PDMA data transfer Disabled.
N * |        |          |1 = PDMA data transfer Enabled.
N * |        |          |Note: When set this bit field to 1, user must set ADCIENn (EADC_CTL[5:2], n=0~3) = 0 to disable interrupt.
N * |[18:16] |SMPTSEL   |ADC Internal Sampling Time Selection
N * |        |          |ADC internal sampling cycle = SMPTSEL + 1.
N * |        |          |000 = 1 ADC clock sampling time.
N * |        |          |001 = 2 ADC clock sampling time.
N * |        |          |010 = 3 ADC clock sampling time.
N * |        |          |011 = 4 ADC clock sampling time.
N * |        |          |100 = 5 ADC clock sampling time.
N * |        |          |101 = 6 ADC clock sampling time.
N * |        |          |110 = 7 ADC clock sampling time.
N * |        |          |111 = 8 ADC clock sampling time.
N * @var EADC_T::SWTRG
N * Offset: 0x54  A/D Sample Module Software Start Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[18:0]  |SWTRG     |A/D Sample Module
N * |        |          |0~18 Software Force To Start ADC Conversion
N * |        |          |0 = No effect.
N * |        |          |1 = Cause an ADC conversion when the priority is given to sample module.
N * |        |          |Note: After write this register to start ADC conversion, the EADC_PENDSTS register will show which sample module will conversion.
N * |        |          |If user want to disable the conversion of the sample module, user can write EADC_PENDSTS register to clear it.
N * @var EADC_T::PENDSTS
N * Offset: 0x58  A/D Start of Conversion Pending Flag Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[18:0]  |STPF      |A/D Sample Module 0~18 Start Of Conversion Pending Flag
N * |        |          |Read:
N * |        |          |0 = There is no pending conversion for sample module.
N * |        |          |1 = Sample module ADC start of conversion is pending.
N * |        |          |Write:
N * |        |          |1 = clear pending flag and cancel the conversion for sample module.
N * |        |          |Note: This bit remains 1 during pending state, when the respective ADC conversion is end, the STPFn (n=0~18) bit is automatically cleared to 0
N * @var EADC_T::OVSTS
N * Offset: 0x5C  A/D Sample Module Start of Conversion Overrun Flag Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[18:0]  |SPOVF     |A/D SAMPLE0~18 Overrun Flag
N * |        |          |0 = No sample module event overrun.
N * |        |          |1 = Indicates a new sample module event is generated while an old one event is pending.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * @var EADC_T::SCTL
N * Offset: 0x80-0x8C  A/D Sample Module n Control Register, n=0~3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |CHSEL     |A/D Sample Module Channel Selection
N * |        |          |00H = EADC_CH0.
N * |        |          |01H = EADC_CH1.
N * |        |          |02H = EADC_CH2.
N * |        |          |03H = EADC_CH3.
N * |        |          |04H = EADC_CH4.
N * |        |          |05H = EADC_CH5.
N * |        |          |06H = EADC_CH6.
N * |        |          |07H = EADC_CH7.
N * |        |          |08H = EADC_CH8.
N * |        |          |09H = EADC_CH9.
N * |        |          |0AH = EADC_CH10.
N * |        |          |0BH = EADC_CH11.
N * |        |          |0CH = EADC_CH12.
N * |        |          |0DH = EADC_CH13.
N * |        |          |0EH = EADC_CH14.
N * |        |          |0FH = EADC_CH15.
N * |[4]     |EXTREN    |A/D External Trigger Rising Edge Enable Bit
N * |        |          |0 = Rising edge Disabled when A/D selects STADC as trigger source.
N * |        |          |1 = Rising edge Enabled when A/D selects STADC as trigger source.
N * |[5]     |EXTFEN    |A/D External Trigger Falling Edge Enable Bit
N * |        |          |0 = Falling edge Disabled when A/D selects STADC as trigger source.
N * |        |          |1 = Falling edge Enabled when A/D selects STADC as trigger source.
N * |[7:6]   |TRGDLYDIV |A/D Sample Module Start Of Conversion Trigger Delay Clock Divider Selection
N * |        |          |Trigger delay clock frequency:
N * |        |          |00 = ADC_CLK/1.
N * |        |          |01 = ADC_CLK/2.
N * |        |          |10 = ADC_CLK/4.
N * |        |          |11 = ADC_CLK/16.
N * |[15:8]  |TRGDLYCNT |A/D Sample Module Start Of Conversion Trigger Delay Time
N * |        |          |Trigger delay time = TRGDLYCNT x ADC_CLK x n (n=1,2,4,16 from TRGDLYDIV setting).
N * |[20:16] |TRGSEL    |A/D Sample Module Start Of Conversion Trigger Source Selection
N * |        |          |0H = Disable trigger.
N * |        |          |1H = External trigger from STADC pin input.
N * |        |          |2H = ADC ADINT0 interrupt EOC (End of conversion) pulse trigger.
N * |        |          |3H = ADC ADINT1 interrupt EOC (End of conversion) pulse trigger.
N * |        |          |4H = Timer0 overflow pulse trigger.
N * |        |          |5H = Timer1 overflow pulse trigger.
N * |        |          |6H = Timer2 overflow pulse trigger.
N * |        |          |7H = Timer3 overflow pulse trigger.
N * |        |          |8H = PWM0TG0.
N * |        |          |9H = PWM0TG1.
N * |        |          |AH = PWM0TG2.
N * |        |          |BH = PWM0TG3.
N * |        |          |CH = PWM0TG4.
N * |        |          |DH = PWM0TG5.
N * |        |          |EH = PWM1TG0.
N * |        |          |FH = PWM1TG1.
N * |        |          |10H = PWM1TG2.
N * |        |          |11H = PWM1TG3.
N * |        |          |12H = PWM1TG4.
N * |        |          |13H = PWM1TG5.
N * |        |          |other = Reserved.
N * |[22]    |INTPOS    |Interrupt Flag Position Select
N * |        |          |0 = Set ADIFn (EADC_STATUS2[n], n=0~3) at A/D end of conversion.
N * |        |          |1 = Set ADIFn (EADC_STATUS2[n], n=0~3) at A/D start of conversion.
N * |[23]    |DBMEN     |Double Buffer Mode Enable Bit
N * |        |          |0 = Sample has one sample result register. (default).
N * |        |          |1 = Sample has two sample result registers.
N * |[31:24] |EXTSMPT   |ADC Sampling Time Extend
N * |        |          |When A/D converting at high conversion rate, the sampling time of analog input voltage may not enough if input channel loading is heavy, user can extend A/D sampling time after trigger source is coming to get enough sampling time.
N * |        |          |The range of start delay time is from 0~255 ADC clock.
N * @var EADC_T::SCTL
N * Offset: 0x90-0xBC  A/D Sample Module n Control Register, n=4~15
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |CHSEL     |A/D Sample Module Channel Selection
N * |        |          |00H = EADC_CH0.
N * |        |          |01H = EADC_CH1.
N * |        |          |02H = EADC_CH2.
N * |        |          |03H = EADC_CH3.
N * |        |          |04H = EADC_CH4.
N * |        |          |05H = EADC_CH5.
N * |        |          |06H = EADC_CH6.
N * |        |          |07H = EADC_CH7.
N * |        |          |08H = EADC_CH8.
N * |        |          |09H = EADC_CH9.
N * |        |          |0AH = EADC_CH10.
N * |        |          |0BH = EADC_CH11.
N * |        |          |0CH = EADC_CH12.
N * |        |          |0DH = EADC_CH13.
N * |        |          |0EH = EADC_CH14.
N * |        |          |0FH = EADC_CH15.
N * |[4]     |EXTREN    |A/D External Trigger Rising Edge Enable Bit
N * |        |          |0 = Rising edge Disabled when A/D selects STADC as trigger source.
N * |        |          |1 = Rising edge Enabled when A/D selects STADC as trigger source.
N * |[5]     |EXTFEN    |A/D External Trigger Falling Edge Enable Bit
N * |        |          |0 = Falling edge Disabled when A/D selects STADC as trigger source.
N * |        |          |1 = Falling edge Enabled when A/D selects STADC as trigger source.
N * |[7:6]   |TRGDLYDIV[1:0]|A/D Sample Module Start Of Conversion Trigger Delay Clock Divider Selection
N * |        |          |Trigger delay clock frequency:
N * |        |          |00 = ADC_CLK/1.
N * |        |          |01 = ADC_CLK/2.
N * |        |          |10 = ADC_CLK/4.
N * |        |          |11 = ADC_CLK/16.
N * |[15:8]  |TRGDLYCNT[7:0]|A/D Sample Module Start Of Conversion Trigger Delay Time
N * |        |          |Trigger delay time = TRGDLYCNT x ADC_CLK x n (n=1,2,4,16 from TRGDLYDIV setting).
N * |[20:16] |TRGSEL    |A/D Sample Module Start Of Conversion Trigger Source Selection
N * |        |          |0H = Disable trigger.
N * |        |          |1H = External trigger from STADC pin input.
N * |        |          |2H = ADC ADINT0 interrupt EOC pulse trigger.
N * |        |          |3H = ADC ADINT1 interrupt EOC pulse trigger.
N * |        |          |4H = Timer0 overflow pulse trigger.
N * |        |          |5H = Timer1 overflow pulse trigger.
N * |        |          |6H = Timer2 overflow pulse trigger.
N * |        |          |7H = Timer3 overflow pulse trigger.
N * |        |          |8H = PWM0TG0.
N * |        |          |9H = PWM0TG1.
N * |        |          |AH = PWM0TG2.
N * |        |          |BH = PWM0TG3.
N * |        |          |CH = PWM0TG4.
N * |        |          |DH = PWM0TG5.
N * |        |          |EH = PWM1TG0.
N * |        |          |FH = PWM1TG1.
N * |        |          |10H = PWM1TG2.
N * |        |          |11H = PWM1TG3.
N * |        |          |12H = PWM1TG4.
N * |        |          |13H = PWM1TG5.
N * |        |          |other = Reserved.
N * |[22]    |INTPOS    |Interrupt Flag Position Select
N * |        |          |0 = Set ADIFn (EADC_STATUS2[n], n=0~3) at A/D end of conversion.
N * |        |          |1 = Set ADIFn (EADC_STATUS2[n], n=0~3) at A/D start of conversion.
N * |[31:24] |EXTSMPT   |ADC Sampling Time Extend
N * |        |          |When A/D converting at high conversion rate, the sampling time of analog input voltage may not enough if input channel loading is heavy, SW can extend A/D sampling time after trigger source is coming to get enough sampling time.
N * |        |          |The range of start delay time is from 0~255 ADC clock.
N * @var EADC_T::SCTL
N * Offset: 0xC0~0xC8  A/D Sample Module n Control Register, n=16~18
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:24] |EXTSMPT   |ADC Sampling Time Extend
N * |        |          |When A/D converting at high conversion rate, the sampling time of analog input voltage may not enough if input channel loading is heavy, SW can extend A/D sampling time after trigger source is coming to get enough sampling time.
N * |        |          |The range of start delay time is from 0~255 ADC clock.
N * @var EADC_T::INTSRC
N * Offset: 0xDC  ADC interrupt n Source Enable Control Register, n=0~3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |SPLIE0    |Sample Module 0 Interrupt Enable Bit
N * |        |          |0 = Sample Module 0 interrupt Disabled.
N * |        |          |1 = Sample Module 0 interrupt Enabled.
N * |[1]     |SPLIE1    |Sample Module 1 Interrupt Enable Bit
N * |        |          |0 = Sample Module 1 interrupt Disabled.
N * |        |          |1 = Sample Module 1 interrupt Enabled.
N * |[2]     |SPLIE2    |Sample Module 2 Interrupt Enable Bit
N * |        |          |0 = Sample Module 2 interrupt Disabled.
N * |        |          |1 = Sample Module 2 interrupt Enabled.
N * |[3]     |SPLIE3    |Sample Module 3 Interrupt Enable Bit
N * |        |          |0 = Sample Module 3 interrupt Disabled.
N * |        |          |1 = Sample Module 3 interrupt Enabled.
N * |[4]     |SPLIE4    |Sample Module 4 Interrupt Enable Bit
N * |        |          |0 = Sample Module 4 interrupt Disabled.
N * |        |          |1 = Sample Module 4 interrupt Enabled.
N * |[5]     |SPLIE5    |Sample Module 5 Interrupt Enable Bit
N * |        |          |0 = Sample Module 5 interrupt Disabled.
N * |        |          |1 = Sample Module 5 interrupt Enabled.
N * |[6]     |SPLIE6    |Sample Module 6 Interrupt Enable Bit
N * |        |          |0 = Sample Module 6 interrupt Disabled.
N * |        |          |1 = Sample Module 6 interrupt Enabled.
N * |[7]     |SPLIE7    |Sample Module 7 Interrupt Enable Bit
N * |        |          |0 = Sample Module 7 interrupt Disabled.
N * |        |          |1 = Sample Module 7 interrupt Enabled.
N * |[8]     |SPLIE8    |Sample Module 8 Interrupt Enable Bit
N * |        |          |0 = Sample Module 8 interrupt Disabled.
N * |        |          |1 = Sample Module 8 interrupt Enabled.
N * |[9]     |SPLIE9    |Sample Module 9 Interrupt Enable Bit
N * |        |          |0 = Sample Module 9 interrupt Disabled.
N * |        |          |1 = Sample Module 9 interrupt Enabled.
N * |[10]    |SPLIE10   |Sample Module 10 Interrupt Enable Bit
N * |        |          |0 = Sample Module 10 interrupt Disabled.
N * |        |          |1 = Sample Module 10 interrupt Enabled.
N * |[11]    |SPLIE11   |Sample Module 11 Interrupt Enable Bit
N * |        |          |0 = Sample Module 11 interrupt Disabled.
N * |        |          |1 = Sample Module 11 interrupt Enabled.
N * |[12]    |SPLIE12   |Sample Module 12 Interrupt Enable Bit
N * |        |          |0 = Sample Module 12 interrupt Disabled.
N * |        |          |1 = Sample Module 12 interrupt Enabled.
N * |[13]    |SPLIE13   |Sample Module 13 Interrupt Enable Bit
N * |        |          |0 = Sample Module 13 interrupt Disabled.
N * |        |          |1 = Sample Module 13 interrupt Enabled.
N * |[14]    |SPLIE14   |Sample Module 14 Interrupt Enable Bit
N * |        |          |0 = Sample Module 14 interrupt Disabled.
N * |        |          |1 = Sample Module 14 interrupt Enabled.
N * |[15]    |SPLIE15   |Sample Module 15 Interrupt Enable Bit
N * |        |          |0 = Sample Module 15 interrupt Disabled.
N * |        |          |1 = Sample Module 15 interrupt Enabled.
N * |[16]    |SPLIE16   |Sample Module 16 Interrupt Enable Bit
N * |        |          |0 = Sample Module 16 interrupt Disabled.
N * |        |          |1 = Sample Module 16 interrupt Enabled.
N * |[17]    |SPLIE17   |Sample Module 17 Interrupt Enable Bit
N * |        |          |0 = Sample Module 17 interrupt Disabled.
N * |        |          |1 = Sample Module 17 interrupt Enabled.
N * |[18]    |SPLIE18   |Sample Module 18 Interrupt Enable Bit
N * |        |          |0 = Sample Module 18 interrupt Disabled.
N * |        |          |1 = Sample Module 18 interrupt Enabled.
N * @var EADC_T::CMP
N * Offset: 0xEC  A/D Result Compare Register n, n=0~3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ADCMPEN   |A/D Result Compare Enable Bit
N * |        |          |0 = Compare Disabled.
N * |        |          |1 = Compare Enabled.
N * |        |          |Set this bit to 1 to enable compare CMPDAT (EADC_CMPn[27:16], n=0~3) with specified sample module conversion result when converted data is loaded into EADC_DAT register.
N * |[1]     |ADCMPIE   |A/D Result Compare Interrupt Enable Bit
N * |        |          |0 = Compare function interrupt Disabled.
N * |        |          |1 = Compare function interrupt Enabled.
N * |        |          |If the compare function is enabled and the compare condition matches the setting of CMPCOND (EADC_CMPn[2], n=0~3) and CMPMCNT (EADC_CMPn[11:8], n=0~3), ADCMPFn (EADC_STATUS2[7:4], n=0~3) will be asserted, in the meanwhile, if ADCMPIE is set to 1, a compare interrupt request is generated.
N * |[2]     |CMPCOND   |Compare Condition
N * |        |          |0= Set the compare condition as that when a 12-bit A/D conversion result is less than the 12-bit CMPDAT (EADC_CMPn
N * |        |          |[27:16]), the internal match counter will increase one.
N * |        |          |1= Set the compare condition as that when a 12-bit A/D conversion result is greater or equal to the 12-bit CMPDAT (EADC_CMPn [27:16]), the internal match counter will increase one.
N * |        |          |Note: When the internal counter reaches the value to (CMPMCNT (EADC_CMPn[11:8], n=0~3) +1), the CMPF bit will be set.
N * |[7:3]   |CMPSPL    |Compare Sample Module Selection
N * |        |          |00000 = Sample Module 0 conversion result EADC_DAT0 is selected to be compared.
N * |        |          |00001 = Sample Module 1 conversion result EADC_DAT1 is selected to be compared.
N * |        |          |00010 = Sample Module 2 conversion result EADC_DAT2 is selected to be compared.
N * |        |          |00011 = Sample Module 3 conversion result EADC_DAT3 is selected to be compared.
N * |        |          |00100 = Sample Module 4 conversion result EADC_DAT4 is selected to be compared.
N * |        |          |00101 = Sample Module 5 conversion result EADC_DAT5 is selected to be compared.
N * |        |          |00110 = Sample Module 6 conversion result EADC_DAT6 is selected to be compared.
N * |        |          |00111 = Sample Module 7 conversion result EADC_DAT7 is selected to be compared.
N * |        |          |01000 = Sample Module 8 conversion result EADC_DAT8 is selected to be compared.
N * |        |          |01001 = Sample Module 9 conversion result EADC_DAT9 is selected to be compared.
N * |        |          |01010 = Sample Module 10 conversion result EADC_DAT10 is selected to be compared.
N * |        |          |01011 = Sample Module 11 conversion result EADC_DAT11 is selected to be compared.
N * |        |          |01100 = Sample Module 12 conversion result EADC_DAT12 is selected to be compared.
N * |        |          |01101 = Sample Module 13 conversion result EADC_DAT13 is selected to be compared.
N * |        |          |01110 = Sample Module 14 conversion result EADC_DAT14 is selected to be compared.
N * |        |          |01111 = Sample Module 15 conversion result EADC_DAT15 is selected to be compared.
N * |        |          |10000 = Sample Module 16 conversion result EADC_DAT16 is selected to be compared.
N * |        |          |10001 = Sample Module 17 conversion result EADC_DAT17 is selected to be compared.
N * |        |          |10010 = Sample Module 18 conversion result EADC_DAT18 is selected to be compared.
N * |[11:8]  |CMPMCNT   |Compare Match Count
N * |        |          |When the specified A/D sample module analog conversion result matches the compare condition defined by CMPCOND (EADC_CMPn[2], n=0~3), the internal match counter will increase 1.
N * |        |          |If the compare result does not meet the compare condition, the internal compare match counter will reset to 0.
N * |        |          |When the internal counter reaches the value to (CMPMCNT +1), the ADCMPFn (EADC_STATUS2[7:4], n=0~3) will be set.
N * |[15]    |CMPWEN    |Compare Window Mode Enable Bit
N * |        |          |0 = ADCMPF0 (EADC_STATUS2[4]) will be set when EADC_CMP0 compared condition matched.
N * |        |          |ADCMPF2 (EADC_STATUS2[6]) will be set when EADC_CMP2 compared condition matched.
N * |        |          |1 = ADCMPF0 (EADC_STATUS2[4]) will be set when both EADC_CMP0 and EADC_CMP1 compared condition matched.
N * |        |          |ADCMPF2 (EADC_STATUS2[6]) will be set when both EADC_CMP2 and EADC_CMP3 compared condition matched.
N * |        |          |Note: This bit is only present in EADC_CMP0 and EADC_CMP2 register.
N * |[27:16] |CMPDAT    |Comparison Data
N * |        |          |The 12 bits data is used to compare with conversion result of specified sample module.
N * |        |          |User can use it to monitor the external analog input pin voltage transition without imposing a load on software.
N * @var EADC_T::STATUS0
N * Offset: 0xF0  A/D Status Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |VALID     |EADC_DAT0~15 Data Valid Flag
N * |        |          |It is a mirror of VALID bit in sample module A/D result data register EADC_DATn. (n=0~18).
N * |[31:16] |OV        |EADC_DAT0~15 Overrun Flag
N * |        |          |It is a mirror to OV bit in sample module A/D result data register EADC_DATn. (n=0~18).
N * @var EADC_T::STATUS1
N * Offset: 0xF4  A/D Status Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2:0]   |VALID     |EADC_DAT16~18 Data Valid Flag
N * |        |          |It is a mirror of VALID bit in sample module A/D result data register EADC_DATn. (n=0~18).
N * |[18:16] |OV        |EADC_DAT16~18 Overrun Flag
N * |        |          |It is a mirror to OV bit in sample module A/D result data register EADC_DATn. (n=0~18).
N * @var EADC_T::STATUS2
N * Offset: 0xF8  A/D Status Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ADIF0     |A/D ADINT0 Interrupt Flag
N * |        |          |0 = No ADINT0 interrupt pulse received.
N * |        |          |1 = ADINT0 interrupt pulse has been received.
N * |        |          |Note1: This bit is cleared by writing 1 to it.
N * |        |          |Note2:This bit indicates whether an A/D conversion of specific sample module has been completed
N * |[1]     |ADIF1     |A/D ADINT1 Interrupt Flag
N * |        |          |0 = No ADINT1 interrupt pulse received.
N * |        |          |1 = ADINT1 interrupt pulse has been received.
N * |        |          |Note1: This bit is cleared by writing 1 to it.
N * |        |          |Note2:This bit indicates whether an A/D conversion of specific sample module has been completed
N * |[2]     |ADIF2     |A/D ADINT2 Interrupt Flag
N * |        |          |0 = No ADINT2 interrupt pulse received.
N * |        |          |1 = ADINT2 interrupt pulse has been received.
N * |        |          |Note1: This bit is cleared by writing 1 to it.
N * |        |          |Note2:This bit indicates whether an A/D conversion of specific sample module has been completed
N * |[3]     |ADIF3     |A/D ADINT3 Interrupt Flag
N * |        |          |0 = No ADINT3 interrupt pulse received.
N * |        |          |1 = ADINT3 interrupt pulse has been received.
N * |        |          |Note1: This bit is cleared by writing 1 to it.
N * |        |          |Note2:This bit indicates whether an A/D conversion of specific sample module has been completed
N * |[4]     |ADCMPF0   |ADC Compare 0 Flag
N * |        |          |When the specific sample module A/D conversion result meets setting condition in EADC_CMP0 then this bit is set to 1.
N * |        |          |0 = Conversion result in EADC_DAT does not meet EADC_CMP0 register setting.
N * |        |          |1 = Conversion result in EADC_DAT meets EADC_CMP0 register setting.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * |[5]     |ADCMPF1   |ADC Compare 1 Flag
N * |        |          |When the specific sample module A/D conversion result meets setting condition in EADC_CMP1 then this bit is set to 1.
N * |        |          |0 = Conversion result in EADC_DAT does not meet EADC_CMP1 register setting.
N * |        |          |1 = Conversion result in EADC_DAT meets EADC_CMP1 register setting.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * |[6]     |ADCMPF2   |ADC Compare 2 Flag
N * |        |          |When the specific sample module A/D conversion result meets setting condition in EADC_CMP2 then this bit is set to 1.
N * |        |          |0 = Conversion result in EADC_DAT does not meet EADC_CMP2 register setting.
N * |        |          |1 = Conversion result in EADC_DAT meets EADC_CMP2 register setting.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * |[7]     |ADCMPF3   |ADC Compare 3 Flag
N * |        |          |When the specific sample module A/D conversion result meets setting condition in EADC_CMP3 then this bit is set to 1.
N * |        |          |0 = Conversion result in EADC_DAT does not meet EADC_CMP3 register setting.
N * |        |          |1 = Conversion result in EADC_DAT meets EADC_CMP3 register setting.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * |[8]     |ADOVIF0   |A/D ADINT0 Interrupt Flag Overrun
N * |        |          |0 = ADINT0 interrupt flag is not overwritten to 1.
N * |        |          |1 = ADINT0 interrupt flag is overwritten to 1.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * |[9]     |ADOVIF1   |A/D ADINT1 Interrupt Flag Overrun
N * |        |          |0 = ADINT1 interrupt flag is not overwritten to 1.
N * |        |          |1 = ADINT1 interrupt flag is overwritten to 1.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * |[10]    |ADOVIF2   |A/D ADINT2 Interrupt Flag Overrun
N * |        |          |0 = ADINT2 interrupt flag is not overwritten to 1.
N * |        |          |1 = ADINT2 interrupt flag is s overwritten to 1.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * |[11]    |ADOVIF3   |A/D ADINT3 Interrupt Flag Overrun
N * |        |          |0 = ADINT3 interrupt flag is not overwritten to 1.
N * |        |          |1 = ADINT3 interrupt flag is overwritten to 1.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * |[12]    |ADCMPO0   |ADC Compare 0 Output Status
N * |        |          |The 12 bits compare0 data CMPDAT0 (EADC_CMP0[27:16]) is used to compare with conversion result of specified sample module.
N * |        |          |User can use it to monitor the external analog input pin voltage status.
N * |        |          |0 = Conversion result in EADC_DAT less than CMPDAT0 setting.
N * |        |          |1 = Conversion result in EADC_DAT great than or equal CMPDAT0
N * |        |          |setting.
N * |[13]    |ADCMPO1   |ADC Compare 1 Output Status
N * |        |          |The 12 bits compare1 data CMPDAT1 (EADC_CMP1[27:16]) is used to compare with conversion result of specified sample module.
N * |        |          |User can use it to monitor the external analog input pin voltage status.
N * |        |          |0 = Conversion result in EADC_DAT less than CMPDAT1 setting.
N * |        |          |1 = Conversion result in EADC_DAT great than or equal CMPDAT1
N * |        |          |setting.
N * |[14]    |ADCMPO2   |ADC Compare 2 Output Status
N * |        |          |The 12 bits compare2 data CMPDAT2 (EADC_CMP2[27:16]) is used to compare with conversion result of specified sample module.
N * |        |          |User can use it to monitor the external analog input pin voltage status.
N * |        |          |0 = Conversion result in EADC_DAT less than CMPDAT2 setting.
N * |        |          |1 = Conversion result in EADC_DAT great than or equal CMPDAT2
N * |        |          |setting.
N * |[15]    |ADCMPO3   |ADC Compare 3 Output Status
N * |        |          |The 12 bits compare3 data CMPDAT3 (EADC_CMP3[27:16]) is used to compare with conversion result of specified sample module.
N * |        |          |User can use it to monitor the external analog input pin voltage status.
N * |        |          |0 = Conversion result in EADC_DAT less than CMPDAT3 setting.
N * |        |          |1 = Conversion result in EADC_DAT great than or equal CMPDAT3
N * |        |          |setting.
N * |[20:16] |CHANNEL   |Current Conversion Channel
N * |        |          |This filed reflects ADC current conversion channel when BUSY=1.
N * |        |          |It is read only.
N * |        |          |00H = EADC_CH0.
N * |        |          |01H = EADC_CH1.
N * |        |          |02H = EADC_CH2.
N * |        |          |03H = EADC_CH3.
N * |        |          |04H = EADC_CH4.
N * |        |          |05H = EADC_CH5.
N * |        |          |06H = EADC_CH6.
N * |        |          |07H = EADC_CH7.
N * |        |          |08H = EADC_CH8.
N * |        |          |09H = EADC_CH9.
N * |        |          |0AH = EADC_CH10.
N * |        |          |0BH = EADC_CH11.
N * |        |          |0CH = EADC_CH12.
N * |        |          |0DH = EADC_CH13.
N * |        |          |0EH = EADC_CH14.
N * |        |          |0FH = EADC_CH15.
N * |        |          |10H = VBG.
N * |        |          |11H = VTEMP.
N * |        |          |12H = VBAT.
N * |[23]    |BUSY      |Busy/Idle
N * |        |          |0 = EADC is in idle state.
N * |        |          |1 = EADC is busy at conversion.
N * |        |          |Note: This bit is read only.
N * |[24]    |ADOVIF    |All A/D Interrupt Flag Overrun Bits Check
N * |        |          |n=0~3.
N * |        |          |0 = None of ADINT interrupt flag ADOVIFn (EADC_STATUS2[11:8]) is overwritten to 1.
N * |        |          |1 = Any one of ADINT interrupt flag ADOVIFn (EADC_STATUS2[11:8]) is overwritten to 1.
N * |        |          |Note: This bit will keep 1 when any ADOVIFn Flag is equal to 1.
N * |[25]    |STOVF     |For All A/D Sample Module Start Of Conversion Overrun Flags Check
N * |        |          |n=0~18.
N * |        |          |0 = None of sample module event overrun flag SPOVFn (EADC_OVSTS[n]) is set to 1.
N * |        |          |1 = Any one of sample module event overrun flag SPOVFn (EADC_OVSTS[n]) is set to 1.
N * |        |          |Note: This bit will keep 1 when any SPOVFn Flag is equal to 1.
N * |[26]    |AVALID    |For All Sample Module A/D Result Data Register EADC_DAT Data Valid Flag Check
N * |        |          |n=0~18.
N * |        |          |0 = None of sample module data register valid flag VALIDn (EADC_DATn[17]) is set to 1.
N * |        |          |1 = Any one of sample module data register valid flag VALIDn (EADC_DATn[17]) is set to 1.
N * |        |          |Note: This bit will keep 1 when any VALIDn Flag is equal to 1.
N * |[27]    |AOV       |For All Sample Module A/D Result Data Register Overrun Flags Check
N * |        |          |n=0~18.
N * |        |          |0 = None of sample module data register overrun flag OVn (EADC_DATn[16]) is set to 1.
N * |        |          |1 = Any one of sample module data register overrun flag OVn (EADC_DATn[16]) is set to 1.
N * |        |          |Note: This bit will keep 1 when any OVn Flag is equal to 1.
N * @var EADC_T::STATUS3
N * Offset: 0xFC  A/D Status Register 3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[4:0]   |CURSPL    |ADC Current Sample Module
N * |        |          |This register show the current ADC is controlled by which sample module control logic modules.
N * |        |          |If the ADC is Idle, this bit filed will set to 0x1F.
N * |        |          |This is a read only register.
N * @var EADC_T::DDAT
N * Offset: 0x100-0x10C  A/D Double Data Register n for Sample Module n, n=0~3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |RESULT    |A/D Conversion Results
N * |        |          |This field contains 12 bits conversion results.
N * |        |          |When the DMOF (EADC_CTL[9]) is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT [11:0] and zero will be filled in RESULT [15:12].
N * |        |          |When DMOF (EADC_CTL[9]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT [11:0] and signed bits to will be filled in RESULT [15:12].
N * |[16]    |OV        |Overrun Flag
N * |        |          |0 = Data in RESULT (EADC_DATn[15:0], n=0~3) is recent conversion result.
N * |        |          |1 = Data in RESULT (EADC_DATn[15:0], n=0~3) is overwrite.
N * |        |          |If converted data in RESULT[15:0] has not been read before new conversion result is loaded to this register, OV is set to 1.
N * |        |          |It is cleared by hardware after EADC_DDAT register is read.
N * |[17]    |VALID     |Valid Flag
N * |        |          |0 = Double data in RESULT (EADC_DDATn[15:0]) is not valid.
N * |        |          |1 = Double data in RESULT (EADC_DDATn[15:0]) is valid.
N * |        |          |This bit is set to 1 when corresponding sample module channel analog input conversion is completed and cleared by hardware after EADC_DDATn register is read.
N * |        |          |(n=0~3).
N */
N
N    __I  uint32_t DAT[19];       /* Offset: 0x00-0x48  A/D Data Register n for Sample Module n, n=0~18               */
X    volatile const  uint32_t DAT[19];        
N    __I  uint32_t CURDAT;        /* Offset: 0x4C  EADC PDMA Current Transfer Data Register                           */
X    volatile const  uint32_t CURDAT;         
N    __IO uint32_t CTL;           /* Offset: 0x50  A/D Control Register                                               */
X    volatile uint32_t CTL;            
N    __O  uint32_t SWTRG;         /* Offset: 0x54  A/D Sample Module Software Start Register                          */
X    volatile  uint32_t SWTRG;          
N    __IO uint32_t PENDSTS;       /* Offset: 0x58  A/D Start of Conversion Pending Flag Register                      */
X    volatile uint32_t PENDSTS;        
N    __IO uint32_t OVSTS;         /* Offset: 0x5C  A/D Sample Module Start of Conversion Overrun Flag Register        */
X    volatile uint32_t OVSTS;          
N    __I  uint32_t RESERVE0[8];  
X    volatile const  uint32_t RESERVE0[8];  
N    __IO uint32_t SCTL[19];      /* Offset: 0x80-0xC8  A/D Sample Module n Control Register, n=0~3                   */
X    volatile uint32_t SCTL[19];       
N    __I  uint32_t RESERVE1[1];  
X    volatile const  uint32_t RESERVE1[1];  
N    __IO uint32_t INTSRC[4];     /* Offset: 0xDC  ADC interrupt n Source Enable Control Register, n=0~3              */
X    volatile uint32_t INTSRC[4];      
N    __IO uint32_t CMP[4];        /* Offset: 0xEC  A/D Result Compare Register n, n=0~3                               */
X    volatile uint32_t CMP[4];         
N    __I  uint32_t STATUS0;       /* Offset: 0xF0  A/D Status Register 0                                              */
X    volatile const  uint32_t STATUS0;        
N    __I  uint32_t STATUS1;       /* Offset: 0xF4  A/D Status Register 1                                              */
X    volatile const  uint32_t STATUS1;        
N    __IO uint32_t STATUS2;       /* Offset: 0xF8  A/D Status Register 2                                              */
X    volatile uint32_t STATUS2;        
N    __I  uint32_t STATUS3;       /* Offset: 0xFC  A/D Status Register 3                                              */
X    volatile const  uint32_t STATUS3;        
N    __I  uint32_t DDAT[4];       /* Offset: 0x100-0x10C  A/D Double Data Register n for Sample Module n, n=0~3       */
X    volatile const  uint32_t DDAT[4];        
N
N} EADC_T;
N
N
N
N/**
N    @addtogroup EADC_CONST EADC Bit Field Definition
N    Constant Definitions for EADC Controller
N@{ */
N#define EADC_DAT_RESULT_Pos               (0)                                               /*!< EADC_T::DAT: RESULT Position              */
N#define EADC_DAT_RESULT_Msk               (0xfffful << EADC_DAT_RESULT_Pos)                 /*!< EADC_T::DAT: RESULT Mask                  */
N
N#define EADC_DAT_OV_Pos                   (16)                                              /*!< EADC_T::DAT: OV Position                  */
N#define EADC_DAT_OV_Msk                   (0x1ul << EADC_DAT_OV_Pos)                        /*!< EADC_T::DAT: OV Mask                      */
N
N#define EADC_DAT_VALID_Pos                (17)                                              /*!< EADC_T::DAT: VALID Position               */
N#define EADC_DAT_VALID_Msk                (0x1ul << EADC_DAT_VALID_Pos)                     /*!< EADC_T::DAT: VALID Mask                   */
N
N#define EADC_CURDAT_CURDAT_Pos            (0)                                               /*!< EADC_T::CURDAT: CURDAT Position           */
N#define EADC_CURDAT_CURDAT_Msk            (0x3fffful << EADC_CURDAT_CURDAT_Pos)             /*!< EADC_T::CURDAT: CURDAT Mask               */
N
N#define EADC_CTL_ADCEN_Pos                (0)                                               /*!< EADC_T::CTL: ADCEN Position               */
N#define EADC_CTL_ADCEN_Msk                (0x1ul << EADC_CTL_ADCEN_Pos)                     /*!< EADC_T::CTL: ADCEN Mask                   */
N
N#define EADC_CTL_ADRST_Pos                (1)                                               /*!< EADC_T::CTL: ADRST Position               */
N#define EADC_CTL_ADRST_Msk                (0x1ul << EADC_CTL_ADRST_Pos)                     /*!< EADC_T::CTL: ADRST Mask                   */
N
N#define EADC_CTL_ADCIEN0_Pos              (2)                                               /*!< EADC_T::CTL: ADCIEN0 Position             */
N#define EADC_CTL_ADCIEN0_Msk              (0x1ul << EADC_CTL_ADCIEN0_Pos)                   /*!< EADC_T::CTL: ADCIEN0 Mask                 */
N
N#define EADC_CTL_ADCIEN1_Pos              (3)                                               /*!< EADC_T::CTL: ADCIEN1 Position             */
N#define EADC_CTL_ADCIEN1_Msk              (0x1ul << EADC_CTL_ADCIEN1_Pos)                   /*!< EADC_T::CTL: ADCIEN1 Mask                 */
N
N#define EADC_CTL_ADCIEN2_Pos              (4)                                               /*!< EADC_T::CTL: ADCIEN2 Position             */
N#define EADC_CTL_ADCIEN2_Msk              (0x1ul << EADC_CTL_ADCIEN2_Pos)                   /*!< EADC_T::CTL: ADCIEN2 Mask                 */
N
N#define EADC_CTL_ADCIEN3_Pos              (5)                                               /*!< EADC_T::CTL: ADCIEN3 Position             */
N#define EADC_CTL_ADCIEN3_Msk              (0x1ul << EADC_CTL_ADCIEN3_Pos)                   /*!< EADC_T::CTL: ADCIEN3 Mask                 */
N
N#define EADC_CTL_DIFFEN_Pos               (8)                                               /*!< EADC_T::CTL: DIFFEN Position              */
N#define EADC_CTL_DIFFEN_Msk               (0x1ul << EADC_CTL_DIFFEN_Pos)                    /*!< EADC_T::CTL: DIFFEN Mask                  */
N
N#define EADC_CTL_DMOF_Pos                 (9)                                               /*!< EADC_T::CTL: DMOF Position                */
N#define EADC_CTL_DMOF_Msk                 (0x1ul << EADC_CTL_DMOF_Pos)                      /*!< EADC_T::CTL: DMOF Mask                    */
N
N#define EADC_CTL_PDMAEN_Pos               (11)                                              /*!< EADC_T::CTL: PDMAEN Position              */
N#define EADC_CTL_PDMAEN_Msk               (0x1ul << EADC_CTL_PDMAEN_Pos)                    /*!< EADC_T::CTL: PDMAEN Mask                  */
N
N#define EADC_CTL_SMPTSEL_Pos              (16)                                              /*!< EADC_T::CTL: SMPTSEL Position             */
N#define EADC_CTL_SMPTSEL_Msk              (0x7ul << EADC_CTL_SMPTSEL_Pos)                   /*!< EADC_T::CTL: SMPTSEL Mask                 */
N
N#define EADC_SWTRG_SWTRG_Pos              (0)                                               /*!< EADC_T::SWTRG: SWTRG Position             */
N#define EADC_SWTRG_SWTRG_Msk              (0x7fffful << EADC_SWTRG_SWTRG_Pos)               /*!< EADC_T::SWTRG: SWTRG Mask                 */
N
N#define EADC_PENDSTS_STPF_Pos             (0)                                               /*!< EADC_T::PENDSTS: STPF Position            */
N#define EADC_PENDSTS_STPF_Msk             (0x7fffful << EADC_PENDSTS_STPF_Pos)              /*!< EADC_T::PENDSTS: STPF Mask                */
N
N#define EADC_OVSTS_SPOVF_Pos              (0)                                               /*!< EADC_T::OVSTS: SPOVF Position             */
N#define EADC_OVSTS_SPOVF_Msk              (0x7fffful << EADC_OVSTS_SPOVF_Pos)               /*!< EADC_T::OVSTS: SPOVF Mask                 */
N
N#define EADC_SCTL_CHSEL_Pos               (0)                                               /*!< EADC_T::SCTL: CHSEL Position              */
N#define EADC_SCTL_CHSEL_Msk               (0xful << EADC_SCTL_CHSEL_Pos)                    /*!< EADC_T::SCTL: CHSEL Mask                  */
N
N#define EADC_SCTL_EXTREN_Pos              (4)                                               /*!< EADC_T::SCTL: EXTREN Position             */
N#define EADC_SCTL_EXTREN_Msk              (0x1ul << EADC_SCTL_EXTREN_Pos)                   /*!< EADC_T::SCTL: EXTREN Mask                 */
N
N#define EADC_SCTL_EXTFEN_Pos              (5)                                               /*!< EADC_T::SCTL: EXTFEN Position             */
N#define EADC_SCTL_EXTFEN_Msk              (0x1ul << EADC_SCTL_EXTFEN_Pos)                   /*!< EADC_T::SCTL: EXTFEN Mask                 */
N
N#define EADC_SCTL_TRGDLYDIV_Pos           (6)                                               /*!< EADC_T::SCTL: TRGDLYDIV Position          */
N#define EADC_SCTL_TRGDLYDIV_Msk           (0x3ul << EADC_SCTL_TRGDLYDIV_Pos)                /*!< EADC_T::SCTL: TRGDLYDIV Mask              */
N
N#define EADC_SCTL_TRGDLYCNT_Pos           (8)                                               /*!< EADC_T::SCTL: TRGDLYCNT Position          */
N#define EADC_SCTL_TRGDLYCNT_Msk           (0xfful << EADC_SCTL_TRGDLYCNT_Pos)               /*!< EADC_T::SCTL: TRGDLYCNT Mask              */
N
N#define EADC_SCTL_TRGSEL_Pos              (16)                                              /*!< EADC_T::SCTL: TRGSEL Position             */
N#define EADC_SCTL_TRGSEL_Msk              (0x1ful << EADC_SCTL_TRGSEL_Pos)                  /*!< EADC_T::SCTL: TRGSEL Mask                 */
N
N#define EADC_SCTL_INTPOS_Pos              (22)                                              /*!< EADC_T::SCTL: INTPOS Position             */
N#define EADC_SCTL_INTPOS_Msk              (0x1ul << EADC_SCTL_INTPOS_Pos)                   /*!< EADC_T::SCTL: INTPOS Mask                 */
N
N#define EADC_SCTL_DBMEN_Pos               (23)                                              /*!< EADC_T::SCTL: DBMEN Position              */
N#define EADC_SCTL_DBMEN_Msk               (0x1ul << EADC_SCTL_DBMEN_Pos)                    /*!< EADC_T::SCTL: DBMEN Mask                  */
N
N#define EADC_SCTL_EXTSMPT_Pos             (24)                                              /*!< EADC_T::SCTL: EXTSMPT Position            */
N#define EADC_SCTL_EXTSMPT_Msk             (0xfful << EADC_SCTL_EXTSMPT_Pos)                 /*!< EADC_T::SCTL: EXTSMPT Mask                */
N
N#define EADC_INTSRC_SPLIE_Pos             (0)                                               /*!< EADC_T::INTSRC: SPLIE Position            */
N#define EADC_INTSRC_SPLIE_Msk             (0x7FFFFul << EADC_INTSRC_SPLIE_Pos)              /*!< EADC_T::INTSRC: SPLIE Mask                */
N
N#define EADC_CMP_ADCMPEN_Pos              (0)                                               /*!< EADC_T::CMP: ADCMPEN Position             */
N#define EADC_CMP_ADCMPEN_Msk              (0x1ul << EADC_CMP_ADCMPEN_Pos)                   /*!< EADC_T::CMP: ADCMPEN Mask                 */
N
N#define EADC_CMP_ADCMPIE_Pos              (1)                                               /*!< EADC_T::CMP: ADCMPIE Position             */
N#define EADC_CMP_ADCMPIE_Msk              (0x1ul << EADC_CMP_ADCMPIE_Pos)                   /*!< EADC_T::CMP: ADCMPIE Mask                 */
N
N#define EADC_CMP_CMPCOND_Pos              (2)                                               /*!< EADC_T::CMP: CMPCOND Position             */
N#define EADC_CMP_CMPCOND_Msk              (0x1ul << EADC_CMP_CMPCOND_Pos)                   /*!< EADC_T::CMP: CMPCOND Mask                 */
N
N#define EADC_CMP_CMPSPL_Pos               (3)                                               /*!< EADC_T::CMP: CMPSPL Position              */
N#define EADC_CMP_CMPSPL_Msk               (0x1ful << EADC_CMP_CMPSPL_Pos)                   /*!< EADC_T::CMP: CMPSPL Mask                  */
N
N#define EADC_CMP_CMPMCNT_Pos              (8)                                               /*!< EADC_T::CMP: CMPMCNT Position             */
N#define EADC_CMP_CMPMCNT_Msk              (0xful << EADC_CMP_CMPMCNT_Pos)                   /*!< EADC_T::CMP: CMPMCNT Mask                 */
N
N#define EADC_CMP_CMPWEN_Pos               (15)                                              /*!< EADC_T::CMP: CMPWEN Position              */
N#define EADC_CMP_CMPWEN_Msk               (0x1ul << EADC_CMP_CMPWEN_Pos)                    /*!< EADC_T::CMP: CMPWEN Mask                  */
N
N#define EADC_CMP_CMPDAT_Pos               (16)                                              /*!< EADC_T::CMP: CMPDAT Position              */
N#define EADC_CMP_CMPDAT_Msk               (0xffful << EADC_CMP_CMPDAT_Pos)                  /*!< EADC_T::CMP: CMPDAT Mask                  */
N
N#define EADC_STATUS0_VALID_Pos            (0)                                               /*!< EADC_T::STATUS0: VALID Position           */
N#define EADC_STATUS0_VALID_Msk            (0xfffful << EADC_STATUS0_VALID_Pos)              /*!< EADC_T::STATUS0: VALID Mask               */
N
N#define EADC_STATUS0_OV_Pos               (16)                                              /*!< EADC_T::STATUS0: OV Position              */
N#define EADC_STATUS0_OV_Msk               (0xfffful << EADC_STATUS0_OV_Pos)                 /*!< EADC_T::STATUS0: OV Mask                  */
N
N#define EADC_STATUS1_VALID_Pos            (0)                                               /*!< EADC_T::STATUS1: VALID Position           */
N#define EADC_STATUS1_VALID_Msk            (0x7ul << EADC_STATUS1_VALID_Pos)                 /*!< EADC_T::STATUS1: VALID Mask               */
N
N#define EADC_STATUS1_OV_Pos               (16)                                              /*!< EADC_T::STATUS1: OV Position              */
N#define EADC_STATUS1_OV_Msk               (0x7ul << EADC_STATUS1_OV_Pos)                    /*!< EADC_T::STATUS1: OV Mask                  */
N
N#define EADC_STATUS2_ADIF0_Pos            (0)                                               /*!< EADC_T::STATUS2: ADIF0 Position           */
N#define EADC_STATUS2_ADIF0_Msk            (0x1ul << EADC_STATUS2_ADIF0_Pos)                 /*!< EADC_T::STATUS2: ADIF0 Mask               */
N
N#define EADC_STATUS2_ADIF1_Pos            (1)                                               /*!< EADC_T::STATUS2: ADIF1 Position           */
N#define EADC_STATUS2_ADIF1_Msk            (0x1ul << EADC_STATUS2_ADIF1_Pos)                 /*!< EADC_T::STATUS2: ADIF1 Mask               */
N
N#define EADC_STATUS2_ADIF2_Pos            (2)                                               /*!< EADC_T::STATUS2: ADIF2 Position           */
N#define EADC_STATUS2_ADIF2_Msk            (0x1ul << EADC_STATUS2_ADIF2_Pos)                 /*!< EADC_T::STATUS2: ADIF2 Mask               */
N
N#define EADC_STATUS2_ADIF3_Pos            (3)                                               /*!< EADC_T::STATUS2: ADIF3 Position           */
N#define EADC_STATUS2_ADIF3_Msk            (0x1ul << EADC_STATUS2_ADIF3_Pos)                 /*!< EADC_T::STATUS2: ADIF3 Mask               */
N
N#define EADC_STATUS2_ADCMPF0_Pos          (4)                                               /*!< EADC_T::STATUS2: ADCMPF0 Position         */
N#define EADC_STATUS2_ADCMPF0_Msk          (0x1ul << EADC_STATUS2_ADCMPF0_Pos)               /*!< EADC_T::STATUS2: ADCMPF0 Mask             */
N
N#define EADC_STATUS2_ADCMPF1_Pos          (5)                                               /*!< EADC_T::STATUS2: ADCMPF1 Position         */
N#define EADC_STATUS2_ADCMPF1_Msk          (0x1ul << EADC_STATUS2_ADCMPF1_Pos)               /*!< EADC_T::STATUS2: ADCMPF1 Mask             */
N
N#define EADC_STATUS2_ADCMPF2_Pos          (6)                                               /*!< EADC_T::STATUS2: ADCMPF2 Position         */
N#define EADC_STATUS2_ADCMPF2_Msk          (0x1ul << EADC_STATUS2_ADCMPF2_Pos)               /*!< EADC_T::STATUS2: ADCMPF2 Mask             */
N
N#define EADC_STATUS2_ADCMPF3_Pos          (7)                                               /*!< EADC_T::STATUS2: ADCMPF3 Position         */
N#define EADC_STATUS2_ADCMPF3_Msk          (0x1ul << EADC_STATUS2_ADCMPF3_Pos)               /*!< EADC_T::STATUS2: ADCMPF3 Mask             */
N
N#define EADC_STATUS2_ADOVIF0_Pos          (8)                                               /*!< EADC_T::STATUS2: ADOVIF0 Position         */
N#define EADC_STATUS2_ADOVIF0_Msk          (0x1ul << EADC_STATUS2_ADOVIF0_Pos)               /*!< EADC_T::STATUS2: ADOVIF0 Mask             */
N
N#define EADC_STATUS2_ADOVIF1_Pos          (9)                                               /*!< EADC_T::STATUS2: ADOVIF1 Position         */
N#define EADC_STATUS2_ADOVIF1_Msk          (0x1ul << EADC_STATUS2_ADOVIF1_Pos)               /*!< EADC_T::STATUS2: ADOVIF1 Mask             */
N
N#define EADC_STATUS2_ADOVIF2_Pos          (10)                                              /*!< EADC_T::STATUS2: ADOVIF2 Position         */
N#define EADC_STATUS2_ADOVIF2_Msk          (0x1ul << EADC_STATUS2_ADOVIF2_Pos)               /*!< EADC_T::STATUS2: ADOVIF2 Mask             */
N
N#define EADC_STATUS2_ADOVIF3_Pos          (11)                                              /*!< EADC_T::STATUS2: ADOVIF3 Position         */
N#define EADC_STATUS2_ADOVIF3_Msk          (0x1ul << EADC_STATUS2_ADOVIF3_Pos)               /*!< EADC_T::STATUS2: ADOVIF3 Mask             */
N
N#define EADC_STATUS2_ADCMPO0_Pos          (12)                                              /*!< EADC_T::STATUS2: ADCMPO0 Position         */
N#define EADC_STATUS2_ADCMPO0_Msk          (0x1ul << EADC_STATUS2_ADCMPO0_Pos)               /*!< EADC_T::STATUS2: ADCMPO0 Mask             */
N
N#define EADC_STATUS2_ADCMPO1_Pos          (13)                                              /*!< EADC_T::STATUS2: ADCMPO1 Position         */
N#define EADC_STATUS2_ADCMPO1_Msk          (0x1ul << EADC_STATUS2_ADCMPO1_Pos)               /*!< EADC_T::STATUS2: ADCMPO1 Mask             */
N
N#define EADC_STATUS2_ADCMPO2_Pos          (14)                                              /*!< EADC_T::STATUS2: ADCMPO2 Position         */
N#define EADC_STATUS2_ADCMPO2_Msk          (0x1ul << EADC_STATUS2_ADCMPO2_Pos)               /*!< EADC_T::STATUS2: ADCMPO2 Mask             */
N
N#define EADC_STATUS2_ADCMPO3_Pos          (15)                                              /*!< EADC_T::STATUS2: ADCMPO3 Position         */
N#define EADC_STATUS2_ADCMPO3_Msk          (0x1ul << EADC_STATUS2_ADCMPO3_Pos)               /*!< EADC_T::STATUS2: ADCMPO3 Mask             */
N
N#define EADC_STATUS2_CHANNEL_Pos          (16)                                              /*!< EADC_T::STATUS2: CHANNEL Position         */
N#define EADC_STATUS2_CHANNEL_Msk          (0x1ful << EADC_STATUS2_CHANNEL_Pos)              /*!< EADC_T::STATUS2: CHANNEL Mask             */
N
N#define EADC_STATUS2_BUSY_Pos             (23)                                              /*!< EADC_T::STATUS2: BUSY Position            */
N#define EADC_STATUS2_BUSY_Msk             (0x1ul << EADC_STATUS2_BUSY_Pos)                  /*!< EADC_T::STATUS2: BUSY Mask                */
N
N#define EADC_STATUS2_ADOVIF_Pos           (24)                                              /*!< EADC_T::STATUS2: ADOVIF Position          */
N#define EADC_STATUS2_ADOVIF_Msk           (0x1ul << EADC_STATUS2_ADOVIF_Pos)                /*!< EADC_T::STATUS2: ADOVIF Mask              */
N
N#define EADC_STATUS2_STOVF_Pos            (25)                                              /*!< EADC_T::STATUS2: STOVF Position           */
N#define EADC_STATUS2_STOVF_Msk            (0x1ul << EADC_STATUS2_STOVF_Pos)                 /*!< EADC_T::STATUS2: STOVF Mask               */
N
N#define EADC_STATUS2_AVALID_Pos           (26)                                              /*!< EADC_T::STATUS2: AVALID Position          */
N#define EADC_STATUS2_AVALID_Msk           (0x1ul << EADC_STATUS2_AVALID_Pos)                /*!< EADC_T::STATUS2: AVALID Mask              */
N
N#define EADC_STATUS2_AOV_Pos              (27)                                              /*!< EADC_T::STATUS2: AOV Position             */
N#define EADC_STATUS2_AOV_Msk              (0x1ul << EADC_STATUS2_AOV_Pos)                   /*!< EADC_T::STATUS2: AOV Mask                 */
N
N#define EADC_STATUS3_CURSPL_Pos           (0)                                               /*!< EADC_T::STATUS3: CURSPL Position          */
N#define EADC_STATUS3_CURSPL_Msk           (0x1ful << EADC_STATUS3_CURSPL_Pos)               /*!< EADC_T::STATUS3: CURSPL Mask              */
N
N#define EADC_DDAT_RESULT_Pos              (0)                                               /*!< EADC_T::DDAT: RESULT Position             */
N#define EADC_DDAT_RESULT_Msk              (0xfffful << EADC_DDAT_RESULT_Pos)                /*!< EADC_T::DDAT: RESULT Mask                 */
N
N#define EADC_DDAT_OV_Pos                  (16)                                              /*!< EADC_T::DDAT: OV Position                 */
N#define EADC_DDAT_OV_Msk                  (0x1ul << EADC_DDAT_OV_Pos)                       /*!< EADC_T::DDAT: OV Mask                     */
N
N#define EADC_DDAT_VALID_Pos               (17)                                              /*!< EADC_T::DDAT: VALID Position              */
N#define EADC_DDAT_VALID_Msk               (0x1ul << EADC_DDAT_VALID_Pos)                    /*!< EADC_T::DDAT: VALID Mask                  */
N
N
N/**@}*/ /* EADC_CONST */
N/**@}*/ /* end of EADC register group */
N
N
N/*---------------------- Controller Area Network Controller -------------------------*/
N/**
N    @addtogroup CAN Controller Area Network Controller(CAN)
N    Memory Mapped Structure for CAN Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N
N/**
N * @var CAN_IF_T::CREQ
N * Offset: 0x20, 0x80  IFn (Register Map Note 2) Command Request Registers
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |MessageNumber|Message Number
N * |        |          |0x01-0x20: Valid Message Number, the Message Object in the Message
N * |        |          |RAM is selected for data transfer.
N * |        |          |0x00: Not a valid Message Number, interpreted as 0x20.
N * |        |          |0x21-0x3F: Not a valid Message Number, interpreted as 0x01-0x1F.
N * |[15]    |Busy      |Busy Flag
N * |        |          |0 = Read/write action has finished.
N * |        |          |1 = Writing to the IFn Command Request Register is in progress.
N * |        |          |This bit can only be read by the software.
N * @var CAN_IF_T::CMASK
N * Offset: 0x24, 0x84  IFn Command Mask Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |DAT_B     |Access Data Bytes [7:4]
N * |        |          |Write Operation:
N * |        |          |0 = Data Bytes [7:4] unchanged.
N * |        |          |1 = Transfer Data Bytes [7:4] to Message Object.
N * |        |          |Read Operation:
N * |        |          |0 = Data Bytes [7:4] unchanged.
N * |        |          |1 = Transfer Data Bytes [7:4] to IFn Message Buffer Register.
N * |[1]     |DAT_A     |Access Data Bytes [3:0]
N * |        |          |Write Operation:
N * |        |          |0 = Data Bytes [3:0] unchanged.
N * |        |          |1 = Transfer Data Bytes [3:0] to Message Object.
N * |        |          |Read Operation:
N * |        |          |0 = Data Bytes [3:0] unchanged.
N * |        |          |1 = Transfer Data Bytes [3:0] to IFn Message Buffer Register.
N * |[2]     |TxRqst_NewDat|Access Transmission Request Bit When Write Operation
N * |        |          |0 = TxRqst bit unchanged.
N * |        |          |1 = Set TxRqst bit.
N * |        |          |Note: If a transmission is requested by programming bit TxRqst/NewDat in the IFn Command Mask Register, bit TxRqst in the IFn Message Control Register will be ignored.
N * |        |          |Access New Data Bit when Read Operation.
N * |        |          |0 = NewDat bit remains unchanged.
N * |        |          |1 = Clear NewDat bit in the Message Object.
N * |        |          |Note: A read access to a Message Object can be combined with the reset of the control bits IntPnd and NewDat.
N * |        |          |The values of these bits transferred to the IFn Message Control Register always reflect the status before resetting these bits.
N * |[3]     |ClrIntPnd |Clear Interrupt Pending Bit
N * |        |          |Write Operation:
N * |        |          |When writing to a Message Object, this bit is ignored.
N * |        |          |Read Operation:
N * |        |          |0 = IntPnd bit (CAN_IFn_MCON[13]) remains unchanged.
N * |        |          |1 = Clear IntPnd bit in the Message Object.
N * |[4]     |Control   |Control Access Control Bits
N * |        |          |Write Operation:
N * |        |          |0 = Control Bits unchanged.
N * |        |          |1 = Transfer Control Bits to Message Object.
N * |        |          |Read Operation:
N * |        |          |0 = Control Bits unchanged.
N * |        |          |1 = Transfer Control Bits to IFn Message Buffer Register.
N * |[5]     |Arb       |Access Arbitration Bits
N * |        |          |Write Operation:
N * |        |          |0 = Arbitration bits unchanged.
N * |        |          |1 = Transfer Identifier + Dir (CAN_IFn_ARB2[13]) + Xtd (CAN_IFn_ARB2[14]) + MsgVal (CAN_IFn_APB2[15]) to Message Object.
N * |        |          |Read Operation:
N * |        |          |0 = Arbitration bits unchanged.
N * |        |          |1 = Transfer Identifier + Dir + Xtd + MsgVal to IFn Message Buffer Register.
N * |[6]     |Mask      |Access Mask Bits
N * |        |          |Write Operation:
N * |        |          |0 = Mask bits unchanged.
N * |        |          |1 = Transfer Identifier Mask + MDir + MXtd to Message Object.
N * |        |          |Read Operation:
N * |        |          |0 = Mask bits unchanged.
N * |        |          |1 = Transfer Identifier Mask + MDir + MXtd to IFn Message Buffer Register.
N * |[7]     |WR_RD     |Write / Read Mode
N * |        |          |0 = Read: Transfer data from the Message Object addressed by the Command Request Register into the selected Message Buffer Registers.
N * |        |          |1 = Write: Transfer data from the selected Message Buffer Registers to the Message Object addressed by the Command Request Register.
N * @var CAN_IF_T::MASK1
N * Offset: 0x28, 0x88  IFn Mask 1 Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |Msk[15:0] |Identifier Mask 15-0
N * |        |          |0 = The corresponding bit in the identifier of the message object cannot inhibit the match in the acceptance filtering.
N * |        |          |1 = The corresponding identifier bit is used for acceptance filtering.
N * @var CAN_IF_T::MASK2
N * Offset: 0x2C, 0x8C  IFn Mask 2 Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[12:0]  |Msk[28:16]|Identifier Mask 28-16
N * |        |          |0 = The corresponding bit in the identifier of the message object cannot inhibit the match in the acceptance filtering.
N * |        |          |1 = The corresponding identifier bit is used for acceptance filtering.
N * |[14]    |MDir      |Mask Message Direction
N * |        |          |0 = The message direction bit (Dir (CAN_IFn_ARB2[13])) has no effect on the acceptance filtering.
N * |        |          |1 = The message direction bit (Dir) is used for acceptance filtering.
N * |[15]    |MXtd      |Mask Extended Identifier
N * |        |          |0 = The extended identifier bit (IDE) has no effect on the acceptance filtering.
N * |        |          |1 = The extended identifier bit (IDE) is used for acceptance filtering.
N * |        |          |Note: When 11-bit ("standard") Identifiers are used for a Message Object, the identifiers of received Data Frames are written into bits ID28 to ID18 (CAN_IFn_ARB2[12:2]).
N * |        |          |For acceptance filtering, only these bits together with mask bits Msk28 to Msk18 (CAN_IFn_MASK2[12:2]) are considered.
N * @var CAN_IF_T::ARB1
N * Offset: 0x30, 0x90  IFn Arbitration 1 Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |ID[15:0]  |Message Identifier 15-0
N * |        |          |ID28 - ID0, 29-bit Identifier ("Extended Frame").
N * |        |          |ID28 - ID18, 11-bit Identifier ("Standard Frame")
N * @var CAN_IF_T::ARB2
N * Offset: 0x34, 0x94  IFn Arbitration 2 Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[12:0]  |ID[28:16] |Message Identifier 28-16
N * |        |          |ID28 - ID0, 29-bit Identifier ("Extended Frame").
N * |        |          |ID28 - ID18, 11-bit Identifier ("Standard Frame")
N * |[13]    |Dir       |Message Direction
N * |        |          |0 = Direction is receive.
N * |        |          |On TxRqst, a Remote Frame with the identifier of this Message Object is transmitted.
N * |        |          |On reception of a Data Frame with matching identifier, that message is stored in this Message Object.
N * |        |          |1 = Direction is transmit.
N * |        |          |On TxRqst, the respective Message Object is transmitted as a Data Frame.
N * |        |          |On reception of a Remote Frame with matching identifier, the TxRqst bit (CAN_IFn_CMASK[2]) of this Message Object is set (if RmtEn (CAN_IFn_MCON[9]) = one).
N * |[14]    |Xtd       |Extended Identifier
N * |        |          |0 = The 11-bit ("standard") Identifier will be used for this Message Object.
N * |        |          |1 = The 29-bit ("extended") Identifier will be used for this Message Object.
N * |[15]    |MsgVal    |Message Valid
N * |        |          |0 = The Message Object is ignored by the Message Handler.
N * |        |          |1 = The Message Object is configured and should be considered by the Message Handler.
N * |        |          |Note: The application software must reset the MsgVal bit of all unused Messages Objects during the initialization before it resets bit Init (CAN_CON[0]).
N * |        |          |This bit must also be reset before the identifier Id28-0 (CAN_IFn_ARB1/2), the control bits Xtd (CAN_IFn_ARB2[14]), Dir (CAN_IFn_APB2[13]), or the Data Length Code DLC3-0 (CAN_IFn_MCON[3:0]) are modified, or if the Messages Object is no longer required.
N * @var CAN_IF_T::MCON
N * Offset: 0x38, 0x98  IFn Message Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |DLC       |Data Length Code
N * |        |          |0-8: Data Frame has 0-8 data bytes.
N * |        |          |9-15: Data Frame has 8 data bytes
N * |        |          |Note: The Data Length Code of a Message Object must be defined the same as in all the corresponding objects with the same identifier at other nodes.
N * |        |          |When the Message Handler stores a data frame, it will write the DLC to the value given by the received message.
N * |        |          |Data 0: 1st data byte of a CAN Data Frame
N * |        |          |Data 1: 2nd data byte of a CAN Data Frame
N * |        |          |Data 2: 3rd data byte of a CAN Data Frame
N * |        |          |Data 3: 4th data byte of a CAN Data Frame
N * |        |          |Data 4: 5th data byte of a CAN Data Frame
N * |        |          |Data 5: 6th data byte of a CAN Data Frame
N * |        |          |Data 6: 7th data byte of a CAN Data Frame
N * |        |          |Data 7 : 8th data byte of a CAN Data Frame
N * |        |          |Note: The Data 0 Byte is the first data byte shifted into the shift register of the CAN Core during a reception while the Data 7 byte is the last.
N * |        |          |When the Message Handler stores a Data Frame, it will write all the eight data bytes into a Message Object.
N * |        |          |If the Data Length Code is less than 8, the remaining bytes of the Message Object will be overwritten by unspecified values.
N * |[7]     |EoB       |End Of Buffer
N * |        |          |0 = Message Object belongs to a FIFO Buffer and is not the last Message Object of that FIFO Buffer.
N * |        |          |1 = Single Message Object or last Message Object of a FIFO Buffer.
N * |        |          |Note: This bit is used to concatenate two or more Message Objects (up to 32) to build a FIFO Buffer.
N * |        |          |For single Message Objects (not belonging to a FIFO Buffer), this bit must always be set to one.
N * |[8]     |TxRqst    |Transmit Request
N * |        |          |0 = This Message Object is not waiting for transmission.
N * |        |          |1 = The transmission of this Message Object is requested and is not yet done.
N * |[9]     |RmtEn     |Remote Enable Control
N * |        |          |0 = At the reception of a Remote Frame, TxRqst (CAN_IFn_MCON[8]) is left unchanged.
N * |        |          |1 = At the reception of a Remote Frame, TxRqst is set.
N * |[10]    |RxIE      |Receive Interrupt Enable Control
N * |        |          |0 = IntPnd (CAN_IFn_MCON[13]) will be left unchanged after a successful reception of a frame.
N * |        |          |1 = IntPnd will be set after a successful reception of a frame.
N * |[11]    |TxIE      |Transmit Interrupt Enable Control
N * |        |          |0 = IntPnd (CAN_IFn_MCON[13]) will be left unchanged after the successful transmission of a frame.
N * |        |          |1 = IntPnd will be set after a successful transmission of a frame.
N * |[12]    |UMask     |Use Acceptance Mask
N * |        |          |0 = Mask ignored.
N * |        |          |1 = Use Mask (Msk28-0, MXtd, and MDir) for acceptance filtering.
N * |        |          |Note: If the UMask bit is set to one, the Message Object's mask bits have to be programmed during initialization of the Message Object before MsgVal bit (CAN_IFn_APB2[15]) is set to one.
N * |[13]    |IntPnd    |Interrupt Pending
N * |        |          |0 = This message object is not the source of an interrupt.
N * |        |          |1 = This message object is the source of an interrupt.
N * |        |          |The Interrupt Identifier in the Interrupt Register will point to this message object if there is no other interrupt source with higher priority.
N * |[14]    |MsgLst    |Message Lost (only valid for Message Objects with direction = receive).
N * |        |          |0 = No message lost since last time this bit was reset by the CPU.
N * |        |          |1 = The Message Handler stored a new message into this object when NewDat was still set, the CPU has lost a message.
N * |[15]    |NewDat    |New Data
N * |        |          |0 = No new data has been written into the data portion of this Message Object by the Message Handler since last time this flag was cleared by the application software.
N * |        |          |1 = The Message Handler or the application software has written new data into the data portion of this Message Object.
N * @var CAN_IF_T::DAT_A1
N * Offset: 0x3C, 0x9C  IFn Data A1 Register (Register Map Note 3)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |Data0     |Data Byte 0
N * |        |          |1st data byte of a CAN Data Frame
N * |[15:8]  |Data1     |Data Byte 1
N * |        |          |2nd data byte of a CAN Data Frame
N * @var CAN_IF_T::DAT_A2
N * Offset: 0x40, 0xA0  IFn Data A2 Register (Register Map Note 3)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |Data2     |Data Byte 2
N * |        |          |3rd data byte of CAN Data Frame
N * |[15:8]  |Data3     |Data Byte 3
N * |        |          |4th data byte of CAN Data Frame
N * @var CAN_IF_T::DAT_B1
N * Offset: 0x44, 0xA4  IFn Data B1 Register (Register Map Note 3)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |Data4     |Data Byte 4
N * |        |          |5th data byte of CAN Data Frame
N * |[15:8]  |Data5     |Data Byte 5
N * |        |          |6th data byte of CAN Data Frame
N * @var CAN_IF_T::DAT_B2
N * Offset: 0x48, 0xA8  IFn Data B2 Register (Register Map Note 3)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |Data6     |Data Byte 6
N * |        |          |7th data byte of CAN Data Frame.
N * |[15:8]  |Data7     |Data Byte 7
N * |        |          |8th data byte of CAN Data Frame.
N */
N
N    __IO uint32_t CREQ;          /* Offset: 0x20, 0x80  IFn (Register Map Note 2) Command Request Registers          */
X    volatile uint32_t CREQ;           
N    __IO uint32_t CMASK;         /* Offset: 0x24, 0x84  IFn Command Mask Register                                    */
X    volatile uint32_t CMASK;          
N    __IO uint32_t MASK1;         /* Offset: 0x28, 0x88  IFn Mask 1 Register                                          */
X    volatile uint32_t MASK1;          
N    __IO uint32_t MASK2;         /* Offset: 0x2C, 0x8C  IFn Mask 2 Register                                          */
X    volatile uint32_t MASK2;          
N    __IO uint32_t ARB1;          /* Offset: 0x30, 0x90  IFn Arbitration 1 Register                                   */
X    volatile uint32_t ARB1;           
N    __IO uint32_t ARB2;          /* Offset: 0x34, 0x94  IFn Arbitration 2 Register                                   */
X    volatile uint32_t ARB2;           
N    __IO uint32_t MCON;          /* Offset: 0x38, 0x98  IFn Message Control Register                                 */
X    volatile uint32_t MCON;           
N    __IO uint32_t DAT_A1;        /* Offset: 0x3C, 0x9C  IFn Data A1 Register (Register Map Note 3)                   */
X    volatile uint32_t DAT_A1;         
N    __IO uint32_t DAT_A2;        /* Offset: 0x40, 0xA0  IFn Data A2 Register (Register Map Note 3)                   */
X    volatile uint32_t DAT_A2;         
N    __IO uint32_t DAT_B1;        /* Offset: 0x44, 0xA4  IFn Data B1 Register (Register Map Note 3)                   */
X    volatile uint32_t DAT_B1;         
N    __IO uint32_t DAT_B2;        /* Offset: 0x48, 0xA8  IFn Data B2 Register (Register Map Note 3)                   */
X    volatile uint32_t DAT_B2;         
N    __I  uint32_t RESERVE0[13];
X    volatile const  uint32_t RESERVE0[13];
N
N} CAN_IF_T;
N
N
N
N
Ntypedef struct
N{
N
N
N
N/**
N * @var CAN_T::CON
N * Offset: 0x00  Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |Init      |Init Initialization
N * |        |          |0 = Normal Operation.
N * |        |          |1 = Initialization is started.
N * |[1]     |IE        |Module Interrupt Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[2]     |SIE       |Status Change Interrupt Enable Control
N * |        |          |0 = Disabled - No Status Change Interrupt will be generated.
N * |        |          |1 = Enabled - An interrupt will be generated when a message transfer is successfully completed or a CAN bus error is detected.
N * |[3]     |EIE       |Error Interrupt Enable Control
N * |        |          |0 = Disabled - No Error Status Interrupt will be generated.
N * |        |          |1 = Enabled - A change in the bits BOff (CAN_STATUS[7]) or EWarn (CAN_STATUS[6]) in the Status Register will generate an interrupt.
N * |[5]     |DAR       |Automatic Re-Transmission Disable Control
N * |        |          |0 = Automatic Retransmission of disturbed messages enabled.
N * |        |          |1 = Automatic Retransmission disabled.
N * |[6]     |CCE       |Configuration Change Enable Control
N * |        |          |0 = No write access to the Bit Timing Register.
N * |        |          |1 = Write access to the Bit Timing Register (CAN_BTIME) allowed. (while Init bit (CAN_CON[0]) = 1).
N * |[7]     |Test      |Test Mode Enable Control
N * |        |          |0 = Normal Operation.
N * |        |          |1 = Test Mode.
N * @var CAN_T::STATUS
N * Offset: 0x04  Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2:0]   |LEC       |Last Error Code (Type Of The Last Error To Occur On The CAN Bus)
N * |        |          |The LEC field holds a code, which indicates the type of the last error to occur on the CAN bus.
N * |        |          |This field will be cleared to '0' when a message has been transferred (reception or transmission) without error.
N * |        |          |The unused code '7' may be written by the CPU to check for updates.
N * |        |          |The following table describes the error code.
N * |[3]     |TxOK      |Transmitted A Message Successfully
N * |        |          |0 = Since this bit was reset by the CPU, no message has been successfully transmitted.
N * |        |          |This bit is never reset by the CAN Core.
N * |        |          |1 = Since this bit was last reset by the CPU, a message has been successfully (error free and acknowledged by at least one other node) transmitted.
N * |[4]     |RxOK      |Received A Message Successfully
N * |        |          |0 = No message has been successfully received since this bit was last reset by the CPU.
N * |        |          |This bit is never reset by the CAN Core.
N * |        |          |1 = A message has been successfully received since this bit was last reset by the CPU (independent of the result of acceptance filtering).
N * |[5]     |EPass     |Error Passive (Read Only)
N * |        |          |0 = The CAN Core is error active.
N * |        |          |1 = The CAN Core is in the error passive state as defined in the CAN Specification.
N * |[6]     |EWarn     |Error Warning Status (Read Only)
N * |        |          |0 = Both error counters are below the error warning limit of 96.
N * |        |          |1 = At least one of the error counters in the EML has reached the error warning limit of 96.
N * |[7]     |BOff      |Bus-Off Status (Read Only)
N * |        |          |0 = The CAN module is not in bus-off state.
N * |        |          |1 = The CAN module is in bus-off state.
N * @var CAN_T::ERR
N * Offset: 0x08  Error Counter Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |TEC       |Transmit Error Counter
N * |        |          |Actual state of the Transmit Error Counter. Values between 0 and 255.
N * |[14:8]  |REC       |Receive Error Counter
N * |        |          |Actual state of the Receive Error Counter. Values between 0 and 127.
N * |[15]    |RP        |Receive Error Passive
N * |        |          |0 = The Receive Error Counter is below the error passive level.
N * |        |          |1 = The Receive Error Counter has reached the error passive level as defined in the CAN Specification.
N * @var CAN_T::BTIME
N * Offset: 0x0C  Bit Timing Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |BRP       |Baud Rate Prescaler
N * |        |          |0x01-0x3F: The value by which the oscillator frequency is divided for generating the bit time quanta.
N * |        |          |The bit time is built up from a multiple of this quanta.
N * |        |          |Valid values for the Baud Rate Prescaler are [ 0 ... 63 ].
N * |        |          |The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.
N * |[7:6]   |SJW       |(Re)Synchronization Jump Width
N * |        |          |0x0-0x3: Valid programmed values are [0 ... 3].
N * |        |          |The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.
N * |[11:8]  |TSeg1     |Time Segment Before The Sample Point Minus Sync_Seg
N * |        |          |0x01-0x0F: valid values for TSeg1 are [1 ... 15].
N * |        |          |The actual interpretation by the hardware of this value is such that one more than the value programmed is used.
N * |[14:12] |TSeg2     |Time Segment After Sample Point
N * |        |          |0x0-0x7: Valid values for TSeg2 are [0 ... 7].
N * |        |          |The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.
N * @var CAN_T::IIDR
N * Offset: 0x10  Interrupt Identifier Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |IntId     |Interrupt Identifier (Indicates The Source Of The Interrupt)
N * |        |          |If several interrupts are pending, the CAN Interrupt Register will point to the pending interrupt with the highest priority, disregarding their chronological order.
N * |        |          |An interrupt remains pending until the application software has cleared it.
N * |        |          |If IntId is different from 0x0000 and IE (CAN_IFn_MCON[1]) is set, the IRQ interrupt signal to the EIC is active.
N * |        |          |The interrupt remains active until IntId is back to value 0x0000 (the cause of the interrupt is reset) or until IE is reset.
N * |        |          |The Status Interrupt has the highest priority.
N * |        |          |Among the message interrupts, the Message Object' s interrupt priority decreases with increasing message number.
N * |        |          |A message interrupt is cleared by clearing the Message Object's IntPnd bit (CAN_IFn_MCON[13]).
N * |        |          |The Status Interrupt is cleared by reading the Status Register.
N * @var CAN_T::TEST
N * Offset: 0x14  Test Register (Register Map Note 1)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |Res       |Reserved
N * |        |          |There are reserved bits.
N * |        |          |These bits are always read as '0' and must always be written with '0'.
N * |[2]     |Basic     |Basic Mode
N * |        |          |0 = Basic Mode disabled.
N * |        |          |1= IF1 Registers used as Tx Buffer, IF2 Registers used as Rx Buffer.
N * |[3]     |Silent    |Silent Mode
N * |        |          |0 = Normal operation.
N * |        |          |1 = The module is in Silent Mode.
N * |[4]     |LBack     |Loop Back Mode Enable Control
N * |        |          |0 = Loop Back Mode is disabled.
N * |        |          |1 = Loop Back Mode is enabled.
N * |[6:5]   |Tx10      |Tx[1:0]: Control Of CAN_TX Pin
N * |        |          |00 = Reset value, CAN_TX pin is controlled by the CAN Core.
N * |        |          |01 = Sample Point can be monitored at CAN_TX pin.
N * |        |          |10 = CAN_TX pin drives a dominant ('0') value.
N * |        |          |11 = CAN_TX pin drives a recessive ('1') value.
N * |[7]     |Rx        |Monitors The Actual Value Of CAN_RX Pin (Read Only)
N * |        |          |0 = The CAN bus is dominant (CAN_RX = '0').
N * |        |          |1 = The CAN bus is recessive (CAN_RX = '1').
N * @var CAN_T::BRPE
N * Offset: 0x18  Baud Rate Prescaler Extension Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |BRPE      |BRPE: Baud Rate Prescaler Extension
N * |        |          |0x00-0x0F: By programming BRPE, the Baud Rate Prescaler can be extended to values up to 1023.
N * |        |          |The actual interpretation by the hardware is that one more than the value programmed by BRPE (MSBs) and BTIME (LSBs) is used.
N * @var CAN_T::IF
N * Offset: 0x20~0xFC  CAN Interface Registers
N * ---------------------------------------------------------------------------------------------------
N * CAN interface structure. Refer to \ref CAN_IF_T for detail information.
N     *
N * @var CAN_T::TXREQ1
N * Offset: 0x100  Transmission Request Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |TxRqst[16:1]|Transmission Request Bits 16-1 (Of All Message Objects)
N * |        |          |0 = This Message Object is not waiting for transmission.
N * |        |          |1 = The transmission of this Message Object is requested and is not yet done.
N * |        |          |These bits are read only.
N * @var CAN_T::TXREQ2
N * Offset: 0x104  Transmission Request Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |TxRqst[32:17]|Transmission Request Bits 32-17 (Of All Message Objects)
N * |        |          |0 = This Message Object is not waiting for transmission.
N * |        |          |1 = The transmission of this Message Object is requested and is not yet done.
N * |        |          |These bits are read only.
N * @var CAN_T::NDAT1
N * Offset: 0x120  New Data Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |NewData[16:1]|New Data Bits 16-1 (Of All Message Objects)
N * |        |          |0 = No new data has been written into the data portion of this Message Object by the Message Handler since the last time this flag was cleared by the application software.
N * |        |          |1 = The Message Handler or the application software has written new data into the data portion of this Message Object.
N * @var CAN_T::NDAT2
N * Offset: 0x124  New Data Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |NewData[32:17]|New Data Bits 32-17 (Of All Message Objects)
N * |        |          |0 = No new data has been written into the data portion of this Message Object by the Message Handler since the last time this flag was cleared by the application software.
N * |        |          |1 = The Message Handler or the application software has written new data into the data portion of this Message Object.
N * @var CAN_T::IPND1
N * Offset: 0x140  Interrupt Pending Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |IntPnd[16:1]|Interrupt Pending Bits 16-1 (Of All Message Objects)
N * |        |          |0 = This message object is not the source of an interrupt.
N * |        |          |1 = This message object is the source of an interrupt.
N * @var CAN_T::IPND2
N * Offset: 0x144  Interrupt Pending Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |IntPnd[32:17]|Interrupt Pending Bits 32-17(Of All Message Objects)
N * |        |          |0 = This message object is not the source of an interrupt.
N * |        |          |1 = This message object is the source of an interrupt.
N * @var CAN_T::MVLD1
N * Offset: 0x160  Message Valid Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |MsgVal[16:1]|Message Valid Bits 16-1 (Of All Message Objects) (Read Only)
N * |        |          |0 = This Message Object is ignored by the Message Handler.
N * |        |          |1 = This Message Object is configured and should be considered by the Message Handler.
N * |        |          |Ex.
N * |        |          |CAN_MVLD1[0] means Message object No.1 is valid or not.
N * |        |          |If CAN_MVLD1[0] is set, message object No.1 is configured.
N * @var CAN_T::MVLD2
N * Offset: 0x164  Message Valid Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |MsgVal[32:17]|Message Valid Bits 32-17 (Of All Message Objects) (Read Only)
N * |        |          |0 = This Message Object is ignored by the Message Handler.
N * |        |          |1 = This Message Object is configured and should be considered by the Message Handler.
N * |        |          |Ex.CAN_MVLD2[15] means Message object No.32 is valid or not.
N * |        |          |If CAN_MVLD2[15] is set, message object No.32 is configured.
N * @var CAN_T::WU_EN
N * Offset: 0x168  Wake-up Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WAKUP_EN  |Wake-Up Enable Control
N * |        |          |0 = The wake-up function Disabled.
N * |        |          |1 = The wake-up function Enabled.
N * |        |          |Note: User can wake-up system when there is a falling edge in the CAN_Rx pin.
N * @var CAN_T::WU_STATUS
N * Offset: 0x16C  Wake-up Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WAKUP_STS |Wake-Up Status
N * |        |          |0 = No wake-up event occurred.
N * |        |          |1 = Wake-up event occurred.
N * |        |          |Note: This bit can be cleared by writing '0'.
N */
N
N    __IO uint32_t CON;           /* Offset: 0x00  Control Register                                                   */
X    volatile uint32_t CON;            
N    __IO uint32_t STATUS;        /* Offset: 0x04  Status Register                                                    */
X    volatile uint32_t STATUS;         
N    __I  uint32_t ERR;           /* Offset: 0x08  Error Counter Register                                             */
X    volatile const  uint32_t ERR;            
N    __IO uint32_t BTIME;         /* Offset: 0x0C  Bit Timing Register                                                */
X    volatile uint32_t BTIME;          
N    __I  uint32_t IIDR;          /* Offset: 0x10  Interrupt Identifier Register                                      */
X    volatile const  uint32_t IIDR;           
N    __IO uint32_t TEST;          /* Offset: 0x14  Test Register (Register Map Note 1)                                */
X    volatile uint32_t TEST;           
N    __IO uint32_t BRPE;          /* Offset: 0x18  Baud Rate Prescaler Extension Register                             */
X    volatile uint32_t BRPE;           
N    __I  uint32_t RESERVE0[1];  
X    volatile const  uint32_t RESERVE0[1];  
N    __IO CAN_IF_T IF[2];         /* Offset: 0x20~0xFC  CAN Interface Registers                                       */
X    volatile CAN_IF_T IF[2];          
N    __I  uint32_t RESERVE1[8];  
X    volatile const  uint32_t RESERVE1[8];  
N    __I  uint32_t TXREQ1;        /* Offset: 0x100  Transmission Request Register 1                                   */
X    volatile const  uint32_t TXREQ1;         
N    __I  uint32_t TXREQ2;        /* Offset: 0x104  Transmission Request Register 2                                   */
X    volatile const  uint32_t TXREQ2;         
N    __I  uint32_t RESERVE3[6];  
X    volatile const  uint32_t RESERVE3[6];  
N    __I  uint32_t NDAT1;         /* Offset: 0x120  New Data Register 1                                               */
X    volatile const  uint32_t NDAT1;          
N    __I  uint32_t NDAT2;         /* Offset: 0x124  New Data Register 2                                               */
X    volatile const  uint32_t NDAT2;          
N    __I  uint32_t RESERVE4[6];  
X    volatile const  uint32_t RESERVE4[6];  
N    __I  uint32_t IPND1;         /* Offset: 0x140  Interrupt Pending Register 1                                      */
X    volatile const  uint32_t IPND1;          
N    __I  uint32_t IPND2;         /* Offset: 0x144  Interrupt Pending Register 2                                      */
X    volatile const  uint32_t IPND2;          
N    __I  uint32_t RESERVE5[6];  
X    volatile const  uint32_t RESERVE5[6];  
N    __I  uint32_t MVLD1;         /* Offset: 0x160  Message Valid Register 1                                          */
X    volatile const  uint32_t MVLD1;          
N    __I  uint32_t MVLD2;         /* Offset: 0x164  Message Valid Register 2                                          */
X    volatile const  uint32_t MVLD2;          
N    __IO uint32_t WU_EN;         /* Offset: 0x168  Wake-up Enable Register                                           */
X    volatile uint32_t WU_EN;          
N    __IO uint32_t WU_STATUS;     /* Offset: 0x16C  Wake-up Status Register                                           */
X    volatile uint32_t WU_STATUS;      
N
N} CAN_T;
N
N
N
N/**
N    @addtogroup CAN_CONST CAN Bit Field Definition
N    Constant Definitions for CAN Controller
N@{ */
N/* CAN CON Bit Field Definitions */
N#define CAN_CON_TEST_Pos           7                                    /*!< CAN_T::CON: TEST Position */
N#define CAN_CON_TEST_Msk           (0x1ul << CAN_CON_TEST_Pos)          /*!< CAN_T::CON: TEST Mask     */
N                                                                                
N#define CAN_CON_CCE_Pos            6                                    /*!< CAN_T::CON: CCE Position  */
N#define CAN_CON_CCE_Msk            (0x1ul << CAN_CON_CCE_Pos)           /*!< CAN_T::CON: CCE Mask      */
N                                                             
N#define CAN_CON_DAR_Pos            5                                    /*!< CAN_T::CON: DAR Position  */
N#define CAN_CON_DAR_Msk            (0x1ul << CAN_CON_DAR_Pos)           /*!< CAN_T::CON: DAR Mask      */
N                                                             
N#define CAN_CON_EIE_Pos            3                                    /*!< CAN_T::CON: EIE Position  */
N#define CAN_CON_EIE_Msk            (0x1ul << CAN_CON_EIE_Pos)           /*!< CAN_T::CON: EIE Mask      */
N                                                             
N#define CAN_CON_SIE_Pos            2                                    /*!< CAN_T::CON: SIE Position  */
N#define CAN_CON_SIE_Msk            (0x1ul << CAN_CON_SIE_Pos)           /*!< CAN_T::CON: SIE Mask      */
N                                                             
N#define CAN_CON_IE_Pos             1                                    /*!< CAN_T::CON: IE Position   */
N#define CAN_CON_IE_Msk             (0x1ul << CAN_CON_IE_Pos)            /*!< CAN_T::CON: IE Mask       */
N                                                             
N#define CAN_CON_INIT_Pos           0                                    /*!< CAN_T::CON: INIT Position */
N#define CAN_CON_INIT_Msk           (0x1ul << CAN_CON_INIT_Pos)          /*!< CAN_T::CON: INIT Mask     */
N
N/* CAN STATUS Bit Field Definitions */
N#define CAN_STATUS_BOFF_Pos        7                                    /*!< CAN_T::STATUS: BOFF Position  */
N#define CAN_STATUS_BOFF_Msk        (0x1ul << CAN_STATUS_BOFF_Pos)       /*!< CAN_T::STATUS: BOFF Mask      */
N
N#define CAN_STATUS_EWARN_Pos       6                                    /*!< CAN_T::STATUS: EWARN Position */
N#define CAN_STATUS_EWARN_Msk       (0x1ul << CAN_STATUS_EWARN_Pos)      /*!< CAN_T::STATUS: EWARN Mask     */
N
N#define CAN_STATUS_EPASS_Pos       5                                    /*!< CAN_T::STATUS: EPASS Position */
N#define CAN_STATUS_EPASS_Msk       (0x1ul << CAN_STATUS_EPASS_Pos)      /*!< CAN_T::STATUS: EPASS Mask     */
N
N#define CAN_STATUS_RXOK_Pos        4                                    /*!< CAN_T::STATUS: RXOK Position  */
N#define CAN_STATUS_RXOK_Msk        (0x1ul << CAN_STATUS_RXOK_Pos)       /*!< CAN_T::STATUS: RXOK Mask      */
N
N#define CAN_STATUS_TXOK_Pos        3                                    /*!< CAN_T::STATUS: TXOK Position  */
N#define CAN_STATUS_TXOK_Msk        (0x1ul << CAN_STATUS_TXOK_Pos)       /*!< CAN_T::STATUS: TXOK Mask      */
N
N#define CAN_STATUS_LEC_Pos         0                                    /*!< CAN_T::STATUS: LEC Position   */
N#define CAN_STATUS_LEC_Msk         (0x7ul << CAN_STATUS_LEC_Pos)        /*!< CAN_T::STATUS: LEC Mask       */
N
N/* CAN ERR Bit Field Definitions */                                             
N#define CAN_ERR_RP_Pos             15                                   /*!< CAN_T::ERR: RP Position       */
N#define CAN_ERR_RP_Msk             (0x1ul << CAN_ERR_RP_Pos)            /*!< CAN_T::ERR: RP Mask           */
N
N#define CAN_ERR_REC_Pos            8                                    /*!< CAN_T::ERR: REC Position      */
N#define CAN_ERR_REC_Msk            (0x7Ful << CAN_ERR_REC_Pos)          /*!< CAN_T::ERR: REC Mask          */
N
N#define CAN_ERR_TEC_Pos            0                                    /*!< CAN_T::ERR: TEC Position      */
N#define CAN_ERR_TEC_Msk            (0xFFul << CAN_ERR_TEC_Pos)          /*!< CAN_T::ERR: TEC Mask          */
N
N/* CAN BTIME Bit Field Definitions */                                           
N#define CAN_BTIME_TSEG2_Pos        12                                   /*!< CAN_T::BTIME: TSEG2 Position  */
N#define CAN_BTIME_TSEG2_Msk        (0x7ul << CAN_BTIME_TSEG2_Pos)       /*!< CAN_T::BTIME: TSEG2 Mask      */
N
N#define CAN_BTIME_TSEG1_Pos        8                                    /*!< CAN_T::BTIME: TSEG1 Position  */
N#define CAN_BTIME_TSEG1_Msk        (0xFul << CAN_BTIME_TSEG1_Pos)       /*!< CAN_T::BTIME: TSEG1 Mask      */
N
N#define CAN_BTIME_SJW_Pos          6                                    /*!< CAN_T::BTIME: SJW Position    */
N#define CAN_BTIME_SJW_Msk          (0x3ul << CAN_BTIME_SJW_Pos)         /*!< CAN_T::BTIME: SJW Mask        */
N
N#define CAN_BTIME_BRP_Pos          0                                    /*!< CAN_T::BTIME: BRP Position    */
N#define CAN_BTIME_BRP_Msk          (0x3Ful << CAN_BTIME_BRP_Pos)        /*!< CAN_T::BTIME: BRP Mask        */
N
N/* CAN IIDR Bit Field Definitions */                                            
N#define CAN_IIDR_INTID_Pos         0                                    /*!< CAN_T::IIDR: INTID Position   */
N#define CAN_IIDR_INTID_Msk         (0xFFFFul << CAN_IIDR_INTID_Pos)     /*!< CAN_T::IIDR: INTID Mask       */
N
N/* CAN TEST Bit Field Definitions */                                            
N#define CAN_TEST_RX_Pos            7                                    /*!< CAN_T::TEST: RX Position      */
N#define CAN_TEST_RX_Msk            (0x1ul << CAN_TEST_RX_Pos)           /*!< CAN_T::TEST: RX Mask          */
N
N#define CAN_TEST_TX_Pos            5                                    /*!< CAN_T::TEST: TX Position      */
N#define CAN_TEST_TX_Msk            (0x3ul << CAN_TEST_TX_Pos)           /*!< CAN_T::TEST: TX Mask          */
N
N#define CAN_TEST_LBACK_Pos         4                                    /*!< CAN_T::TEST: LBACK Position   */
N#define CAN_TEST_LBACK_Msk         (0x1ul << CAN_TEST_LBACK_Pos)        /*!< CAN_T::TEST: LBACK Mask       */
N
N#define CAN_TEST_SILENT_Pos        3                                    /*!< CAN_T::TEST: Silent Position  */
N#define CAN_TEST_SILENT_Msk        (0x1ul << CAN_TEST_SILENT_Pos)       /*!< CAN_T::TEST: Silent Mask      */
N
N#define CAN_TEST_BASIC_Pos         2                                    /*!< CAN_T::TEST: Basic Position   */
N#define CAN_TEST_BASIC_Msk         (0x1ul << CAN_TEST_BASIC_Pos)        /*!< CAN_T::TEST: Basic Mask       */
N
N/* CAN BPRE Bit Field Definitions */                                           
N#define CAN_BRPE_BRPE_Pos          0                                    /*!< CAN_T::BRPE: BRPE Position    */
N#define CAN_BRPE_BRPE_Msk          (0xFul << CAN_BRPE_BRPE_Pos)         /*!< CAN_T::BRPE: BRPE Mask        */
N
N/* CAN IFn_CREQ Bit Field Definitions */
N#define CAN_IF_CREQ_BUSY_Pos       15                                     /*!< CAN_IF_T::CREQ: BUSY Position */
N#define CAN_IF_CREQ_BUSY_Msk       (0x1ul << CAN_IF_CREQ_BUSY_Pos)        /*!< CAN_IF_T::CREQ: BUSY Mask     */
N                                                                                  
N#define CAN_IF_CREQ_MSGNUM_Pos     0                                      /*!< CAN_IF_T::CREQ: MSGNUM Position */
N#define CAN_IF_CREQ_MSGNUM_Msk     (0x3Ful << CAN_IF_CREQ_MSGNUM_Pos)     /*!< CAN_IF_T::CREQ: MSGNUM Mask     */
N                                                                                  
N/* CAN IFn_CMASK Bit Field Definitions */                                         
N#define CAN_IF_CMASK_WRRD_Pos      7                                      /*!< CAN_IF_T::CMASK: WRRD Position */
N#define CAN_IF_CMASK_WRRD_Msk      (0x1ul << CAN_IF_CMASK_WRRD_Pos)       /*!< CAN_IF_T::CMASK: WRRD Mask     */
N                                                                                  
N#define CAN_IF_CMASK_MASK_Pos      6                                      /*!< CAN_IF_T::CMASK: MASK Position */
N#define CAN_IF_CMASK_MASK_Msk      (0x1ul << CAN_IF_CMASK_MASK_Pos)       /*!< CAN_IF_T::CMASK: MASK Mask     */
N                                                                                  
N#define CAN_IF_CMASK_ARB_Pos       5                                      /*!< CAN_IF_T::CMASK: ARB Position  */
N#define CAN_IF_CMASK_ARB_Msk       (0x1ul << CAN_IF_CMASK_ARB_Pos)        /*!< CAN_IF_T::CMASK: ARB Mask      */
N
N#define CAN_IF_CMASK_CONTROL_Pos   4                                     /*!< CAN_IF_T::CMASK: CONTROL Position */
N#define CAN_IF_CMASK_CONTROL_Msk   (0x1ul << CAN_IF_CMASK_CONTROL_Pos)   /*!< CAN_IF_T::CMASK: CONTROL Mask */
N
N#define CAN_IF_CMASK_CLRINTPND_Pos 3                                       /*!< CAN_IF_T::CMASK: CLRINTPND Position */
N#define CAN_IF_CMASK_CLRINTPND_Msk (0x1ul << CAN_IF_CMASK_CLRINTPND_Pos)   /*!< CAN_IF_T::CMASK: CLRINTPND Mask */
N
N#define CAN_IF_CMASK_TXRQSTNEWDAT_Pos 2                                         /*!< CAN_IF_T::CMASK: TXRQSTNEWDAT Position */
N#define CAN_IF_CMASK_TXRQSTNEWDAT_Msk (0x1ul << CAN_IF_CMASK_TXRQSTNEWDAT_Pos)  /*!< CAN_IF_T::CMASK: TXRQSTNEWDAT Mask     */
N
N#define CAN_IF_CMASK_DATAA_Pos     1                                    /*!< CAN_IF_T::CMASK: DATAA Position */
N#define CAN_IF_CMASK_DATAA_Msk     (0x1ul << CAN_IF_CMASK_DATAA_Pos)    /*!< CAN_IF_T::CMASK: DATAA Mask     */
N
N#define CAN_IF_CMASK_DATAB_Pos     0                                    /*!< CAN_IF_T::CMASK: DATAB Position */
N#define CAN_IF_CMASK_DATAB_Msk     (0x1ul << CAN_IF_CMASK_DATAB_Pos)    /*!< CAN_IF_T::CMASK: DATAB Mask     */
N
N/* CAN IFn_MASK1 Bit Field Definitions */
N#define CAN_IF_MASK1_MSK_Pos       0                                    /*!< CAN_IF_T::MASK1: MSK Position   */
N#define CAN_IF_MASK1_MSK_Msk       (0xFFul << CAN_IF_MASK1_MSK_Pos)     /*!< CAN_IF_T::MASK1: MSK Mask       */
N
N/* CAN IFn_MASK2 Bit Field Definitions */                                       
N#define CAN_IF_MASK2_MXTD_Pos      15                                   /*!< CAN_IF_T::MASK2: MXTD Position */
N#define CAN_IF_MASK2_MXTD_Msk      (0x1ul << CAN_IF_MASK2_MXTD_Pos)     /*!< CAN_IF_T::MASK2: MXTD Mask     */
N
N#define CAN_IF_MASK2_MDIR_Pos      14                                   /*!< CAN_IF_T::MASK2: MDIR Position */
N#define CAN_IF_MASK2_MDIR_Msk      (0x1ul << CAN_IF_MASK2_MDIR_Pos)     /*!< CAN_IF_T::MASK2: MDIR Mask     */
N
N#define CAN_IF_MASK2_MSK_Pos       0                                    /*!< CAN_IF_T::MASK2: MSK Position */
N#define CAN_IF_MASK2_MSK_Msk       (0x1FFul << CAN_IF_MASK2_MSK_Pos)    /*!< CAN_IF_T::MASK2: MSK Mask     */
N
N/* CAN IFn_ARB1 Bit Field Definitions */                                        
N#define CAN_IF_ARB1_ID_Pos         0                                    /*!< CAN_IF_T::ARB1: ID Position   */
N#define CAN_IF_ARB1_ID_Msk         (0xFFFFul << CAN_IF_ARB1_ID_Pos)     /*!< CAN_IF_T::ARB1: ID Mask       */
N
N/* CAN IFn_ARB2 Bit Field Definitions */                                        
N#define CAN_IF_ARB2_MSGVAL_Pos     15                                   /*!< CAN_IF_T::ARB2: MSGVAL Position */
N#define CAN_IF_ARB2_MSGVAL_Msk     (0x1ul << CAN_IF_ARB2_MSGVAL_Pos)    /*!< CAN_IF_T::ARB2: MSGVAL Mask     */
N
N#define CAN_IF_ARB2_XTD_Pos        14                                   /*!< CAN_IF_T::ARB2: XTD Position    */
N#define CAN_IF_ARB2_XTD_Msk        (0x1ul << CAN_IF_ARB2_XTD_Pos)       /*!< CAN_IF_T::ARB2: XTD Mask        */
N
N#define CAN_IF_ARB2_DIR_Pos        13                                   /*!< CAN_IF_T::ARB2: DIR Position    */
N#define CAN_IF_ARB2_DIR_Msk        (0x1ul << CAN_IF_ARB2_DIR_Pos)       /*!< CAN_IF_T::ARB2: DIR Mask        */
N
N#define CAN_IF_ARB2_ID_Pos         0                                    /*!< CAN_IF_T::ARB2: ID Position     */
N#define CAN_IF_ARB2_ID_Msk         (0x1FFFul << CAN_IF_ARB2_ID_Pos)     /*!< CAN_IF_T::ARB2: ID Mask         */
N
N/* CAN IFn_MCON Bit Field Definitions */                                        
N#define CAN_IF_MCON_NEWDAT_Pos     15                                   /*!< CAN_IF_T::MCON: NEWDAT Position */
N#define CAN_IF_MCON_NEWDAT_Msk     (0x1ul << CAN_IF_MCON_NEWDAT_Pos)    /*!< CAN_IF_T::MCON: NEWDAT Mask     */
N
N#define CAN_IF_MCON_MSGLST_Pos     14                                   /*!< CAN_IF_T::MCON: MSGLST Position */
N#define CAN_IF_MCON_MSGLST_Msk     (0x1ul << CAN_IF_MCON_MSGLST_Pos)    /*!< CAN_IF_T::MCON: MSGLST Mask     */
N
N#define CAN_IF_MCON_INTPND_Pos     13                                   /*!< CAN_IF_T::MCON: INTPND Position */
N#define CAN_IF_MCON_INTPND_Msk     (0x1ul << CAN_IF_MCON_INTPND_Pos)    /*!< CAN_IF_T::MCON: INTPND Mask     */
N
N#define CAN_IF_MCON_UMASK_Pos      12                                   /*!< CAN_IF_T::MCON: UMASK Position  */
N#define CAN_IF_MCON_UMASK_Msk      (0x1ul << CAN_IF_MCON_UMASK_Pos)     /*!< CAN_IF_T::MCON: UMASK Mask      */
N
N#define CAN_IF_MCON_TXIE_Pos       11                                   /*!< CAN_IF_T::MCON: TXIE Position   */
N#define CAN_IF_MCON_TXIE_Msk       (0x1ul << CAN_IF_MCON_TXIE_Pos)      /*!< CAN_IF_T::MCON: TXIE Mask       */
N
N#define CAN_IF_MCON_RXIE_Pos       10                                   /*!< CAN_IF_T::MCON: RXIE Position   */
N#define CAN_IF_MCON_RXIE_Msk       (0x1ul << CAN_IF_MCON_RXIE_Pos)      /*!< CAN_IF_T::MCON: RXIE Mask       */
N
N#define CAN_IF_MCON_RMTEN_Pos      9                                    /*!< CAN_IF_T::MCON: RMTEN Position  */
N#define CAN_IF_MCON_RMTEN_Msk      (0x1ul << CAN_IF_MCON_RMTEN_Pos)     /*!< CAN_IF_T::MCON: RMTEN Mask      */
N
N#define CAN_IF_MCON_TXRQST_Pos     8                                    /*!< CAN_IF_T::MCON: TXRQST Position */
N#define CAN_IF_MCON_TXRQST_Msk     (0x1ul << CAN_IF_MCON_TXRQST_Pos)    /*!< CAN_IF_T::MCON: TXRQST Mask     */
N
N#define CAN_IF_MCON_EOB_Pos        7                                    /*!< CAN_IF_T::MCON: EOB Position    */
N#define CAN_IF_MCON_EOB_Msk        (0x1ul << CAN_IF_MCON_EOB_Pos)       /*!< CAN_IF_T::MCON: EOB Mask        */
N
N#define CAN_IF_MCON_DLC_Pos        0                                    /*!< CAN_IF_T::MCON: DLC Position    */
N#define CAN_IF_MCON_DLC_Msk        (0xFul << CAN_IF_MCON_DLC_Pos)       /*!< CAN_IF_T::MCON: DLC Mask        */
N
N/* CAN IFn_DATA_A1 Bit Field Definitions */                                     
N#define CAN_IF_DAT_A1_DATA1_Pos    8                                    /*!< CAN_IF_T::DATAA1: DATA1 Position */
N#define CAN_IF_DAT_A1_DATA1_Msk    (0xFFul << CAN_IF_DAT_A1_DATA1_Pos)  /*!< CAN_IF_T::DATAA1: DATA1 Mask     */
N
N#define CAN_IF_DAT_A1_DATA0_Pos    0                                    /*!< CAN_IF_T::DATAA1: DATA0 Position */
N#define CAN_IF_DAT_A1_DATA0_Msk    (0xFFul << CAN_IF_DAT_A1_DATA0_Pos)  /*!< CAN_IF_T::DATAA1: DATA0 Mask     */
N
N/* CAN IFn_DATA_A2 Bit Field Definitions */                                     
N#define CAN_IF_DAT_A2_DATA3_Pos    8                                    /*!< CAN_IF_T::DATAA1: DATA3 Position */
N#define CAN_IF_DAT_A2_DATA3_Msk    (0xFFul << CAN_IF_DAT_A2_DATA3_Pos)  /*!< CAN_IF_T::DATAA1: DATA3 Mask     */
N
N#define CAN_IF_DAT_A2_DATA2_Pos    0                                    /*!< CAN_IF_T::DATAA1: DATA2 Position */
N#define CAN_IF_DAT_A2_DATA2_Msk    (0xFFul << CAN_IF_DAT_A2_DATA2_Pos)  /*!< CAN_IF_T::DATAA1: DATA2 Mask     */
N
N/* CAN IFn_DATA_B1 Bit Field Definitions */                                     
N#define CAN_IF_DAT_B1_DATA5_Pos    8                                    /*!< CAN_IF_T::DATAB1: DATA5 Position */
N#define CAN_IF_DAT_B1_DATA5_Msk    (0xFFul << CAN_IF_DAT_B1_DATA5_Pos)  /*!< CAN_IF_T::DATAB1: DATA5 Mask */
N
N#define CAN_IF_DAT_B1_DATA4_Pos    0                                    /*!< CAN_IF_T::DATAB1: DATA4 Position */
N#define CAN_IF_DAT_B1_DATA4_Msk    (0xFFul << CAN_IF_DAT_B1_DATA4_Pos)  /*!< CAN_IF_T::DATAB1: DATA4 Mask */
N
N/* CAN IFn_DATA_B2 Bit Field Definitions */                                     
N#define CAN_IF_DAT_B2_DATA7_Pos    8                                    /*!< CAN_IF_T::DATAB2: DATA7 Position */
N#define CAN_IF_DAT_B2_DATA7_Msk    (0xFFul << CAN_IF_DAT_B2_DATA7_Pos)  /*!< CAN_IF_T::DATAB2: DATA7 Mask     */
N
N#define CAN_IF_DAT_B2_DATA6_Pos    0                                    /*!< CAN_IF_T::DATAB2: DATA6 Position */
N#define CAN_IF_DAT_B2_DATA6_Msk    (0xFFul << CAN_IF_DAT_B2_DATA6_Pos)  /*!< CAN_IF_T::DATAB2: DATA6 Mask     */
N
N/* CAN IFn_TXRQST1 Bit Field Definitions */
N#define CAN_TXRQST1_TXRQST_Pos  0                                        /*!< CAN_T::TXRQST1: TXRQST Position */
N#define CAN_TXRQST1_TXRQST_Msk  (0xFFFFul << CAN_TXRQST1_TXRQST_Pos)  /*!< CAN_T::TXRQST1: TXRQST Mask     */
N
N/* CAN IFn_TXRQST2 Bit Field Definitions */                                         
N#define CAN_TXRQST2_TXRQST_Pos  0                                        /*!< CAN_T::TXRQST2: TXRQST Position  */
N#define CAN_TXRQST2_TXRQST_Msk  (0xFFFFul << CAN_TXRQST2_TXRQST_Pos)  /*!< CAN_T::TXRQST2: TXRQST Mask      */
N
N/* CAN IFn_NDAT1 Bit Field Definitions */                                           
N#define CAN_NDAT1_NEWDATA_Pos   0                                        /*!< CAN_T::NDAT1: NEWDATA Position */
N#define CAN_NDAT1_NEWDATA_Msk   (0xFFFFul << CAN_NDAT1_NEWDATA_Pos)   /*!< CAN_T::NDAT1: NEWDATA Mask     */
N
N/* CAN IFn_NDAT2 Bit Field Definitions */                                          
N#define CAN_NDAT2_NEWDATA_Pos   0                                        /*!< CAN_T::NDAT2: NEWDATA Position */
N#define CAN_NDAT2_NEWDATA_Msk   (0xFFFFul << CAN_NDAT2_NEWDATA_Pos)   /*!< CAN_T::NDAT2: NEWDATA Mask     */
N
N/* CAN IFn_IPND1 Bit Field Definitions */                                          
N#define CAN_IPND1_INTPND_Pos   0                                         /*!< CAN_T::IPND1: INTPND Position */
N#define CAN_IPND1_INTPND_Msk   (0xFFFFul << CAN_IPND1_INTPND_Pos)     /*!< CAN_T::IPND1: INTPND Mask     */
N
N/* CAN IFn_IPND2 Bit Field Definitions */                                          
N#define CAN_IPND2_INTPND_Pos   0                                         /*!< CAN_T::IPND2: INTPND Position */
N#define CAN_IPND2_INTPND_Msk   (0xFFFFul << CAN_IPND2_INTPND_Pos)     /*!< CAN_T::IPND2: INTPND Mask     */
N
N/* CAN IFn_MVLD1 Bit Field Definitions */                                          
N#define CAN_MVLD1_MSGVAL_Pos   0                                         /*!< CAN_T::MVLD1: MSGVAL Position */
N#define CAN_MVLD1_MSGVAL_Msk   (0xFFFFul << CAN_MVLD1_MSGVAL_Pos)     /*!< CAN_T::MVLD1: MSGVAL Mask     */
N
N/* CAN IFn_MVLD2 Bit Field Definitions */                                           
N#define CAN_MVLD2_MSGVAL_Pos   0                                         /*!< CAN_T::MVLD2: MSGVAL Position */
N#define CAN_MVLD2_MSGVAL_Msk   (0xFFFFul << CAN_MVLD2_MSGVAL_Pos)     /*!< CAN_T::MVLD2: MSGVAL Mask     */
N
N/* CAN WUEN Bit Field Definitions */                                                
N#define CAN_WUEN_WAKUP_EN_Pos     0                                         /*!< CAN_T::WU_EN: WAKUP_EN Position */
N#define CAN_WUEN_WAKUP_EN_Msk    (0x1ul << CAN_WUEN_WAKUP_EN_Pos)           /*!< CAN_T::WU_EN: WAKUP_EN Mask     */
N
N/* CAN WUSTATUS Bit Field Definitions */
N#define CAN_WUSTATUS_WAKUP_STS_Pos     0                                      /*!< CAN_T::WU_STATUS: WAKUP_STS Position */
N#define CAN_WUSTATUS_WAKUP_STS_Msk    (0x1ul << CAN_WUSTATUS_WAKUP_STS_Pos)   /*!< CAN_T::WU_STATUS: WAKUP_STS Mask     */
N
N
N/**@}*/ /* CAN_CONST */
N/**@}*/ /* end of CAN register group */
N
N
N/*---------------------- System Clock Controller -------------------------*/
N/**
N    @addtogroup CLK System Clock Controller(CLK)
N    Memory Mapped Structure for CLK Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N
N
N/**
N * @var CLK_T::PWRCTL
N * Offset: 0x00  System Power-down Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |HXTEN     |External 4~24 MHz High-Speed Crystal Enable Bit (Write Protect)
N * |        |          |The bit default value is set by flash controller user configuration register CONFIG0 [26:24].
N * |        |          |When the default clock source is from external 4~24 MHz high-speed crystal, this bit is set to 1 automatically.
N * |        |          |0 = External 4 ~ 24 MHz high speed crystal oscillator (HXT) Disabled.
N * |        |          |1 = External 4 MH~ 24 z high speed crystal oscillator (HXT) Enabled.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[1]     |LXTEN     |External 32.768 KHz Low-Speed Crystal Enable Bit (Write Protect)
N * |        |          |0 = External 32.768 kHz low-speed crystal oscillator (LXT) Disabled.
N * |        |          |1 = External 32.768 kHz low-speed crystal oscillator (LXT) Enabled.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[2]     |HIRCEN    |Internal 22.1184 MHz High-Speed Oscillator Enable Bit (Write Protect)
N * |        |          |0 = Internal 22.1184 MHz high-speed RC oscillator (HIRC) Disabled.
N * |        |          |1 = Internal 22.1184 MHz high-speed RC oscillator (HIRC) Enabled.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[3]     |LIRCEN    |Internal 10 KHz Low-Speed Oscillator Enable Bit (Write Protect)
N * |        |          |0 = Internal 10 kHz low speed RC oscillator (LIRC) Disabled.
N * |        |          |1 = Internal 10 kHz low speed RC oscillator (LIRC) Enabled.
N * |[4]     |PDWKDLY   |Enable The Wake-Up Delay Counter (Write Protect)
N * |        |          |When the chip wakes up from Power-down mode, the clock control will delay certain clock cycles to wait system clock stable.
N * |        |          |The delayed clock cycle is 4096 clock cycles when chip work at external 4~24 MHz high-speed crystal, and 256 clock cycles when chip work at internal 22.1184 MHz high-speed oscillator.
N * |        |          |0 = Clock cycles delay Disabled.
N * |        |          |1 = Clock cycles delay Enabled.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[5]     |PDWKIEN   |Power-Down Mode Wake-Up Interrupt Enable Bit (Write Protect)
N * |        |          |0 = Power-down Mode Wake-up Interrupt Disabled.
N * |        |          |1 = Power-down Mode Wake-up Interrupt Enabled.
N * |        |          |Note1: The interrupt will occur when both PDWKIF and PDWKIEN are high.
N * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[6]     |PDWKIF    |Power-Down Mode Wake-Up Interrupt Status
N * |        |          |Set by "Power-down wake-up event", it indicates that resume from Power-down mode
N * |        |          |The flag is set if the EINT0~5, GPIO, USBH, USBD, OTG, UART0~3, WDT, CAN0, ACMP01, BOD, RTC, TMR0~3, I2C0~1 or TK wake-up occurred.
N * |        |          |Note1: Write 1 to clear the bit to 0.
N * |        |          |Note2: This bit works only if PDWKIEN (CLK_PWRCTL[5]) set to 1.
N * |[7]     |PDEN      |System Power-Down Enable (Write Protect)
N * |        |          |When this bit is set to 1, Power-down mode is enabled and chip Power-down behavior will depend on the PDWTCPU bit.
N * |        |          |(a) If the PDWTCPU is 0, then the chip enters Power-down mode immediately after the PDEN bit set.(default)
N * |        |          |(b) if the PDWTCPU is 1, then the chip keeps active till the CPU sleep mode is also active and then the chip enters Power-down mode.
N * |        |          |When chip wakes up from Power-down mode, this bit is auto cleared.
N * |        |          |Users need to set this bit again for next Power-down.
N * |        |          |In Power-down mode, external 4~24 MHz high-speed crystal and the internal 22.1184 MHz high-speed oscillator will be disabled in this mode, but the external 32.768 kHz low-speed crystal and internal 10 kHz low-speed oscillator are not controlled by Power-down mode.
N * |        |          |In Power-down mode, the PLL and system clock are disabled, and ignored the clock source selection.
N * |        |          |The clocks of peripheral are not controlled by Power-down mode, if the peripheral clock source is from external 32.768 kHz low-speed crystal or the internal 10 kHz low-speed oscillator.
N * |        |          |0 = Chip operating normally or chip in idle mode because of WFI command.
N * |        |          |1 = Chip enters Power-down mode instant or wait CPU sleep command WFI.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[8]     |PDWTCPU   |This Bit Control The Power-Down Entry Condition (Write Protect)
N * |        |          |0 = Chip enters Power-down mode when the PDEN bit is set to 1.
N * |        |          |1 = Chip enters Power-down mode when the both PDWTCPU and PDEN bits are set to 1 and CPU run WFI instruction.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[11:10] |HXTGAIN   |4~24 MHz High-Speed Crystal Gain Control Bit
N * |        |          |(Write Protect)
N * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N * |        |          |Gain control is used to enlarge the gain of crystal to make sure crystal work normally.
N * |        |          |If gain control is enabled, crystal will consume more power than gain control off.
N * |        |          |00 = HXT frequency is lower than from 8 MHz.
N * |        |          |01 = HXT frequency is from 8 MHz to 12 MHz.
N * |        |          |10 = HXT frequency is from 12 MHz to 16 MHz.
N * |        |          |11 = HXT frequency is higher than 16 MHz.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[12]    |HXTSELTYP |4~24 MHz High-Speed Crystal Type Select Bit (Write Protect)
N * |        |          |This is a protected register. Please refer to open lock sequence to program it.
N * |        |          |0 = Select INV type.
N * |        |          |1 = Select GM type.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * @var CLK_T::AHBCLK
N * Offset: 0x04  AHB Devices Clock Enable Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1]     |PDMACKEN  |PDMA Controller Clock Enable Bit
N * |        |          |0 = PDMA peripheral clock Disabled.
N * |        |          |1 = PDMA peripheral clock Enabled.
N * |[2]     |ISPCKEN   |Flash ISP Controller Clock Enable Bit
N * |        |          |0 = Flash ISP peripheral clock Disabled.
N * |        |          |1 = Flash ISP peripheral clock Enabled.
N * |[3]     |EBICKEN   |EBI Controller Clock Enable Bit
N * |        |          |0 = EBI peripheral clock Disabled.
N * |        |          |1 = EBI peripheral clock Enabled.
N * |[4]     |USBHCKEN  |USB HOST Controller Clock Enable Bit
N * |        |          |0 = USB HOST peripheral clock Disabled.
N * |        |          |1 = USB HOST peripheral clock Enabled.
N * |[7]     |CRCCKEN   |CRC Generator Controller Clock Enable Bit
N * |        |          |0 = CRC peripheral clock Disabled.
N * |        |          |1 = CRC peripheral clock Enabled.
N * |[15]    |FMCIDLE   |Flash Memory Controller Clock Enable Bit In IDLE Mode
N * |        |          |0 = FMC peripheral clock Disabled when chip operating at IDLE mode.
N * |        |          |1 = FMC peripheral clock Enabled when chip operating at IDLE mode.
N * @var CLK_T::APBCLK0
N * Offset: 0x08  APB Devices Clock Enable Control Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WDTCKEN   |Watchdog Timer Clock Enable Bit (Write Protect)
N * |        |          |0 = Watchdog Timer Clock Disabled.
N * |        |          |1 = Watchdog Timer Clock Enabled.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[1]     |RTCCKEN   |Real-Time-Clock APB Interface Clock Enable Bit
N * |        |          |This bit is used to control the RTC APB clock only.
N * |        |          |The RTC peripheral clock source is selected from RTCSEL(CLK_CLKSEL3[8]).
N * |        |          |It can be selected to external 32.768 kHz low speed crystal or internal 10 kHz low speed oscillator.
N * |        |          |0 = RTC Clock Disabled.
N * |        |          |1 = RTC Clock Enabled.
N * |[2]     |TMR0CKEN  |Timer0 Clock Enable Bit
N * |        |          |0 = Timer0 Clock Disabled.
N * |        |          |1 = Timer0 Clock Enabled.
N * |[3]     |TMR1CKEN  |Timer1 Clock Enable Bit
N * |        |          |0 = Timer1 Clock Disabled.
N * |        |          |1 = Timer1 Clock Enabled.
N * |[4]     |TMR2CKEN  |Timer2 Clock Enable Bit
N * |        |          |0 = Timer2 Clock Disabled.
N * |        |          |1 = Timer2 Clock Enabled.
N * |[5]     |TMR3CKEN  |Timer3 Clock Enable Bit
N * |        |          |0 = Timer3 Clock Disabled.
N * |        |          |1 = Timer3 Clock Enabled.
N * |[6]     |CLKOCKEN  |CLKO Clock Enable Bit
N * |        |          |0 = CLKO Clock Disabled.
N * |        |          |1 = CLKO Clock Enabled.
N * |[7]     |ACMP01CKEN|Analog Comparator 0/1 Clock Enable Bit
N * |        |          |0 = Analog Comparator 0/1 Clock Disabled.
N * |        |          |1 = Analog Comparator 0/1 Clock Enabled.
N * |[8]     |I2C0CKEN  |I2C0 Clock Enable Bit
N * |        |          |0 = I2C0 Clock Disabled.
N * |        |          |1 = I2C0 Clock Enabled.
N * |[9]     |I2C1CKEN  |I2C1 Clock Enable Bit
N * |        |          |0 = I2C1 Clock Disabled.
N * |        |          |1 = I2C1 Clock Enabled.
N * |[12]    |SPI0CKEN  |SPI0 Clock Enable Bit
N * |        |          |0 = SPI0 Clock Disabled.
N * |        |          |1 = SPI0 Clock Enabled.
N * |[13]    |SPI1CKEN  |SPI1 Clock Enable Bit
N * |        |          |0 = SPI1 Clock Disabled.
N * |        |          |1 = SPI1 Clock Enabled.
N * |[14]    |SPI2CKEN  |SPI2 Clock Enable Bit
N * |        |          |0 = SPI2 Clock Disabled.
N * |        |          |1 = SPI2 Clock Enabled.
N * |[16]    |UART0CKEN |UART0 Clock Enable Bit
N * |        |          |0 = UART0 clock Disabled.
N * |        |          |1 = UART0 clock Enabled.
N * |[17]    |UART1CKEN |UART1 Clock Enable Bit
N * |        |          |0 = UART1 clock Disabled.
N * |        |          |1 = UART1 clock Enabled.
N * |[18]    |UART2CKEN |UART2 Clock Enable Bit
N * |        |          |0 = UART2 clock Disabled.
N * |        |          |1 = UART2 clock Enabled.
N * |[19]    |UART3CKEN |UART3 Clock Enable Bit
N * |        |          |0 = UART3 clock Disabled.
N * |        |          |1 = UART3 clock Enabled.
N * |[24]    |CAN0CKEN  |CAN0 Clock Enable Bit
N * |        |          |0 = CAN0 clock Disabled.
N * |        |          |1 = CAN0 clock Enabled.
N * |[26]    |OTGCKEN   |USB OTG Clock Enable Bit
N * |        |          |0 = USB OTG clock Disabled.
N * |        |          |1 = USB OTG clock Enabled.
N * |[27]    |USBDCKEN  |USB Device Clock Enable Bit
N * |        |          |0 = USB Device clock Disabled.
N * |        |          |1 = USB Device clock Enabled.
N * |[28]    |EADCCKEN  |Enhanced Analog-Digital-Converter (EADC) Clock Enable Bit
N * |        |          |0 = EADC clock Disabled.
N * |        |          |1 = EADC clock Enabled.
N * @var CLK_T::APBCLK1
N * Offset: 0x0C  APB Devices Clock Enable Control Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |SC0CKEN   |SC0 Clock Enable Bit
N * |        |          |0 = SC0 Clock Disabled.
N * |        |          |1 = SC0 Clock Enabled.
N * |[12]    |DACCKEN   |DAC Clock Enable Bit
N * |        |          |0 = DAC Clock Disabled.
N * |        |          |1 = DAC Clock Enabled.
N * |[16]    |PWM0CKEN  |PWM0 Clock Enable Bit
N * |        |          |0 = PWM0 Clock Disabled.
N * |        |          |1 = PWM0 Clock Enabled.
N * |[17]    |PWM1CKEN  |PWM1 Clock Enable Bit
N * |        |          |0 = PWM1 Clock Disabled.
N * |        |          |1 = PWM1 Clock Enabled.
N * |[25]    |TKCKEN    |Touch Key Clock Enable Bit
N * |        |          |0 = Touch Key Clock Disabled.
N * |        |          |1 = Touch key Clock Enabled.
N * @var CLK_T::CLKSEL0
N * Offset: 0x10  Clock Source Select Control Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2:0]   |HCLKSEL   |HCLK Clock Source Selection (Write Protect)
N * |        |          |Before clock switching, the related clock sources (both pre-select and new-select) must be turned on.
N * |        |          |The default value is reloaded from the value of CFOSC (CONFIG0[26:24]) in user configuration register of Flash controller by any reset.
N * |        |          |Therefore the default value is either 000b or 111b.
N * |        |          |000 = Clock source from external 4~24 MHz high-speed crystal clock.
N * |        |          |001 = Clock source from external 32.768 kHz low-speed crystal clock.
N * |        |          |010 = Clock source from PLL clock.
N * |        |          |011 = Clock source from internal 10 kHz low-speed oscillator clock.
N * |        |          |111= Clock source from internal 22.1184 MHz high-speed oscillator clock.
N * |        |          |Other = Reserved.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[5:3]   |STCLKSEL  |Cortex-M4 SysTick Clock Source Selection (Write Protect)
N * |        |          |If SYST_CTRL[2]=0, SysTick uses listed clock source below.
N * |        |          |000 = Clock source from external 4~24 MHz high-speed crystal clock.
N * |        |          |001 = Clock source from external 32.768 kHz low-speed crystal clock.
N * |        |          |010 = Clock source from external 4~24 MHz high-speed crystal clock/2.
N * |        |          |011 = Clock source from HCLK/2.
N * |        |          |111 = Clock source from internal 22.1184 MHz high-speed oscillator clock/2.
N * |        |          |Note: if SysTick clock source is not from HCLK (i.e.
N * |        |          |SYST_CTRL[2] = 0), SysTick clock source must less than or equal to HCLK/2.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[6]     |PCLK0SEL  |PCLK0 Clock Source Selection (Write Protect)
N * |        |          |0 = APB0 BUS clock source from HCLK.
N * |        |          |1 = APB0 BUS clock source from HCLK/2.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[7]     |PCLK1SEL  |PCLK1 Clock Source Selection (Write Protect)
N * |        |          |0 = APB1 BUS clock source from HCLK.
N * |        |          |1 = APB1 BUS clock source from HCLK/2.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * @var CLK_T::CLKSEL1
N * Offset: 0x14  Clock Source Select Control Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |WDTSEL    |Watchdog Timer Clock Source Selection (Write Protect)
N * |        |          |00 = Reserved.
N * |        |          |01 = Clock source from external 32.768 kHz low-speed crystal clock.
N * |        |          |10 = Clock source from PCLK0/2048 clock.
N * |        |          |11 = Clock source from internal 10 kHz low-speed oscillator clock.
N * |[10:8]  |TMR0SEL   |TIMER0 Clock Source Selection
N * |        |          |000 = Clock source from external 4~24 MHz high-speed crystal clock.
N * |        |          |001 = Clock source from external 32.768 kHz low-speed crystal clock.
N * |        |          |010 = Clock source from PCLK0.
N * |        |          |011 = Clock source from external clock T0 pin
N * |        |          |101 = Clock source from internal 10 kHz low-speed oscillator clock.
N * |        |          |111 = Clock source from internal 22.1184 MHz high-speed oscillator clock.
N * |        |          |Others = Reserved.
N * |[14:12] |TMR1SEL   |TIMER1 Clock Source Selection
N * |        |          |000 = Clock source from external 4~24 MHz high-speed crystal clock.
N * |        |          |001 = Clock source from external 32.768 kHz low-speed crystal clock.
N * |        |          |010 = Clock source from PCLK0.
N * |        |          |011 = Clock source from external clock T1 pin
N * |        |          |101 = Clock source from internal 10 kHz low-speed oscillator clock.
N * |        |          |111 = Clock source from internal 22.1184 MHz high-speed oscillator clock.
N * |        |          |Others = Reserved.
N * |[18:16] |TMR2SEL   |TIMER2 Clock Source Selection
N * |        |          |000 = Clock source from external 4~24 MHz high-speed crystal clock.
N * |        |          |001 = Clock source from external 32.768 kHz low-speed crystal clock.
N * |        |          |010 = Clock source from PCLK1.
N * |        |          |011 = Clock source from external clock T2 pin
N * |        |          |101 = Clock source from internal 10 kHz low-speed oscillator clock.
N * |        |          |111 = Clock source from internal 22.1184 MHz high-speed oscillator clock.
N * |        |          |Others = Reserved.
N * |[22:20] |TMR3SEL   |TIMER3 Clock Source Selection
N * |        |          |000 = Clock source from external 4~24 MHz high-speed crystal clock.
N * |        |          |001 = Clock source from external 32.768 kHz low-speed crystal clock.
N * |        |          |010 = Clock source from PCLK1.
N * |        |          |011 = Clock source from external clock T3 pin.
N * |        |          |101 = Clock source from internal 10 kHz low-speed oscillator clock.
N * |        |          |111 = Clock source from internal 22.1184 MHz high-speed oscillator clock.
N * |        |          |Others = Reserved.
N * |[25:24] |UARTSEL   |UART Clock Source Selection
N * |        |          |00 = Clock source from external 4~24 MHz high-speed crystal clock (HXT).
N * |        |          |01 = Clock source from PLL clock.
N * |        |          |10 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT).
N * |        |          |11 = Clock source from internal 22.1184 MHz high-speed oscillator clock (HIRC).
N * |[29:28] |CLKOSEL   |Clock Divider Clock Source Selection
N * |        |          |00 = Clock source from external 4~24 MHz high-speed crystal clock.
N * |        |          |01 = Clock source from external 32.768 kHz low-speed crystal clock.
N * |        |          |10 = Clock source from HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high-speed oscillator clock.
N * |[31:30] |WWDTSEL   |Window Watchdog Timer Clock Source Selection
N * |        |          |10 = Clock source from PCLK0/2048 clock.
N * |        |          |11 = Clock source from internal 10 kHz low-speed oscillator clock.
N * |        |          |Others = Reserved.
N * @var CLK_T::CLKSEL2
N * Offset: 0x18  Clock Source Select Control Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PWM0SEL   |PWM0 Clock Source Selection
N * |        |          |The peripheral clock source of PWM0 is defined by PWM0SEL.
N * |        |          |0 = Clock source from PLL clock.
N * |        |          |1 = Clock source from PCLK0.
N * |[1]     |PWM1SEL   |PWM1 Clock Source Selection
N * |        |          |The peripheral clock source of PWM1 is defined by PWM1SEL.
N * |        |          |0 = Clock source from PLL clock.
N * |        |          |1 = Clock source from PCLK1.
N * |[3:2]   |SPI0SEL   |SPI0 Clock Source Selection
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from PLL clock.
N * |        |          |10 = Clock source from PCLK0.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |[5:4]   |SPI1SEL   |SPI1 Clock Source Selection
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from PLL clock.
N * |        |          |10 = Clock source from PCLK1.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |[7:6]   |SPI2SEL   |SPI2 Clock Source Selection
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from PLL clock.
N * |        |          |10 = Clock source from PCLK0.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * @var CLK_T::CLKSEL3
N * Offset: 0x1C  Clock Source Select Control Register 3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |SC0SEL    |SC0 Clock Source Selection
N * |        |          |00 = Clock source from external 4~24 MHz high-speed crystal clock.
N * |        |          |01 = Clock source from PLL clock.
N * |        |          |10 = Clock source from PCLK0.
N * |        |          |11 = Clock source from internal 22.1184 MHz high-speed oscillator clock.
N * |[8]     |RTCSEL    |RTC Clock Source Selection
N * |        |          |0 = Clock source from external 32.768 kHz low-speed oscillator.
N * |        |          |1 = Clock source from internal 10 kHz low speed RC oscillator.
N * @var CLK_T::CLKDIV0
N * Offset: 0x20  Clock Divider Number Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |HCLKDIV   |HCLK Clock Divide Number From HCLK Clock Source
N * |        |          |HCLK clock frequency = (HCLK clock source frequency) / (HCLKDIV + 1).
N * |[7:4]   |USBDIV    |USB Clock Divide Number From PLL Clock
N * |        |          |USB clock frequency = (PLL frequency) / (USBDIV + 1).
N * |[11:8]  |UARTDIV   |UART Clock Divide Number From UART Clock Source
N * |        |          |UART clock frequency = (UART clock source frequency) / (UARTDIV + 1).
N * |[23:16] |EADCDIV   |EADC Clock Divide Number From EADC Clock Source
N * |        |          |EADC clock frequency = (EADC clock source frequency) / (EADCDIV + 1).
N * @var CLK_T::CLKDIV1
N * Offset: 0x24  Clock Divider Number Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |SC0DIV    |SC0 Clock Divide Number From SC0 Clock Source
N * |        |          |SC0 clock frequency = (SC0 clock source frequency ) / (SC0DIV + 1).
N * @var CLK_T::PLLCTL
N * Offset: 0x40  PLL Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[8:0]   |FBDIV     |PLL Feedback Divider Control Pins (Write Protect)
N * |        |          |Refer to the formulas below the table.
N * |[13:9]  |INDIV     |PLL Input Divider Control Pins (Write Protect)
N * |        |          |Refer to the formulas below the table.
N * |[15:14] |OUTDIV    |PLL Output Divider Control Pins (Write Protect)
N * |        |          |Refer to the formulas below the table.
N * |[16]    |PD        |Power-Down Mode (Write Protect)
N * |        |          |If set the PDEN bit to 1 in CLK_PWRCTL register, the PLL will enter Power-down mode, too.
N * |        |          |0 = PLL is in normal mode.
N * |        |          |1 = PLL is in Power-down mode (default).
N * |[17]    |BP        |PLL Bypass Control (Write Protect)
N * |        |          |0 = PLL is in normal mode (default).
N * |        |          |1 = PLL clock output is same as PLL input clock FIN.
N * |[18]    |OE        |PLL OE (FOUT Enable) Pin Control (Write Protect)
N * |        |          |0 = PLL FOUT Enabled.
N * |        |          |1 = PLL FOUT is fixed low.
N * |[19]    |PLLSRC    |PLL Source Clock Selection (Write Protect)
N * |        |          |0 = PLL source clock from external 4~24 MHz high-speed crystal (HXT).
N * |        |          |1 = PLL source clock from internal 22.1184 MHz high-speed oscillator (HIRC).
N * |[23]    |STBSEL    |PLL Stable Counter Selection (Write Protect)
N * |        |          |0 = PLL stable time is 6144 PLL source clock (suitable for source clock is equal to or less than 12MHz).
N * |        |          |1 = PLL stable time is 12288 PLL source clock (suitable for source clock is larger than 12MHz).
N * @var CLK_T::STATUS
N * Offset: 0x50  Clock Status Monitor Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |HXTSTB    |External 4~24 MHz High-Speed Crystal Clock Source Stable Flag (Read Only)
N * |        |          |0 = External 4~24 MHz high-speed crystal clock is not stable or disabled.
N * |        |          |1 = External 4~24 MHz high-speed crystal clock is stable and enabled.
N * |[1]     |LXTSTB    |External 32.768 kHz Low-Speed Crystal Clock Source Stable Flag (Read Only)
N * |        |          |0 = External 32.768 kHz low-speed crystal clock is not stable or disabled.
N * |        |          |1 = External 32.768 kHz low-speed crystal clock is stabled and enabled.
N * |[2]     |PLLSTB    |Internal PLL Clock Source Stable Flag (Read Only)
N * |        |          |0 = Internal PLL clock is not stable or disabled.
N * |        |          |1 = Internal PLL clock is stable and enabled.
N * |[3]     |LIRCSTB   |Internal 10 KHz Low-Speed Oscillator Clock Source Stable Flag (Read Only)
N * |        |          |0 = Internal 10 kHz low-speed oscillator clock is not stable or disabled.
N * |        |          |1 = Internal 10 kHz low-speed oscillator clock is stable and enabled.
N * |[4]     |HIRCSTB   |Internal 22.1184 MHz High-Speed Oscillator Clock Source Stable Flag (Read Only)
N * |        |          |0 = Internal 22.1184 MHz high-speed oscillator clock is not stable or disabled.
N * |        |          |1 = Internal 22.1184 MHz high-speed oscillator clock is stable and enabled.
N * |[7]     |CLKSFAIL  |Clock Switching Fail Flag (Read Only)
N * |        |          |This bit is updated when software switches system clock source.
N * |        |          |If switch target clock is stable, this bit will be set to 0.
N * |        |          |If switch target clock is not stable, this bit will be set to 1.
N * |        |          |0 = Clock switching success.
N * |        |          |1 = Clock switching failure.
N * |        |          |Note: Write 1 to clear the bit to 0.
N * @var CLK_T::CLKOCTL
N * Offset: 0x60  Clock Output Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |FREQSEL   |Clock Output Frequency Selection
N * |        |          |The formula of output frequency is
N * |        |          |Fout = Fin/2(N+1).
N * |        |          |Fin is the input clock frequency.
N * |        |          |Fout is the frequency of divider output clock.
N * |        |          |N is the 4-bit value of FREQSEL[3:0].
N * |[4]     |CLKOEN    |Clock Output Enable Bit
N * |        |          |0 =Clock Output function Disabled.
N * |        |          |1 = Clock Output function Enabled.
N * |[5]     |DIV1EN    |Clock Output Divide One Enable Bit
N * |        |          |0 = Clock Output will output clock with source frequency divided by FREQSEL.
N * |        |          |1 = Clock Output will output clock with source frequency.
N * |[6]     |CLK1HZEN  |Clock Output 1Hz Enable Bit
N * |        |          |0 = 1 Hz clock output for 32.768kHz frequency compensation Disabled.
N * |        |          |1 = 1 Hz clock output for 332.768kHz frequency compensation Enabled.
N * @var CLK_T::CLKDCTL
N * Offset: 0x70  Clock Fail Detector Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[4]     |HXTFDEN   |HXT Clock Fail Detector Enable Bit
N * |        |          |0 = HXT clock Fail detector Disabled.
N * |        |          |1 = HXT clock Fail detector Enabled.
N * |[5]     |HXTFIEN   |HXT Clock Fail Interrupt Enable Bit
N * |        |          |0 = HXT clock Fail interrupt Disabled.
N * |        |          |1 = HXT clock Fail interrupt Enabled.
N * |[12]    |LXTFDEN   |LXT Clock Fail Detector Enable Bit
N * |        |          |0 = LXT clock Fail detector Disabled.
N * |        |          |1 = LXT clock Fail detector Enabled.
N * |[13]    |LXTFIEN   |LXT Clock Fail Interrupt Enable Bit
N * |        |          |0 = LXT clock Fail interrupt Disabled.
N * |        |          |1 = LXT clock Fail interrupt Enabled.
N * |[16]    |HXTFQDEN  |HXT Clock Frequency Monitor Enable Bit
N * |        |          |0 = HXT clock frequency monitor Disabled.
N * |        |          |1 = HXT clock frequency monitor Enabled.
N * |[17]    |HXTFQIEN  |HXT Clock Frequency Monitor Interrupt Enable Bit
N * |        |          |0 = HXT clock frequency monitor fail interrupt Disabled.
N * |        |          |1 = HXT clock frequency monitor fail interrupt Enabled.
N * @var CLK_T::CLKDSTS
N * Offset: 0x74  Clock Fail Detector Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |HXTFIF    |HXT Clock Fail Interrupt Flag
N * |        |          |0 = HXT clock normal.
N * |        |          |1 = HXT clock stop
N * |        |          |Note: Write 1 to clear the bit to 0.
N * |[1]     |LXTFIF    |LXT Clock Fail Interrupt Flag
N * |        |          |0 = LXT clock normal.
N * |        |          |1 = LXT stop
N * |        |          |Note: Write 1 to clear the bit to 0.
N * |[8]     |HXTFQIF   |HXT Clock Frequency Monitor Interrupt Flag
N * |        |          |0 = HXT clock normal.
N * |        |          |1 = HXT clock frequency abnormal
N * |        |          |Note: Write 1 to clear the bit to 0.
N * @var CLK_T::CDUPB
N * Offset: 0x78  Clock Frequency Detector Upper Boundary Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[9:0]   |UPERBD    |HXT Clock Frequency Detector Upper Boundary
N * |        |          |The bits define the high value of frequency monitor window.
N * |        |          |When HXT frequency monitor value higher than this register, the HXT frequency detect fail interrupt flag will set to 1.
N * @var CLK_T::CDLOWB
N * Offset: 0x7C  Clock Frequency Detector Low Boundary Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[9:0]   |LOWERBD   |HXT Clock Frequency Detector Low Boundary
N * |        |          |The bits define the low value of frequency monitor window.
N * |        |          |When HXT frequency monitor value lower than this register, the HXT frequency detect fail interrupt flag will set to 1.
N */
N
N    __IO uint32_t PWRCTL;        /* Offset: 0x00  System Power-down Control Register                                 */
X    volatile uint32_t PWRCTL;         
N    __IO uint32_t AHBCLK;        /* Offset: 0x04  AHB Devices Clock Enable Control Register                          */
X    volatile uint32_t AHBCLK;         
N    __IO uint32_t APBCLK0;       /* Offset: 0x08  APB Devices Clock Enable Control Register 0                        */
X    volatile uint32_t APBCLK0;        
N    __IO uint32_t APBCLK1;       /* Offset: 0x0C  APB Devices Clock Enable Control Register 1                        */
X    volatile uint32_t APBCLK1;        
N    __IO uint32_t CLKSEL0;       /* Offset: 0x10  Clock Source Select Control Register 0                             */
X    volatile uint32_t CLKSEL0;        
N    __IO uint32_t CLKSEL1;       /* Offset: 0x14  Clock Source Select Control Register 1                             */
X    volatile uint32_t CLKSEL1;        
N    __IO uint32_t CLKSEL2;       /* Offset: 0x18  Clock Source Select Control Register 2                             */
X    volatile uint32_t CLKSEL2;        
N    __IO uint32_t CLKSEL3;       /* Offset: 0x1C  Clock Source Select Control Register 3                             */
X    volatile uint32_t CLKSEL3;        
N    __IO uint32_t CLKDIV0;       /* Offset: 0x20  Clock Divider Number Register 0                                    */
X    volatile uint32_t CLKDIV0;        
N    __IO uint32_t CLKDIV1;       /* Offset: 0x24  Clock Divider Number Register 1                                    */
X    volatile uint32_t CLKDIV1;        
N    __I  uint32_t RESERVE0[6];  
X    volatile const  uint32_t RESERVE0[6];  
N    __IO uint32_t PLLCTL;        /* Offset: 0x40  PLL Control Register                                               */
X    volatile uint32_t PLLCTL;         
N    __I  uint32_t RESERVE1[3];  
X    volatile const  uint32_t RESERVE1[3];  
N    __I  uint32_t STATUS;        /* Offset: 0x50  Clock Status Monitor Register                                      */
X    volatile const  uint32_t STATUS;         
N    __I  uint32_t RESERVE2[3];  
X    volatile const  uint32_t RESERVE2[3];  
N    __IO uint32_t CLKOCTL;       /* Offset: 0x60  Clock Output Control Register                                      */
X    volatile uint32_t CLKOCTL;        
N    __I  uint32_t RESERVE3[3];  
X    volatile const  uint32_t RESERVE3[3];  
N    __IO uint32_t CLKDCTL;       /* Offset: 0x70  Clock Fail Detector Control Register                               */
X    volatile uint32_t CLKDCTL;        
N    __IO uint32_t CLKDSTS;       /* Offset: 0x74  Clock Fail Detector Status Register                                */
X    volatile uint32_t CLKDSTS;        
N    __IO uint32_t CDUPB;         /* Offset: 0x78  Clock Frequency Detector Upper Boundary Register                   */
X    volatile uint32_t CDUPB;          
N    __IO uint32_t CDLOWB;        /* Offset: 0x7C  Clock Frequency Detector Low Boundary Register                     */
X    volatile uint32_t CDLOWB;         
N
N} CLK_T;
N
N
N
N/**
N    @addtogroup CLK_CONST CLK Bit Field Definition
N    Constant Definitions for CLK Controller
N@{ */
N
N#define CLK_PWRCTL_HXTEN_Pos             (0)                                               /*!< CLK_T::PWRCTL: HXTEN Position             */
N#define CLK_PWRCTL_HXTEN_Msk             (0x1ul << CLK_PWRCTL_HXTEN_Pos)                   /*!< CLK_T::PWRCTL: HXTEN Mask                 */
N
N#define CLK_PWRCTL_LXTEN_Pos             (1)                                               /*!< CLK_T::PWRCTL: LXTEN Position             */
N#define CLK_PWRCTL_LXTEN_Msk             (0x1ul << CLK_PWRCTL_LXTEN_Pos)                   /*!< CLK_T::PWRCTL: LXTEN Mask                 */
N
N#define CLK_PWRCTL_HIRCEN_Pos            (2)                                               /*!< CLK_T::PWRCTL: HIRCEN Position            */
N#define CLK_PWRCTL_HIRCEN_Msk            (0x1ul << CLK_PWRCTL_HIRCEN_Pos)                  /*!< CLK_T::PWRCTL: HIRCEN Mask                */
N
N#define CLK_PWRCTL_LIRCEN_Pos            (3)                                               /*!< CLK_T::PWRCTL: LIRCEN Position            */
N#define CLK_PWRCTL_LIRCEN_Msk            (0x1ul << CLK_PWRCTL_LIRCEN_Pos)                  /*!< CLK_T::PWRCTL: LIRCEN Mask                */
N
N#define CLK_PWRCTL_PDWKDLY_Pos           (4)                                               /*!< CLK_T::PWRCTL: PDWKDLY Position           */
N#define CLK_PWRCTL_PDWKDLY_Msk           (0x1ul << CLK_PWRCTL_PDWKDLY_Pos)                 /*!< CLK_T::PWRCTL: PDWKDLY Mask               */
N
N#define CLK_PWRCTL_PDWKIEN_Pos           (5)                                               /*!< CLK_T::PWRCTL: PDWKIEN Position           */
N#define CLK_PWRCTL_PDWKIEN_Msk           (0x1ul << CLK_PWRCTL_PDWKIEN_Pos)                 /*!< CLK_T::PWRCTL: PDWKIEN Mask               */
N
N#define CLK_PWRCTL_PDWKIF_Pos            (6)                                               /*!< CLK_T::PWRCTL: PDWKIF Position            */
N#define CLK_PWRCTL_PDWKIF_Msk            (0x1ul << CLK_PWRCTL_PDWKIF_Pos)                  /*!< CLK_T::PWRCTL: PDWKIF Mask                */
N
N#define CLK_PWRCTL_PDEN_Pos              (7)                                               /*!< CLK_T::PWRCTL: PDEN Position              */
N#define CLK_PWRCTL_PDEN_Msk              (0x1ul << CLK_PWRCTL_PDEN_Pos)                    /*!< CLK_T::PWRCTL: PDEN Mask                  */
N
N#define CLK_PWRCTL_PDWTCPU_Pos           (8)                                               /*!< CLK_T::PWRCTL: PDWTCPU Position           */
N#define CLK_PWRCTL_PDWTCPU_Msk           (0x1ul << CLK_PWRCTL_PDWTCPU_Pos)                 /*!< CLK_T::PWRCTL: PDWTCPU Mask               */
N
N#define CLK_PWRCTL_HXTGAIN_Pos           (10)                                              /*!< CLK_T::PWRCTL: HXTGAIN Position           */
N#define CLK_PWRCTL_HXTGAIN_Msk           (0x3ul << CLK_PWRCTL_HXTGAIN_Pos)                 /*!< CLK_T::PWRCTL: HXTGAIN Mask               */
N
N#define CLK_PWRCTL_HXTSELTYP_Pos         (12)                                              /*!< CLK_T::PWRCTL: HXTSELTYP Position         */
N#define CLK_PWRCTL_HXTSELTYP_Msk         (0x1ul << CLK_PWRCTL_HXTSELTYP_Pos)               /*!< CLK_T::PWRCTL: HXTSELTYP Mask             */
N
N#define CLK_AHBCLK_PDMACKEN_Pos          (1)                                               /*!< CLK_T::AHBCLK: PDMACKEN Position          */
N#define CLK_AHBCLK_PDMACKEN_Msk          (0x1ul << CLK_AHBCLK_PDMACKEN_Pos)                /*!< CLK_T::AHBCLK: PDMACKEN Mask              */
N
N#define CLK_AHBCLK_ISPCKEN_Pos           (2)                                               /*!< CLK_T::AHBCLK: ISPCKEN Position           */
N#define CLK_AHBCLK_ISPCKEN_Msk           (0x1ul << CLK_AHBCLK_ISPCKEN_Pos)                 /*!< CLK_T::AHBCLK: ISPCKEN Mask               */
N
N#define CLK_AHBCLK_EBICKEN_Pos           (3)                                               /*!< CLK_T::AHBCLK: EBICKEN Position           */
N#define CLK_AHBCLK_EBICKEN_Msk           (0x1ul << CLK_AHBCLK_EBICKEN_Pos)                 /*!< CLK_T::AHBCLK: EBICKEN Mask               */
N
N#define CLK_AHBCLK_USBHCKEN_Pos          (4)                                               /*!< CLK_T::AHBCLK: USBHCKEN Position          */
N#define CLK_AHBCLK_USBHCKEN_Msk          (0x1ul << CLK_AHBCLK_USBHCKEN_Pos)                /*!< CLK_T::AHBCLK: USBHCKEN Mask              */
N
N#define CLK_AHBCLK_CRCCKEN_Pos           (7)                                               /*!< CLK_T::AHBCLK: CRCCKEN Position           */
N#define CLK_AHBCLK_CRCCKEN_Msk           (0x1ul << CLK_AHBCLK_CRCCKEN_Pos)                 /*!< CLK_T::AHBCLK: CRCCKEN Mask               */
N
N#define CLK_AHBCLK_FMCIDLE_Pos           (15)                                              /*!< CLK_T::AHBCLK: FMCIDLE Position           */
N#define CLK_AHBCLK_FMCIDLE_Msk           (0x1ul << CLK_AHBCLK_FMCIDLE_Pos)                 /*!< CLK_T::AHBCLK: FMCIDLE Mask               */
N
N#define CLK_APBCLK0_WDTCKEN_Pos          (0)                                               /*!< CLK_T::APBCLK0: WDTCKEN Position          */
N#define CLK_APBCLK0_WDTCKEN_Msk          (0x1ul << CLK_APBCLK0_WDTCKEN_Pos)                /*!< CLK_T::APBCLK0: WDTCKEN Mask              */
N
N#define CLK_APBCLK0_RTCCKEN_Pos          (1)                                               /*!< CLK_T::APBCLK0: RTCCKEN Position          */
N#define CLK_APBCLK0_RTCCKEN_Msk          (0x1ul << CLK_APBCLK0_RTCCKEN_Pos)                /*!< CLK_T::APBCLK0: RTCCKEN Mask              */
N
N#define CLK_APBCLK0_TMR0CKEN_Pos         (2)                                               /*!< CLK_T::APBCLK0: TMR0CKEN Position         */
N#define CLK_APBCLK0_TMR0CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR0CKEN_Pos)               /*!< CLK_T::APBCLK0: TMR0CKEN Mask             */
N
N#define CLK_APBCLK0_TMR1CKEN_Pos         (3)                                               /*!< CLK_T::APBCLK0: TMR1CKEN Position         */
N#define CLK_APBCLK0_TMR1CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR1CKEN_Pos)               /*!< CLK_T::APBCLK0: TMR1CKEN Mask             */
N
N#define CLK_APBCLK0_TMR2CKEN_Pos         (4)                                               /*!< CLK_T::APBCLK0: TMR2CKEN Position         */
N#define CLK_APBCLK0_TMR2CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR2CKEN_Pos)               /*!< CLK_T::APBCLK0: TMR2CKEN Mask             */
N
N#define CLK_APBCLK0_TMR3CKEN_Pos         (5)                                               /*!< CLK_T::APBCLK0: TMR3CKEN Position         */
N#define CLK_APBCLK0_TMR3CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR3CKEN_Pos)               /*!< CLK_T::APBCLK0: TMR3CKEN Mask             */
N
N#define CLK_APBCLK0_CLKOCKEN_Pos         (6)                                               /*!< CLK_T::APBCLK0: CLKOCKEN Position         */
N#define CLK_APBCLK0_CLKOCKEN_Msk         (0x1ul << CLK_APBCLK0_CLKOCKEN_Pos)               /*!< CLK_T::APBCLK0: CLKOCKEN Mask             */
N
N#define CLK_APBCLK0_ACMP01CKEN_Pos       (7)                                               /*!< CLK_T::APBCLK0: ACMP01CKEN Position       */
N#define CLK_APBCLK0_ACMP01CKEN_Msk       (0x1ul << CLK_APBCLK0_ACMP01CKEN_Pos)             /*!< CLK_T::APBCLK0: ACMP01CKEN Mask           */
N
N#define CLK_APBCLK0_I2C0CKEN_Pos         (8)                                               /*!< CLK_T::APBCLK0: I2C0CKEN Position         */
N#define CLK_APBCLK0_I2C0CKEN_Msk         (0x1ul << CLK_APBCLK0_I2C0CKEN_Pos)               /*!< CLK_T::APBCLK0: I2C0CKEN Mask             */
N
N#define CLK_APBCLK0_I2C1CKEN_Pos         (9)                                               /*!< CLK_T::APBCLK0: I2C1CKEN Position         */
N#define CLK_APBCLK0_I2C1CKEN_Msk         (0x1ul << CLK_APBCLK0_I2C1CKEN_Pos)               /*!< CLK_T::APBCLK0: I2C1CKEN Mask             */
N
N#define CLK_APBCLK0_SPI0CKEN_Pos         (12)                                              /*!< CLK_T::APBCLK0: SPI0CKEN Position         */
N#define CLK_APBCLK0_SPI0CKEN_Msk         (0x1ul << CLK_APBCLK0_SPI0CKEN_Pos)               /*!< CLK_T::APBCLK0: SPI0CKEN Mask             */
N
N#define CLK_APBCLK0_SPI1CKEN_Pos         (13)                                              /*!< CLK_T::APBCLK0: SPI1CKEN Position         */
N#define CLK_APBCLK0_SPI1CKEN_Msk         (0x1ul << CLK_APBCLK0_SPI1CKEN_Pos)               /*!< CLK_T::APBCLK0: SPI1CKEN Mask             */
N
N#define CLK_APBCLK0_SPI2CKEN_Pos         (14)                                              /*!< CLK_T::APBCLK0: SPI2CKEN Position         */
N#define CLK_APBCLK0_SPI2CKEN_Msk         (0x1ul << CLK_APBCLK0_SPI2CKEN_Pos)               /*!< CLK_T::APBCLK0: SPI2CKEN Mask             */
N
N#define CLK_APBCLK0_UART0CKEN_Pos        (16)                                              /*!< CLK_T::APBCLK0: UART0CKEN Position        */
N#define CLK_APBCLK0_UART0CKEN_Msk        (0x1ul << CLK_APBCLK0_UART0CKEN_Pos)              /*!< CLK_T::APBCLK0: UART0CKEN Mask            */
N
N#define CLK_APBCLK0_UART1CKEN_Pos        (17)                                              /*!< CLK_T::APBCLK0: UART1CKEN Position        */
N#define CLK_APBCLK0_UART1CKEN_Msk        (0x1ul << CLK_APBCLK0_UART1CKEN_Pos)              /*!< CLK_T::APBCLK0: UART1CKEN Mask            */
N
N#define CLK_APBCLK0_UART2CKEN_Pos        (18)                                              /*!< CLK_T::APBCLK0: UART2CKEN Position        */
N#define CLK_APBCLK0_UART2CKEN_Msk        (0x1ul << CLK_APBCLK0_UART2CKEN_Pos)              /*!< CLK_T::APBCLK0: UART2CKEN Mask            */
N
N#define CLK_APBCLK0_UART3CKEN_Pos        (19)                                              /*!< CLK_T::APBCLK0: UART3CKEN Position        */
N#define CLK_APBCLK0_UART3CKEN_Msk        (0x1ul << CLK_APBCLK0_UART3CKEN_Pos)              /*!< CLK_T::APBCLK0: UART3CKEN Mask            */
N
N#define CLK_APBCLK0_CAN0CKEN_Pos         (24)                                              /*!< CLK_T::APBCLK0: CAN0CKEN Position         */
N#define CLK_APBCLK0_CAN0CKEN_Msk         (0x1ul << CLK_APBCLK0_CAN0CKEN_Pos)               /*!< CLK_T::APBCLK0: CAN0CKEN Mask             */
N
N#define CLK_APBCLK0_OTGCKEN_Pos          (26)                                              /*!< CLK_T::APBCLK0: OTGCKEN Position          */
N#define CLK_APBCLK0_OTGCKEN_Msk          (0x1ul << CLK_APBCLK0_OTGCKEN_Pos)                /*!< CLK_T::APBCLK0: OTGCKEN Mask              */
N
N#define CLK_APBCLK0_USBDCKEN_Pos         (27)                                              /*!< CLK_T::APBCLK0: USBDCKEN Position         */
N#define CLK_APBCLK0_USBDCKEN_Msk         (0x1ul << CLK_APBCLK0_USBDCKEN_Pos)               /*!< CLK_T::APBCLK0: USBDCKEN Mask             */
N
N#define CLK_APBCLK0_EADCCKEN_Pos         (28)                                              /*!< CLK_T::APBCLK0: EADCCKEN Position         */
N#define CLK_APBCLK0_EADCCKEN_Msk         (0x1ul << CLK_APBCLK0_EADCCKEN_Pos)               /*!< CLK_T::APBCLK0: EADCCKEN Mask             */
N
N#define CLK_APBCLK1_SC0CKEN_Pos          (0)                                               /*!< CLK_T::APBCLK1: SC0CKEN Position          */
N#define CLK_APBCLK1_SC0CKEN_Msk          (0x1ul << CLK_APBCLK1_SC0CKEN_Pos)                /*!< CLK_T::APBCLK1: SC0CKEN Mask              */
N
N#define CLK_APBCLK1_DACCKEN_Pos          (12)                                              /*!< CLK_T::APBCLK1: DACCKEN Position          */
N#define CLK_APBCLK1_DACCKEN_Msk          (0x1ul << CLK_APBCLK1_DACCKEN_Pos)                /*!< CLK_T::APBCLK1: DACCKEN Mask              */
N
N#define CLK_APBCLK1_PWM0CKEN_Pos         (16)                                              /*!< CLK_T::APBCLK1: PWM0CKEN Position         */
N#define CLK_APBCLK1_PWM0CKEN_Msk         (0x1ul << CLK_APBCLK1_PWM0CKEN_Pos)               /*!< CLK_T::APBCLK1: PWM0CKEN Mask             */
N
N#define CLK_APBCLK1_PWM1CKEN_Pos         (17)                                              /*!< CLK_T::APBCLK1: PWM1CKEN Position         */
N#define CLK_APBCLK1_PWM1CKEN_Msk         (0x1ul << CLK_APBCLK1_PWM1CKEN_Pos)               /*!< CLK_T::APBCLK1: PWM1CKEN Mask             */
N
N#define CLK_APBCLK1_TKCKEN_Pos           (25)                                              /*!< CLK_T::APBCLK1: TKCKEN Position           */
N#define CLK_APBCLK1_TKCKEN_Msk           (0x1ul << CLK_APBCLK1_TKCKEN_Pos)                 /*!< CLK_T::APBCLK1: TKCKEN Mask               */
N
N#define CLK_CLKSEL0_HCLKSEL_Pos          (0)                                               /*!< CLK_T::CLKSEL0: HCLKSEL Position          */
N#define CLK_CLKSEL0_HCLKSEL_Msk          (0x7ul << CLK_CLKSEL0_HCLKSEL_Pos)                /*!< CLK_T::CLKSEL0: HCLKSEL Mask              */
N
N#define CLK_CLKSEL0_STCLKSEL_Pos         (3)                                               /*!< CLK_T::CLKSEL0: STCLKSEL Position         */
N#define CLK_CLKSEL0_STCLKSEL_Msk         (0x7ul << CLK_CLKSEL0_STCLKSEL_Pos)               /*!< CLK_T::CLKSEL0: STCLKSEL Mask             */
N
N#define CLK_CLKSEL0_PCLK0SEL_Pos         (6)                                               /*!< CLK_T::CLKSEL0: PCLK0SEL Position         */
N#define CLK_CLKSEL0_PCLK0SEL_Msk         (0x1ul << CLK_CLKSEL0_PCLK0SEL_Pos)               /*!< CLK_T::CLKSEL0: PCLK0SEL Mask             */
N
N#define CLK_CLKSEL0_PCLK1SEL_Pos         (7)                                               /*!< CLK_T::CLKSEL0: PCLK1SEL Position         */
N#define CLK_CLKSEL0_PCLK1SEL_Msk         (0x1ul << CLK_CLKSEL0_PCLK1SEL_Pos)               /*!< CLK_T::CLKSEL0: PCLK1SEL Mask             */
N
N#define CLK_CLKSEL1_WDTSEL_Pos           (0)                                               /*!< CLK_T::CLKSEL1: WDTSEL Position           */
N#define CLK_CLKSEL1_WDTSEL_Msk           (0x3ul << CLK_CLKSEL1_WDTSEL_Pos)                 /*!< CLK_T::CLKSEL1: WDTSEL Mask               */
N
N#define CLK_CLKSEL1_TMR0SEL_Pos          (8)                                               /*!< CLK_T::CLKSEL1: TMR0SEL Position          */
N#define CLK_CLKSEL1_TMR0SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR0SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR0SEL Mask              */
N
N#define CLK_CLKSEL1_TMR1SEL_Pos          (12)                                              /*!< CLK_T::CLKSEL1: TMR1SEL Position          */
N#define CLK_CLKSEL1_TMR1SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR1SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR1SEL Mask              */
N
N#define CLK_CLKSEL1_TMR2SEL_Pos          (16)                                              /*!< CLK_T::CLKSEL1: TMR2SEL Position          */
N#define CLK_CLKSEL1_TMR2SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR2SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR2SEL Mask              */
N
N#define CLK_CLKSEL1_TMR3SEL_Pos          (20)                                              /*!< CLK_T::CLKSEL1: TMR3SEL Position          */
N#define CLK_CLKSEL1_TMR3SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR3SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR3SEL Mask              */
N
N#define CLK_CLKSEL1_UARTSEL_Pos          (24)                                              /*!< CLK_T::CLKSEL1: UARTSEL Position          */
N#define CLK_CLKSEL1_UARTSEL_Msk          (0x3ul << CLK_CLKSEL1_UARTSEL_Pos)                /*!< CLK_T::CLKSEL1: UARTSEL Mask              */
N
N#define CLK_CLKSEL1_CLKOSEL_Pos          (28)                                              /*!< CLK_T::CLKSEL1: CLKOSEL Position          */
N#define CLK_CLKSEL1_CLKOSEL_Msk          (0x3ul << CLK_CLKSEL1_CLKOSEL_Pos)                /*!< CLK_T::CLKSEL1: CLKOSEL Mask              */
N
N#define CLK_CLKSEL1_WWDTSEL_Pos          (30)                                              /*!< CLK_T::CLKSEL1: WWDTSEL Position          */
N#define CLK_CLKSEL1_WWDTSEL_Msk          (0x3ul << CLK_CLKSEL1_WWDTSEL_Pos)                /*!< CLK_T::CLKSEL1: WWDTSEL Mask              */
N
N#define CLK_CLKSEL2_PWM0SEL_Pos          (0)                                               /*!< CLK_T::CLKSEL2: PWM0SEL Position          */
N#define CLK_CLKSEL2_PWM0SEL_Msk          (0x1ul << CLK_CLKSEL2_PWM0SEL_Pos)                /*!< CLK_T::CLKSEL2: PWM0SEL Mask              */
N
N#define CLK_CLKSEL2_PWM1SEL_Pos          (1)                                               /*!< CLK_T::CLKSEL2: PWM1SEL Position          */
N#define CLK_CLKSEL2_PWM1SEL_Msk          (0x1ul << CLK_CLKSEL2_PWM1SEL_Pos)                /*!< CLK_T::CLKSEL2: PWM1SEL Mask              */
N
N#define CLK_CLKSEL2_SPI0SEL_Pos          (2)                                               /*!< CLK_T::CLKSEL2: SPI0SEL Position          */
N#define CLK_CLKSEL2_SPI0SEL_Msk          (0x3ul << CLK_CLKSEL2_SPI0SEL_Pos)                /*!< CLK_T::CLKSEL2: SPI0SEL Mask              */
N
N#define CLK_CLKSEL2_SPI1SEL_Pos          (4)                                               /*!< CLK_T::CLKSEL2: SPI1SEL Position          */
N#define CLK_CLKSEL2_SPI1SEL_Msk          (0x3ul << CLK_CLKSEL2_SPI1SEL_Pos)                /*!< CLK_T::CLKSEL2: SPI1SEL Mask              */
N
N#define CLK_CLKSEL2_SPI2SEL_Pos          (6)                                               /*!< CLK_T::CLKSEL2: SPI2SEL Position          */
N#define CLK_CLKSEL2_SPI2SEL_Msk          (0x3ul << CLK_CLKSEL2_SPI2SEL_Pos)                /*!< CLK_T::CLKSEL2: SPI2SEL Mask              */
N
N#define CLK_CLKSEL3_SC0SEL_Pos           (0)                                               /*!< CLK_T::CLKSEL3: SC0SEL Position           */
N#define CLK_CLKSEL3_SC0SEL_Msk           (0x3ul << CLK_CLKSEL3_SC0SEL_Pos)                 /*!< CLK_T::CLKSEL3: SC0SEL Mask               */
N
N#define CLK_CLKSEL3_RTCSEL_Pos           (8)                                               /*!< CLK_T::CLKSEL3: RTCSEL Position           */
N#define CLK_CLKSEL3_RTCSEL_Msk           (0x1ul << CLK_CLKSEL3_RTCSEL_Pos)                 /*!< CLK_T::CLKSEL3: RTCSEL Mask               */
N
N#define CLK_CLKDIV0_HCLKDIV_Pos          (0)                                               /*!< CLK_T::CLKDIV0: HCLKDIV Position          */
N#define CLK_CLKDIV0_HCLKDIV_Msk          (0xful << CLK_CLKDIV0_HCLKDIV_Pos)                /*!< CLK_T::CLKDIV0: HCLKDIV Mask              */
N
N#define CLK_CLKDIV0_USBDIV_Pos           (4)                                               /*!< CLK_T::CLKDIV0: USBDIV Position           */
N#define CLK_CLKDIV0_USBDIV_Msk           (0xful << CLK_CLKDIV0_USBDIV_Pos)                 /*!< CLK_T::CLKDIV0: USBDIV Mask               */
N
N#define CLK_CLKDIV0_UARTDIV_Pos          (8)                                               /*!< CLK_T::CLKDIV0: UARTDIV Position          */
N#define CLK_CLKDIV0_UARTDIV_Msk          (0xful << CLK_CLKDIV0_UARTDIV_Pos)                /*!< CLK_T::CLKDIV0: UARTDIV Mask              */
N
N#define CLK_CLKDIV0_EADCDIV_Pos          (16)                                              /*!< CLK_T::CLKDIV0: EADCDIV Position          */
N#define CLK_CLKDIV0_EADCDIV_Msk          (0xfful << CLK_CLKDIV0_EADCDIV_Pos)               /*!< CLK_T::CLKDIV0: EADCDIV Mask              */
N
N#define CLK_CLKDIV1_SC0DIV_Pos           (0)                                               /*!< CLK_T::CLKDIV1: SC0DIV Position           */
N#define CLK_CLKDIV1_SC0DIV_Msk           (0xfful << CLK_CLKDIV1_SC0DIV_Pos)                /*!< CLK_T::CLKDIV1: SC0DIV Mask               */
N
N#define CLK_PLLCTL_FBDIV_Pos             (0)                                               /*!< CLK_T::PLLCTL: FBDIV Position             */
N#define CLK_PLLCTL_FBDIV_Msk             (0x1fful << CLK_PLLCTL_FBDIV_Pos)                 /*!< CLK_T::PLLCTL: FBDIV Mask                 */
N
N#define CLK_PLLCTL_INDIV_Pos             (9)                                               /*!< CLK_T::PLLCTL: INDIV Position             */
N#define CLK_PLLCTL_INDIV_Msk             (0x1ful << CLK_PLLCTL_INDIV_Pos)                  /*!< CLK_T::PLLCTL: INDIV Mask                 */
N
N#define CLK_PLLCTL_OUTDIV_Pos            (14)                                              /*!< CLK_T::PLLCTL: OUTDIV Position            */
N#define CLK_PLLCTL_OUTDIV_Msk            (0x3ul << CLK_PLLCTL_OUTDIV_Pos)                  /*!< CLK_T::PLLCTL: OUTDIV Mask                */
N
N#define CLK_PLLCTL_PD_Pos                (16)                                              /*!< CLK_T::PLLCTL: PD Position                */
N#define CLK_PLLCTL_PD_Msk                (0x1ul << CLK_PLLCTL_PD_Pos)                      /*!< CLK_T::PLLCTL: PD Mask                    */
N
N#define CLK_PLLCTL_BP_Pos                (17)                                              /*!< CLK_T::PLLCTL: BP Position                */
N#define CLK_PLLCTL_BP_Msk                (0x1ul << CLK_PLLCTL_BP_Pos)                      /*!< CLK_T::PLLCTL: BP Mask                    */
N
N#define CLK_PLLCTL_OE_Pos                (18)                                              /*!< CLK_T::PLLCTL: OE Position                */
N#define CLK_PLLCTL_OE_Msk                (0x1ul << CLK_PLLCTL_OE_Pos)                      /*!< CLK_T::PLLCTL: OE Mask                    */
N
N#define CLK_PLLCTL_PLLSRC_Pos            (19)                                              /*!< CLK_T::PLLCTL: PLLSRC Position            */
N#define CLK_PLLCTL_PLLSRC_Msk            (0x1ul << CLK_PLLCTL_PLLSRC_Pos)                  /*!< CLK_T::PLLCTL: PLLSRC Mask                */
N
N#define CLK_PLLCTL_STBSEL_Pos            (23)                                              /*!< CLK_T::PLLCTL: STBSEL Position            */
N#define CLK_PLLCTL_STBSEL_Msk            (0x1ul << CLK_PLLCTL_STBSEL_Pos)                  /*!< CLK_T::PLLCTL: STBSEL Mask                */
N
N#define CLK_STATUS_HXTSTB_Pos            (0)                                               /*!< CLK_T::STATUS: HXTSTB Position            */
N#define CLK_STATUS_HXTSTB_Msk            (0x1ul << CLK_STATUS_HXTSTB_Pos)                  /*!< CLK_T::STATUS: HXTSTB Mask                */
N
N#define CLK_STATUS_LXTSTB_Pos            (1)                                               /*!< CLK_T::STATUS: LXTSTB Position            */
N#define CLK_STATUS_LXTSTB_Msk            (0x1ul << CLK_STATUS_LXTSTB_Pos)                  /*!< CLK_T::STATUS: LXTSTB Mask                */
N
N#define CLK_STATUS_PLLSTB_Pos            (2)                                               /*!< CLK_T::STATUS: PLLSTB Position            */
N#define CLK_STATUS_PLLSTB_Msk            (0x1ul << CLK_STATUS_PLLSTB_Pos)                  /*!< CLK_T::STATUS: PLLSTB Mask                */
N
N#define CLK_STATUS_LIRCSTB_Pos           (3)                                               /*!< CLK_T::STATUS: LIRCSTB Position           */
N#define CLK_STATUS_LIRCSTB_Msk           (0x1ul << CLK_STATUS_LIRCSTB_Pos)                 /*!< CLK_T::STATUS: LIRCSTB Mask               */
N
N#define CLK_STATUS_HIRCSTB_Pos           (4)                                               /*!< CLK_T::STATUS: HIRCSTB Position           */
N#define CLK_STATUS_HIRCSTB_Msk           (0x1ul << CLK_STATUS_HIRCSTB_Pos)                 /*!< CLK_T::STATUS: HIRCSTB Mask               */
N
N#define CLK_STATUS_CLKSFAIL_Pos          (7)                                               /*!< CLK_T::STATUS: CLKSFAIL Position          */
N#define CLK_STATUS_CLKSFAIL_Msk          (0x1ul << CLK_STATUS_CLKSFAIL_Pos)                /*!< CLK_T::STATUS: CLKSFAIL Mask              */
N
N#define CLK_CLKOCTL_FREQSEL_Pos          (0)                                               /*!< CLK_T::CLKOCTL: FREQSEL Position          */
N#define CLK_CLKOCTL_FREQSEL_Msk          (0xful << CLK_CLKOCTL_FREQSEL_Pos)                /*!< CLK_T::CLKOCTL: FREQSEL Mask              */
N
N#define CLK_CLKOCTL_CLKOEN_Pos           (4)                                               /*!< CLK_T::CLKOCTL: CLKOEN Position           */
N#define CLK_CLKOCTL_CLKOEN_Msk           (0x1ul << CLK_CLKOCTL_CLKOEN_Pos)                 /*!< CLK_T::CLKOCTL: CLKOEN Mask               */
N
N#define CLK_CLKOCTL_DIV1EN_Pos           (5)                                               /*!< CLK_T::CLKOCTL: DIV1EN Position           */
N#define CLK_CLKOCTL_DIV1EN_Msk           (0x1ul << CLK_CLKOCTL_DIV1EN_Pos)                 /*!< CLK_T::CLKOCTL: DIV1EN Mask               */
N
N#define CLK_CLKOCTL_CLK1HZEN_Pos         (6)                                               /*!< CLK_T::CLKOCTL: CLK1HZEN Position         */
N#define CLK_CLKOCTL_CLK1HZEN_Msk         (0x1ul << CLK_CLKOCTL_CLK1HZEN_Pos)               /*!< CLK_T::CLKOCTL: CLK1HZEN Mask             */
N
N#define CLK_CLKDCTL_HXTFDEN_Pos          (4)                                               /*!< CLK_T::CLKDCTL: HXTFDEN Position          */
N#define CLK_CLKDCTL_HXTFDEN_Msk          (0x1ul << CLK_CLKDCTL_HXTFDEN_Pos)                /*!< CLK_T::CLKDCTL: HXTFDEN Mask              */
N
N#define CLK_CLKDCTL_HXTFIEN_Pos          (5)                                               /*!< CLK_T::CLKDCTL: HXTFIEN Position          */
N#define CLK_CLKDCTL_HXTFIEN_Msk          (0x1ul << CLK_CLKDCTL_HXTFIEN_Pos)                /*!< CLK_T::CLKDCTL: HXTFIEN Mask              */
N
N#define CLK_CLKDCTL_LXTFDEN_Pos          (12)                                              /*!< CLK_T::CLKDCTL: LXTFDEN Position          */
N#define CLK_CLKDCTL_LXTFDEN_Msk          (0x1ul << CLK_CLKDCTL_LXTFDEN_Pos)                /*!< CLK_T::CLKDCTL: LXTFDEN Mask              */
N
N#define CLK_CLKDCTL_LXTFIEN_Pos          (13)                                              /*!< CLK_T::CLKDCTL: LXTFIEN Position          */
N#define CLK_CLKDCTL_LXTFIEN_Msk          (0x1ul << CLK_CLKDCTL_LXTFIEN_Pos)                /*!< CLK_T::CLKDCTL: LXTFIEN Mask              */
N
N#define CLK_CLKDCTL_HXTFQDEN_Pos         (16)                                              /*!< CLK_T::CLKDCTL: HXTFQDEN Position         */
N#define CLK_CLKDCTL_HXTFQDEN_Msk         (0x1ul << CLK_CLKDCTL_HXTFQDEN_Pos)               /*!< CLK_T::CLKDCTL: HXTFQDEN Mask             */
N
N#define CLK_CLKDCTL_HXTFQIEN_Pos         (17)                                              /*!< CLK_T::CLKDCTL: HXTFQIEN Position         */
N#define CLK_CLKDCTL_HXTFQIEN_Msk         (0x1ul << CLK_CLKDCTL_HXTFQIEN_Pos)               /*!< CLK_T::CLKDCTL: HXTFQIEN Mask             */
N
N#define CLK_CLKDSTS_HXTFIF_Pos           (0)                                               /*!< CLK_T::CLKDSTS: HXTFIF Position           */
N#define CLK_CLKDSTS_HXTFIF_Msk           (0x1ul << CLK_CLKDSTS_HXTFIF_Pos)                 /*!< CLK_T::CLKDSTS: HXTFIF Mask               */
N
N#define CLK_CLKDSTS_LXTFIF_Pos           (1)                                               /*!< CLK_T::CLKDSTS: LXTFIF Position           */
N#define CLK_CLKDSTS_LXTFIF_Msk           (0x1ul << CLK_CLKDSTS_LXTFIF_Pos)                 /*!< CLK_T::CLKDSTS: LXTFIF Mask               */
N
N#define CLK_CLKDSTS_HXTFQIF_Pos          (8)                                               /*!< CLK_T::CLKDSTS: HXTFQIF Position          */
N#define CLK_CLKDSTS_HXTFQIF_Msk          (0x1ul << CLK_CLKDSTS_HXTFQIF_Pos)                /*!< CLK_T::CLKDSTS: HXTFQIF Mask              */
N
N#define CLK_CDUPB_UPERBD_Pos             (0)                                               /*!< CLK_T::CDUPB: UPERBD Position             */
N#define CLK_CDUPB_UPERBD_Msk             (0x3fful << CLK_CDUPB_UPERBD_Pos)                 /*!< CLK_T::CDUPB: UPERBD Mask                 */
N
N#define CLK_CDLOWB_LOWERBD_Pos           (0)                                               /*!< CLK_T::CDLOWB: LOWERBD Position           */
N#define CLK_CDLOWB_LOWERBD_Msk           (0x3fful << CLK_CDLOWB_LOWERBD_Pos)               /*!< CLK_T::CDLOWB: LOWERBD Mask               */
N
N
N/**@}*/ /* CLK_CONST */
N/**@}*/ /* end of CLK register group */
N
N
N
N/*---------------------- Cyclic Redundancy Check Controller -------------------------*/
N/**
N    @addtogroup CRC Cyclic Redundancy Check Controller(CRC)
N    Memory Mapped Structure for CRC Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N
N
N/**
N * @var CRC_T::CTL
N * Offset: 0x00  CRC Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CRCEN     |CRC Channel Enable Bit
N * |        |          |0 = No effect.
N * |        |          |1 = CRC operation Enabled.
N * |[1]     |CRCRST    |CRC Engine Reset
N * |        |          |0 = No effect.
N * |        |          |1 = Reset the internal CRC state machine and internal buffer.
N * |        |          |The others contents of CRC_CTL register will not be cleared.
N * |        |          |Note1: This bit will be cleared automatically.
N * |        |          |Note2: Setting this bit will reload the initial seed value (CRC_SEED register).
N * |[24]    |DATREV    |Write Data Bit Order Reverse
N * |        |          |This bit is used to enable the bit order reverse function for write data value in CRC_DAT register.
N * |        |          |0 = Bit order reversed for CRC write data in Disabled.
N * |        |          |1 = Bit order reversed for CRC write data in Enabled (per byte).
N * |        |          |Note: If the write data is 0xAABBCCDD, the bit order reverse for CRC write data in is 0x55DD33BB.
N * |[25]    |CHKSREV   |Checksum Bit Order Reverse
N * |        |          |This bit is used to enable the bit order reverse function for write data value in CRC_CHECKSUM register.
N * |        |          |0 = Bit order reverse for CRC checksum Disabled.
N * |        |          |1 = Bit order reverse for CRC checksum Enabled.
N * |        |          |Note: If the checksum result is 0xDD7B0F2E, the bit order reverse for CRC checksum is 0x74F0DEBB.
N * |[26]    |DATFMT    |Write Data 1's Complement
N * |        |          |This bit is used to enable the 1's complement function for write data value in CRC_DAT register.
N * |        |          |0 = 1's complement for CRC writes data in Disabled.
N * |        |          |1 = 1's complement for CRC writes data in Enabled.
N * |[27]    |CHKSFMT   |Checksum 1's Complement
N * |        |          |This bit is used to enable the 1's complement function for checksum result in CRC_CHECKSUM register.
N * |        |          |0 = 1's complement for CRC checksum Disabled.
N * |        |          |1 = 1's complement for CRC checksum Enabled.
N * |[29:28] |DATLEN    |CPU Write Data Length
N * |        |          |This field indicates the write data length.
N * |        |          |00 = Data length is 8-bit mode.
N * |        |          |01 = Data length is 16-bit mode.
N * |        |          |1x = Data length is 32-bit mode.
N * |        |          |Note: When the write data length is 8-bit mode, the valid data in CRC_DAT register is only DATA[7:0] bits; if the write data length is 16-bit mode, the valid data in CRC_DAT register is only DATA[15:0]
N * |[31:30] |CRCMODE   |CRC Polynomial Mode
N * |        |          |This field indicates the CRC operation polynomial mode.
N * |        |          |00 = CRC-CCITT Polynomial mode.
N * |        |          |01 = CRC-8 Polynomial mode.
N * |        |          |10 = CRC-16 Polynomial mode.
N * |        |          |11 = CRC-32 Polynomial mode.
N * @var CRC_T::DAT
N * Offset: 0x04  CRC Write Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |DATA      |CRC Write Data Bits
N * |        |          |User can write data directly by CPU mode or use PDMA function to write data to this field to perform CRC operation.
N * |        |          |Note: When the write data length is 8-bit mode, the valid data in CRC_DAT register is only DATA[7:0] bits; if the write data length is 16-bit mode, the valid data in CRC_DAT register is only DATA[15:0].
N * @var CRC_T::SEED
N * Offset: 0x08  CRC Seed Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |SEED      |CRC Seed Value
N * |        |          |This field indicates the CRC seed value.
N * @var CRC_T::CHECKSUM
N * Offset: 0x0C  CRC Checksum Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |CHECKSUM  |CRC Checksum Results
N * |        |          |This field indicates the CRC checksum result.
N */
N
N    __IO uint32_t CTL;           /* Offset: 0x00  CRC Control Register                                               */
X    volatile uint32_t CTL;            
N    __IO uint32_t DAT;           /* Offset: 0x04  CRC Write Data Register                                            */
X    volatile uint32_t DAT;            
N    __IO uint32_t SEED;          /* Offset: 0x08  CRC Seed Register                                                  */
X    volatile uint32_t SEED;           
N    __I  uint32_t CHECKSUM;      /* Offset: 0x0C  CRC Checksum Register                                              */
X    volatile const  uint32_t CHECKSUM;       
N
N} CRC_T;
N
N
N
N/**
N    @addtogroup CRC_CONST CRC Bit Field Definition
N    Constant Definitions for CRC Controller
N@{ */
N
N#define CRC_CTL_CRCEN_Pos                (0)                                               /*!< CRC_T::CTL: CRCEN Position                */
N#define CRC_CTL_CRCEN_Msk                (0x1ul << CRC_CTL_CRCEN_Pos)                      /*!< CRC_T::CTL: CRCEN Mask                    */
N
N#define CRC_CTL_CRCRST_Pos               (1)                                               /*!< CRC_T::CTL: CRCRST Position               */
N#define CRC_CTL_CRCRST_Msk               (0x1ul << CRC_CTL_CRCRST_Pos)                     /*!< CRC_T::CTL: CRCRST Mask                   */
N
N#define CRC_CTL_DATREV_Pos               (24)                                              /*!< CRC_T::CTL: DATREV Position               */
N#define CRC_CTL_DATREV_Msk               (0x1ul << CRC_CTL_DATREV_Pos)                     /*!< CRC_T::CTL: DATREV Mask                   */
N
N#define CRC_CTL_CHKSREV_Pos              (25)                                              /*!< CRC_T::CTL: CHKSREV Position              */
N#define CRC_CTL_CHKSREV_Msk              (0x1ul << CRC_CTL_CHKSREV_Pos)                    /*!< CRC_T::CTL: CHKSREV Mask                  */
N
N#define CRC_CTL_DATFMT_Pos               (26)                                              /*!< CRC_T::CTL: DATFMT Position               */
N#define CRC_CTL_DATFMT_Msk               (0x1ul << CRC_CTL_DATFMT_Pos)                     /*!< CRC_T::CTL: DATFMT Mask                   */
N
N#define CRC_CTL_CHKSFMT_Pos              (27)                                              /*!< CRC_T::CTL: CHKSFMT Position              */
N#define CRC_CTL_CHKSFMT_Msk              (0x1ul << CRC_CTL_CHKSFMT_Pos)                    /*!< CRC_T::CTL: CHKSFMT Mask                  */
N
N#define CRC_CTL_DATLEN_Pos               (28)                                              /*!< CRC_T::CTL: DATLEN Position               */
N#define CRC_CTL_DATLEN_Msk               (0x3ul << CRC_CTL_DATLEN_Pos)                     /*!< CRC_T::CTL: DATLEN Mask                   */
N
N#define CRC_CTL_CRCMODE_Pos              (30)                                              /*!< CRC_T::CTL: CRCMODE Position              */
N#define CRC_CTL_CRCMODE_Msk              (0x3ul << CRC_CTL_CRCMODE_Pos)                    /*!< CRC_T::CTL: CRCMODE Mask                  */
N
N#define CRC_DAT_DATA_Pos                 (0)                                               /*!< CRC_T::DAT: DATA Position                 */
N#define CRC_DAT_DATA_Msk                 (0xfffffffful << CRC_DAT_DATA_Pos)                /*!< CRC_T::DAT: DATA Mask                     */
N
N#define CRC_SEED_SEED_Pos                (0)                                               /*!< CRC_T::SEED: SEED Position                */
N#define CRC_SEED_SEED_Msk                (0xfffffffful << CRC_SEED_SEED_Pos)               /*!< CRC_T::SEED: SEED Mask                    */
N
N#define CRC_CHECKSUM_CHECKSUM_Pos        (0)                                               /*!< CRC_T::CHECKSUM: CHECKSUM Position        */
N#define CRC_CHECKSUM_CHECKSUM_Msk        (0xfffffffful << CRC_CHECKSUM_CHECKSUM_Pos)       /*!< CRC_T::CHECKSUM: CHECKSUM Mask            */
N
N/**@}*/ /* CRC_CONST */
N/**@}*/ /* end of CRC register group */
N
N
N/*---------------------- Digital to Analog Converter -------------------------*/
N/**
N    @addtogroup DAC Digital to Analog Converter(DAC)
N    Memory Mapped Structure for DAC Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N
N/**
N * @var DAC_T::CTL
N * Offset: 0x00  DAC Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |DACEN     |DAC Enable Bit
N * |        |          |0 = DAC is Disabled.
N * |        |          |1 = DAC is Enabled.
N * |[1]     |DACIEN    |DAC Interrupt Enable Bit
N * |        |          |0 = Interrupt is Disabled.
N * |        |          |1 = Interrupt is Enabled.
N * |[2]     |DMAEN     |DMA Mode Enable Bit
N * |        |          |0 = DMA mode Disabled.
N * |        |          |1 = DMA mode Enabled.
N * |[3]     |DMAURIEN  |DMA Under-Run Interrupt Enable Bit
N * |        |          |0 = DMA under run interrupt Disabled.
N * |        |          |1 = DMA under run interrupt Enabled.
N * |[4]     |TRGEN     |Trigger Mode Enable Bit
N * |        |          |0 = DAC event trigger mode Disabled.
N * |        |          |1 = DAC event trigger mode Enabled.
N * |[7:5]   |TRGSEL    |Trigger Source Selection
N * |        |          |000 = Software trigger.
N * |        |          |001 = External pin STDAC trigger.
N * |        |          |010 = Timer 0 trigger.
N * |        |          |011 = Timer 1 trigger.
N * |        |          |100 = Timer 2 trigger.
N * |        |          |101 = Timer 3 trigger.
N * |        |          |110 = PWM0 trigger.
N * |        |          |111 = PWM1 trigger.
N * |[8]     |BYPASS    |Bypass Buffer Mode
N * |        |          |0 = Output voltage buffer Enabled.
N * |        |          |1 = Output voltage buffer Disabled.
N * |[10]    |LALIGN    |DAC Data Left-Aligned Enabled Control
N * |        |          |0 = Right alignment.
N * |        |          |1 = Left alignment.
N * |[13:12] |ETRGSEL   |External Pin Trigger Selection
N * |        |          |00 = Low level trigger.
N * |        |          |01 = High level trigger.
N * |        |          |10 = Falling edge trigger.
N * |        |          |11 = Rising edge trigger.
N * @var DAC_T::SWTRG
N * Offset: 0x04  DAC Software Trigger Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |SWTRG     |Software Trigger
N * |        |          |0 = Software trigger Disabled.
N * |        |          |1 = Software trigger Enabled.
N * |        |          |User writes this bit to generate one shot pulse and it is cleared to 0 by hardware automatically; Reading this bit will always get 0.
N * @var DAC_T::DAT
N * Offset: 0x08  DAC Data Holding Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |DAC_DAT   |DAC 12-Bit Holding Data
N * |        |          |These bits are written by user software which specifies 12-bit conversion data for DAC output.
N * |        |          |The unused bits (DAC_DAT[3:0] in left-alignment mode and DAC_DAT[15:12] in right alignment mode) are ignored by DAC controller hardware.
N * |        |          |12 bit left alignment: user has to load data into DAC_DAT[15:4] bits.
N * |        |          |12 bit right alignment: user has to load data into DAC_DAT[11:0] bits.
N * @var DAC_T::DATOUT
N * Offset: 0x0C  DAC Data Output Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |DATOUT    |DAC 12-Bit Output Data
N * |        |          |These bits are current digital data for DAC output conversion.
N * |        |          |It is loaded from DAC_DAT register and user cannot write it directly.
N * @var DAC_T::STATUS
N * Offset: 0x10  DAC Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |FINISH    |DAC Conversion Complete Finish Flag
N * |        |          |0 = DAC is in conversion state.
N * |        |          |1 = DAC conversion finish.
N * |        |          |This bit set to 1 when conversion time counter counts to SETTLET.
N * |        |          |It is cleared to 0 when DAC starts a new conversion.
N * |        |          |User writes 1 to clear this bit to 0.
N * |[1]     |DMAUDR    |DMA Under Run Interrupt Flag
N * |        |          |0 = No DMA under-run error condition occurred.
N * |        |          |1 = DMA under-run error condition occurred.
N * |        |          |User writes 1 to clear this bit.
N * |[8]     |BUSY      |DAC Busy Flag (Read Only)
N * |        |          |0 = DAC is ready for next conversion.
N * |        |          |1 = DAC is busy in conversion.
N * |        |          |This is read only bit.
N * @var DAC_T::TCTL
N * Offset: 0x14  DAC Timing Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[9:0]   |SETTLET   |DAC Output Settling Time
N * |        |          |User software needs to write appropriate value to these bits to meet DAC conversion settling time base on PCLK (APB clock) speed.
N * |        |          |For example, DAC controller clock speed is 72MHz and DAC conversion setting time is 1 us, SETTLET value must be greater than 0x48.
N */
N
N    __IO uint32_t CTL;           /* Offset: 0x00  DAC Control Register                                               */
X    volatile uint32_t CTL;            
N    __IO uint32_t SWTRG;         /* Offset: 0x04  DAC Software Trigger Control Register                              */
X    volatile uint32_t SWTRG;          
N    __IO uint32_t DAT;           /* Offset: 0x08  DAC Data Holding Register                                          */
X    volatile uint32_t DAT;            
N    __I  uint32_t DATOUT;        /* Offset: 0x0C  DAC Data Output Register                                           */
X    volatile const  uint32_t DATOUT;         
N    __IO uint32_t STATUS;        /* Offset: 0x10  DAC Status Register                                                */
X    volatile uint32_t STATUS;         
N    __IO uint32_t TCTL;          /* Offset: 0x14  DAC Timing Control Register                                        */
X    volatile uint32_t TCTL;           
N
N} DAC_T;
N
N
N
N/**
N    @addtogroup DAC_CONST DAC Bit Field Definition
N    Constant Definitions for DAC Controller
N@{ */
N
N#define DAC_CTL_DACEN_Pos                (0)                                               /*!< DAC_T::CTL: DACEN Position                */
N#define DAC_CTL_DACEN_Msk                (0x1ul << DAC_CTL_DACEN_Pos)                      /*!< DAC_T::CTL: DACEN Mask                    */
N
N#define DAC_CTL_DACIEN_Pos               (1)                                               /*!< DAC_T::CTL: DACIEN Position               */
N#define DAC_CTL_DACIEN_Msk               (0x1ul << DAC_CTL_DACIEN_Pos)                     /*!< DAC_T::CTL: DACIEN Mask                   */
N
N#define DAC_CTL_DMAEN_Pos                (2)                                               /*!< DAC_T::CTL: DMAEN Position                */
N#define DAC_CTL_DMAEN_Msk                (0x1ul << DAC_CTL_DMAEN_Pos)                      /*!< DAC_T::CTL: DMAEN Mask                    */
N
N#define DAC_CTL_DMAURIEN_Pos             (3)                                               /*!< DAC_T::CTL: DMAURIEN Position             */
N#define DAC_CTL_DMAURIEN_Msk             (0x1ul << DAC_CTL_DMAURIEN_Pos)                   /*!< DAC_T::CTL: DMAURIEN Mask                 */
N
N#define DAC_CTL_TRGEN_Pos                (4)                                               /*!< DAC_T::CTL: TRGEN Position                */
N#define DAC_CTL_TRGEN_Msk                (0x1ul << DAC_CTL_TRGEN_Pos)                      /*!< DAC_T::CTL: TRGEN Mask                    */
N
N#define DAC_CTL_TRGSEL_Pos               (5)                                               /*!< DAC_T::CTL: TRGSEL Position               */
N#define DAC_CTL_TRGSEL_Msk               (0x7ul << DAC_CTL_TRGSEL_Pos)                     /*!< DAC_T::CTL: TRGSEL Mask                   */
N
N#define DAC_CTL_BYPASS_Pos               (8)                                               /*!< DAC_T::CTL: BYPASS Position               */
N#define DAC_CTL_BYPASS_Msk               (0x1ul << DAC_CTL_BYPASS_Pos)                     /*!< DAC_T::CTL: BYPASS Mask                   */
N
N#define DAC_CTL_LALIGN_Pos               (10)                                              /*!< DAC_T::CTL: LALIGN Position               */
N#define DAC_CTL_LALIGN_Msk               (0x1ul << DAC_CTL_LALIGN_Pos)                     /*!< DAC_T::CTL: LALIGN Mask                   */
N
N#define DAC_CTL_ETRGSEL_Pos              (12)                                              /*!< DAC_T::CTL: ETRGSEL Position              */
N#define DAC_CTL_ETRGSEL_Msk              (0x3ul << DAC_CTL_ETRGSEL_Pos)                    /*!< DAC_T::CTL: ETRGSEL Mask                  */
N
N#define DAC_SWTRG_SWTRG_Pos              (0)                                               /*!< DAC_T::SWTRG: SWTRG Position              */
N#define DAC_SWTRG_SWTRG_Msk              (0x1ul << DAC_SWTRG_SWTRG_Pos)                    /*!< DAC_T::SWTRG: SWTRG Mask                  */
N
N#define DAC_DAT_DAC_DAT_Pos              (0)                                               /*!< DAC_T::DAT: DAC_DAT Position              */
N#define DAC_DAT_DAC_DAT_Msk              (0xfffful << DAC_DAT_DAC_DAT_Pos)                 /*!< DAC_T::DAT: DAC_DAT Mask                  */
N
N#define DAC_DATOUT_DATOUT_Pos            (0)                                               /*!< DAC_T::DATOUT: DATOUT Position            */
N#define DAC_DATOUT_DATOUT_Msk            (0xffful << DAC_DATOUT_DATOUT_Pos)                /*!< DAC_T::DATOUT: DATOUT Mask                */
N
N#define DAC_STATUS_FINISH_Pos            (0)                                               /*!< DAC_T::STATUS: FINISH Position            */
N#define DAC_STATUS_FINISH_Msk            (0x1ul << DAC_STATUS_FINISH_Pos)                  /*!< DAC_T::STATUS: FINISH Mask                */
N
N#define DAC_STATUS_DMAUDR_Pos            (1)                                               /*!< DAC_T::STATUS: DMAUDR Position            */
N#define DAC_STATUS_DMAUDR_Msk            (0x1ul << DAC_STATUS_DMAUDR_Pos)                  /*!< DAC_T::STATUS: DMAUDR Mask                */
N
N#define DAC_STATUS_BUSY_Pos              (8)                                               /*!< DAC_T::STATUS: BUSY Position              */
N#define DAC_STATUS_BUSY_Msk              (0x1ul << DAC_STATUS_BUSY_Pos)                    /*!< DAC_T::STATUS: BUSY Mask                  */
N
N#define DAC_TCTL_SETTLET_Pos             (0)                                               /*!< DAC_T::TCTL: SETTLET Position             */
N#define DAC_TCTL_SETTLET_Msk             (0x3fful << DAC_TCTL_SETTLET_Pos)                 /*!< DAC_T::TCTL: SETTLET Mask                 */
N
N/**@}*/ /* DAC_CONST */
N/**@}*/ /* end of DAC register group */
N
N
N/*---------------------- External Bus Interface Controller -------------------------*/
N/**
N    @addtogroup EBI External Bus Interface Controller(EBI)
N    Memory Mapped Structure for EBI Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N
N
N/**
N * @var EBI_T::CTL0
N * Offset: 0x00  External Bus Interface Bank0 Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |EN        |EBI Enable Bit
N * |        |          |This bit is the functional enable bit for EBI.
N * |        |          |0 = EBI function Disabled.
N * |        |          |1 = EBI function Enabled.
N * |[1]     |DW16      |EBI Data Width 16-Bit Select
N * |        |          |This bit defines if the EBI data width is 8-bit or 16-bit.
N * |        |          |0 = EBI data width is 8-bit.
N * |        |          |1 = EBI data width is 16-bit.
N * |[2]     |CSPOLINV  |Chip Select Pin Polar Inverse
N * |        |          |This bit defines the active level of EBI chip select pin (EBI_nCS).
N * |        |          |0 = Chip select pin (EBI_nCS) is active low.
N * |        |          |1 = Chip select pin (EBI_nCS) is active high.
N * |[10:8]  |MCLKDIV   |External Output Clock Divider
N * |        |          |The frequency of EBI output clock (MCLK) is controlled by MCLKDIV as follow:
N * |        |          |000 = HCLK/1.
N * |        |          |001 = HCLK/2.
N * |        |          |010 = HCLK/4.
N * |        |          |011 = HCLK/8.
N * |        |          |100 = HCLK/16.
N * |        |          |101 = HCLK/32.
N * |        |          |110 = Reserved.
N * |        |          |111 = Reserved.
N * |[18:16] |TALE      |Extend Time Of ALE
N * |        |          |The EBI_ALE high pulse period (tALE) to latch the address can be controlled by TALE.
N * |        |          |tALE = (TALE+1)*EBI_MCLK.
N * |        |          |Note: This field only available in EBI_CTL0 register
N * |[24]    |WBUFEN    |EBI Write Buffer Enable Bit
N * |        |          |0 = EBI write buffer Disabled.
N * |        |          |1 = EBI write buffer Enabled.
N * |        |          |Note: This bit only available in EBI_CTL0 register
N * @var EBI_T::TCTL0
N * Offset: 0x04  External Bus Interface Bank0 Timing Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:3]   |TACC      |EBI Data Access Time
N * |        |          |TACC define data access time (tACC).
N * |        |          |tACC = (TACC +1) * EBI_MCLK.
N * |[10:8]  |TAHD      |EBI Data Access Hold Time
N * |        |          |TAHD define data access hold time (tAHD).
N * |        |          |tAHD = (TAHD +1) * EBI_MCLK.
N * |[15:12] |W2X       |Idle Cycle After Write
N * |        |          |This field defines the number of W2X idle cycle.
N * |        |          |W2X idle cycle = (W2X * EBI_MCLK).
N * |        |          |When write action is finish, W2X idle cycle is inserted and EBI_nCS return to idle state.
N * |[22]    |RAHDOFF   |Access Hold Time Disable Control When Read
N * |        |          |0 = The Data Access Hold Time (tAHD) during EBI reading is Enabled.
N * |        |          |1 = The Data Access Hold Time (tAHD) during EBI reading is Disabled.
N * |[23]    |WAHDOFF   |Access Hold Time Disable Control When Write
N * |        |          |0 = The Data Access Hold Time (tAHD) during EBI writing is Enabled.
N * |        |          |1 = The Data Access Hold Time (tAHD) during EBI writing is Disabled.
N * |[27:24] |R2R       |Idle Cycle Between Read-To-Read
N * |        |          |This field defines the number of R2R idle cycle.
N * |        |          |R2R idle cycle = (R2R * EBI_MCLK).
N * |        |          |When read action is finish and next action is going to read, R2R idle cycle is inserted and EBI_nCS return to idle state.
N * @var EBI_T::CTL1
N * Offset: 0x10  External Bus Interface Bank1 Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |EN        |EBI Enable Bit
N * |        |          |This bit is the functional enable bit for EBI.
N * |        |          |0 = EBI function Disabled.
N * |        |          |1 = EBI function Enabled.
N * |[1]     |DW16      |EBI Data Width 16-Bit Select
N * |        |          |This bit defines if the EBI data width is 8-bit or 16-bit.
N * |        |          |0 = EBI data width is 8-bit.
N * |        |          |1 = EBI data width is 16-bit.
N * |[2]     |CSPOLINV  |Chip Select Pin Polar Inverse
N * |        |          |This bit defines the active level of EBI chip select pin (EBI_nCS).
N * |        |          |0 = Chip select pin (EBI_nCS) is active low.
N * |        |          |1 = Chip select pin (EBI_nCS) is active high.
N * |[10:8]  |MCLKDIV   |External Output Clock Divider
N * |        |          |The frequency of EBI output clock (MCLK) is controlled by MCLKDIV as follow:
N * |        |          |000 = HCLK/1.
N * |        |          |001 = HCLK/2.
N * |        |          |010 = HCLK/4.
N * |        |          |011 = HCLK/8.
N * |        |          |100 = HCLK/16.
N * |        |          |101 = HCLK/32.
N * |        |          |110 = Reserved.
N * |        |          |111 = Reserved.
N * |[18:16] |TALE      |Extend Time Of ALE
N * |        |          |The EBI_ALE high pulse period (tALE) to latch the address can be controlled by TALE.
N * |        |          |tALE = (TALE+1)*EBI_MCLK.
N * |        |          |Note: This field only available in EBI_CTL0 register
N * |[24]    |WBUFEN    |EBI Write Buffer Enable Bit
N * |        |          |0 = EBI write buffer Disabled.
N * |        |          |1 = EBI write buffer Enabled.
N * |        |          |Note: This bit only available in EBI_CTL0 register
N * @var EBI_T::TCTL1
N * Offset: 0x14  External Bus Interface Bank1 Timing Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:3]   |TACC      |EBI Data Access Time
N * |        |          |TACC define data access time (tACC).
N * |        |          |tACC = (TACC +1) * EBI_MCLK.
N * |[10:8]  |TAHD      |EBI Data Access Hold Time
N * |        |          |TAHD define data access hold time (tAHD).
N * |        |          |tAHD = (TAHD +1) * EBI_MCLK.
N * |[15:12] |W2X       |Idle Cycle After Write
N * |        |          |This field defines the number of W2X idle cycle.
N * |        |          |W2X idle cycle = (W2X * EBI_MCLK).
N * |        |          |When write action is finish, W2X idle cycle is inserted and EBI_nCS return to idle state.
N * |[22]    |RAHDOFF   |Access Hold Time Disable Control When Read
N * |        |          |0 = The Data Access Hold Time (tAHD) during EBI reading is Enabled.
N * |        |          |1 = The Data Access Hold Time (tAHD) during EBI reading is Disabled.
N * |[23]    |WAHDOFF   |Access Hold Time Disable Control When Write
N * |        |          |0 = The Data Access Hold Time (tAHD) during EBI writing is Enabled.
N * |        |          |1 = The Data Access Hold Time (tAHD) during EBI writing is Disabled.
N * |[27:24] |R2R       |Idle Cycle Between Read-To-Read
N * |        |          |This field defines the number of R2R idle cycle.
N * |        |          |R2R idle cycle = (R2R * EBI_MCLK).
N * |        |          |When read action is finish and next action is going to read, R2R idle cycle is inserted and EBI_nCS return to idle state.
N */
N
N    __IO uint32_t CTL0;          /* Offset: 0x00  External Bus Interface Bank0 Control Register                      */
X    volatile uint32_t CTL0;           
N    __IO uint32_t TCTL0;         /* Offset: 0x04  External Bus Interface Bank0 Timing Control Register               */
X    volatile uint32_t TCTL0;          
N    __I  uint32_t RESERVE0[2];  
X    volatile const  uint32_t RESERVE0[2];  
N    __IO uint32_t CTL1;          /* Offset: 0x10  External Bus Interface Bank1 Control Register                      */
X    volatile uint32_t CTL1;           
N    __IO uint32_t TCTL1;         /* Offset: 0x14  External Bus Interface Bank1 Timing Control Register               */
X    volatile uint32_t TCTL1;          
N
N} EBI_T;
N
N
N
N/**
N    @addtogroup EBI_CONST EBI Bit Field Definition
N    Constant Definitions for EBI Controller
N@{ */
N
N#define EBI_CTL0_EN_Pos                  (0)                                               /*!< EBI_T::CTL0: EN Position                  */
N#define EBI_CTL0_EN_Msk                  (0x1ul << EBI_CTL0_EN_Pos)                        /*!< EBI_T::CTL0: EN Mask                      */
N
N#define EBI_CTL0_DW16_Pos                (1)                                               /*!< EBI_T::CTL0: DW16 Position                */
N#define EBI_CTL0_DW16_Msk                (0x1ul << EBI_CTL0_DW16_Pos)                      /*!< EBI_T::CTL0: DW16 Mask                    */
N
N#define EBI_CTL0_CSPOLINV_Pos            (2)                                               /*!< EBI_T::CTL0: CSPOLINV Position            */
N#define EBI_CTL0_CSPOLINV_Msk            (0x1ul << EBI_CTL0_CSPOLINV_Pos)                  /*!< EBI_T::CTL0: CSPOLINV Mask                */
N
N#define EBI_CTL0_MCLKDIV_Pos             (8)                                               /*!< EBI_T::CTL0: MCLKDIV Position             */
N#define EBI_CTL0_MCLKDIV_Msk             (0x7ul << EBI_CTL0_MCLKDIV_Pos)                   /*!< EBI_T::CTL0: MCLKDIV Mask                 */
N
N#define EBI_CTL0_TALE_Pos                (16)                                              /*!< EBI_T::CTL0: TALE Position                */
N#define EBI_CTL0_TALE_Msk                (0x7ul << EBI_CTL0_TALE_Pos)                      /*!< EBI_T::CTL0: TALE Mask                    */
N
N#define EBI_CTL0_WBUFEN_Pos              (24)                                              /*!< EBI_T::CTL0: WBUFEN Position              */
N#define EBI_CTL0_WBUFEN_Msk              (0x1ul << EBI_CTL0_WBUFEN_Pos)                    /*!< EBI_T::CTL0: WBUFEN Mask                  */
N
N#define EBI_TCTL0_TACC_Pos               (3)                                               /*!< EBI_T::TCTL0: TACC Position               */
N#define EBI_TCTL0_TACC_Msk               (0x1ful << EBI_TCTL0_TACC_Pos)                    /*!< EBI_T::TCTL0: TACC Mask                   */
N
N#define EBI_TCTL0_TAHD_Pos               (8)                                               /*!< EBI_T::TCTL0: TAHD Position               */
N#define EBI_TCTL0_TAHD_Msk               (0x7ul << EBI_TCTL0_TAHD_Pos)                     /*!< EBI_T::TCTL0: TAHD Mask                   */
N
N#define EBI_TCTL0_W2X_Pos                (12)                                              /*!< EBI_T::TCTL0: W2X Position                */
N#define EBI_TCTL0_W2X_Msk                (0xful << EBI_TCTL0_W2X_Pos)                      /*!< EBI_T::TCTL0: W2X Mask                    */
N
N#define EBI_TCTL0_RAHDOFF_Pos            (22)                                              /*!< EBI_T::TCTL0: RAHDOFF Position            */
N#define EBI_TCTL0_RAHDOFF_Msk            (0x1ul << EBI_TCTL0_RAHDOFF_Pos)                  /*!< EBI_T::TCTL0: RAHDOFF Mask                */
N
N#define EBI_TCTL0_WAHDOFF_Pos            (23)                                              /*!< EBI_T::TCTL0: WAHDOFF Position            */
N#define EBI_TCTL0_WAHDOFF_Msk            (0x1ul << EBI_TCTL0_WAHDOFF_Pos)                  /*!< EBI_T::TCTL0: WAHDOFF Mask                */
N
N#define EBI_TCTL0_R2R_Pos                (24)                                              /*!< EBI_T::TCTL0: R2R Position                */
N#define EBI_TCTL0_R2R_Msk                (0xful << EBI_TCTL0_R2R_Pos)                      /*!< EBI_T::TCTL0: R2R Mask                    */
N
N#define EBI_CTL1_EN_Pos                  (0)                                               /*!< EBI_T::CTL1: EN Position                  */
N#define EBI_CTL1_EN_Msk                  (0x1ul << EBI_CTL1_EN_Pos)                        /*!< EBI_T::CTL1: EN Mask                      */
N
N#define EBI_CTL1_DW16_Pos                (1)                                               /*!< EBI_T::CTL1: DW16 Position                */
N#define EBI_CTL1_DW16_Msk                (0x1ul << EBI_CTL1_DW16_Pos)                      /*!< EBI_T::CTL1: DW16 Mask                    */
N
N#define EBI_CTL1_CSPOLINV_Pos            (2)                                               /*!< EBI_T::CTL1: CSPOLINV Position            */
N#define EBI_CTL1_CSPOLINV_Msk            (0x1ul << EBI_CTL1_CSPOLINV_Pos)                  /*!< EBI_T::CTL1: CSPOLINV Mask                */
N
N#define EBI_CTL1_MCLKDIV_Pos             (8)                                               /*!< EBI_T::CTL1: MCLKDIV Position             */
N#define EBI_CTL1_MCLKDIV_Msk             (0x7ul << EBI_CTL1_MCLKDIV_Pos)                   /*!< EBI_T::CTL1: MCLKDIV Mask                 */
N
N#define EBI_CTL1_TALE_Pos                (16)                                              /*!< EBI_T::CTL1: TALE Position                */
N#define EBI_CTL1_TALE_Msk                (0x7ul << EBI_CTL1_TALE_Pos)                      /*!< EBI_T::CTL1: TALE Mask                    */
N
N#define EBI_CTL1_WBUFEN_Pos              (24)                                              /*!< EBI_T::CTL1: WBUFEN Position              */
N#define EBI_CTL1_WBUFEN_Msk              (0x1ul << EBI_CTL1_WBUFEN_Pos)                    /*!< EBI_T::CTL1: WBUFEN Mask                  */
N
N#define EBI_TCTL1_TACC_Pos               (3)                                               /*!< EBI_T::TCTL1: TACC Position               */
N#define EBI_TCTL1_TACC_Msk               (0x1ful << EBI_TCTL1_TACC_Pos)                    /*!< EBI_T::TCTL1: TACC Mask                   */
N
N#define EBI_TCTL1_TAHD_Pos               (8)                                               /*!< EBI_T::TCTL1: TAHD Position               */
N#define EBI_TCTL1_TAHD_Msk               (0x7ul << EBI_TCTL1_TAHD_Pos)                     /*!< EBI_T::TCTL1: TAHD Mask                   */
N
N#define EBI_TCTL1_W2X_Pos                (12)                                              /*!< EBI_T::TCTL1: W2X Position                */
N#define EBI_TCTL1_W2X_Msk                (0xful << EBI_TCTL1_W2X_Pos)                      /*!< EBI_T::TCTL1: W2X Mask                    */
N
N#define EBI_TCTL1_RAHDOFF_Pos            (22)                                              /*!< EBI_T::TCTL1: RAHDOFF Position            */
N#define EBI_TCTL1_RAHDOFF_Msk            (0x1ul << EBI_TCTL1_RAHDOFF_Pos)                  /*!< EBI_T::TCTL1: RAHDOFF Mask                */
N
N#define EBI_TCTL1_WAHDOFF_Pos            (23)                                              /*!< EBI_T::TCTL1: WAHDOFF Position            */
N#define EBI_TCTL1_WAHDOFF_Msk            (0x1ul << EBI_TCTL1_WAHDOFF_Pos)                  /*!< EBI_T::TCTL1: WAHDOFF Mask                */
N
N#define EBI_TCTL1_R2R_Pos                (24)                                              /*!< EBI_T::TCTL1: R2R Position                */
N#define EBI_TCTL1_R2R_Msk                (0xful << EBI_TCTL1_R2R_Pos)                      /*!< EBI_T::TCTL1: R2R Mask                    */
N
N/**@}*/ /* EBI_CONST */
N/**@}*/ /* end of EBI register group */
N
N
N/*---------------------- Flash Memory Controller -------------------------*/
N/**
N    @addtogroup FMC Flash Memory Controller(FMC)
N    Memory Mapped Structure for FMC Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N
N
N/**
N * @var FMC_T::ISPCTL
N * Offset: 0x00  ISP Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ISPEN     |ISP Enable Bit (Write Protect)
N * |        |          |ISP function enable bit. Set this bit to enable ISP function.
N * |        |          |0 = ISP function Disabled.
N * |        |          |1 = ISP function Enabled.
N * |[1]     |BS        |Boot Select (Write Protect)
N * |        |          |When MBS in CONFIG0 is 1, set/clear this bit to select next booting from LDROM/APROM, respectively.
N * |        |          |This bit also functions as chip booting status flag, which can be used to check where chip booted from.
N * |        |          |This bit is initiated with the inverted value of CBS[1] (CONFIG0[7]) after any reset is happened except CPU reset (CPU is 1) or system reset (SYS) is happened.
N * |        |          |0 = Booting from APROM when MBS (CONFIG0[5]) is 1.
N * |        |          |1 = Booting from LDROM when MBS (CONFIG0[5]) is 1.
N * |[3]     |APUEN     |APROM Update Enable Bit (Write Protect)
N * |        |          |0 = APROM cannot be updated when the chip runs in APROM.
N * |        |          |1 = APROM can be updated when the chip runs in APROM.
N * |[4]     |CFGUEN    |CONFIG Update Enable Bit (Write Protect)
N * |        |          |0 = CONFIG cannot be updated.
N * |        |          |1 = CONFIG can be updated.
N * |[5]     |LDUEN     |LDROM Update Enable Bit (Write Protect)
N * |        |          |LDROM update enable bit.
N * |        |          |0 = LDROM cannot be updated.
N * |        |          |1 = LDROM can be updated.
N * |[6]     |ISPFF     |ISP Fail Flag (Write Protect)
N * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
N * |        |          |This bit needs to be cleared by writing 1 to it.
N * |        |          |(1) APROM writes to itself if APUEN is set to 0.
N * |        |          |(2) LDROM writes to itself if LDUEN is set to 0.
N * |        |          |(3) CONFIG is erased/programmed if CFGUEN is set to 0.
N * |        |          |(4) SPROM is erased/programmed if SPUEN is set to 0
N * |        |          |(5) SPROM is programmed at SPROM secured mode.
N * |        |          |(6) Page Erase command at LOCK mode with ICE connection
N * |        |          |(7) Erase or Program command at brown-out detected
N * |        |          |(8) Destination address is illegal, such as over an available range.
N * |        |          |(9) Invalid ISP commands
N * |[16]    |BL        |Boot Loader Booting (Write Protect)
N * |        |          |This bit is initiated with the inverted value of MBS (CONFIG0[5]).
N * |        |          |Any reset, except CPU reset (CPU is 1) or system reset (SYS), BL will be reloaded.
N * |        |          |This bit is used to check chip boot from Boot Loader or not.
N * |        |          |User should keep original value of this bit when updating FMC_ISPCTL register.
N * |        |          |0 = Booting from APROM or LDROM.
N * |        |          |1 = Booting from Boot Loader.
N * @var FMC_T::ISPADDR
N * Offset: 0x04  ISP Address Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |ISPADDR   |ISP Address
N * |        |          |The NuMicro M451 series is equipped with embedded flash.
N * |        |          |ISPADDR[1:0] must be kept 00 for ISP 32-bit operation.
N * |        |          |ISPADDR[2:0] must be kept 000 for ISP 64-bit operation.
N * |        |          |For Checksum Calculation command, this field is the flash starting address for checksum calculation, 2 Kbytes alignment is necessary for checksum calculation.
N * @var FMC_T::ISPDAT
N * Offset: 0x08  ISP Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |ISPDAT    |ISP Data
N * |        |          |Write data to this register before ISP program operation.
N * |        |          |Read data from this register after ISP read operation.
N * |        |          |For Run Checksum Calculation command, ISPDAT is the memory size (byte) and 2 Kbytes alignment.
N * |        |          |For ISP Read Checksum command, ISPDAT is the checksum result.
N * |        |          |If ISPDAT = 0x0000_0000, it means that (1) the checksum calculation is in progress, (2) the memory range for checksum calculation is incorrect, or (3) all of data are 0.
N * @var FMC_T::ISPCMD
N * Offset: 0x0C  ISP CMD Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[6:0]   |CMD       |ISP CMD
N * |        |          |ISP command table is shown below:
N * |        |          |0x00= FLASH Read.
N * |        |          |0x04= Read Unique ID.
N * |        |          |0x0B= Read Company ID.
N * |        |          |0x0C= Read Device ID.
N * |        |          |0x0D= Read Checksum.
N * |        |          |0x21= FLASH 32-bit Program.
N * |        |          |0x22= FLASH Page Erase.
N * |        |          |0x27= FLASH Multi-Word Program.
N * |        |          |0x2D= Run Checksum Calculation.
N * |        |          |0x2E= Vector Remap.
N * |        |          |0x61= FLASH 64-bit Program.
N * |        |          |The other commands are invalid.
N * @var FMC_T::ISPTRG
N * Offset: 0x10  ISP Trigger Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ISPGO     |ISP Start Trigger (Write Protect)
N * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.
N * |        |          |0 = ISP operation is finished.
N * |        |          |1 = ISP is progressed.
N * @var FMC_T::DFBA
N * Offset: 0x14  Data Flash Base Address
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |DFBA      |Data Flash Base Address
N * |        |          |This register indicates Data Flash start address. It is a read only register.
N * |        |          |The Data Flash is shared with APROM. the content of this register is loaded from CONFIG1
N * |        |          |This register is valid when DFEN (CONFIG0[0]) =0 .
N * @var FMC_T::FTCTL
N * Offset: 0x18  Flash Access Time Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[6:4]   |FOM       |Frequency Optimization Mode (Write Protect)
N * |        |          |The NuMicro M451 series support adjustable flash access timing to optimize the flash access cycles in different working frequency.
N * |        |          |001 = Frequency <= 12MHz.
N * |        |          |010 = Frequency <= 36MHz.
N * |        |          |100 = Frequency <= 60MHz.
N * |        |          |Others = Frequency <= 72MHz.
N * @var FMC_T::ISPSTS
N * Offset: 0x40  ISP Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ISPBUSY   |ISP Busy Flag (Read Only)
N * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.
N * |        |          |This bit is the mirror of ISPGO(FMC_ISPTRG[0]).
N * |        |          |0 = ISP operation is finished.
N * |        |          |1 = ISP is progressed.
N * |[2:1]   |CBS       |Boot Selection Of CONFIG (Read Only)
N * |        |          |This bit is initiated with the CBS (CONFIG0[7:6]) after any reset is happened except CPU reset (CPU is 1) or system reset (SYS) is happened.
N * |        |          |The following function is valid when MBS (FMC_ISPSTS[3])= 1.
N * |        |          |00 = LDROM with IAP mode.
N * |        |          |01 = LDROM without IAP mode.
N * |        |          |10 = APROM with IAP mode.
N * |        |          |11 = APROM without IAP mode.
N * |[3]     |MBS       |Boot From Boot Loader Selection Flag (Read Only)
N * |        |          |This bit is initiated with the MBS (CONFIG0[5]) after any reset is happened except CPU reset (CPU is 1) or system reset (SYS) is happened
N * |        |          |0 = Booting from Boot Loader.
N * |        |          |1 = Booting
N * |        |          |from LDROM/APROM.(see CBS bit setting)
N * |[5]     |PGFF      |Flash Program With Fast Verification Flag (Read Only)
N * |        |          |This bit is set if data is mismatched at ISP programming verification.
N * |        |          |This bit is clear by performing ISP flash erase or ISP read CID operation.
N * |        |          |0 = Flash Program is success.
N * |        |          |1 = Flash Program is fail. Program data is different with data in the flash memory
N * |[6]     |ISPFF     |ISP Fail Flag (Write Protect)
N * |        |          |This bit is the mirror of ISPFF (FMC_ISPCTL[6]), it needs to be cleared by writing 1 to FMC_ISPCTL[6] or FMC_ISPSTS[6].
N * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
N * |        |          |(1) APROM writes to itself if APUEN is set to 0.
N * |        |          |(2) LDROM writes to itself if LDUEN is set to 0.
N * |        |          |(3) CONFIG is erased/programmed if CFGUEN is set to 0.
N * |        |          |(4) SPROM is erased/programmed if SPUEN is set to 0
N * |        |          |(5) SPROM is programmed at SPROM secured mode.
N * |        |          |(6) Page Erase command at LOCK mode with ICE connection
N * |        |          |(7) Erase or Program command at brown-out detected
N * |        |          |(8) Destination address is illegal, such as over an available range.
N * |        |          |(9) Invalid ISP commands
N * |[23:9]  |VECMAP    |Vector Page Mapping Address (Read Only)
N * |        |          |All access to 0x0000_0000~0x0000_01FF is remapped to the flash memory address {VECMAP[14:0], 9'h000} ~ {VECMAP[14:0], 9'h1FF}
N * @var FMC_T::MPDAT0
N * Offset: 0x80  ISP Data0 Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |ISPDAT0   |ISP Data 0
N * |        |          |This register is the first 32-bit data for 32-bit/64-bit/multi-word programming, and it is also the mirror of FMC_ISPDAT, both registers keep the same data
N * @var FMC_T::MPDAT1
N * Offset: 0x84  ISP Data1 Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |ISPDAT1   |ISP Data 1
N * |        |          |This register is the second 32-bit data for 64-bit/multi-word programming.
N * @var FMC_T::MPDAT2
N * Offset: 0x88  ISP Data2 Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |ISPDAT2   |ISP Data 2
N * |        |          |This register is the third 32-bit data for multi-word programming.
N * @var FMC_T::MPDAT3
N * Offset: 0x8C  ISP Data3 Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |ISPDAT3   |ISP Data 3
N * |        |          |This register is the fourth 32-bit data for multi-word programming.
N * @var FMC_T::MPSTS
N * Offset: 0xC0  ISP Multi-Program Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |MPBUSY    |ISP Multi-Word Program Busy Flag (Read Only)
N * |        |          |Write 1 to start ISP Multi-Word program operation and this bit will be cleared to 0 by hardware automatically when ISP Multi-Word program operation is finished.
N * |        |          |This bit is the mirror of ISPGO(FMC_ISPTRG[0]).
N * |        |          |0 = ISP Multi-Word program operation is finished.
N * |        |          |1 = ISP Multi-Word program operation
N * |        |          |is progressed.
N * |[1]     |PPGO      |ISP Multi-Program Status (Read Only)
N * |        |          |0 = ISP multi-word program operation is not active.
N * |        |          |1 = ISP multi-word program operation is in progress.
N * |[2]     |ISPFF     |ISP Fail Flag (Read Only)
N * |        |          |This bit is the mirror of ISPFF (FMC_ISPCTL[6]), it needs to be cleared by writing 1 to FMC_ISPCTL[6] or FMC_ISPSTS[6].
N * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
N * |        |          |(1) APROM writes to itself if APUEN is set to 0.
N * |        |          |(2) LDROM writes to itself if LDUEN is set to 0.
N * |        |          |(3) CONFIG is erased/programmed if CFGUEN is set to 0.
N * |        |          |(4) SPROM is erased/programmed if SPUEN is set to 0
N * |        |          |(5) SPROM is programmed at SPROM secured mode.
N * |        |          |(6) Page Erase command at LOCK mode with ICE connection
N * |        |          |(7) Erase or Program command at brown-out detected
N * |        |          |(8) Destination address is illegal, such as over an available range.
N * |        |          |(9) Invalid ISP commands
N * |[4]     |D0        |ISP DATA 0 Flag (Read Only)
N * |        |          |This bit is set when FMC_MPDAT0 is written and auto-clear to 0 when the FMC_MPDAT0 data is programmed to flash complete.
N * |        |          |0 = FMC_MPDAT0 register is empty, or program to flash complete.
N * |        |          |1 = FMC_MPDAT0 register has been written, and not program to flash complete.
N * |[5]     |D1        |ISP DATA 1 Flag (Read Only)
N * |        |          |This bit is set when FMC_MPDAT1 is written and auto-clear to 0 when the FMC_MPDAT1 data is programmed to flash complete.
N * |        |          |0 = FMC_MPDAT1 register is empty, or program to flash complete.
N * |        |          |1 = FMC_MPDAT1 register has been written, and not program to flash complete.
N * |[6]     |D2        |ISP DATA 2 Flag (Read Only)
N * |        |          |This bit is set when FMC_MPDAT2 is written and auto-clear to 0 when the FMC_MPDAT2 data is programmed to flash complete.
N * |        |          |0 = FMC_MPDAT2 register is empty, or program to flash complete.
N * |        |          |1 = FMC_MPDAT2 register has been written, and not program to flash complete.
N * |[7]     |D3        |ISP DATA 3 Flag (Read Only)
N * |        |          |This bit is set when FMC_MPDAT3 is written and auto-clear to 0 when the FMC_MPDAT3 data is programmed to flash complete.
N * |        |          |0 = FMC_MPDAT3 register is empty, or program to flash complete.
N * |        |          |1 = FMC_MPDAT3 register has been written, and not program to flash complete.
N * @var FMC_T::MPADDR
N * Offset: 0xC4  ISP Multi-Program Address Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |MPADDR    |ISP Multi-Word Program Address
N * |        |          |MPADDR is the address of ISP multi-word program operation when ISPGO flag is 1.
N * |        |          |MPADDR will keep the final ISP address when ISP multi-word program is complete.
N    */
N
N    __IO uint32_t ISPCTL;        /* Offset: 0x00  ISP Control Register                                               */
X    volatile uint32_t ISPCTL;         
N    __IO uint32_t ISPADDR;       /* Offset: 0x04  ISP Address Register                                               */
X    volatile uint32_t ISPADDR;        
N    __IO uint32_t ISPDAT;        /* Offset: 0x08  ISP Data Register                                                  */
X    volatile uint32_t ISPDAT;         
N    __IO uint32_t ISPCMD;        /* Offset: 0x0C  ISP CMD Register                                                   */
X    volatile uint32_t ISPCMD;         
N    __IO uint32_t ISPTRG;        /* Offset: 0x10  ISP Trigger Control Register                                       */
X    volatile uint32_t ISPTRG;         
N    __I  uint32_t DFBA;          /* Offset: 0x14  Data Flash Base Address                                            */
X    volatile const  uint32_t DFBA;           
N    __IO uint32_t FTCTL;         /* Offset: 0x18  Flash Access Time Control Register                                 */
X    volatile uint32_t FTCTL;          
N    __I  uint32_t RESERVE0[9];  
X    volatile const  uint32_t RESERVE0[9];  
N    __I  uint32_t ISPSTS;        /* Offset: 0x40  ISP Status Register                                                */
X    volatile const  uint32_t ISPSTS;         
N    __I  uint32_t RESERVE1[15]; 
X    volatile const  uint32_t RESERVE1[15]; 
N    __IO uint32_t MPDAT0;        /* Offset: 0x80  ISP Data0 Register                                                 */
X    volatile uint32_t MPDAT0;         
N    __IO uint32_t MPDAT1;        /* Offset: 0x84  ISP Data1 Register                                                 */
X    volatile uint32_t MPDAT1;         
N    __IO uint32_t MPDAT2;        /* Offset: 0x88  ISP Data2 Register                                                 */
X    volatile uint32_t MPDAT2;         
N    __IO uint32_t MPDAT3;        /* Offset: 0x8C  ISP Data3 Register                                                 */
X    volatile uint32_t MPDAT3;         
N    __I  uint32_t RESERVE2[12]; 
X    volatile const  uint32_t RESERVE2[12]; 
N    __I  uint32_t MPSTS;         /* Offset: 0xC0  ISP Multi-Program Status Register                                  */
X    volatile const  uint32_t MPSTS;          
N    __I  uint32_t MPADDR;        /* Offset: 0xC4  ISP Multi-Program Address Register                                 */
X    volatile const  uint32_t MPADDR;         
N
N} FMC_T;
N
N
N
N
N/**
N    @addtogroup FMC_CONST FMC Bit Field Definition
N    Constant Definitions for FMC Controller
N@{ */
N
N#define FMC_ISPCTL_ISPEN_Pos             (0)                                               /*!< FMC_T::ISPCTL: ISPEN Position             */
N#define FMC_ISPCTL_ISPEN_Msk             (0x1ul << FMC_ISPCTL_ISPEN_Pos)                   /*!< FMC_T::ISPCTL: ISPEN Mask                 */
N
N#define FMC_ISPCTL_BS_Pos                (1)                                               /*!< FMC_T::ISPCTL: BS Position                */
N#define FMC_ISPCTL_BS_Msk                (0x1ul << FMC_ISPCTL_BS_Pos)                      /*!< FMC_T::ISPCTL: BS Mask                    */
N
N#define FMC_ISPCTL_APUEN_Pos             (3)                                               /*!< FMC_T::ISPCTL: APUEN Position             */
N#define FMC_ISPCTL_APUEN_Msk             (0x1ul << FMC_ISPCTL_APUEN_Pos)                   /*!< FMC_T::ISPCTL: APUEN Mask                 */
N
N#define FMC_ISPCTL_CFGUEN_Pos            (4)                                               /*!< FMC_T::ISPCTL: CFGUEN Position            */
N#define FMC_ISPCTL_CFGUEN_Msk            (0x1ul << FMC_ISPCTL_CFGUEN_Pos)                  /*!< FMC_T::ISPCTL: CFGUEN Mask                */
N
N#define FMC_ISPCTL_LDUEN_Pos             (5)                                               /*!< FMC_T::ISPCTL: LDUEN Position             */
N#define FMC_ISPCTL_LDUEN_Msk             (0x1ul << FMC_ISPCTL_LDUEN_Pos)                   /*!< FMC_T::ISPCTL: LDUEN Mask                 */
N
N#define FMC_ISPCTL_ISPFF_Pos             (6)                                               /*!< FMC_T::ISPCTL: ISPFF Position             */
N#define FMC_ISPCTL_ISPFF_Msk             (0x1ul << FMC_ISPCTL_ISPFF_Pos)                   /*!< FMC_T::ISPCTL: ISPFF Mask                 */
N
N#define FMC_ISPCTL_BL_Pos                (16)                                              /*!< FMC_T::ISPCTL: BL Position                */
N#define FMC_ISPCTL_BL_Msk                (0x1ul << FMC_ISPCTL_BL_Pos)                      /*!< FMC_T::ISPCTL: BL Mask                    */
N
N#define FMC_ISPADDR_ISPADDR_Pos          (0)                                               /*!< FMC_T::ISPADDR: ISPADDR Position          */
N#define FMC_ISPADDR_ISPADDR_Msk          (0xfffffffful << FMC_ISPADDR_ISPADDR_Pos)         /*!< FMC_T::ISPADDR: ISPADDR Mask              */
N
N#define FMC_ISPDAT_ISPDAT_Pos            (0)                                               /*!< FMC_T::ISPDAT: ISPDAT Position            */
N#define FMC_ISPDAT_ISPDAT_Msk            (0xfffffffful << FMC_ISPDAT_ISPDAT_Pos)           /*!< FMC_T::ISPDAT: ISPDAT Mask                */
N
N#define FMC_ISPCMD_CMD_Pos               (0)                                               /*!< FMC_T::ISPCMD: CMD Position               */
N#define FMC_ISPCMD_CMD_Msk               (0x7ful << FMC_ISPCMD_CMD_Pos)                    /*!< FMC_T::ISPCMD: CMD Mask                   */
N
N#define FMC_ISPTRG_ISPGO_Pos             (0)                                               /*!< FMC_T::ISPTRG: ISPGO Position             */
N#define FMC_ISPTRG_ISPGO_Msk             (0x1ul << FMC_ISPTRG_ISPGO_Pos)                   /*!< FMC_T::ISPTRG: ISPGO Mask                 */
N
N#define FMC_DFBA_DFBA_Pos                (0)                                               /*!< FMC_T::DFBA: DFBA Position                */
N#define FMC_DFBA_DFBA_Msk                (0xfffffffful << FMC_DFBA_DFBA_Pos)               /*!< FMC_T::DFBA: DFBA Mask                    */
N
N#define FMC_FTCTL_FOM_Pos                (4)                                               /*!< FMC_T::FTCTL: FOM Position                */
N#define FMC_FTCTL_FOM_Msk                (0x7ul << FMC_FTCTL_FOM_Pos)                      /*!< FMC_T::FTCTL: FOM Mask                    */
N
N#define FMC_ISPSTS_ISPBUSY_Pos           (0)                                               /*!< FMC_T::ISPSTS: ISPBUSY Position           */
N#define FMC_ISPSTS_ISPBUSY_Msk           (0x1ul << FMC_ISPSTS_ISPBUSY_Pos)                 /*!< FMC_T::ISPSTS: ISPBUSY Mask               */
N
N#define FMC_ISPSTS_CBS_Pos               (1)                                               /*!< FMC_T::ISPSTS: CBS Position               */
N#define FMC_ISPSTS_CBS_Msk               (0x3ul << FMC_ISPSTS_CBS_Pos)                     /*!< FMC_T::ISPSTS: CBS Mask                   */
N
N#define FMC_ISPSTS_MBS_Pos               (3)                                               /*!< FMC_T::ISPSTS: MBS Position               */
N#define FMC_ISPSTS_MBS_Msk               (0x1ul << FMC_ISPSTS_MBS_Pos)                     /*!< FMC_T::ISPSTS: MBS Mask                   */
N
N#define FMC_ISPSTS_PGFF_Pos              (5)                                               /*!< FMC_T::ISPSTS: PGFF Position              */
N#define FMC_ISPSTS_PGFF_Msk              (0x1ul << FMC_ISPSTS_PGFF_Pos)                    /*!< FMC_T::ISPSTS: PGFF Mask                  */
N
N#define FMC_ISPSTS_ISPFF_Pos             (6)                                               /*!< FMC_T::ISPSTS: ISPFF Position             */
N#define FMC_ISPSTS_ISPFF_Msk             (0x1ul << FMC_ISPSTS_ISPFF_Pos)                   /*!< FMC_T::ISPSTS: ISPFF Mask                 */
N
N#define FMC_ISPSTS_VECMAP_Pos            (9)                                               /*!< FMC_T::ISPSTS: VECMAP Position            */
N#define FMC_ISPSTS_VECMAP_Msk            (0x7ffful << FMC_ISPSTS_VECMAP_Pos)               /*!< FMC_T::ISPSTS: VECMAP Mask                */
N
N#define FMC_MPDAT0_ISPDAT0_Pos           (0)                                               /*!< FMC_T::MPDAT0: ISPDAT0 Position           */
N#define FMC_MPDAT0_ISPDAT0_Msk           (0xfffffffful << FMC_MPDAT0_ISPDAT0_Pos)          /*!< FMC_T::MPDAT0: ISPDAT0 Mask               */
N
N#define FMC_MPDAT1_ISPDAT1_Pos           (0)                                               /*!< FMC_T::MPDAT1: ISPDAT1 Position           */
N#define FMC_MPDAT1_ISPDAT1_Msk           (0xfffffffful << FMC_MPDAT1_ISPDAT1_Pos)          /*!< FMC_T::MPDAT1: ISPDAT1 Mask               */
N
N#define FMC_MPDAT2_ISPDAT2_Pos           (0)                                               /*!< FMC_T::MPDAT2: ISPDAT2 Position           */
N#define FMC_MPDAT2_ISPDAT2_Msk           (0xfffffffful << FMC_MPDAT2_ISPDAT2_Pos)          /*!< FMC_T::MPDAT2: ISPDAT2 Mask               */
N
N#define FMC_MPDAT3_ISPDAT3_Pos           (0)                                               /*!< FMC_T::MPDAT3: ISPDAT3 Position           */
N#define FMC_MPDAT3_ISPDAT3_Msk           (0xfffffffful << FMC_MPDAT3_ISPDAT3_Pos)          /*!< FMC_T::MPDAT3: ISPDAT3 Mask               */
N
N#define FMC_MPSTS_MPBUSY_Pos             (0)                                               /*!< FMC_T::MPSTS: MPBUSY Position             */
N#define FMC_MPSTS_MPBUSY_Msk             (0x1ul << FMC_MPSTS_MPBUSY_Pos)                   /*!< FMC_T::MPSTS: MPBUSY Mask                 */
N
N#define FMC_MPSTS_PPGO_Pos               (1)                                               /*!< FMC_T::MPSTS: PPGO Position               */
N#define FMC_MPSTS_PPGO_Msk               (0x1ul << FMC_MPSTS_PPGO_Pos)                     /*!< FMC_T::MPSTS: PPGO Mask                   */
N
N#define FMC_MPSTS_ISPFF_Pos              (2)                                               /*!< FMC_T::MPSTS: ISPFF Position              */
N#define FMC_MPSTS_ISPFF_Msk              (0x1ul << FMC_MPSTS_ISPFF_Pos)                    /*!< FMC_T::MPSTS: ISPFF Mask                  */
N
N#define FMC_MPSTS_D0_Pos                 (4)                                               /*!< FMC_T::MPSTS: D0 Position                 */
N#define FMC_MPSTS_D0_Msk                 (0x1ul << FMC_MPSTS_D0_Pos)                       /*!< FMC_T::MPSTS: D0 Mask                     */
N
N#define FMC_MPSTS_D1_Pos                 (5)                                               /*!< FMC_T::MPSTS: D1 Position                 */
N#define FMC_MPSTS_D1_Msk                 (0x1ul << FMC_MPSTS_D1_Pos)                       /*!< FMC_T::MPSTS: D1 Mask                     */
N
N#define FMC_MPSTS_D2_Pos                 (6)                                               /*!< FMC_T::MPSTS: D2 Position                 */
N#define FMC_MPSTS_D2_Msk                 (0x1ul << FMC_MPSTS_D2_Pos)                       /*!< FMC_T::MPSTS: D2 Mask                     */
N
N#define FMC_MPSTS_D3_Pos                 (7)                                               /*!< FMC_T::MPSTS: D3 Position                 */
N#define FMC_MPSTS_D3_Msk                 (0x1ul << FMC_MPSTS_D3_Pos)                       /*!< FMC_T::MPSTS: D3 Mask                     */
N
N#define FMC_MPADDR_MPADDR_Pos            (0)                                               /*!< FMC_T::MPADDR: MPADDR Position            */
N#define FMC_MPADDR_MPADDR_Msk            (0xfffffffful << FMC_MPADDR_MPADDR_Pos)           /*!< FMC_T::MPADDR: MPADDR Mask                */
N
N/**@}*/ /* FMC_CONST */
N/**@}*/ /* end of FMC register group */
N
N
N/*---------------------- General Purpose Input/Output Controller -------------------------*/
N/**
N    @addtogroup GPIO General Purpose Input/Output Controller(GPIO)
N    Memory Mapped Structure for GPIO Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N
N/**
N * @var GPIO_T::MODE
N * Offset: 0x00/0x40/0x80/0xC0/0x100/0x140  Port A-F I/O Mode Control
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2n+1:2n]|MODEn    |Port A-F I/O Pin[n] Mode Control
N * |        |          |Determine each I/O mode of Px.n pins.
N * |        |          |00 = Px.n is in Input mode.
N * |        |          |01 = Px.n is in Push-pull Output mode.
N * |        |          |10 = Px.n is in Open-drain Output mode.
N * |        |          |11 = Px.n is in Quasi-bidirectional mode.
N * |        |          |Note1: The initial value of this field is defined by CIOINI (CONFIG0 [10]).
N * |        |          |If CIOINI is set to 0, the default value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on.
N * |        |          |If CIOINI is set to 1, the default value is 0x0000_0000 and all pins will be
N * |        |          |input mode after chip powered on.
N * |        |          |Note2:
N * |        |          |n=0~15 for port A/B/C/D.
N * |        |          |n=0~14 for port E.
N * |        |          |n=0~7 for port F.
N * @var GPIO_T::DINOFF
N * Offset: 0x04/0x44/0x84/0xC4/0x104/0x144  Port A-F Digital Input Path Disable Control
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[n+16]  |DINOFFn   |Port A-F Pin[n] Digital Input Path Disable Control
N * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled.
N * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
N * |        |          |0 = Px.n digital input path Enabled.
N * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
N * |        |          |Note:
N * |        |          |n=0~15 for port A/B/C/D.
N * |        |          |n=0~14 for port E.
N * |        |          |n=0~7 for port F.
N * @var GPIO_T::DOUT
N * Offset: 0x08/0x48/0x88/0xC8/0x108/0x148  Port A-F Data Output Value
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[n]     |DOUTn     |Port A-F Pin[n] Output Value
N * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
N * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
N * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
N * |        |          |Note:
N * |        |          |n=0~15 for port A/B/C/D.
N * |        |          |n=0~14 for port E.
N * |        |          |n=0~7 for port F.
N * @var GPIO_T::DATMSK
N * Offset: 0x0C/0x4C/0x8C/0xCC/0x10C/0x14C  Port A-F Data Output Write Mask
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[n]     |DMASKn    |Port A-F Pin[n] Data Output Write Mask
N * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit.
N * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected.
N * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
N * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
N * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
N * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
N * |        |          |Note2:
N * |        |          |n=0~15 for port A/B/C/D.
N * |        |          |n=0~14 for port E.
N * |        |          |n=0~7 for port F.
N * @var GPIO_T::PIN
N * Offset: 0x10/0x50/0x90/0xD0/0x110/0x150  Port A-F Pin Value
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[n]     |PINn      |Port A-F Pin[n] Pin Value
N * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin.
N * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
N * |        |          |Note:
N * |        |          |n=0~15 for port A/B/C/D.
N * |        |          |n=0~14 for port E.
N * |        |          |n=0~7 for port F.
N * @var GPIO_T::DBEN
N * Offset: 0x14/0x54/0x94/0xD4/0x114/0x154  Port A-F De-Bounce Enable Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[n]     |DBENn     |Port A-F Pin[n] Input Signal De-Bounce Enable Bit
N * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit.
N * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
N * |        |          |0 = Px.n de-bounce function Disabled.
N * |        |          |1 = Px.n de-bounce function Enabled.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note:
N * |        |          |n=0~15 for port A/B/C/D.
N * |        |          |n=0~14 for port E.
N * |        |          |n=0~7 for port F.
N * @var GPIO_T::INTTYPE
N * Offset: 0x18/0x58/0x98/0xD8/0x118/0x158  Port A-F Interrupt Trigger Type Control
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[n]     |TYPEn     |Port A-F Pin[n] Edge Or Level Detection Interrupt Trigger Type Control
N * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger.
N * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
N * |        |          |0 = Edge trigger interrupt.
N * |        |          |1 = Level trigger interrupt.
N * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]).
N * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note:
N * |        |          |n=0~15 for port A/B/C/D.
N * |        |          |n=0~14 for port E.
N * |        |          |n=0~7 for port F.
N * @var GPIO_T::INTEN
N * Offset: 0x1C/0x5C/0x9C/0xDC/0x11C/0x15C  Port A-F Interrupt Enable Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[n]     |FLIENn    |Port A-F Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Bit
N * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
N * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
N * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
N * |        |          |0 = Px.n level low or high to low interrupt Disabled.
N * |        |          |1 = Px.n level low or high to low interrupt Enabled.
N * |        |          |Note:
N * |        |          |n=0~15 for port A/B/C/D.
N * |        |          |n=0~14 for port E.
N * |        |          |n=0~7 for port F.
N * @var GPIO_T::INTSRC
N * Offset: 0x20/0x60/0xA0/0xE0/0x120/0x160  Port A-F Interrupt Source Flag
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[n]     |INTSRCn   |Port A-F Pin[n] Interrupt Source Flag
N * |        |          |Write Operation :
N * |        |          |0 = No action.
N * |        |          |1 = Clear the corresponding pending interrupt.
N * |        |          |Read Operation :
N * |        |          |0 = No interrupt at Px.n.
N * |        |          |1 = Px.n generates an interrupt.
N * |        |          |Note:
N * |        |          |n=0~15 for port A/B/C/D.
N * |        |          |n=0~14 for port E.
N * |        |          |n=0~7 for port F.
N * @var GPIO_T::SMTEN
N * Offset: 0x24/0x64/0xA4/0xE4/0x124/0x164  Port A-F Input Schmitt Trigger Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[n]     |SMTENn    |Port A-F Pin[n] Input Schmitt Trigger Enable Bit
N * |        |          |0 = Px.n input Schmitt trigger function Disabled.
N * |        |          |1 = Px.n input Schmitt trigger function Enabled.
N * |        |          |Note:
N * |        |          |n=0~15 for port A/B/C/D.
N * |        |          |n=0~14 for port E.
N * |        |          |n=0~7 for port F.
N * @var GPIO_T::SLEWCTL
N * Offset: 0x28/0x68/0xA8/0xE8/0x128/0x168  Port A-F High Slew Rate Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[n]     |HSRENn    |Port A-F Pin[n] High Slew Rate Control
N * |        |          |0 = Px.n output with basic slew rate.
N * |        |          |1 = Px.n output with higher slew rate.
N * |        |          |Note:
N * |        |          |n=0~15 for port A/B/C/D.
N * |        |          |n=0~14 for port E.
N * |        |          |n=0~7 for port F.
N * @var GPIO_T::DRVCTL
N * Offset: 0x2C  Port E High Drive Strength Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[n]     |HDRVENn   |Port E Pin[n] Driving Strength Control
N * |        |          |0 = Px.n output with basic driving strength.
N * |        |          |1 = Px.n output with high driving strength.
N * |        |          |Note:
N * |        |          |n=8,9..13 for port E.
N */
N
N    __IO uint32_t MODE;          /* Offset: 0x00/0x40/0x80/0xC0/0x100/0x140  Port A-F I/O Mode Control                       */
X    volatile uint32_t MODE;           
N    __IO uint32_t DINOFF;        /* Offset: 0x04/0x44/0x84/0xC4/0x104/0x144  Port A-F Digital Input Path Disable Control     */
X    volatile uint32_t DINOFF;         
N    __IO uint32_t DOUT;          /* Offset: 0x08/0x48/0x88/0xC8/0x108/0x148  Port A-F Data Output Value                      */
X    volatile uint32_t DOUT;           
N    __IO uint32_t DATMSK;        /* Offset: 0x0C/0x4C/0x8C/0xCC/0x10C/0x14C  Port A-F Data Output Write Mask                 */
X    volatile uint32_t DATMSK;         
N    __I  uint32_t PIN;           /* Offset: 0x10/0x50/0x90/0xD0/0x110/0x150  Port A-F Pin Value                              */
X    volatile const  uint32_t PIN;            
N    __IO uint32_t DBEN;          /* Offset: 0x14/0x54/0x94/0xD4/0x114/0x154  Port A-F De-Bounce Enable Control Register      */
X    volatile uint32_t DBEN;           
N    __IO uint32_t INTTYPE;       /* Offset: 0x18/0x58/0x98/0xD8/0x118/0x158  Port A-F Interrupt Trigger Type Control         */
X    volatile uint32_t INTTYPE;        
N    __IO uint32_t INTEN;         /* Offset: 0x1C/0x5C/0x9C/0xDC/0x11C/0x15C  Port A-F Interrupt Enable Control Register      */
X    volatile uint32_t INTEN;          
N    __IO uint32_t INTSRC;        /* Offset: 0x20/0x60/0xA0/0xE0/0x120/0x160  Port A-F Interrupt Source Flag                  */
X    volatile uint32_t INTSRC;         
N    __IO uint32_t SMTEN;         /* Offset: 0x24/0x64/0xA4/0xE4/0x124/0x164  Port A-F Input Schmitt Trigger Enable Register  */
X    volatile uint32_t SMTEN;          
N    __IO uint32_t SLEWCTL;       /* Offset: 0x28/0x68/0xA8/0xE8/0x128/0x168  Port A-F High Slew Rate Control Register        */
X    volatile uint32_t SLEWCTL;        
N    __IO uint32_t DRVCTL;        /* Offset: 0x12C  Port E High Drive Strength Control Register                               */
X    volatile uint32_t DRVCTL;         
N
N} GPIO_T;
N
N
N
N
Ntypedef struct
N{
N
N
N
N/**
N * @var GPIO_DBCTL_T::DBCTL
N * Offset: 0x440  Interrupt De-bounce Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |DBCLKSEL  |De-Bounce Sampling Cycle Selection
N * |        |          |0000 = Sample interrupt input once per 1 clocks.
N * |        |          |0001 = Sample interrupt input once per 2 clocks.
N * |        |          |0010 = Sample interrupt input once per 4 clocks.
N * |        |          |0011 = Sample interrupt input once per 8 clocks.
N * |        |          |0100 = Sample interrupt input once per 16 clocks.
N * |        |          |0101 = Sample interrupt input once per 32 clocks.
N * |        |          |0110 = Sample interrupt input once per 64 clocks.
N * |        |          |0111 = Sample interrupt input once per 128 clocks.
N * |        |          |1000 = Sample interrupt input once per 256 clocks.
N * |        |          |1001 = Sample interrupt input once per 2*256 clocks.
N * |        |          |1010 = Sample interrupt input once per 4*256 clocks.
N * |        |          |1011 = Sample interrupt input once per 8*256 clocks.
N * |        |          |1100 = Sample interrupt input once per 16*256 clocks.
N * |        |          |1101 = Sample interrupt input once per 32*256 clocks.
N * |        |          |1110 = Sample interrupt input once per 64*256 clocks.
N * |        |          |1111 = Sample interrupt input once per 128*256 clocks.
N * |[4]     |DBCLKSRC  |De-Bounce Counter Clock Source Selection
N * |        |          |0 = De-bounce counter clock source is the HCLK.
N * |        |          |1 = De-bounce counter clock source is the internal 10 kHz internal low speed oscillator.
N * |[5]     |ICLKON    |Interrupt Clock On Mode
N * |        |          |0 = Edge detection circuit is active only if I/O pin corresponding RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]) bit is set to 1.
N * |        |          |1 = All I/O pins edge detection circuit is always active after reset.
N * |        |          |Note: It is recommended to disable this bit to save system power if no special application concern.
N */
N
N    __IO uint32_t DBCTL;         /* Offset: 0x440  Interrupt De-bounce Control Register                              */
X    volatile uint32_t DBCTL;          
N
N} GPIO_DBCTL_T;
N
N
N
N
N/**
N    @addtogroup GPIO_CONST GPIO Bit Field Definition
N    Constant Definitions for GPIO Controller
N@{ */
N
N#define GPIO_MODE_MODE0_Pos              (0)                                               /*!< GPIO_T::MODE: MODE0 Position              */
N#define GPIO_MODE_MODE0_Msk              (0x3ul << GPIO_MODE_MODE0_Pos)                    /*!< GPIO_T::MODE: MODE0 Mask                  */
N
N#define GPIO_MODE_MODE1_Pos              (2)                                               /*!< GPIO_T::MODE: MODE1 Position              */
N#define GPIO_MODE_MODE1_Msk              (0x3ul << GPIO_MODE_MODE1_Pos)                    /*!< GPIO_T::MODE: MODE1 Mask                  */
N
N#define GPIO_MODE_MODE2_Pos              (4)                                               /*!< GPIO_T::MODE: MODE2 Position              */
N#define GPIO_MODE_MODE2_Msk              (0x3ul << GPIO_MODE_MODE2_Pos)                    /*!< GPIO_T::MODE: MODE2 Mask                  */
N
N#define GPIO_MODE_MODE3_Pos              (6)                                               /*!< GPIO_T::MODE: MODE3 Position              */
N#define GPIO_MODE_MODE3_Msk              (0x3ul << GPIO_MODE_MODE3_Pos)                    /*!< GPIO_T::MODE: MODE3 Mask                  */
N
N#define GPIO_MODE_MODE4_Pos              (8)                                               /*!< GPIO_T::MODE: MODE4 Position              */
N#define GPIO_MODE_MODE4_Msk              (0x3ul << GPIO_MODE_MODE4_Pos)                    /*!< GPIO_T::MODE: MODE4 Mask                  */
N
N#define GPIO_MODE_MODE5_Pos              (10)                                              /*!< GPIO_T::MODE: MODE5 Position              */
N#define GPIO_MODE_MODE5_Msk              (0x3ul << GPIO_MODE_MODE5_Pos)                    /*!< GPIO_T::MODE: MODE5 Mask                  */
N
N#define GPIO_MODE_MODE6_Pos              (12)                                              /*!< GPIO_T::MODE: MODE6 Position              */
N#define GPIO_MODE_MODE6_Msk              (0x3ul << GPIO_MODE_MODE6_Pos)                    /*!< GPIO_T::MODE: MODE6 Mask                  */
N
N#define GPIO_MODE_MODE7_Pos              (14)                                              /*!< GPIO_T::MODE: MODE7 Position              */
N#define GPIO_MODE_MODE7_Msk              (0x3ul << GPIO_MODE_MODE7_Pos)                    /*!< GPIO_T::MODE: MODE7 Mask                  */
N
N#define GPIO_MODE_MODE8_Pos              (16)                                              /*!< GPIO_T::MODE: MODE8 Position              */
N#define GPIO_MODE_MODE8_Msk              (0x3ul << GPIO_MODE_MODE8_Pos)                    /*!< GPIO_T::MODE: MODE8 Mask                  */
N
N#define GPIO_MODE_MODE9_Pos              (18)                                              /*!< GPIO_T::MODE: MODE9 Position              */
N#define GPIO_MODE_MODE9_Msk              (0x3ul << GPIO_MODE_MODE9_Pos)                    /*!< GPIO_T::MODE: MODE9 Mask                  */
N
N#define GPIO_MODE_MODE10_Pos             (20)                                              /*!< GPIO_T::MODE: MODE10 Position             */
N#define GPIO_MODE_MODE10_Msk             (0x3ul << GPIO_MODE_MODE10_Pos)                   /*!< GPIO_T::MODE: MODE10 Mask                 */
N
N#define GPIO_MODE_MODE11_Pos             (22)                                              /*!< GPIO_T::MODE: MODE11 Position             */
N#define GPIO_MODE_MODE11_Msk             (0x3ul << GPIO_MODE_MODE11_Pos)                   /*!< GPIO_T::MODE: MODE11 Mask                 */
N
N#define GPIO_MODE_MODE12_Pos             (24)                                              /*!< GPIO_T::MODE: MODE12 Position             */
N#define GPIO_MODE_MODE12_Msk             (0x3ul << GPIO_MODE_MODE12_Pos)                   /*!< GPIO_T::MODE: MODE12 Mask                 */
N
N#define GPIO_MODE_MODE13_Pos             (26)                                              /*!< GPIO_T::MODE: MODE13 Position             */
N#define GPIO_MODE_MODE13_Msk             (0x3ul << GPIO_MODE_MODE13_Pos)                   /*!< GPIO_T::MODE: MODE13 Mask                 */
N
N#define GPIO_MODE_MODE14_Pos             (28)                                              /*!< GPIO_T::MODE: MODE14 Position             */
N#define GPIO_MODE_MODE14_Msk             (0x3ul << GPIO_MODE_MODE14_Pos)                   /*!< GPIO_T::MODE: MODE14 Mask                 */
N
N#define GPIO_MODE_MODE15_Pos             (30)                                              /*!< GPIO_T::MODE: MODE15 Position             */
N#define GPIO_MODE_MODE15_Msk             (0x3ul << GPIO_MODE_MODE15_Pos)                   /*!< GPIO_T::MODE: MODE15 Mask                 */
N
N#define GPIO_DINOFF_DINOFF0_Pos          (16)                                              /*!< GPIO_T::DINOFF: DINOFF0 Position          */
N#define GPIO_DINOFF_DINOFF0_Msk          (0x1ul << GPIO_DINOFF_DINOFF0_Pos)                /*!< GPIO_T::DINOFF: DINOFF0 Mask              */
N
N#define GPIO_DINOFF_DINOFF1_Pos          (17)                                              /*!< GPIO_T::DINOFF: DINOFF1 Position          */
N#define GPIO_DINOFF_DINOFF1_Msk          (0x1ul << GPIO_DINOFF_DINOFF1_Pos)                /*!< GPIO_T::DINOFF: DINOFF1 Mask              */
N
N#define GPIO_DINOFF_DINOFF2_Pos          (18)                                              /*!< GPIO_T::DINOFF: DINOFF2 Position          */
N#define GPIO_DINOFF_DINOFF2_Msk          (0x1ul << GPIO_DINOFF_DINOFF2_Pos)                /*!< GPIO_T::DINOFF: DINOFF2 Mask              */
N
N#define GPIO_DINOFF_DINOFF3_Pos          (19)                                              /*!< GPIO_T::DINOFF: DINOFF3 Position          */
N#define GPIO_DINOFF_DINOFF3_Msk          (0x1ul << GPIO_DINOFF_DINOFF3_Pos)                /*!< GPIO_T::DINOFF: DINOFF3 Mask              */
N
N#define GPIO_DINOFF_DINOFF4_Pos          (20)                                              /*!< GPIO_T::DINOFF: DINOFF4 Position          */
N#define GPIO_DINOFF_DINOFF4_Msk          (0x1ul << GPIO_DINOFF_DINOFF4_Pos)                /*!< GPIO_T::DINOFF: DINOFF4 Mask              */
N
N#define GPIO_DINOFF_DINOFF5_Pos          (21)                                              /*!< GPIO_T::DINOFF: DINOFF5 Position          */
N#define GPIO_DINOFF_DINOFF5_Msk          (0x1ul << GPIO_DINOFF_DINOFF5_Pos)                /*!< GPIO_T::DINOFF: DINOFF5 Mask              */
N
N#define GPIO_DINOFF_DINOFF6_Pos          (22)                                              /*!< GPIO_T::DINOFF: DINOFF6 Position          */
N#define GPIO_DINOFF_DINOFF6_Msk          (0x1ul << GPIO_DINOFF_DINOFF6_Pos)                /*!< GPIO_T::DINOFF: DINOFF6 Mask              */
N
N#define GPIO_DINOFF_DINOFF7_Pos          (23)                                              /*!< GPIO_T::DINOFF: DINOFF7 Position          */
N#define GPIO_DINOFF_DINOFF7_Msk          (0x1ul << GPIO_DINOFF_DINOFF7_Pos)                /*!< GPIO_T::DINOFF: DINOFF7 Mask              */
N
N#define GPIO_DINOFF_DINOFF8_Pos          (24)                                              /*!< GPIO_T::DINOFF: DINOFF8 Position          */
N#define GPIO_DINOFF_DINOFF8_Msk          (0x1ul << GPIO_DINOFF_DINOFF8_Pos)                /*!< GPIO_T::DINOFF: DINOFF8 Mask              */
N
N#define GPIO_DINOFF_DINOFF9_Pos          (25)                                              /*!< GPIO_T::DINOFF: DINOFF9 Position          */
N#define GPIO_DINOFF_DINOFF9_Msk          (0x1ul << GPIO_DINOFF_DINOFF9_Pos)                /*!< GPIO_T::DINOFF: DINOFF9 Mask              */
N
N#define GPIO_DINOFF_DINOFF10_Pos         (26)                                              /*!< GPIO_T::DINOFF: DINOFF10 Position         */
N#define GPIO_DINOFF_DINOFF10_Msk         (0x1ul << GPIO_DINOFF_DINOFF10_Pos)               /*!< GPIO_T::DINOFF: DINOFF10 Mask             */
N
N#define GPIO_DINOFF_DINOFF11_Pos         (27)                                              /*!< GPIO_T::DINOFF: DINOFF11 Position         */
N#define GPIO_DINOFF_DINOFF11_Msk         (0x1ul << GPIO_DINOFF_DINOFF11_Pos)               /*!< GPIO_T::DINOFF: DINOFF11 Mask             */
N
N#define GPIO_DINOFF_DINOFF12_Pos         (28)                                              /*!< GPIO_T::DINOFF: DINOFF12 Position         */
N#define GPIO_DINOFF_DINOFF12_Msk         (0x1ul << GPIO_DINOFF_DINOFF12_Pos)               /*!< GPIO_T::DINOFF: DINOFF12 Mask             */
N
N#define GPIO_DINOFF_DINOFF13_Pos         (29)                                              /*!< GPIO_T::DINOFF: DINOFF13 Position         */
N#define GPIO_DINOFF_DINOFF13_Msk         (0x1ul << GPIO_DINOFF_DINOFF13_Pos)               /*!< GPIO_T::DINOFF: DINOFF13 Mask             */
N
N#define GPIO_DINOFF_DINOFF14_Pos         (30)                                              /*!< GPIO_T::DINOFF: DINOFF14 Position         */
N#define GPIO_DINOFF_DINOFF14_Msk         (0x1ul << GPIO_DINOFF_DINOFF14_Pos)               /*!< GPIO_T::DINOFF: DINOFF14 Mask             */
N
N#define GPIO_DINOFF_DINOFF15_Pos         (31)                                              /*!< GPIO_T::DINOFF: DINOFF15 Position         */
N#define GPIO_DINOFF_DINOFF15_Msk         (0x1ul << GPIO_DINOFF_DINOFF15_Pos)               /*!< GPIO_T::DINOFF: DINOFF15 Mask             */
N
N#define GPIO_DOUT_DOUT0_Pos              (0)                                               /*!< GPIO_T::DOUT: DOUT0 Position              */
N#define GPIO_DOUT_DOUT0_Msk              (0x1ul << GPIO_DOUT_DOUT0_Pos)                    /*!< GPIO_T::DOUT: DOUT0 Mask                  */
N
N#define GPIO_DOUT_DOUT1_Pos              (1)                                               /*!< GPIO_T::DOUT: DOUT1 Position              */
N#define GPIO_DOUT_DOUT1_Msk              (0x1ul << GPIO_DOUT_DOUT1_Pos)                    /*!< GPIO_T::DOUT: DOUT1 Mask                  */
N
N#define GPIO_DOUT_DOUT2_Pos              (2)                                               /*!< GPIO_T::DOUT: DOUT2 Position              */
N#define GPIO_DOUT_DOUT2_Msk              (0x1ul << GPIO_DOUT_DOUT2_Pos)                    /*!< GPIO_T::DOUT: DOUT2 Mask                  */
N
N#define GPIO_DOUT_DOUT3_Pos              (3)                                               /*!< GPIO_T::DOUT: DOUT3 Position              */
N#define GPIO_DOUT_DOUT3_Msk              (0x1ul << GPIO_DOUT_DOUT3_Pos)                    /*!< GPIO_T::DOUT: DOUT3 Mask                  */
N
N#define GPIO_DOUT_DOUT4_Pos              (4)                                               /*!< GPIO_T::DOUT: DOUT4 Position              */
N#define GPIO_DOUT_DOUT4_Msk              (0x1ul << GPIO_DOUT_DOUT4_Pos)                    /*!< GPIO_T::DOUT: DOUT4 Mask                  */
N
N#define GPIO_DOUT_DOUT5_Pos              (5)                                               /*!< GPIO_T::DOUT: DOUT5 Position              */
N#define GPIO_DOUT_DOUT5_Msk              (0x1ul << GPIO_DOUT_DOUT5_Pos)                    /*!< GPIO_T::DOUT: DOUT5 Mask                  */
N
N#define GPIO_DOUT_DOUT6_Pos              (6)                                               /*!< GPIO_T::DOUT: DOUT6 Position              */
N#define GPIO_DOUT_DOUT6_Msk              (0x1ul << GPIO_DOUT_DOUT6_Pos)                    /*!< GPIO_T::DOUT: DOUT6 Mask                  */
N
N#define GPIO_DOUT_DOUT7_Pos              (7)                                               /*!< GPIO_T::DOUT: DOUT7 Position              */
N#define GPIO_DOUT_DOUT7_Msk              (0x1ul << GPIO_DOUT_DOUT7_Pos)                    /*!< GPIO_T::DOUT: DOUT7 Mask                  */
N
N#define GPIO_DOUT_DOUT8_Pos              (8)                                               /*!< GPIO_T::DOUT: DOUT8 Position              */
N#define GPIO_DOUT_DOUT8_Msk              (0x1ul << GPIO_DOUT_DOUT8_Pos)                    /*!< GPIO_T::DOUT: DOUT8 Mask                  */
N
N#define GPIO_DOUT_DOUT9_Pos              (9)                                               /*!< GPIO_T::DOUT: DOUT9 Position              */
N#define GPIO_DOUT_DOUT9_Msk              (0x1ul << GPIO_DOUT_DOUT9_Pos)                    /*!< GPIO_T::DOUT: DOUT9 Mask                  */
N
N#define GPIO_DOUT_DOUT10_Pos             (10)                                              /*!< GPIO_T::DOUT: DOUT10 Position             */
N#define GPIO_DOUT_DOUT10_Msk             (0x1ul << GPIO_DOUT_DOUT10_Pos)                   /*!< GPIO_T::DOUT: DOUT10 Mask                 */
N
N#define GPIO_DOUT_DOUT11_Pos             (11)                                              /*!< GPIO_T::DOUT: DOUT11 Position             */
N#define GPIO_DOUT_DOUT11_Msk             (0x1ul << GPIO_DOUT_DOUT11_Pos)                   /*!< GPIO_T::DOUT: DOUT11 Mask                 */
N
N#define GPIO_DOUT_DOUT12_Pos             (12)                                              /*!< GPIO_T::DOUT: DOUT12 Position             */
N#define GPIO_DOUT_DOUT12_Msk             (0x1ul << GPIO_DOUT_DOUT12_Pos)                   /*!< GPIO_T::DOUT: DOUT12 Mask                 */
N
N#define GPIO_DOUT_DOUT13_Pos             (13)                                              /*!< GPIO_T::DOUT: DOUT13 Position             */
N#define GPIO_DOUT_DOUT13_Msk             (0x1ul << GPIO_DOUT_DOUT13_Pos)                   /*!< GPIO_T::DOUT: DOUT13 Mask                 */
N
N#define GPIO_DOUT_DOUT14_Pos             (14)                                              /*!< GPIO_T::DOUT: DOUT14 Position             */
N#define GPIO_DOUT_DOUT14_Msk             (0x1ul << GPIO_DOUT_DOUT14_Pos)                   /*!< GPIO_T::DOUT: DOUT14 Mask                 */
N
N#define GPIO_DOUT_DOUT15_Pos             (15)                                              /*!< GPIO_T::DOUT: DOUT15 Position             */
N#define GPIO_DOUT_DOUT15_Msk             (0x1ul << GPIO_DOUT_DOUT15_Pos)                   /*!< GPIO_T::DOUT: DOUT15 Mask                 */
N
N#define GPIO_DATMSK_DMASK0_Pos           (0)                                               /*!< GPIO_T::DATMSK: DMASK0 Position           */
N#define GPIO_DATMSK_DMASK0_Msk           (0x1ul << GPIO_DATMSK_DMASK0_Pos)                 /*!< GPIO_T::DATMSK: DMASK0 Mask               */
N
N#define GPIO_DATMSK_DMASK1_Pos           (1)                                               /*!< GPIO_T::DATMSK: DMASK1 Position           */
N#define GPIO_DATMSK_DMASK1_Msk           (0x1ul << GPIO_DATMSK_DMASK1_Pos)                 /*!< GPIO_T::DATMSK: DMASK1 Mask               */
N
N#define GPIO_DATMSK_DMASK2_Pos           (2)                                               /*!< GPIO_T::DATMSK: DMASK2 Position           */
N#define GPIO_DATMSK_DMASK2_Msk           (0x1ul << GPIO_DATMSK_DMASK2_Pos)                 /*!< GPIO_T::DATMSK: DMASK2 Mask               */
N
N#define GPIO_DATMSK_DMASK3_Pos           (3)                                               /*!< GPIO_T::DATMSK: DMASK3 Position           */
N#define GPIO_DATMSK_DMASK3_Msk           (0x1ul << GPIO_DATMSK_DMASK3_Pos)                 /*!< GPIO_T::DATMSK: DMASK3 Mask               */
N
N#define GPIO_DATMSK_DMASK4_Pos           (4)                                               /*!< GPIO_T::DATMSK: DMASK4 Position           */
N#define GPIO_DATMSK_DMASK4_Msk           (0x1ul << GPIO_DATMSK_DMASK4_Pos)                 /*!< GPIO_T::DATMSK: DMASK4 Mask               */
N
N#define GPIO_DATMSK_DMASK5_Pos           (5)                                               /*!< GPIO_T::DATMSK: DMASK5 Position           */
N#define GPIO_DATMSK_DMASK5_Msk           (0x1ul << GPIO_DATMSK_DMASK5_Pos)                 /*!< GPIO_T::DATMSK: DMASK5 Mask               */
N
N#define GPIO_DATMSK_DMASK6_Pos           (6)                                               /*!< GPIO_T::DATMSK: DMASK6 Position           */
N#define GPIO_DATMSK_DMASK6_Msk           (0x1ul << GPIO_DATMSK_DMASK6_Pos)                 /*!< GPIO_T::DATMSK: DMASK6 Mask               */
N
N#define GPIO_DATMSK_DMASK7_Pos           (7)                                               /*!< GPIO_T::DATMSK: DMASK7 Position           */
N#define GPIO_DATMSK_DMASK7_Msk           (0x1ul << GPIO_DATMSK_DMASK7_Pos)                 /*!< GPIO_T::DATMSK: DMASK7 Mask               */
N
N#define GPIO_DATMSK_DMASK8_Pos           (8)                                               /*!< GPIO_T::DATMSK: DMASK8 Position           */
N#define GPIO_DATMSK_DMASK8_Msk           (0x1ul << GPIO_DATMSK_DMASK8_Pos)                 /*!< GPIO_T::DATMSK: DMASK8 Mask               */
N
N#define GPIO_DATMSK_DMASK9_Pos           (9)                                               /*!< GPIO_T::DATMSK: DMASK9 Position           */
N#define GPIO_DATMSK_DMASK9_Msk           (0x1ul << GPIO_DATMSK_DMASK9_Pos)                 /*!< GPIO_T::DATMSK: DMASK9 Mask               */
N
N#define GPIO_DATMSK_DMASK10_Pos          (10)                                              /*!< GPIO_T::DATMSK: DMASK10 Position          */
N#define GPIO_DATMSK_DMASK10_Msk          (0x1ul << GPIO_DATMSK_DMASK10_Pos)                /*!< GPIO_T::DATMSK: DMASK10 Mask              */
N
N#define GPIO_DATMSK_DMASK11_Pos          (11)                                              /*!< GPIO_T::DATMSK: DMASK11 Position          */
N#define GPIO_DATMSK_DMASK11_Msk          (0x1ul << GPIO_DATMSK_DMASK11_Pos)                /*!< GPIO_T::DATMSK: DMASK11 Mask              */
N
N#define GPIO_DATMSK_DMASK12_Pos          (12)                                              /*!< GPIO_T::DATMSK: DMASK12 Position          */
N#define GPIO_DATMSK_DMASK12_Msk          (0x1ul << GPIO_DATMSK_DMASK12_Pos)                /*!< GPIO_T::DATMSK: DMASK12 Mask              */
N
N#define GPIO_DATMSK_DMASK13_Pos          (13)                                              /*!< GPIO_T::DATMSK: DMASK13 Position          */
N#define GPIO_DATMSK_DMASK13_Msk          (0x1ul << GPIO_DATMSK_DMASK13_Pos)                /*!< GPIO_T::DATMSK: DMASK13 Mask              */
N
N#define GPIO_DATMSK_DMASK14_Pos          (14)                                              /*!< GPIO_T::DATMSK: DMASK14 Position          */
N#define GPIO_DATMSK_DMASK14_Msk          (0x1ul << GPIO_DATMSK_DMASK14_Pos)                /*!< GPIO_T::DATMSK: DMASK14 Mask              */
N
N#define GPIO_DATMSK_DMASK15_Pos          (15)                                              /*!< GPIO_T::DATMSK: DMASK15 Position          */
N#define GPIO_DATMSK_DMASK15_Msk          (0x1ul << GPIO_DATMSK_DMASK15_Pos)                /*!< GPIO_T::DATMSK: DMASK15 Mask              */
N
N#define GPIO_PIN_PIN0_Pos                (0)                                               /*!< GPIO_T::PIN: PIN0 Position                */
N#define GPIO_PIN_PIN0_Msk                (0x1ul << GPIO_PIN_PIN0_Pos)                      /*!< GPIO_T::PIN: PIN0 Mask                    */
N
N#define GPIO_PIN_PIN1_Pos                (1)                                               /*!< GPIO_T::PIN: PIN1 Position                */
N#define GPIO_PIN_PIN1_Msk                (0x1ul << GPIO_PIN_PIN1_Pos)                      /*!< GPIO_T::PIN: PIN1 Mask                    */
N
N#define GPIO_PIN_PIN2_Pos                (2)                                               /*!< GPIO_T::PIN: PIN2 Position                */
N#define GPIO_PIN_PIN2_Msk                (0x1ul << GPIO_PIN_PIN2_Pos)                      /*!< GPIO_T::PIN: PIN2 Mask                    */
N
N#define GPIO_PIN_PIN3_Pos                (3)                                               /*!< GPIO_T::PIN: PIN3 Position                */
N#define GPIO_PIN_PIN3_Msk                (0x1ul << GPIO_PIN_PIN3_Pos)                      /*!< GPIO_T::PIN: PIN3 Mask                    */
N
N#define GPIO_PIN_PIN4_Pos                (4)                                               /*!< GPIO_T::PIN: PIN4 Position                */
N#define GPIO_PIN_PIN4_Msk                (0x1ul << GPIO_PIN_PIN4_Pos)                      /*!< GPIO_T::PIN: PIN4 Mask                    */
N
N#define GPIO_PIN_PIN5_Pos                (5)                                               /*!< GPIO_T::PIN: PIN5 Position                */
N#define GPIO_PIN_PIN5_Msk                (0x1ul << GPIO_PIN_PIN5_Pos)                      /*!< GPIO_T::PIN: PIN5 Mask                    */
N
N#define GPIO_PIN_PIN6_Pos                (6)                                               /*!< GPIO_T::PIN: PIN6 Position                */
N#define GPIO_PIN_PIN6_Msk                (0x1ul << GPIO_PIN_PIN6_Pos)                      /*!< GPIO_T::PIN: PIN6 Mask                    */
N
N#define GPIO_PIN_PIN7_Pos                (7)                                               /*!< GPIO_T::PIN: PIN7 Position                */
N#define GPIO_PIN_PIN7_Msk                (0x1ul << GPIO_PIN_PIN7_Pos)                      /*!< GPIO_T::PIN: PIN7 Mask                    */
N
N#define GPIO_PIN_PIN8_Pos                (8)                                               /*!< GPIO_T::PIN: PIN8 Position                */
N#define GPIO_PIN_PIN8_Msk                (0x1ul << GPIO_PIN_PIN8_Pos)                      /*!< GPIO_T::PIN: PIN8 Mask                    */
N
N#define GPIO_PIN_PIN9_Pos                (9)                                               /*!< GPIO_T::PIN: PIN9 Position                */
N#define GPIO_PIN_PIN9_Msk                (0x1ul << GPIO_PIN_PIN9_Pos)                      /*!< GPIO_T::PIN: PIN9 Mask                    */
N
N#define GPIO_PIN_PIN10_Pos               (10)                                              /*!< GPIO_T::PIN: PIN10 Position               */
N#define GPIO_PIN_PIN10_Msk               (0x1ul << GPIO_PIN_PIN10_Pos)                     /*!< GPIO_T::PIN: PIN10 Mask                   */
N
N#define GPIO_PIN_PIN11_Pos               (11)                                              /*!< GPIO_T::PIN: PIN11 Position               */
N#define GPIO_PIN_PIN11_Msk               (0x1ul << GPIO_PIN_PIN11_Pos)                     /*!< GPIO_T::PIN: PIN11 Mask                   */
N
N#define GPIO_PIN_PIN12_Pos               (12)                                              /*!< GPIO_T::PIN: PIN12 Position               */
N#define GPIO_PIN_PIN12_Msk               (0x1ul << GPIO_PIN_PIN12_Pos)                     /*!< GPIO_T::PIN: PIN12 Mask                   */
N
N#define GPIO_PIN_PIN13_Pos               (13)                                              /*!< GPIO_T::PIN: PIN13 Position               */
N#define GPIO_PIN_PIN13_Msk               (0x1ul << GPIO_PIN_PIN13_Pos)                     /*!< GPIO_T::PIN: PIN13 Mask                   */
N
N#define GPIO_PIN_PIN14_Pos               (14)                                              /*!< GPIO_T::PIN: PIN14 Position               */
N#define GPIO_PIN_PIN14_Msk               (0x1ul << GPIO_PIN_PIN14_Pos)                     /*!< GPIO_T::PIN: PIN14 Mask                   */
N
N#define GPIO_PIN_PIN15_Pos               (15)                                              /*!< GPIO_T::PIN: PIN15 Position               */
N#define GPIO_PIN_PIN15_Msk               (0x1ul << GPIO_PIN_PIN15_Pos)                     /*!< GPIO_T::PIN: PIN15 Mask                   */
N
N#define GPIO_DBEN_DBEN0_Pos              (0)                                               /*!< GPIO_T::DBEN: DBEN0 Position              */
N#define GPIO_DBEN_DBEN0_Msk              (0x1ul << GPIO_DBEN_DBEN0_Pos)                    /*!< GPIO_T::DBEN: DBEN0 Mask                  */
N
N#define GPIO_DBEN_DBEN1_Pos              (1)                                               /*!< GPIO_T::DBEN: DBEN1 Position              */
N#define GPIO_DBEN_DBEN1_Msk              (0x1ul << GPIO_DBEN_DBEN1_Pos)                    /*!< GPIO_T::DBEN: DBEN1 Mask                  */
N
N#define GPIO_DBEN_DBEN2_Pos              (2)                                               /*!< GPIO_T::DBEN: DBEN2 Position              */
N#define GPIO_DBEN_DBEN2_Msk              (0x1ul << GPIO_DBEN_DBEN2_Pos)                    /*!< GPIO_T::DBEN: DBEN2 Mask                  */
N
N#define GPIO_DBEN_DBEN3_Pos              (3)                                               /*!< GPIO_T::DBEN: DBEN3 Position              */
N#define GPIO_DBEN_DBEN3_Msk              (0x1ul << GPIO_DBEN_DBEN3_Pos)                    /*!< GPIO_T::DBEN: DBEN3 Mask                  */
N
N#define GPIO_DBEN_DBEN4_Pos              (4)                                               /*!< GPIO_T::DBEN: DBEN4 Position              */
N#define GPIO_DBEN_DBEN4_Msk              (0x1ul << GPIO_DBEN_DBEN4_Pos)                    /*!< GPIO_T::DBEN: DBEN4 Mask                  */
N
N#define GPIO_DBEN_DBEN5_Pos              (5)                                               /*!< GPIO_T::DBEN: DBEN5 Position              */
N#define GPIO_DBEN_DBEN5_Msk              (0x1ul << GPIO_DBEN_DBEN5_Pos)                    /*!< GPIO_T::DBEN: DBEN5 Mask                  */
N
N#define GPIO_DBEN_DBEN6_Pos              (6)                                               /*!< GPIO_T::DBEN: DBEN6 Position              */
N#define GPIO_DBEN_DBEN6_Msk              (0x1ul << GPIO_DBEN_DBEN6_Pos)                    /*!< GPIO_T::DBEN: DBEN6 Mask                  */
N
N#define GPIO_DBEN_DBEN7_Pos              (7)                                               /*!< GPIO_T::DBEN: DBEN7 Position              */
N#define GPIO_DBEN_DBEN7_Msk              (0x1ul << GPIO_DBEN_DBEN7_Pos)                    /*!< GPIO_T::DBEN: DBEN7 Mask                  */
N
N#define GPIO_DBEN_DBEN8_Pos              (8)                                               /*!< GPIO_T::DBEN: DBEN8 Position              */
N#define GPIO_DBEN_DBEN8_Msk              (0x1ul << GPIO_DBEN_DBEN8_Pos)                    /*!< GPIO_T::DBEN: DBEN8 Mask                  */
N
N#define GPIO_DBEN_DBEN9_Pos              (9)                                               /*!< GPIO_T::DBEN: DBEN9 Position              */
N#define GPIO_DBEN_DBEN9_Msk              (0x1ul << GPIO_DBEN_DBEN9_Pos)                    /*!< GPIO_T::DBEN: DBEN9 Mask                  */
N
N#define GPIO_DBEN_DBEN10_Pos             (10)                                              /*!< GPIO_T::DBEN: DBEN10 Position             */
N#define GPIO_DBEN_DBEN10_Msk             (0x1ul << GPIO_DBEN_DBEN10_Pos)                   /*!< GPIO_T::DBEN: DBEN10 Mask                 */
N
N#define GPIO_DBEN_DBEN11_Pos             (11)                                              /*!< GPIO_T::DBEN: DBEN11 Position             */
N#define GPIO_DBEN_DBEN11_Msk             (0x1ul << GPIO_DBEN_DBEN11_Pos)                   /*!< GPIO_T::DBEN: DBEN11 Mask                 */
N
N#define GPIO_DBEN_DBEN12_Pos             (12)                                              /*!< GPIO_T::DBEN: DBEN12 Position             */
N#define GPIO_DBEN_DBEN12_Msk             (0x1ul << GPIO_DBEN_DBEN12_Pos)                   /*!< GPIO_T::DBEN: DBEN12 Mask                 */
N
N#define GPIO_DBEN_DBEN13_Pos             (13)                                              /*!< GPIO_T::DBEN: DBEN13 Position             */
N#define GPIO_DBEN_DBEN13_Msk             (0x1ul << GPIO_DBEN_DBEN13_Pos)                   /*!< GPIO_T::DBEN: DBEN13 Mask                 */
N
N#define GPIO_DBEN_DBEN14_Pos             (14)                                              /*!< GPIO_T::DBEN: DBEN14 Position             */
N#define GPIO_DBEN_DBEN14_Msk             (0x1ul << GPIO_DBEN_DBEN14_Pos)                   /*!< GPIO_T::DBEN: DBEN14 Mask                 */
N
N#define GPIO_DBEN_DBEN15_Pos             (15)                                              /*!< GPIO_T::DBEN: DBEN15 Position             */
N#define GPIO_DBEN_DBEN15_Msk             (0x1ul << GPIO_DBEN_DBEN15_Pos)                   /*!< GPIO_T::DBEN: DBEN15 Mask                 */
N
N#define GPIO_INTTYPE_TYPE0_Pos           (0)                                               /*!< GPIO_T::INTTYPE: TYPE0 Position           */
N#define GPIO_INTTYPE_TYPE0_Msk           (0x1ul << GPIO_INTTYPE_TYPE0_Pos)                 /*!< GPIO_T::INTTYPE: TYPE0 Mask               */
N
N#define GPIO_INTTYPE_TYPE1_Pos           (1)                                               /*!< GPIO_T::INTTYPE: TYPE1 Position           */
N#define GPIO_INTTYPE_TYPE1_Msk           (0x1ul << GPIO_INTTYPE_TYPE1_Pos)                 /*!< GPIO_T::INTTYPE: TYPE1 Mask               */
N
N#define GPIO_INTTYPE_TYPE2_Pos           (2)                                               /*!< GPIO_T::INTTYPE: TYPE2 Position           */
N#define GPIO_INTTYPE_TYPE2_Msk           (0x1ul << GPIO_INTTYPE_TYPE2_Pos)                 /*!< GPIO_T::INTTYPE: TYPE2 Mask               */
N
N#define GPIO_INTTYPE_TYPE3_Pos           (3)                                               /*!< GPIO_T::INTTYPE: TYPE3 Position           */
N#define GPIO_INTTYPE_TYPE3_Msk           (0x1ul << GPIO_INTTYPE_TYPE3_Pos)                 /*!< GPIO_T::INTTYPE: TYPE3 Mask               */
N
N#define GPIO_INTTYPE_TYPE4_Pos           (4)                                               /*!< GPIO_T::INTTYPE: TYPE4 Position           */
N#define GPIO_INTTYPE_TYPE4_Msk           (0x1ul << GPIO_INTTYPE_TYPE4_Pos)                 /*!< GPIO_T::INTTYPE: TYPE4 Mask               */
N
N#define GPIO_INTTYPE_TYPE5_Pos           (5)                                               /*!< GPIO_T::INTTYPE: TYPE5 Position           */
N#define GPIO_INTTYPE_TYPE5_Msk           (0x1ul << GPIO_INTTYPE_TYPE5_Pos)                 /*!< GPIO_T::INTTYPE: TYPE5 Mask               */
N
N#define GPIO_INTTYPE_TYPE6_Pos           (6)                                               /*!< GPIO_T::INTTYPE: TYPE6 Position           */
N#define GPIO_INTTYPE_TYPE6_Msk           (0x1ul << GPIO_INTTYPE_TYPE6_Pos)                 /*!< GPIO_T::INTTYPE: TYPE6 Mask               */
N
N#define GPIO_INTTYPE_TYPE7_Pos           (7)                                               /*!< GPIO_T::INTTYPE: TYPE7 Position           */
N#define GPIO_INTTYPE_TYPE7_Msk           (0x1ul << GPIO_INTTYPE_TYPE7_Pos)                 /*!< GPIO_T::INTTYPE: TYPE7 Mask               */
N
N#define GPIO_INTTYPE_TYPE8_Pos           (8)                                               /*!< GPIO_T::INTTYPE: TYPE8 Position           */
N#define GPIO_INTTYPE_TYPE8_Msk           (0x1ul << GPIO_INTTYPE_TYPE8_Pos)                 /*!< GPIO_T::INTTYPE: TYPE8 Mask               */
N
N#define GPIO_INTTYPE_TYPE9_Pos           (9)                                               /*!< GPIO_T::INTTYPE: TYPE9 Position           */
N#define GPIO_INTTYPE_TYPE9_Msk           (0x1ul << GPIO_INTTYPE_TYPE9_Pos)                 /*!< GPIO_T::INTTYPE: TYPE9 Mask               */
N
N#define GPIO_INTTYPE_TYPE10_Pos          (10)                                              /*!< GPIO_T::INTTYPE: TYPE10 Position          */
N#define GPIO_INTTYPE_TYPE10_Msk          (0x1ul << GPIO_INTTYPE_TYPE10_Pos)                /*!< GPIO_T::INTTYPE: TYPE10 Mask              */
N
N#define GPIO_INTTYPE_TYPE11_Pos          (11)                                              /*!< GPIO_T::INTTYPE: TYPE11 Position          */
N#define GPIO_INTTYPE_TYPE11_Msk          (0x1ul << GPIO_INTTYPE_TYPE11_Pos)                /*!< GPIO_T::INTTYPE: TYPE11 Mask              */
N
N#define GPIO_INTTYPE_TYPE12_Pos          (12)                                              /*!< GPIO_T::INTTYPE: TYPE12 Position          */
N#define GPIO_INTTYPE_TYPE12_Msk          (0x1ul << GPIO_INTTYPE_TYPE12_Pos)                /*!< GPIO_T::INTTYPE: TYPE12 Mask              */
N
N#define GPIO_INTTYPE_TYPE13_Pos          (13)                                              /*!< GPIO_T::INTTYPE: TYPE13 Position          */
N#define GPIO_INTTYPE_TYPE13_Msk          (0x1ul << GPIO_INTTYPE_TYPE13_Pos)                /*!< GPIO_T::INTTYPE: TYPE13 Mask              */
N
N#define GPIO_INTTYPE_TYPE14_Pos          (14)                                              /*!< GPIO_T::INTTYPE: TYPE14 Position          */
N#define GPIO_INTTYPE_TYPE14_Msk          (0x1ul << GPIO_INTTYPE_TYPE14_Pos)                /*!< GPIO_T::INTTYPE: TYPE14 Mask              */
N
N#define GPIO_INTTYPE_TYPE15_Pos          (15)                                              /*!< GPIO_T::INTTYPE: TYPE15 Position          */
N#define GPIO_INTTYPE_TYPE15_Msk          (0x1ul << GPIO_INTTYPE_TYPE15_Pos)                /*!< GPIO_T::INTTYPE: TYPE15 Mask              */
N
N#define GPIO_INTEN_FLIEN0_Pos            (0)                                               /*!< GPIO_T::INTEN: FLIEN0 Position            */
N#define GPIO_INTEN_FLIEN0_Msk            (0x1ul << GPIO_INTEN_FLIEN0_Pos)                  /*!< GPIO_T::INTEN: FLIEN0 Mask                */
N
N#define GPIO_INTEN_FLIEN1_Pos            (1)                                               /*!< GPIO_T::INTEN: FLIEN1 Position            */
N#define GPIO_INTEN_FLIEN1_Msk            (0x1ul << GPIO_INTEN_FLIEN1_Pos)                  /*!< GPIO_T::INTEN: FLIEN1 Mask                */
N
N#define GPIO_INTEN_FLIEN2_Pos            (2)                                               /*!< GPIO_T::INTEN: FLIEN2 Position            */
N#define GPIO_INTEN_FLIEN2_Msk            (0x1ul << GPIO_INTEN_FLIEN2_Pos)                  /*!< GPIO_T::INTEN: FLIEN2 Mask                */
N
N#define GPIO_INTEN_FLIEN3_Pos            (3)                                               /*!< GPIO_T::INTEN: FLIEN3 Position            */
N#define GPIO_INTEN_FLIEN3_Msk            (0x1ul << GPIO_INTEN_FLIEN3_Pos)                  /*!< GPIO_T::INTEN: FLIEN3 Mask                */
N
N#define GPIO_INTEN_FLIEN4_Pos            (4)                                               /*!< GPIO_T::INTEN: FLIEN4 Position            */
N#define GPIO_INTEN_FLIEN4_Msk            (0x1ul << GPIO_INTEN_FLIEN4_Pos)                  /*!< GPIO_T::INTEN: FLIEN4 Mask                */
N
N#define GPIO_INTEN_FLIEN5_Pos            (5)                                               /*!< GPIO_T::INTEN: FLIEN5 Position            */
N#define GPIO_INTEN_FLIEN5_Msk            (0x1ul << GPIO_INTEN_FLIEN5_Pos)                  /*!< GPIO_T::INTEN: FLIEN5 Mask                */
N
N#define GPIO_INTEN_FLIEN6_Pos            (6)                                               /*!< GPIO_T::INTEN: FLIEN6 Position            */
N#define GPIO_INTEN_FLIEN6_Msk            (0x1ul << GPIO_INTEN_FLIEN6_Pos)                  /*!< GPIO_T::INTEN: FLIEN6 Mask                */
N
N#define GPIO_INTEN_FLIEN7_Pos            (7)                                               /*!< GPIO_T::INTEN: FLIEN7 Position            */
N#define GPIO_INTEN_FLIEN7_Msk            (0x1ul << GPIO_INTEN_FLIEN7_Pos)                  /*!< GPIO_T::INTEN: FLIEN7 Mask                */
N
N#define GPIO_INTEN_FLIEN8_Pos            (8)                                               /*!< GPIO_T::INTEN: FLIEN8 Position            */
N#define GPIO_INTEN_FLIEN8_Msk            (0x1ul << GPIO_INTEN_FLIEN8_Pos)                  /*!< GPIO_T::INTEN: FLIEN8 Mask                */
N
N#define GPIO_INTEN_FLIEN9_Pos            (9)                                               /*!< GPIO_T::INTEN: FLIEN9 Position            */
N#define GPIO_INTEN_FLIEN9_Msk            (0x1ul << GPIO_INTEN_FLIEN9_Pos)                  /*!< GPIO_T::INTEN: FLIEN9 Mask                */
N
N#define GPIO_INTEN_FLIEN10_Pos           (10)                                              /*!< GPIO_T::INTEN: FLIEN10 Position           */
N#define GPIO_INTEN_FLIEN10_Msk           (0x1ul << GPIO_INTEN_FLIEN10_Pos)                 /*!< GPIO_T::INTEN: FLIEN10 Mask               */
N
N#define GPIO_INTEN_FLIEN11_Pos           (11)                                              /*!< GPIO_T::INTEN: FLIEN11 Position           */
N#define GPIO_INTEN_FLIEN11_Msk           (0x1ul << GPIO_INTEN_FLIEN11_Pos)                 /*!< GPIO_T::INTEN: FLIEN11 Mask               */
N
N#define GPIO_INTEN_FLIEN12_Pos           (12)                                              /*!< GPIO_T::INTEN: FLIEN12 Position           */
N#define GPIO_INTEN_FLIEN12_Msk           (0x1ul << GPIO_INTEN_FLIEN12_Pos)                 /*!< GPIO_T::INTEN: FLIEN12 Mask               */
N
N#define GPIO_INTEN_FLIEN13_Pos           (13)                                              /*!< GPIO_T::INTEN: FLIEN13 Position           */
N#define GPIO_INTEN_FLIEN13_Msk           (0x1ul << GPIO_INTEN_FLIEN13_Pos)                 /*!< GPIO_T::INTEN: FLIEN13 Mask               */
N
N#define GPIO_INTEN_FLIEN14_Pos           (14)                                              /*!< GPIO_T::INTEN: FLIEN14 Position           */
N#define GPIO_INTEN_FLIEN14_Msk           (0x1ul << GPIO_INTEN_FLIEN14_Pos)                 /*!< GPIO_T::INTEN: FLIEN14 Mask               */
N
N#define GPIO_INTEN_FLIEN15_Pos           (15)                                              /*!< GPIO_T::INTEN: FLIEN15 Position           */
N#define GPIO_INTEN_FLIEN15_Msk           (0x1ul << GPIO_INTEN_FLIEN15_Pos)                 /*!< GPIO_T::INTEN: FLIEN15 Mask               */
N
N#define GPIO_INTEN_RHIEN0_Pos            (16)                                              /*!< GPIO_T::INTEN: RHIEN0 Position            */
N#define GPIO_INTEN_RHIEN0_Msk            (0x1ul << GPIO_INTEN_RHIEN0_Pos)                  /*!< GPIO_T::INTEN: RHIEN0 Mask                */
N
N#define GPIO_INTEN_RHIEN1_Pos            (17)                                              /*!< GPIO_T::INTEN: RHIEN1 Position            */
N#define GPIO_INTEN_RHIEN1_Msk            (0x1ul << GPIO_INTEN_RHIEN1_Pos)                  /*!< GPIO_T::INTEN: RHIEN1 Mask                */
N
N#define GPIO_INTEN_RHIEN2_Pos            (18)                                              /*!< GPIO_T::INTEN: RHIEN2 Position            */
N#define GPIO_INTEN_RHIEN2_Msk            (0x1ul << GPIO_INTEN_RHIEN2_Pos)                  /*!< GPIO_T::INTEN: RHIEN2 Mask                */
N
N#define GPIO_INTEN_RHIEN3_Pos            (19)                                              /*!< GPIO_T::INTEN: RHIEN3 Position            */
N#define GPIO_INTEN_RHIEN3_Msk            (0x1ul << GPIO_INTEN_RHIEN3_Pos)                  /*!< GPIO_T::INTEN: RHIEN3 Mask                */
N
N#define GPIO_INTEN_RHIEN4_Pos            (20)                                              /*!< GPIO_T::INTEN: RHIEN4 Position            */
N#define GPIO_INTEN_RHIEN4_Msk            (0x1ul << GPIO_INTEN_RHIEN4_Pos)                  /*!< GPIO_T::INTEN: RHIEN4 Mask                */
N
N#define GPIO_INTEN_RHIEN5_Pos            (21)                                              /*!< GPIO_T::INTEN: RHIEN5 Position            */
N#define GPIO_INTEN_RHIEN5_Msk            (0x1ul << GPIO_INTEN_RHIEN5_Pos)                  /*!< GPIO_T::INTEN: RHIEN5 Mask                */
N
N#define GPIO_INTEN_RHIEN6_Pos            (22)                                              /*!< GPIO_T::INTEN: RHIEN6 Position            */
N#define GPIO_INTEN_RHIEN6_Msk            (0x1ul << GPIO_INTEN_RHIEN6_Pos)                  /*!< GPIO_T::INTEN: RHIEN6 Mask                */
N
N#define GPIO_INTEN_RHIEN7_Pos            (23)                                              /*!< GPIO_T::INTEN: RHIEN7 Position            */
N#define GPIO_INTEN_RHIEN7_Msk            (0x1ul << GPIO_INTEN_RHIEN7_Pos)                  /*!< GPIO_T::INTEN: RHIEN7 Mask                */
N
N#define GPIO_INTEN_RHIEN8_Pos            (24)                                              /*!< GPIO_T::INTEN: RHIEN8 Position            */
N#define GPIO_INTEN_RHIEN8_Msk            (0x1ul << GPIO_INTEN_RHIEN8_Pos)                  /*!< GPIO_T::INTEN: RHIEN8 Mask                */
N
N#define GPIO_INTEN_RHIEN9_Pos            (25)                                              /*!< GPIO_T::INTEN: RHIEN9 Position            */
N#define GPIO_INTEN_RHIEN9_Msk            (0x1ul << GPIO_INTEN_RHIEN9_Pos)                  /*!< GPIO_T::INTEN: RHIEN9 Mask                */
N
N#define GPIO_INTEN_RHIEN10_Pos           (26)                                              /*!< GPIO_T::INTEN: RHIEN10 Position           */
N#define GPIO_INTEN_RHIEN10_Msk           (0x1ul << GPIO_INTEN_RHIEN10_Pos)                 /*!< GPIO_T::INTEN: RHIEN10 Mask               */
N
N#define GPIO_INTEN_RHIEN11_Pos           (27)                                              /*!< GPIO_T::INTEN: RHIEN11 Position           */
N#define GPIO_INTEN_RHIEN11_Msk           (0x1ul << GPIO_INTEN_RHIEN11_Pos)                 /*!< GPIO_T::INTEN: RHIEN11 Mask               */
N
N#define GPIO_INTEN_RHIEN12_Pos           (28)                                              /*!< GPIO_T::INTEN: RHIEN12 Position           */
N#define GPIO_INTEN_RHIEN12_Msk           (0x1ul << GPIO_INTEN_RHIEN12_Pos)                 /*!< GPIO_T::INTEN: RHIEN12 Mask               */
N
N#define GPIO_INTEN_RHIEN13_Pos           (29)                                              /*!< GPIO_T::INTEN: RHIEN13 Position           */
N#define GPIO_INTEN_RHIEN13_Msk           (0x1ul << GPIO_INTEN_RHIEN13_Pos)                 /*!< GPIO_T::INTEN: RHIEN13 Mask               */
N
N#define GPIO_INTEN_RHIEN14_Pos           (30)                                              /*!< GPIO_T::INTEN: RHIEN14 Position           */
N#define GPIO_INTEN_RHIEN14_Msk           (0x1ul << GPIO_INTEN_RHIEN14_Pos)                 /*!< GPIO_T::INTEN: RHIEN14 Mask               */
N
N#define GPIO_INTEN_RHIEN15_Pos           (31)                                              /*!< GPIO_T::INTEN: RHIEN15 Position           */
N#define GPIO_INTEN_RHIEN15_Msk           (0x1ul << GPIO_INTEN_RHIEN15_Pos)                 /*!< GPIO_T::INTEN: RHIEN15 Mask               */
N
N#define GPIO_INTSRC_INTSRC0_Pos          (0)                                               /*!< GPIO_T::INTSRC: INTSRC0 Position          */
N#define GPIO_INTSRC_INTSRC0_Msk          (0x1ul << GPIO_INTSRC_INTSRC0_Pos)                /*!< GPIO_T::INTSRC: INTSRC0 Mask              */
N
N#define GPIO_INTSRC_INTSRC1_Pos          (1)                                               /*!< GPIO_T::INTSRC: INTSRC1 Position          */
N#define GPIO_INTSRC_INTSRC1_Msk          (0x1ul << GPIO_INTSRC_INTSRC1_Pos)                /*!< GPIO_T::INTSRC: INTSRC1 Mask              */
N
N#define GPIO_INTSRC_INTSRC2_Pos          (2)                                               /*!< GPIO_T::INTSRC: INTSRC2 Position          */
N#define GPIO_INTSRC_INTSRC2_Msk          (0x1ul << GPIO_INTSRC_INTSRC2_Pos)                /*!< GPIO_T::INTSRC: INTSRC2 Mask              */
N
N#define GPIO_INTSRC_INTSRC3_Pos          (3)                                               /*!< GPIO_T::INTSRC: INTSRC3 Position          */
N#define GPIO_INTSRC_INTSRC3_Msk          (0x1ul << GPIO_INTSRC_INTSRC3_Pos)                /*!< GPIO_T::INTSRC: INTSRC3 Mask              */
N
N#define GPIO_INTSRC_INTSRC4_Pos          (4)                                               /*!< GPIO_T::INTSRC: INTSRC4 Position          */
N#define GPIO_INTSRC_INTSRC4_Msk          (0x1ul << GPIO_INTSRC_INTSRC4_Pos)                /*!< GPIO_T::INTSRC: INTSRC4 Mask              */
N
N#define GPIO_INTSRC_INTSRC5_Pos          (5)                                               /*!< GPIO_T::INTSRC: INTSRC5 Position          */
N#define GPIO_INTSRC_INTSRC5_Msk          (0x1ul << GPIO_INTSRC_INTSRC5_Pos)                /*!< GPIO_T::INTSRC: INTSRC5 Mask              */
N
N#define GPIO_INTSRC_INTSRC6_Pos          (6)                                               /*!< GPIO_T::INTSRC: INTSRC6 Position          */
N#define GPIO_INTSRC_INTSRC6_Msk          (0x1ul << GPIO_INTSRC_INTSRC6_Pos)                /*!< GPIO_T::INTSRC: INTSRC6 Mask              */
N
N#define GPIO_INTSRC_INTSRC7_Pos          (7)                                               /*!< GPIO_T::INTSRC: INTSRC7 Position          */
N#define GPIO_INTSRC_INTSRC7_Msk          (0x1ul << GPIO_INTSRC_INTSRC7_Pos)                /*!< GPIO_T::INTSRC: INTSRC7 Mask              */
N
N#define GPIO_INTSRC_INTSRC8_Pos          (8)                                               /*!< GPIO_T::INTSRC: INTSRC8 Position          */
N#define GPIO_INTSRC_INTSRC8_Msk          (0x1ul << GPIO_INTSRC_INTSRC8_Pos)                /*!< GPIO_T::INTSRC: INTSRC8 Mask              */
N
N#define GPIO_INTSRC_INTSRC9_Pos          (9)                                               /*!< GPIO_T::INTSRC: INTSRC9 Position          */
N#define GPIO_INTSRC_INTSRC9_Msk          (0x1ul << GPIO_INTSRC_INTSRC9_Pos)                /*!< GPIO_T::INTSRC: INTSRC9 Mask              */
N
N#define GPIO_INTSRC_INTSRC10_Pos         (10)                                              /*!< GPIO_T::INTSRC: INTSRC10 Position         */
N#define GPIO_INTSRC_INTSRC10_Msk         (0x1ul << GPIO_INTSRC_INTSRC10_Pos)               /*!< GPIO_T::INTSRC: INTSRC10 Mask             */
N
N#define GPIO_INTSRC_INTSRC11_Pos         (11)                                              /*!< GPIO_T::INTSRC: INTSRC11 Position         */
N#define GPIO_INTSRC_INTSRC11_Msk         (0x1ul << GPIO_INTSRC_INTSRC11_Pos)               /*!< GPIO_T::INTSRC: INTSRC11 Mask             */
N
N#define GPIO_INTSRC_INTSRC12_Pos         (12)                                              /*!< GPIO_T::INTSRC: INTSRC12 Position         */
N#define GPIO_INTSRC_INTSRC12_Msk         (0x1ul << GPIO_INTSRC_INTSRC12_Pos)               /*!< GPIO_T::INTSRC: INTSRC12 Mask             */
N
N#define GPIO_INTSRC_INTSRC13_Pos         (13)                                              /*!< GPIO_T::INTSRC: INTSRC13 Position         */
N#define GPIO_INTSRC_INTSRC13_Msk         (0x1ul << GPIO_INTSRC_INTSRC13_Pos)               /*!< GPIO_T::INTSRC: INTSRC13 Mask             */
N
N#define GPIO_INTSRC_INTSRC14_Pos         (14)                                              /*!< GPIO_T::INTSRC: INTSRC14 Position         */
N#define GPIO_INTSRC_INTSRC14_Msk         (0x1ul << GPIO_INTSRC_INTSRC14_Pos)               /*!< GPIO_T::INTSRC: INTSRC14 Mask             */
N
N#define GPIO_INTSRC_INTSRC15_Pos         (15)                                              /*!< GPIO_T::INTSRC: INTSRC15 Position         */
N#define GPIO_INTSRC_INTSRC15_Msk         (0x1ul << GPIO_INTSRC_INTSRC15_Pos)               /*!< GPIO_T::INTSRC: INTSRC15 Mask             */
N
N#define GPIO_SMTEN_SMTEN0_Pos            (0)                                               /*!< GPIO_T::SMTEN: SMTEN0 Position            */
N#define GPIO_SMTEN_SMTEN0_Msk            (0x1ul << GPIO_SMTEN_SMTEN0_Pos)                  /*!< GPIO_T::SMTEN: SMTEN0 Mask                */
N
N#define GPIO_SMTEN_SMTEN1_Pos            (1)                                               /*!< GPIO_T::SMTEN: SMTEN1 Position            */
N#define GPIO_SMTEN_SMTEN1_Msk            (0x1ul << GPIO_SMTEN_SMTEN1_Pos)                  /*!< GPIO_T::SMTEN: SMTEN1 Mask                */
N
N#define GPIO_SMTEN_SMTEN2_Pos            (2)                                               /*!< GPIO_T::SMTEN: SMTEN2 Position            */
N#define GPIO_SMTEN_SMTEN2_Msk            (0x1ul << GPIO_SMTEN_SMTEN2_Pos)                  /*!< GPIO_T::SMTEN: SMTEN2 Mask                */
N
N#define GPIO_SMTEN_SMTEN3_Pos            (3)                                               /*!< GPIO_T::SMTEN: SMTEN3 Position            */
N#define GPIO_SMTEN_SMTEN3_Msk            (0x1ul << GPIO_SMTEN_SMTEN3_Pos)                  /*!< GPIO_T::SMTEN: SMTEN3 Mask                */
N
N#define GPIO_SMTEN_SMTEN4_Pos            (4)                                               /*!< GPIO_T::SMTEN: SMTEN4 Position            */
N#define GPIO_SMTEN_SMTEN4_Msk            (0x1ul << GPIO_SMTEN_SMTEN4_Pos)                  /*!< GPIO_T::SMTEN: SMTEN4 Mask                */
N
N#define GPIO_SMTEN_SMTEN5_Pos            (5)                                               /*!< GPIO_T::SMTEN: SMTEN5 Position            */
N#define GPIO_SMTEN_SMTEN5_Msk            (0x1ul << GPIO_SMTEN_SMTEN5_Pos)                  /*!< GPIO_T::SMTEN: SMTEN5 Mask                */
N
N#define GPIO_SMTEN_SMTEN6_Pos            (6)                                               /*!< GPIO_T::SMTEN: SMTEN6 Position            */
N#define GPIO_SMTEN_SMTEN6_Msk            (0x1ul << GPIO_SMTEN_SMTEN6_Pos)                  /*!< GPIO_T::SMTEN: SMTEN6 Mask                */
N
N#define GPIO_SMTEN_SMTEN7_Pos            (7)                                               /*!< GPIO_T::SMTEN: SMTEN7 Position            */
N#define GPIO_SMTEN_SMTEN7_Msk            (0x1ul << GPIO_SMTEN_SMTEN7_Pos)                  /*!< GPIO_T::SMTEN: SMTEN7 Mask                */
N
N#define GPIO_SMTEN_SMTEN8_Pos            (8)                                               /*!< GPIO_T::SMTEN: SMTEN8 Position            */
N#define GPIO_SMTEN_SMTEN8_Msk            (0x1ul << GPIO_SMTEN_SMTEN8_Pos)                  /*!< GPIO_T::SMTEN: SMTEN8 Mask                */
N
N#define GPIO_SMTEN_SMTEN9_Pos            (9)                                               /*!< GPIO_T::SMTEN: SMTEN9 Position            */
N#define GPIO_SMTEN_SMTEN9_Msk            (0x1ul << GPIO_SMTEN_SMTEN9_Pos)                  /*!< GPIO_T::SMTEN: SMTEN9 Mask                */
N
N#define GPIO_SMTEN_SMTEN10_Pos           (10)                                              /*!< GPIO_T::SMTEN: SMTEN10 Position           */
N#define GPIO_SMTEN_SMTEN10_Msk           (0x1ul << GPIO_SMTEN_SMTEN10_Pos)                 /*!< GPIO_T::SMTEN: SMTEN10 Mask               */
N
N#define GPIO_SMTEN_SMTEN11_Pos           (11)                                              /*!< GPIO_T::SMTEN: SMTEN11 Position           */
N#define GPIO_SMTEN_SMTEN11_Msk           (0x1ul << GPIO_SMTEN_SMTEN11_Pos)                 /*!< GPIO_T::SMTEN: SMTEN11 Mask               */
N
N#define GPIO_SMTEN_SMTEN12_Pos           (12)                                              /*!< GPIO_T::SMTEN: SMTEN12 Position           */
N#define GPIO_SMTEN_SMTEN12_Msk           (0x1ul << GPIO_SMTEN_SMTEN12_Pos)                 /*!< GPIO_T::SMTEN: SMTEN12 Mask               */
N
N#define GPIO_SMTEN_SMTEN13_Pos           (13)                                              /*!< GPIO_T::SMTEN: SMTEN13 Position           */
N#define GPIO_SMTEN_SMTEN13_Msk           (0x1ul << GPIO_SMTEN_SMTEN13_Pos)                 /*!< GPIO_T::SMTEN: SMTEN13 Mask               */
N
N#define GPIO_SMTEN_SMTEN14_Pos           (14)                                              /*!< GPIO_T::SMTEN: SMTEN14 Position           */
N#define GPIO_SMTEN_SMTEN14_Msk           (0x1ul << GPIO_SMTEN_SMTEN14_Pos)                 /*!< GPIO_T::SMTEN: SMTEN14 Mask               */
N
N#define GPIO_SMTEN_SMTEN15_Pos           (15)                                              /*!< GPIO_T::SMTEN: SMTEN15 Position           */
N#define GPIO_SMTEN_SMTEN15_Msk           (0x1ul << GPIO_SMTEN_SMTEN15_Pos)                 /*!< GPIO_T::SMTEN: SMTEN15 Mask               */
N
N#define GPIO_SLEWCTL_HSREN0_Pos          (0)                                               /*!< GPIO_T::SLEWCTL: HSREN0 Position          */
N#define GPIO_SLEWCTL_HSREN0_Msk          (0x1ul << GPIO_SLEWCTL_HSREN0_Pos)                /*!< GPIO_T::SLEWCTL: HSREN0 Mask              */
N
N#define GPIO_SLEWCTL_HSREN1_Pos          (1)                                               /*!< GPIO_T::SLEWCTL: HSREN1 Position          */
N#define GPIO_SLEWCTL_HSREN1_Msk          (0x1ul << GPIO_SLEWCTL_HSREN1_Pos)                /*!< GPIO_T::SLEWCTL: HSREN1 Mask              */
N
N#define GPIO_SLEWCTL_HSREN2_Pos          (2)                                               /*!< GPIO_T::SLEWCTL: HSREN2 Position          */
N#define GPIO_SLEWCTL_HSREN2_Msk          (0x1ul << GPIO_SLEWCTL_HSREN2_Pos)                /*!< GPIO_T::SLEWCTL: HSREN2 Mask              */
N
N#define GPIO_SLEWCTL_HSREN3_Pos          (3)                                               /*!< GPIO_T::SLEWCTL: HSREN3 Position          */
N#define GPIO_SLEWCTL_HSREN3_Msk          (0x1ul << GPIO_SLEWCTL_HSREN3_Pos)                /*!< GPIO_T::SLEWCTL: HSREN3 Mask              */
N
N#define GPIO_SLEWCTL_HSREN4_Pos          (4)                                               /*!< GPIO_T::SLEWCTL: HSREN4 Position          */
N#define GPIO_SLEWCTL_HSREN4_Msk          (0x1ul << GPIO_SLEWCTL_HSREN4_Pos)                /*!< GPIO_T::SLEWCTL: HSREN4 Mask              */
N
N#define GPIO_SLEWCTL_HSREN5_Pos          (5)                                               /*!< GPIO_T::SLEWCTL: HSREN5 Position          */
N#define GPIO_SLEWCTL_HSREN5_Msk          (0x1ul << GPIO_SLEWCTL_HSREN5_Pos)                /*!< GPIO_T::SLEWCTL: HSREN5 Mask              */
N
N#define GPIO_SLEWCTL_HSREN6_Pos          (6)                                               /*!< GPIO_T::SLEWCTL: HSREN6 Position          */
N#define GPIO_SLEWCTL_HSREN6_Msk          (0x1ul << GPIO_SLEWCTL_HSREN6_Pos)                /*!< GPIO_T::SLEWCTL: HSREN6 Mask              */
N
N#define GPIO_SLEWCTL_HSREN7_Pos          (7)                                               /*!< GPIO_T::SLEWCTL: HSREN7 Position          */
N#define GPIO_SLEWCTL_HSREN7_Msk          (0x1ul << GPIO_SLEWCTL_HSREN7_Pos)                /*!< GPIO_T::SLEWCTL: HSREN7 Mask              */
N
N#define GPIO_SLEWCTL_HSREN8_Pos          (8)                                               /*!< GPIO_T::SLEWCTL: HSREN8 Position          */
N#define GPIO_SLEWCTL_HSREN8_Msk          (0x1ul << GPIO_SLEWCTL_HSREN8_Pos)                /*!< GPIO_T::SLEWCTL: HSREN8 Mask              */
N
N#define GPIO_SLEWCTL_HSREN9_Pos          (9)                                               /*!< GPIO_T::SLEWCTL: HSREN9 Position          */
N#define GPIO_SLEWCTL_HSREN9_Msk          (0x1ul << GPIO_SLEWCTL_HSREN9_Pos)                /*!< GPIO_T::SLEWCTL: HSREN9 Mask              */
N
N#define GPIO_SLEWCTL_HSREN10_Pos         (10)                                              /*!< GPIO_T::SLEWCTL: HSREN10 Position         */
N#define GPIO_SLEWCTL_HSREN10_Msk         (0x1ul << GPIO_SLEWCTL_HSREN10_Pos)               /*!< GPIO_T::SLEWCTL: HSREN10 Mask             */
N
N#define GPIO_SLEWCTL_HSREN11_Pos         (11)                                              /*!< GPIO_T::SLEWCTL: HSREN11 Position         */
N#define GPIO_SLEWCTL_HSREN11_Msk         (0x1ul << GPIO_SLEWCTL_HSREN11_Pos)               /*!< GPIO_T::SLEWCTL: HSREN11 Mask             */
N
N#define GPIO_SLEWCTL_HSREN12_Pos         (12)                                              /*!< GPIO_T::SLEWCTL: HSREN12 Position         */
N#define GPIO_SLEWCTL_HSREN12_Msk         (0x1ul << GPIO_SLEWCTL_HSREN12_Pos)               /*!< GPIO_T::SLEWCTL: HSREN12 Mask             */
N
N#define GPIO_SLEWCTL_HSREN13_Pos         (13)                                              /*!< GPIO_T::SLEWCTL: HSREN13 Position         */
N#define GPIO_SLEWCTL_HSREN13_Msk         (0x1ul << GPIO_SLEWCTL_HSREN13_Pos)               /*!< GPIO_T::SLEWCTL: HSREN13 Mask             */
N
N#define GPIO_SLEWCTL_HSREN14_Pos         (14)                                              /*!< GPIO_T::SLEWCTL: HSREN14 Position         */
N#define GPIO_SLEWCTL_HSREN14_Msk         (0x1ul << GPIO_SLEWCTL_HSREN14_Pos)               /*!< GPIO_T::SLEWCTL: HSREN14 Mask             */
N
N#define GPIO_SLEWCTL_HSREN15_Pos         (15)                                              /*!< GPIO_T::SLEWCTL: HSREN15 Position         */
N#define GPIO_SLEWCTL_HSREN15_Msk         (0x1ul << GPIO_SLEWCTL_HSREN15_Pos)               /*!< GPIO_T::SLEWCTL: HSREN15 Mask             */
N
N#define GPIO_DRVCTL_HDRVEN8_Pos          (8)                                               /*!< GPIO_T::DRVCTL: HDRVEN8 Position          */
N#define GPIO_DRVCTL_HDRVEN8_Msk          (0x1ul << GPIO_DRVCTL_HDRVEN8_Pos)                /*!< GPIO_T::DRVCTL: HDRVEN8 Mask              */
N
N#define GPIO_DRVCTL_HDRVEN9_Pos          (9)                                               /*!< GPIO_T::DRVCTL: HDRVEN9 Position          */
N#define GPIO_DRVCTL_HDRVEN9_Msk          (0x1ul << GPIO_DRVCTL_HDRVEN9_Pos)                /*!< GPIO_T::DRVCTL: HDRVEN9 Mask              */
N
N#define GPIO_DRVCTL_HDRVEN10_Pos         (10)                                              /*!< GPIO_T::DRVCTL: HDRVEN10 Position         */
N#define GPIO_DRVCTL_HDRVEN10_Msk         (0x1ul << GPIO_DRVCTL_HDRVEN10_Pos)               /*!< GPIO_T::DRVCTL: HDRVEN10 Mask             */
N
N#define GPIO_DRVCTL_HDRVEN11_Pos         (11)                                              /*!< GPIO_T::DRVCTL: HDRVEN11 Position         */
N#define GPIO_DRVCTL_HDRVEN11_Msk         (0x1ul << GPIO_DRVCTL_HDRVEN11_Pos)               /*!< GPIO_T::DRVCTL: HDRVEN11 Mask             */
N
N#define GPIO_DRVCTL_HDRVEN12_Pos         (12)                                              /*!< GPIO_T::DRVCTL: HDRVEN12 Position         */
N#define GPIO_DRVCTL_HDRVEN12_Msk         (0x1ul << GPIO_DRVCTL_HDRVEN12_Pos)               /*!< GPIO_T::DRVCTL: HDRVEN12 Mask             */
N
N#define GPIO_DRVCTL_HDRVEN13_Pos         (13)                                              /*!< GPIO_T::DRVCTL: HDRVEN13 Position         */
N#define GPIO_DRVCTL_HDRVEN13_Msk         (0x1ul << GPIO_DRVCTL_HDRVEN13_Pos)               /*!< GPIO_T::DRVCTL: HDRVEN13 Mask             */
N
N#define GPIO_DBCTL_DBCLKSEL_Pos          (0)                                               /*!< GPIO_T::DBCTL: DBCLKSEL Position          */
N#define GPIO_DBCTL_DBCLKSEL_Msk          (0xFul << GPIO_DBCTL_DBCLKSEL_Pos)                /*!< GPIO_T::DBCTL: DBCLKSEL Mask              */
N
N#define GPIO_DBCTL_DBCLKSRC_Pos          (4)                                               /*!< GPIO_T::DBCTL: DBCLKSRC Position          */
N#define GPIO_DBCTL_DBCLKSRC_Msk          (1ul << GPIO_DBCTL_DBCLKSRC_Pos)                  /*!< GPIO_T::DBCTL: DBCLKSRC Mask              */
N
N#define GPIO_DBCTL_ICLKON_Pos            (5)                                               /*!< GPIO_T::DBCTL: ICLKON Position            */
N#define GPIO_DBCTL_ICLKON_Msk            (1ul << GPIO_DBCTL_ICLKON_Pos)                    /*!< GPIO_T::DBCTL: ICLKON Mask                */
N
N
N/**@}*/ /* GPIO_CONST */
N/**@}*/ /* end of GPIO register group */
N
N
N/*---------------------- Inter-IC Bus Controller -------------------------*/
N/**
N    @addtogroup I2C Inter-IC Bus Controller(I2C)
N    Memory Mapped Structure for I2C Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N
N
N/**
N * @var I2C_T::CTL
N * Offset: 0x00  I2C Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2]     |AA        |Assert Acknowledge Control
N * |        |          |When AA =1 prior to address or data is received, 
N * |        |          |an acknowledged (low level to SDA) will be returned during the acknowledge clock pulse on the SCL line when 
N * |        |          |1. A slave is acknowledging the address sent from master. 
N * |        |          |2. The receiver devices are acknowledging the data sent by transmitter.
N * |        |          |When AA=0 prior to address or data received, 
N * |        |          |a Not acknowledged (high level to SDA) will be returned during the acknowledge clock pulse on the SCL line.
N * |[3]     |SI        |I2C Interrupt Flag
N * |        |          |When a new I2C state is present in the I2C_STATUS register, the SI flag is set by hardware.
N * |        |          |If bit INTEN (I2C_CTL [7]) is set, the I2C interrupt is requested.
N * |        |          |SI must be cleared by software.
N * |        |          |Clear SI by writing 1 to this bit.
N * |        |          |For ACKMEN is set in slave read mode, the SI flag is set in 8th clock period for user to confirm the acknowledge bit and 9th clock period for user to read the data in the data buffer.
N * |[4]     |STO       |I2C STOP Control
N * |        |          |In Master mode, setting STO to transmit a STOP condition to bus then I2C controller will check the bus condition if a STOP condition is detected.
N * |        |          |This bit will be cleared by hardware automatically.
N * |[5]     |STA       |I2C START Control
N * |        |          |Setting STA to logic 1 to enter Master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.
N * |[6]     |I2CEN     |I2C Controller Enable Bit
N * |        |          |Set to enable I2C serial function controller.
N * |        |          |When I2CEN=1 the I2C serial function enable.
N * |        |          |The multi-function pin function must set to SDA, and SCL of I2C function first.
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[7]     |INTEN     |Enable Interrupt
N * |        |          |0 = I2C interrupt Disabled.
N * |        |          |1 = I2C interrupt Enabled.
N * @var I2C_T::ADDR0
N * Offset: 0x04  I2C Slave Address Register0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GC        |General Call Function
N * |        |          |0 = General Call Function Disabled.
N * |        |          |1 = General Call Function Enabled.
N * |[7:1]   |ADDR      |I2C Address
N * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
N * |        |          |The I2C hardware will react if either of the address is matched.
N * @var I2C_T::DAT
N * Offset: 0x08  I2C Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |DAT       |I2C Data
N * |        |          |Bit [7:0] is located with the 8-bit transferred/received data of I2C serial port.
N * @var I2C_T::STATUS
N * Offset: 0x0C  I2C Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |STATUS    |I2C Status
N * |        |          |The three least significant bits are always 0.
N * |        |          |The five most significant bits contain the status code.
N * |        |          |There are 28 possible status codes.
N * |        |          |When the content of I2C_STATUS is F8H, no serial interrupt is requested.
N * |        |          |Others I2C_STATUS values correspond to defined I2C states.
N * |        |          |When each of these states is entered, a status interrupt is requested (SI = 1).
N * |        |          |A valid status code is present in I2C_STATUS one cycle after SI is set by hardware and is still present one cycle after SI has been reset by software.
N * |        |          |In addition, states 00H stands for a Bus Error.
N * |        |          |A Bus Error occurs when a START or STOP condition is present at an illegal position in the formation frame.
N * |        |          |Example of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit.
N * |        |          |Note:
N * |        |          |1.
N * |        |          |If the BUSEN and ACKMEN are enabled in slave received mode, there is SI interrupt in the 8th clock.
N * |        |          |The user can read the I2C_STATUS = 0xf0 for the function condition has done.
N * |        |          |2.
N * |        |          |If the BUSEN and PECEN are enabled, the status of PECERR, I2C_BUSSTS[3], is used to substitute for I2C_STATUS to check the ACK status in the last frame when the byte count done interrupt has active and the PEC frame has been transformed.
N * @var I2C_T::CLKDIV
N * Offset: 0x10  I2C Clock Divided Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |DIVIDER   |I2C Clock Divided
N * |        |          |Indicates the I2C clock rate: Data Baud Rate of I2C = (system clock) / (4x (I2C_CLKDIV+1)).
N * |        |          |Note: The minimum value of I2C_CLKDIV is 4.
N * @var I2C_T::TOCTL
N * Offset: 0x14  I2C Time-out Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TOIF      |Time-Out Flag
N * |        |          |This bit is set by hardware when I2C time-out happened and it can interrupt CPU if I2C interrupt enable bit (INTEN) is set to 1.
N * |        |          |Note: Software can write 1 to clear this bit.
N * |[1]     |TOCDIV4   |Time-Out Counter Input Clock Divided By 4
N * |        |          |When Enabled, The time-out period is extend 4 times.
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[2]     |TOCEN     |Time-Out Counter Enable Bit
N * |        |          |When Enabled, the 14-bit time-out counter will start counting when SI is clear.
N * |        |          |Setting flag SI to '1' will reset counter and re-start up counting after SI is cleared.
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * @var I2C_T::ADDR1
N * Offset: 0x18  I2C Slave Address Register1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GC        |General Call Function
N * |        |          |0 = General Call Function Disabled.
N * |        |          |1 = General Call Function Enabled.
N * |[7:1]   |ADDR      |I2C Address
N * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
N * |        |          |The I2C hardware will react if either of the address is matched.
N * @var I2C_T::ADDR2
N * Offset: 0x1C  I2C Slave Address Register2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GC        |General Call Function
N * |        |          |0 = General Call Function Disabled.
N * |        |          |1 = General Call Function Enabled.
N * |[7:1]   |ADDR      |I2C Address
N * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
N * |        |          |The I2C hardware will react if either of the address is matched.
N * @var I2C_T::ADDR3
N * Offset: 0x20  I2C Slave Address Register3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GC        |General Call Function
N * |        |          |0 = General Call Function Disabled.
N * |        |          |1 = General Call Function Enabled.
N * |[7:1]   |ADDR      |I2C Address
N * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
N * |        |          |The I2C hardware will react if either of the address is matched.
N * @var I2C_T::ADDRMSK0
N * Offset: 0x24  I2C Slave Address Mask Register0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:1]   |ADDRMSK   |I2C Address Mask
N * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
N * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
N * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
N * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
N * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
N * @var I2C_T::ADDRMSK1
N * Offset: 0x28  I2C Slave Address Mask Register1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:1]   |ADDRMSK   |I2C Address Mask
N * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
N * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
N * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
N * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
N * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
N * @var I2C_T::ADDRMSK2
N * Offset: 0x2C  I2C Slave Address Mask Register2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:1]   |ADDRMSK   |I2C Address Mask
N * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
N * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
N * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
N * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
N * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
N * @var I2C_T::ADDRMSK3
N * Offset: 0x30  I2C Slave Address Mask Register3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:1]   |ADDRMSK   |I2C Address Mask
N * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
N * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
N * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
N * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
N * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
N * @var I2C_T::WKCTL
N * Offset: 0x3C  I2C Wake-up Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WKEN      |I2C Wake-Up Enable Bit
N * |        |          |0 = I2C wake-up function Disabled.
N * |        |          |1= I2C wake-up function Enabled.
N * @var I2C_T::WKSTS
N * Offset: 0x40  I2C Wake-up Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WKIF      |I2C Wake-Up Flag
N * |        |          |When chip is woken up from Power-down mode by I2C, this bit is set to 1.
N * |        |          |Software can write 1 to clear this bit.
N * @var I2C_T::BUSCTL
N * Offset: 0x44  I2C Bus Management Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ACKMEN    |Acknowledge Control By Manual
N * |        |          |In order to allow ACK control in slave reception including the command and data, slave byte control mode must be enabled by setting the ACKMEN bit.
N * |        |          |0 = Slave byte control Disabled.
N * |        |          |1 = Slave byte control Enabled.
N * |        |          |The 9th bit can response the ACK or NACK according the received data by user.
N * |        |          |When the byte is received, stretching the SCLK signal low between the 8th and 9th SCLK pulse.
N * |        |          |Note: If the BMDEN =1 and this bit is enabled, the information of I2C_STATUS will be fixed as 0xF0 in slave receive condition.
N * |[1]     |PECEN     |Packet Error Checking Calculation Enable Bit
N * |        |          |0 = Packet Error Checking Calculation Disabled.
N * |        |          |1 = Packet Error Checking Calculation Enabled.
N * |[2]     |BMDEN     |Bus Management Device Default Address Enable Bit
N * |        |          |0 = Device default address Disable.
N * |        |          |When the address 0'b1100001x coming and the both of BMDEN and ACKMEN are enabled, the device responses NACKed.
N * |        |          |1 = Device default address Enabled.
N * |        |          |When the address 0'b1100001x coming and the both of BMDEN and ACKMEN are enabled, the device responses ACKed.
N * |[3]     |BMHEN     |Bus Management Host Enable Bit
N * |        |          |0 = Host function Disabled.
N * |        |          |1 = Host function Enabled and the SUSCON will be used as CONTROL function.
N * |[4]     |ALERTEN   |Bus Management Alert Enable Bit
N * |        |          |Device Mode (BMHEN =0).
N * |        |          |0 = Release the BM_ALERT pin high and Alert Response Header disabled: 0001100x followed by NACK if both of BMDEN and ACKMEN are enabled.
N * |        |          |1 = Drive BM_ALERT pin low and Alert Response Address Header enables: 0001100x followed by ACK if both of BMDEN and ACKMEN are enabled.
N * |        |          |Host Mode (BMHEN =1).
N * |        |          |0 = BM_ALERT pin not supported.
N * |        |          |1 = BM_ALERT pin supported.
N * |[5]     |SCTLOSTS  |Suspend/Control Data Output Status
N * |        |          |0 = The output of SUSCON pin is low.
N * |        |          |1 = The output of SUSCON pin is high.
N * |[6]     |SCTLOEN   |Suspend Or Control Pin Output Enable Bit
N * |        |          |0 = The SUSCON pin in input.
N * |        |          |1 = The output enable is active on the SUSCON pin.
N * |[7]     |BUSEN     |BUS Enable Bit
N * |        |          |0 = The system management function is Disabled.
N * |        |          |1 = The system management function is Enable.
N * |        |          |Note: When the bit is enabled, the internal 14-bit counter is used to calculate the time out event of clock low condition.
N * |[8]     |PECTXEN   |Packet Error Checking Byte Transmission/Reception
N * |        |          |This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address Matched is received
N * |        |          |0 = No PEC transfer.
N * |        |          |1 = PEC transmission/reception is requested.
N * |        |          |Note: 1.This bit has no effect in slave mode when ACKMEN =0.
N * |[9]     |TIDLE     |Timer Check In Idle State
N * |        |          |The BUSTOUT is used to calculate the time-out of clock low in bus active and the idle period in bus Idle.
N * |        |          |This bit is used to define which condition is enabled.
N * |        |          |0 = The BUSTOUT is used to calculate the clock low period in bus active.
N * |        |          |1 = The BUSTOUT is used to calculate the IDLE period in bus Idle.
N * |        |          |Note: The BUSY (I2C_BUSSTS[0]) indicate the current bus state.
N * |[10]    |PECCLR    |PEC Clear At Repeat Start
N * |        |          |The calculation of PEC starts when PECEN is set to 1 and it is clear when the STA or STO bit is detected.
N * |        |          |This PECCLR bit is used to enable the condition of REPEAT START can clear the PEC calculation.
N * |        |          |0 = The PEC calculation is cleared by "Repeat Start" function is Disabled.
N * |        |          |1 = The PEC calculation is cleared by "Repeat Start" function is Enabled.
N * |[11]    |ACKM9SI   |Acknowledge Manual Enable Extra SI Interrupt
N * |        |          |0 = There is no SI interrupt in the 9th clock cycle when the BUSEN =1 and ACKMEN =1.
N * |        |          |1 = There is SI interrupt in the 9th clock cycle when the BUSEN =1 and ACKMEN =1.
N * @var I2C_T::BUSTCTL
N * Offset: 0x48  I2C Bus Management Timer Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |BUSTOEN   |Bus Time Out Enable Bit
N * |        |          |0 = Indicates the bus clock low time-out detection is Disabled.
N * |        |          |1 = Indicates the bus clock low time-out detection is Enabled 
N * |        |          |bus clock is low for more than Time-out (in BIDLE=0) or high more than Time-out(in BIDLE =1),
N * |[1]     |CLKTOEN   |Cumulative Clock Low Time Out Enable Bit
N * |        |          |0 = Indicates the cumulative clock low time-out detection is Disabled.
N * |        |          |1 = Indicates the cumulative clock low time-out detection is Enabled.
N * |        |          |For Master, it calculates the period from START to ACK
N * |        |          |For Slave, it calculates the period from START to STOP
N * |[2]     |BUSTOIEN  |Time-Out Interrupt Enable Bit
N * |        |          |BUSY =1.
N * |        |          |0 = Indicates the SCLK low time-out interrupt is Disabled.
N * |        |          |1 = Indicates the SCLK low time-out interrupt is Enabled.
N * |        |          |BUSY =0.
N * |        |          |0 = Indicates the bus IDLE time-out interrupt is Disabled.
N * |        |          |1 = Indicates the bus IDLE time-out interrupt is Enabled.
N * |[3]     |CLKTOIEN  |Extended Clock Time Out Interrupt Enable Bit
N * |        |          |0 = Indicates the time extended interrupt is Disabled.
N * |        |          |1 = Indicates the time extended interrupt is Enabled.
N * |[4]     |TORSTEN   |Time Out Reset Enable Bit
N * |        |          |0 = Indicates the I2C state machine reset is Disable.
N * |        |          |1 = Indicates the I2C state machine reset is Enable. (The clock and data bus will be released to high)
N * |[5]     |PECIEN    |Packet Error Checking Byte Count Done Interrupt Enable Bit
N * |        |          |0 = Indicates the byte count done interrupt is Disabled.
N * |        |          |1 = Indicates the byte count done interrupt is Enabled.
N * |        |          |Note: This bit is used in PECEN =1.
N * @var I2C_T::BUSSTS
N * Offset: 0x4C  I2C Bus Management Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |BUSY      |Bus Busy
N * |        |          |Indicates that a communication is in progress on the bus.
N * |        |          |It is set by hardware when a START condition is detected.
N * |        |          |It is cleared by hardware when a STOP condition is detected.
N * |        |          |0 = The bus is IDLE (both SCLK and SDA High).
N * |        |          |1 = The bus is busy.
N * |[1]     |BCDONE    |Byte Count Transmission/Receive Done
N * |        |          |0 = Indicates the transmission/ receive is not finished when the PECEN is set.
N * |        |          |1 = Indicates the transmission/ receive is finished when the PECEN is set.
N * |        |          |Note: Software can write 1 to clear this bit.
N * |[2]     |PECERR    |PEC Error In Reception
N * |        |          |0 = Indicates the PEC value equal the received PEC data packet.
N * |        |          |1 = Indicates the PEC value doesn't match the receive PEC data packet.
N * |        |          |Note: Software can write 1 to clear this bit.
N * |[3]     |ALERT     |SMBus Alert Status
N * |        |          |Device Mode (BMHEN =0).
N * |        |          |0 = Indicates SMALERT pin state is low.
N * |        |          |1 = Indicates SMALERT pin state is high
N * |        |          |Host Mode (BMHEN =1).
N * |        |          |0 = No SMBALERT event.
N * |        |          |1 = Indicates there is SMBALERT event (falling edge) is detected in SMALERT pin when the BMHEN = 1 (SMBus host configuration) and the ALERTEN = 1.
N * |        |          |Note: 1.
N * |        |          |The SMALERT pin is an open-drain pin, the pull-high resistor is must in the system.
N * |        |          |2.
N * |        |          |Software can write 1 to clear this bit.
N * |[4]     |SCTLDIN   |Bus Suspend Or Control Signal Input Status
N * |        |          |0 = The input status of SUSCON pin is 0.
N * |        |          |1 = The input status of SUSCON pin is 1.
N * |[5]     |BUSTO     |Bus Time-out Status
N * |        |          |0 = Indicates that there is no any time-out or external clock time-out.
N * |        |          |1 = Indicates that a time-out or external clock time-out occurred.
N * |        |          |In bus busy, the bit indicates the total clock low time-out event occurred otherwise, it indicates the bus idle time-out event occurred.
N * |        |          |Note: Software can write 1 to clear this bit.
N * |[6]     |CLKTO     |Clock Low Cumulate Time-out Status
N * |        |          |0 = Indicates that the cumulative clock low is no any time-out.
N * |        |          |1 = Indicates that the cumulative clock low time-out occurred.
N * |        |          |Note: Software can write 1 to clear this bit.
N * @var I2C_T::PKTSIZE
N * Offset: 0x50  I2C Packet Error Checking Byte Number Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |PLDSIZE   |Transfer Byte Number
N * |        |          |The transmission or receive byte number in one transaction when the PECEN is set.
N * |        |          |The maximum transaction or receive byte is 255 Bytes.
N * @var I2C_T::PKTCRC
N * Offset: 0x54  I2C Packet Error Checking Byte Value Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |PECCRC    |Packet Error Checking Byte Value
N * |        |          |This byte indicates the packet error checking content after transmission or receive byte count by using the C(x) = X8 + X2 + X + 1.
N * |        |          |I t is read only.
N * @var I2C_T::BUSTOUT
N * Offset: 0x58  I2C Bus Management Timer Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |BUSTO     |Bus Management Time-out Value
N * |        |          |Indicate the bus time-out value in bus is IDLE or SCLK low.
N * |        |          |Note: If the user wants to revise the value of BUSTOUT, the TORSTEN (I2C_BUSTCTL[4]) bit shall be set to 1 and clear to 0 first in the BUSEN(I2C_BUSCTL[7]) is set.
N * @var I2C_T::CLKTOUT
N * Offset: 0x5C  I2C Bus Management Clock Low Timer Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |CLKTO     |Bus Clock Low Timer
N * |        |          |The field is used to configure the cumulative clock extension time-out.
N * |        |          |Note: If the user wants to revise the value of CLKLTOUT, the TORSTEN bit shall be set to 1 and d clear to 0 first in the BUSEN is set.
N    */
N
N    __IO uint32_t CTL;           /* Offset: 0x00  I2C Control Register                                               */
X    volatile uint32_t CTL;            
N    __IO uint32_t ADDR0;         /* Offset: 0x04  I2C Slave Address Register0                                        */
X    volatile uint32_t ADDR0;          
N    __IO uint32_t DAT;           /* Offset: 0x08  I2C Data Register                                                  */
X    volatile uint32_t DAT;            
N    __I  uint32_t STATUS;        /* Offset: 0x0C  I2C Status Register                                                */
X    volatile const  uint32_t STATUS;         
N    __IO uint32_t CLKDIV;        /* Offset: 0x10  I2C Clock Divided Register                                         */
X    volatile uint32_t CLKDIV;         
N    __IO uint32_t TOCTL;         /* Offset: 0x14  I2C Time-out Control Register                                      */
X    volatile uint32_t TOCTL;          
N    __IO uint32_t ADDR1;         /* Offset: 0x18  I2C Slave Address Register1                                        */
X    volatile uint32_t ADDR1;          
N    __IO uint32_t ADDR2;         /* Offset: 0x1C  I2C Slave Address Register2                                        */
X    volatile uint32_t ADDR2;          
N    __IO uint32_t ADDR3;         /* Offset: 0x20  I2C Slave Address Register3                                        */
X    volatile uint32_t ADDR3;          
N    __IO uint32_t ADDRMSK0;      /* Offset: 0x24  I2C Slave Address Mask Register0                                   */
X    volatile uint32_t ADDRMSK0;       
N    __IO uint32_t ADDRMSK1;      /* Offset: 0x28  I2C Slave Address Mask Register1                                   */
X    volatile uint32_t ADDRMSK1;       
N    __IO uint32_t ADDRMSK2;      /* Offset: 0x2C  I2C Slave Address Mask Register2                                   */
X    volatile uint32_t ADDRMSK2;       
N    __IO uint32_t ADDRMSK3;      /* Offset: 0x30  I2C Slave Address Mask Register3                                   */
X    volatile uint32_t ADDRMSK3;       
N    __I  uint32_t RESERVE0[2];  
X    volatile const  uint32_t RESERVE0[2];  
N    __IO uint32_t WKCTL;         /* Offset: 0x3C  I2C Wake-up Control Register                                       */
X    volatile uint32_t WKCTL;          
N    __IO uint32_t WKSTS;         /* Offset: 0x40  I2C Wake-up Status Register                                        */
X    volatile uint32_t WKSTS;          
N    __IO uint32_t BUSCTL;        /* Offset: 0x44  I2C Bus Management Control Register                                */
X    volatile uint32_t BUSCTL;         
N    __IO uint32_t BUSTCTL;       /* Offset: 0x48  I2C Bus Management Timer Control Register                          */
X    volatile uint32_t BUSTCTL;        
N    __IO uint32_t BUSSTS;        /* Offset: 0x4C  I2C Bus Management Status Register                                 */
X    volatile uint32_t BUSSTS;         
N    __IO uint32_t PKTSIZE;       /* Offset: 0x50  I2C Packet Error Checking Byte Number Register                     */
X    volatile uint32_t PKTSIZE;        
N    __I  uint32_t PKTCRC;        /* Offset: 0x54  I2C Packet Error Checking Byte Value Register                      */
X    volatile const  uint32_t PKTCRC;         
N    __IO uint32_t BUSTOUT;       /* Offset: 0x58  I2C Bus Management Timer Register                                  */
X    volatile uint32_t BUSTOUT;        
N    __IO uint32_t CLKTOUT;       /* Offset: 0x5C  I2C Bus Management Clock Low Timer Register                        */
X    volatile uint32_t CLKTOUT;        
N
N} I2C_T;
N
N
N
N/**
N    @addtogroup I2C_CONST I2C Bit Field Definition
N    Constant Definitions for I2C Controller
N@{ */
N
N#define I2C_CTL_AA_Pos                   (2)                                               /*!< I2C_T::CTL: AA Position                   */
N#define I2C_CTL_AA_Msk                   (0x1ul << I2C_CTL_AA_Pos)                         /*!< I2C_T::CTL: AA Mask                       */
N
N#define I2C_CTL_SI_Pos                   (3)                                               /*!< I2C_T::CTL: SI Position                   */
N#define I2C_CTL_SI_Msk                   (0x1ul << I2C_CTL_SI_Pos)                         /*!< I2C_T::CTL: SI Mask                       */
N
N#define I2C_CTL_STO_Pos                  (4)                                               /*!< I2C_T::CTL: STO Position                  */
N#define I2C_CTL_STO_Msk                  (0x1ul << I2C_CTL_STO_Pos)                        /*!< I2C_T::CTL: STO Mask                      */
N
N#define I2C_CTL_STA_Pos                  (5)                                               /*!< I2C_T::CTL: STA Position                  */
N#define I2C_CTL_STA_Msk                  (0x1ul << I2C_CTL_STA_Pos)                        /*!< I2C_T::CTL: STA Mask                      */
N
N#define I2C_CTL_I2CEN_Pos                (6)                                               /*!< I2C_T::CTL: I2CEN Position                */
N#define I2C_CTL_I2CEN_Msk                (0x1ul << I2C_CTL_I2CEN_Pos)                      /*!< I2C_T::CTL: I2CEN Mask                    */
N
N#define I2C_CTL_INTEN_Pos                (7)                                               /*!< I2C_T::CTL: INTEN Position                */
N#define I2C_CTL_INTEN_Msk                (0x1ul << I2C_CTL_INTEN_Pos)                      /*!< I2C_T::CTL: INTEN Mask                    */
N
N#define I2C_ADDR0_GC_Pos                 (0)                                               /*!< I2C_T::ADDR0: GC Position                 */
N#define I2C_ADDR0_GC_Msk                 (0x1ul << I2C_ADDR0_GC_Pos)                       /*!< I2C_T::ADDR0: GC Mask                     */
N
N#define I2C_ADDR0_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR0: ADDR Position               */
N#define I2C_ADDR0_ADDR_Msk               (0x7ful << I2C_ADDR0_ADDR_Pos)                    /*!< I2C_T::ADDR0: ADDR Mask                   */
N
N#define I2C_DAT_DAT_Pos                  (0)                                               /*!< I2C_T::DAT: DAT Position                  */
N#define I2C_DAT_DAT_Msk                  (0xfful << I2C_DAT_DAT_Pos)                       /*!< I2C_T::DAT: DAT Mask                      */
N
N#define I2C_STATUS_STATUS_Pos            (0)                                               /*!< I2C_T::STATUS: STATUS Position            */
N#define I2C_STATUS_STATUS_Msk            (0xfful << I2C_STATUS_STATUS_Pos)                 /*!< I2C_T::STATUS: STATUS Mask                */
N
N#define I2C_CLKDIV_DIVIDER_Pos           (0)                                               /*!< I2C_T::CLKDIV: DIVIDER Position           */
N#define I2C_CLKDIV_DIVIDER_Msk           (0xfful << I2C_CLKDIV_DIVIDER_Pos)                /*!< I2C_T::CLKDIV: DIVIDER Mask               */
N
N#define I2C_TOCTL_TOIF_Pos               (0)                                               /*!< I2C_T::TOCTL: TOIF Position               */
N#define I2C_TOCTL_TOIF_Msk               (0x1ul << I2C_TOCTL_TOIF_Pos)                     /*!< I2C_T::TOCTL: TOIF Mask                   */
N
N#define I2C_TOCTL_TOCDIV4_Pos            (1)                                               /*!< I2C_T::TOCTL: TOCDIV4 Position            */
N#define I2C_TOCTL_TOCDIV4_Msk            (0x1ul << I2C_TOCTL_TOCDIV4_Pos)                  /*!< I2C_T::TOCTL: TOCDIV4 Mask                */
N
N#define I2C_TOCTL_TOCEN_Pos              (2)                                               /*!< I2C_T::TOCTL: TOCEN Position              */
N#define I2C_TOCTL_TOCEN_Msk              (0x1ul << I2C_TOCTL_TOCEN_Pos)                    /*!< I2C_T::TOCTL: TOCEN Mask                  */
N
N#define I2C_ADDR1_GC_Pos                 (0)                                               /*!< I2C_T::ADDR1: GC Position                 */
N#define I2C_ADDR1_GC_Msk                 (0x1ul << I2C_ADDR1_GC_Pos)                       /*!< I2C_T::ADDR1: GC Mask                     */
N
N#define I2C_ADDR1_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR1: ADDR Position               */
N#define I2C_ADDR1_ADDR_Msk               (0x7ful << I2C_ADDR1_ADDR_Pos)                    /*!< I2C_T::ADDR1: ADDR Mask                   */
N
N#define I2C_ADDR2_GC_Pos                 (0)                                               /*!< I2C_T::ADDR2: GC Position                 */
N#define I2C_ADDR2_GC_Msk                 (0x1ul << I2C_ADDR2_GC_Pos)                       /*!< I2C_T::ADDR2: GC Mask                     */
N
N#define I2C_ADDR2_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR2: ADDR Position               */
N#define I2C_ADDR2_ADDR_Msk               (0x7ful << I2C_ADDR2_ADDR_Pos)                    /*!< I2C_T::ADDR2: ADDR Mask                   */
N
N#define I2C_ADDR3_GC_Pos                 (0)                                               /*!< I2C_T::ADDR3: GC Position                 */
N#define I2C_ADDR3_GC_Msk                 (0x1ul << I2C_ADDR3_GC_Pos)                       /*!< I2C_T::ADDR3: GC Mask                     */
N
N#define I2C_ADDR3_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR3: ADDR Position               */
N#define I2C_ADDR3_ADDR_Msk               (0x7ful << I2C_ADDR3_ADDR_Pos)                    /*!< I2C_T::ADDR3: ADDR Mask                   */
N
N#define I2C_ADDRMSK0_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK0: ADDRMSK Position         */
N#define I2C_ADDRMSK0_ADDRMSK_Msk         (0x7ful << I2C_ADDRMSK0_ADDRMSK_Pos)              /*!< I2C_T::ADDRMSK0: ADDRMSK Mask             */
N
N#define I2C_ADDRMSK1_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK1: ADDRMSK Position         */
N#define I2C_ADDRMSK1_ADDRMSK_Msk         (0x7ful << I2C_ADDRMSK1_ADDRMSK_Pos)              /*!< I2C_T::ADDRMSK1: ADDRMSK Mask             */
N
N#define I2C_ADDRMSK2_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK2: ADDRMSK Position         */
N#define I2C_ADDRMSK2_ADDRMSK_Msk         (0x7ful << I2C_ADDRMSK2_ADDRMSK_Pos)              /*!< I2C_T::ADDRMSK2: ADDRMSK Mask             */
N
N#define I2C_ADDRMSK3_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK3: ADDRMSK Position         */
N#define I2C_ADDRMSK3_ADDRMSK_Msk         (0x7ful << I2C_ADDRMSK3_ADDRMSK_Pos)              /*!< I2C_T::ADDRMSK3: ADDRMSK Mask             */
N
N#define I2C_WKCTL_WKEN_Pos               (0)                                               /*!< I2C_T::WKCTL: WKEN Position               */
N#define I2C_WKCTL_WKEN_Msk               (0x1ul << I2C_WKCTL_WKEN_Pos)                     /*!< I2C_T::WKCTL: WKEN Mask                   */
N
N#define I2C_WKSTS_WKIF_Pos               (0)                                               /*!< I2C_T::WKSTS: WKIF Position               */
N#define I2C_WKSTS_WKIF_Msk               (0x1ul << I2C_WKSTS_WKIF_Pos)                     /*!< I2C_T::WKSTS: WKIF Mask                   */
N
N#define I2C_BUSCTL_ACKMEN_Pos            (0)                                               /*!< I2C_T::BUSCTL: ACKMEN Position            */
N#define I2C_BUSCTL_ACKMEN_Msk            (0x1ul << I2C_BUSCTL_ACKMEN_Pos)                  /*!< I2C_T::BUSCTL: ACKMEN Mask                */
N
N#define I2C_BUSCTL_PECEN_Pos             (1)                                               /*!< I2C_T::BUSCTL: PECEN Position             */
N#define I2C_BUSCTL_PECEN_Msk             (0x1ul << I2C_BUSCTL_PECEN_Pos)                   /*!< I2C_T::BUSCTL: PECEN Mask                 */
N
N#define I2C_BUSCTL_BMDEN_Pos             (2)                                               /*!< I2C_T::BUSCTL: BMDEN Position             */
N#define I2C_BUSCTL_BMDEN_Msk             (0x1ul << I2C_BUSCTL_BMDEN_Pos)                   /*!< I2C_T::BUSCTL: BMDEN Mask                 */
N
N#define I2C_BUSCTL_BMHEN_Pos             (3)                                               /*!< I2C_T::BUSCTL: BMHEN Position             */
N#define I2C_BUSCTL_BMHEN_Msk             (0x1ul << I2C_BUSCTL_BMHEN_Pos)                   /*!< I2C_T::BUSCTL: BMHEN Mask                 */
N
N#define I2C_BUSCTL_ALERTEN_Pos           (4)                                               /*!< I2C_T::BUSCTL: ALERTEN Position           */
N#define I2C_BUSCTL_ALERTEN_Msk           (0x1ul << I2C_BUSCTL_ALERTEN_Pos)                 /*!< I2C_T::BUSCTL: ALERTEN Mask               */
N
N#define I2C_BUSCTL_SCTLOSTS_Pos          (5)                                               /*!< I2C_T::BUSCTL: SCTLOSTS Position          */
N#define I2C_BUSCTL_SCTLOSTS_Msk          (0x1ul << I2C_BUSCTL_SCTLOSTS_Pos)                /*!< I2C_T::BUSCTL: SCTLOSTS Mask              */
N
N#define I2C_BUSCTL_SCTLOEN_Pos           (6)                                               /*!< I2C_T::BUSCTL: SCTLOEN Position           */
N#define I2C_BUSCTL_SCTLOEN_Msk           (0x1ul << I2C_BUSCTL_SCTLOEN_Pos)                 /*!< I2C_T::BUSCTL: SCTLOEN Mask               */
N
N#define I2C_BUSCTL_BUSEN_Pos             (7)                                               /*!< I2C_T::BUSCTL: BUSEN Position             */
N#define I2C_BUSCTL_BUSEN_Msk             (0x1ul << I2C_BUSCTL_BUSEN_Pos)                   /*!< I2C_T::BUSCTL: BUSEN Mask                 */
N
N#define I2C_BUSCTL_PECTXEN_Pos           (8)                                               /*!< I2C_T::BUSCTL: PECTXEN Position           */
N#define I2C_BUSCTL_PECTXEN_Msk           (0x1ul << I2C_BUSCTL_PECTXEN_Pos)                 /*!< I2C_T::BUSCTL: PECTXEN Mask               */
N
N#define I2C_BUSCTL_TIDLE_Pos             (9)                                               /*!< I2C_T::BUSCTL: TIDLE Position             */
N#define I2C_BUSCTL_TIDLE_Msk             (0x1ul << I2C_BUSCTL_TIDLE_Pos)                   /*!< I2C_T::BUSCTL: TIDLE Mask                 */
N
N#define I2C_BUSCTL_PECCLR_Pos            (10)                                              /*!< I2C_T::BUSCTL: PECCLR Position            */
N#define I2C_BUSCTL_PECCLR_Msk            (0x1ul << I2C_BUSCTL_PECCLR_Pos)                  /*!< I2C_T::BUSCTL: PECCLR Mask                */
N
N#define I2C_BUSCTL_ACKM9SI_Pos           (11)                                              /*!< I2C_T::BUSCTL: ACKM9SI Position           */
N#define I2C_BUSCTL_ACKM9SI_Msk           (0x1ul << I2C_BUSCTL_ACKM9SI_Pos)                 /*!< I2C_T::BUSCTL: ACKM9SI Mask               */
N
N#define I2C_BUSTCTL_BUSTOEN_Pos          (0)                                               /*!< I2C_T::BUSTCTL: BUSTOEN Position          */
N#define I2C_BUSTCTL_BUSTOEN_Msk          (0x1ul << I2C_BUSTCTL_BUSTOEN_Pos)                /*!< I2C_T::BUSTCTL: BUSTOEN Mask              */
N
N#define I2C_BUSTCTL_CLKTOEN_Pos          (1)                                               /*!< I2C_T::BUSTCTL: CLKTOEN Position          */
N#define I2C_BUSTCTL_CLKTOEN_Msk          (0x1ul << I2C_BUSTCTL_CLKTOEN_Pos)                /*!< I2C_T::BUSTCTL: CLKTOEN Mask              */
N
N#define I2C_BUSTCTL_BUSTOIEN_Pos         (2)                                               /*!< I2C_T::BUSTCTL: BUSTOIEN Position         */
N#define I2C_BUSTCTL_BUSTOIEN_Msk         (0x1ul << I2C_BUSTCTL_BUSTOIEN_Pos)               /*!< I2C_T::BUSTCTL: BUSTOIEN Mask             */
N
N#define I2C_BUSTCTL_CLKTOIEN_Pos         (3)                                               /*!< I2C_T::BUSTCTL: CLKTOIEN Position         */
N#define I2C_BUSTCTL_CLKTOIEN_Msk         (0x1ul << I2C_BUSTCTL_CLKTOIEN_Pos)               /*!< I2C_T::BUSTCTL: CLKTOIEN Mask             */
N
N#define I2C_BUSTCTL_TORSTEN_Pos          (4)                                               /*!< I2C_T::BUSTCTL: TORSTEN Position          */
N#define I2C_BUSTCTL_TORSTEN_Msk          (0x1ul << I2C_BUSTCTL_TORSTEN_Pos)                /*!< I2C_T::BUSTCTL: TORSTEN Mask              */
N
N#define I2C_BUSTCTL_PECIEN_Pos           (5)                                               /*!< I2C_T::BUSTCTL: PECIEN Position           */
N#define I2C_BUSTCTL_PECIEN_Msk           (0x1ul << I2C_BUSTCTL_PECIEN_Pos)                 /*!< I2C_T::BUSTCTL: PECIEN Mask               */
N
N#define I2C_BUSSTS_BUSY_Pos              (0)                                               /*!< I2C_T::BUSSTS: BUSY Position              */
N#define I2C_BUSSTS_BUSY_Msk              (0x1ul << I2C_BUSSTS_BUSY_Pos)                    /*!< I2C_T::BUSSTS: BUSY Mask                  */
N
N#define I2C_BUSSTS_BCDONE_Pos            (1)                                               /*!< I2C_T::BUSSTS: BCDONE Position            */
N#define I2C_BUSSTS_BCDONE_Msk            (0x1ul << I2C_BUSSTS_BCDONE_Pos)                  /*!< I2C_T::BUSSTS: BCDONE Mask                */
N
N#define I2C_BUSSTS_PECERR_Pos            (2)                                               /*!< I2C_T::BUSSTS: PECERR Position            */
N#define I2C_BUSSTS_PECERR_Msk            (0x1ul << I2C_BUSSTS_PECERR_Pos)                  /*!< I2C_T::BUSSTS: PECERR Mask                */
N
N#define I2C_BUSSTS_ALERT_Pos             (3)                                               /*!< I2C_T::BUSSTS: ALERT Position             */
N#define I2C_BUSSTS_ALERT_Msk             (0x1ul << I2C_BUSSTS_ALERT_Pos)                   /*!< I2C_T::BUSSTS: ALERT Mask                 */
N
N#define I2C_BUSSTS_SCTLDIN_Pos           (4)                                               /*!< I2C_T::BUSSTS: SCTLDIN Position           */
N#define I2C_BUSSTS_SCTLDIN_Msk           (0x1ul << I2C_BUSSTS_SCTLDIN_Pos)                 /*!< I2C_T::BUSSTS: SCTLDIN Mask               */
N
N#define I2C_BUSSTS_BUSTO_Pos             (5)                                               /*!< I2C_T::BUSSTS: BUSTO Position             */
N#define I2C_BUSSTS_BUSTO_Msk             (0x1ul << I2C_BUSSTS_BUSTO_Pos)                   /*!< I2C_T::BUSSTS: BUSTO Mask                 */
N
N#define I2C_BUSSTS_CLKTO_Pos             (6)                                               /*!< I2C_T::BUSSTS: CLKTO Position             */
N#define I2C_BUSSTS_CLKTO_Msk             (0x1ul << I2C_BUSSTS_CLKTO_Pos)                   /*!< I2C_T::BUSSTS: CLKTO Mask                 */
N
N#define I2C_PKTSIZE_PLDSIZE_Pos          (0)                                               /*!< I2C_T::PKTSIZE: PLDSIZE Position          */
N#define I2C_PKTSIZE_PLDSIZE_Msk          (0xfful << I2C_PKTSIZE_PLDSIZE_Pos)               /*!< I2C_T::PKTSIZE: PLDSIZE Mask              */
N
N#define I2C_PKTCRC_PECCRC_Pos            (0)                                               /*!< I2C_T::PKTCRC: PECCRC Position            */
N#define I2C_PKTCRC_PECCRC_Msk            (0xfful << I2C_PKTCRC_PECCRC_Pos)                 /*!< I2C_T::PKTCRC: PECCRC Mask                */
N
N#define I2C_BUSTOUT_BUSTO_Pos            (0)                                               /*!< I2C_T::BUSTOUT: BUSTO Position            */
N#define I2C_BUSTOUT_BUSTO_Msk            (0xfful << I2C_BUSTOUT_BUSTO_Pos)                 /*!< I2C_T::BUSTOUT: BUSTO Mask                */
N
N#define I2C_CLKTOUT_CLKTO_Pos            (0)                                               /*!< I2C_T::CLKTOUT: CLKTO Position            */
N#define I2C_CLKTOUT_CLKTO_Msk            (0xfful << I2C_CLKTOUT_CLKTO_Pos)                 /*!< I2C_T::CLKTOUT: CLKTO Mask                */
N
N
N/**@}*/ /* I2C_CONST */
N/**@}*/ /* end of I2C register group */
N
N/*---------------------- USB On-The-Go Controller -------------------------*/
N/**
N    @addtogroup OTG USB On-The-Go Controller(OTG)
N    Memory Mapped Structure for OTG Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var OTG_T::CTL
N * Offset: 0x00  OTG Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |VBUSDROP  |Drop VBUS Control
N * |        |          |If user application running on this OTG A-device wants to conserve power, set this bit to drop VBUS.
N * |        |          |BUSREQ (OTG_CTL[1]) will be also cleared no matter A-device or B-device.
N * |        |          |0 = Not drop the VBUS.
N * |        |          |1 = Drop the VBUS.
N * |[1]     |BUSREQ    |OTG Bus Request
N * |        |          |If OTG A-device wants to do data transfers via USB bus, setting this bit will drive VBUS high to detect USB device connection.
N * |        |          |If user won't use the bus any more, clearing this bit will drop VBUS to save power.
N * |        |          |This bit will be cleared when A-device goes to A_wait_vfall state. A_wait_vfall state is defined in OTG specification.
N * |        |          |This bit will be also cleared if VBUSDROP (OTG_CTL[0]) bit is set or IDSTS (OTG_STATUS[1]) changed.
N * |        |          |If user of an OTG-B Device wants to request VBUS, setting this bit will run SRP protocol.
N * |        |          |This bit will be cleared if SRP failure (OTG A-device does not provide VBUS after B-device issues ARP in specified interval, defined in OTG specification).
N * |        |          |This bit will be also cleared if VBUSDROP (OTG_CTL[0]) bit is set IDSTS (OTG_STATUS[1]) changed.
N * |        |          |0 = Not launch VBUS in OTG A-device or not request SRP in OTG B-device.
N * |        |          |1 = Launch VBUS in OTG A-device or request SRP in OTG B-device.
N * |[2]     |HNPREQEN  |OTG HNP Request Enable Bit
N * |        |          |When USB frame as A-device, set this bit when A-device allows to process Host Negotiation Protocol.
N * |        |          |This bit will be cleared when OTG state changes from a_suspend to a_peripheral or goes back to a_idle state.
N * |        |          |When USB frame is as B-device, set this bit after the OTG A-device successfully sends a SetFeature (b_hnp_enable) command to the OTG B-device to start role change.
N * |        |          |This bit will be cleared when OTG state changes from b_peripheral to b_wait_acon or goes back to b_idle state.
N * |        |          |0 = HNP request Disabled.
N * |        |          |1 = HNP request Enabled (A-device can change role from Host to Peripheral or B-device can change role from Peripheral to Host).
N * |        |          |Note: Refer to OTG specification to get a_suspend, a_peripheral, a_idle and b_idle state.
N * |[4]     |OTGEN     |OTG Function Enable Bit
N * |        |          |User needs to set this bit to enable OTG function while USB frame configured as OTG device.
N * |        |          |When USB frame not configured as OTG device, this bit is must be low.
N * |        |          |0 = OTG function Disabled.
N * |        |          |1 = OTG function Enabled.
N * |[5]     |WKEN      |OTG ID Pin Wake-Up Enable Bit
N * |        |          |0 = OTG ID pin status change wake-up function Disabled.
N * |        |          |1 = OTG ID pin status change wake-up function Enabled.
N * @var OTG_T::PHYCTL
N * Offset: 0x04  OTG PHY Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |OTGPHYEN  |OTG PHY Enable
N * |        |          |When USB frame is configured as OTG-device, user needs to set this bit before using OTG function.
N * |        |          |If device is not configured as OTG-device, this bit is "don't care".
N * |        |          |0 = OTG PHY Disabled.
N * |        |          |1 = OTG PHY Enabled.
N * |[1]     |IDDETEN   |ID Detection Enable Bit
N * |        |          |0 = Detect ID pin status Disabled.
N * |        |          |1 = Detect ID pin status Enabled.
N * |[4]     |VBENPOL   |Off-Chip USB VBUS Power Switch Enable Polarity
N * |        |          |The OTG controller will enable off-chip USB VBUS power switch to provide VBUS power when need.
N * |        |          |A USB_VBUS_EN pin is used to control the off-chip USB VBUS power switch.
N * |        |          |The polarity of enabling off-chip USB VBUS power switch (high active or low active) depends on the selected component.
N * |        |          |Set this bit as following according to the polarity of off-chip USB VBUS power switch.
N * |        |          |0 = The off-chip USB VBUS power switch enable is active high.
N * |        |          |1 = The off-chip USB VBUS power switch enable is active low.
N * |[5]     |VBSTSPOL  |Off-Chip USB VBUS Power Switch Status Polarity
N * |        |          |The polarity of off-chip USB VBUS power switch valid signal depends on the selected component.
N * |        |          |A USB_VBUS_ST pin is used to monitor the valid signal of the off-chip USB VBUS power switch.
N * |        |          |Set this bit as following according to the polarity of off-chip USB VBUS power switch.
N * |        |          |0 = The polarity of off-chip USB VBUS power switch valid status is high.
N * |        |          |1 = The polarity of off-chip USB VBUS power switch valid status is low.
N * @var OTG_T::INTEN
N * Offset: 0x08  OTG Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ROLECHGIEN|Role (Host Or Peripheral) Changed Interrupt Enable Bit
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |[1]     |VBEIEN    |VBUS Error Interrupt Enable Bit
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |        |          |Note: VBUS error means going to a_vbus_err state. Please refer to A-device state diagram in OTG spec.
N * |[2]     |SRPFIEN   |SRP Fail Interrupt Enable Bit
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |[3]     |HNPFIEN   |HNP Fail Interrupt Enable Bit
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |[4]     |GOIDLEIEN |OTG Device Goes to IDLE State Interrupt Enable Bit
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |        |          |Note: Going to idle state means going to a_idle or b_idle state.
N * |        |          |Please refer to A-device state diagram and B-device state diagram in OTG spec.
N * |[5]     |IDCHGIEN  |IDSTS Changed Interrupt Enable Bit
N * |        |          |If this bit is set to 1 and IDSTS (OTG_STATUS[1]) status is changed from high to low or from low to high, a interrupt will be asserted.
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |[6]     |PDEVIEN   |Act As Peripheral Interrupt Enable Bit
N * |        |          |If this bit is set to 1 and the device is changed as a peripheral, a interrupt will be asserted.
N * |        |          |0 = This device as a peripheral interrupt Disabled.
N * |        |          |1 = This device as a peripheral interrupt Enabled.
N * |[7]     |HOSTIEN   |Act As Host Interrupt Enable Bit
N * |        |          |If this bit is set to 1 and the device is changed as a host, a interrupt will be asserted.
N * |        |          |0 = This device as a host interrupt Disabled.
N * |        |          |1 = This device as a host interrupt Enabled.
N * |[8]     |BVLDCHGIEN|B-Device Session Valid Status Changed Interrupt Enable Bit
N * |        |          |If this bit is set to 1 and BVLD (OTG_STATUS[3]) status is changed from high to low or from low to high, a interrupt will be asserted.
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |[9]     |AVLDCHGIEN|A-Device Session Valid Status Changed Interrupt Enable Bit
N * |        |          |If this bit is set to 1 and AVLD (OTG_STATUS[4]) status is changed from high to low or from low to high, a interrupt will be asserted.
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |[10]    |VBCHGIEN  |VBUSVLD Status Changed
N * |        |          |Interrupt Enable Bit
N * |        |          |If this bit is set to 1 and VBUSVLD (OTG_STATUS[5]) status is changed from high to low or from low to high, a interrupt will be asserted.
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |[11]    |SECHGIEN  |SESSEND Status Changed Interrupt Enable Bit
N * |        |          |If this bit is set to 1 and SESSEND (OTG_STATUS[2]) status is changed from high to low or from low to high, a interrupt will be asserted.
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |[13]    |SRPDETIEN |SRP Detected Interrupt Enable Bit
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * @var OTG_T::INTSTS
N * Offset: 0x0C  OTG Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ROLECHGIF |OTG Role Change Interrupt Status
N * |        |          |This flag is set when the role of an OTG device changed from a host to a peripheral, or changed from a peripheral to a host while USB_ID pin status does not change.
N * |        |          |0 = OTG device role not changed.
N * |        |          |1 = OTG device role changed.
N * |        |          |Note: Write 1 to clear this flag.
N * |[1]     |VBEIF     |VBUS Error Interrupt Status
N * |        |          |This bit will be set when voltage on VBUS cannot reach a minimum valid threshold 4.4V within a maximum time of 100ms after OTG A-device starting to drive VBUS high.
N * |        |          |0 = OTG A-device drives VBUS over threshold voltage before this interval expires.
N * |        |          |1 = OTG A-device cannot drive VBUS over threshold voltage before this interval expires.
N * |        |          |Note: Write 1 to clear this flag and recover from the VBUS error state.
N * |[2]     |SRPFIF    |SRP Fail Interrupt Status
N * |        |          |After initiating SRP, an OTG B-device will wait for the OTG A-device to drive VBUS high at least TB_SRP_FAIL minimum, defined in OTG specification.
N * |        |          |This flag is set when the OTG B-device does not get VBUS high after this interval.
N * |        |          |0 = OTG B-device gets VBUS high before this interval.
N * |        |          |1 = OTG B-device does not get VBUS high before this interval.
N * |        |          |Note: Write 1 to clear this flag.
N * |[3]     |HNPFIF    |HNP Fail Interrupt Status
N * |        |          |When A-device has granted B-device to be host and USB bus is in SE0 (both USB_D+ and USB_D- low) state, this bit will be set when A-device does not connect after specified interval expires.
N * |        |          |0 = A-device connects to B-device before specified interval expires.
N * |        |          |1 = A-device does not connect to B-device before specified interval expires.
N * |        |          |Note: Write 1 to clear this flag.
N * |[4]     |GOIDLEIF  |OTG Device Goes to IDLE Interrupt Status
N * |        |          |Flag is set if the OTG device transfers from non-idle state to idle state.
N * |        |          |The OTG device will be neither a host nor a peripheral.
N * |        |          |0 = OTG device does not go back to idle state (a_idle or b_idle).
N * |        |          |1 = OTG device goes back to idle state (a_idle or b_idle).
N * |        |          |Note 1: Going to idle state means going to a_idle or b_idle state. Please refer to OTG specification for the details of a_idle state and b_idle state.
N * |        |          |Note 2: Write 1 to clear this flag.
N * |[5]     |IDCHGIF   |ID State Change Interrupt Status
N * |        |          |0 = IDSTS (OTG_STATUS[1]) not toggled.
N * |        |          |1 = IDSTS (OTG_STATUS[1]) from high to low or from low to high.
N * |        |          |Note: Write 1 to clear this flag.
N * |[6]     |PDEVIF    |Act As Peripheral Interrupt Status
N * |        |          |0 = This device does not act as a peripheral.
N * |        |          |1 = This device acts as a peripheral.
N * |        |          |Note: Write 1 to clear this flag.
N * |[7]     |HOSTIF    |Act As Host Interrupt Status
N * |        |          |0 = This device does not act as a host.
N * |        |          |1 = This device acts as a host.
N * |        |          |Note: Write 1 to clear this flag.
N * |[8]     |BVLDCHGIF |B-Device Session Valid State Change Interrupt Status
N * |        |          |0 = BVLD (OTG_STATUS[3]) is not toggled.
N * |        |          |1 = BVLD (OTG_STATUS[3]) from high to low or low to high.
N * |        |          |Note: Write 1 to clear this status.
N * |[9]     |AVLDCHGIF |A-Device Session Valid State Change Interrupt Status
N * |        |          |0 = AVLD (OTG_STATUS[4]) not toggled.
N * |        |          |1 = AVLD (OTG_STATUS[4]) from high to low or low to high.
N * |        |          |Note: Write 1 to clear this status.
N * |[10]    |VBCHGIF   |VBUSVLD State Change Interrupt Status
N * |        |          |0 = VBUSVLD (OTG_STATUS[5]) not toggled.
N * |        |          |1 = VBUSVLD (OTG_STATUS[5]) from high to low or from low to high.
N * |        |          |Note: Write 1 to clear this status.
N * |[11]    |SECHGIF   |SESSEND State Change Interrupt Status
N * |        |          |0 = SESSEND (OTG_STATUS[2]) not toggled.
N * |        |          |1 = SESSEND (OTG_STATUS[2]) from high to low or from low to high.
N * |        |          |Note: Write 1 to clear this flag.
N * |[13]    |SRPDETIF  |SRP Detected Interrupt Status
N * |        |          |0 = SRP not detected.
N * |        |          |1 = SRP detected.
N * |        |          |Note: Write 1 to clear this status.
N * @var OTG_T::STATUS
N * Offset: 0x10  OTG Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |OVERCUR   |Over Current Condition
N * |        |          |The voltage on VBUS cannot reach a minimum VBUS valid threshold, 4.4V minimum, within a maximum time of 100ms after OTG A-device drives VBUS high.
N * |        |          |0 = OTG A-device drives VBUS successfully.
N * |        |          |1 = OTG A-device cannot drives VBUS high in this interval.
N * |[1]     |IDSTS     |USB_ID Pin State Of Mini-B/Micro-Plug
N * |        |          |0 = Mini-A/Micro-A plug is attached.
N * |        |          |1 = Mini-B/Micro-B plug is attached.
N * |[2]     |SESSEND   |Session End Status
N * |        |          |When VBUS voltage is lower than 0.4V, this bit will be set to 1.
N * |        |          |Session end means no meaningful power on VBUS.
N * |        |          |0 = Session is not end.
N * |        |          |1 = Session is end.
N * |[3]     |BVLD      |B-Device Session Valid Status
N * |        |          |0 = B-device session is not valid.
N * |        |          |1 = B-device session is valid.
N * |[4]     |AVLD      |A-Device Session Valid Status
N * |        |          |0 = A-device session is not valid.
N * |        |          |1 = A-device session is valid.
N * |[5]     |VBUSVLD   |VBUS Valid Status
N * |        |          |When VBUS is larger than 4.7V, this bit will be set to 1.
N * |        |          |0 = VBUS is not valid.
N * |        |          |1 = VBUS is valid.
N */
N
N    __IO uint32_t CTL;           /* Offset: 0x00  OTG Control Register                                               */
X    volatile uint32_t CTL;            
N    __IO uint32_t PHYCTL;        /* Offset: 0x04  OTG PHY Control Register                                           */
X    volatile uint32_t PHYCTL;         
N    __IO uint32_t INTEN;         /* Offset: 0x08  OTG Interrupt Enable Register                                      */
X    volatile uint32_t INTEN;          
N    __IO uint32_t INTSTS;        /* Offset: 0x0C  OTG Interrupt Status Register                                      */
X    volatile uint32_t INTSTS;         
N    __I  uint32_t STATUS;        /* Offset: 0x10  OTG Status Register                                                */
X    volatile const  uint32_t STATUS;         
N
N} OTG_T;
N
N
N
N/**
N    @addtogroup OTG_CONST OTG Bit Field Definition
N    Constant Definitions for OTG Controller
N@{ */
N
N#define OTG_CTL_VBUSDROP_Pos             (0)                                               /*!< OTG_T::CTL: VBUSDROP Position             */
N#define OTG_CTL_VBUSDROP_Msk             (0x1ul << OTG_CTL_VBUSDROP_Pos)                   /*!< OTG_T::CTL: VBUSDROP Mask                 */
N
N#define OTG_CTL_BUSREQ_Pos               (1)                                               /*!< OTG_T::CTL: BUSREQ Position               */
N#define OTG_CTL_BUSREQ_Msk               (0x1ul << OTG_CTL_BUSREQ_Pos)                     /*!< OTG_T::CTL: BUSREQ Mask                   */
N
N#define OTG_CTL_HNPREQEN_Pos             (2)                                               /*!< OTG_T::CTL: HNPREQEN Position             */
N#define OTG_CTL_HNPREQEN_Msk             (0x1ul << OTG_CTL_HNPREQEN_Pos)                   /*!< OTG_T::CTL: HNPREQEN Mask                 */
N
N#define OTG_CTL_OTGEN_Pos                (4)                                               /*!< OTG_T::CTL: OTGEN Position                */
N#define OTG_CTL_OTGEN_Msk                (0x1ul << OTG_CTL_OTGEN_Pos)                      /*!< OTG_T::CTL: OTGEN Mask                    */
N
N#define OTG_CTL_WKEN_Pos                 (5)                                               /*!< OTG_T::CTL: WKEN Position                 */
N#define OTG_CTL_WKEN_Msk                 (0x1ul << OTG_CTL_WKEN_Pos)                       /*!< OTG_T::CTL: WKEN Mask                     */
N
N#define OTG_PHYCTL_OTGPHYEN_Pos          (0)                                               /*!< OTG_T::PHYCTL: OTGPHYEN Position          */
N#define OTG_PHYCTL_OTGPHYEN_Msk          (0x1ul << OTG_PHYCTL_OTGPHYEN_Pos)                /*!< OTG_T::PHYCTL: OTGPHYEN Mask              */
N
N#define OTG_PHYCTL_IDDETEN_Pos           (1)                                               /*!< OTG_T::PHYCTL: IDDETEN Position           */
N#define OTG_PHYCTL_IDDETEN_Msk           (0x1ul << OTG_PHYCTL_IDDETEN_Pos)                 /*!< OTG_T::PHYCTL: IDDETEN Mask               */
N
N#define OTG_PHYCTL_VBENPOL_Pos           (4)                                               /*!< OTG_T::PHYCTL: VBENPOL Position           */
N#define OTG_PHYCTL_VBENPOL_Msk           (0x1ul << OTG_PHYCTL_VBENPOL_Pos)                 /*!< OTG_T::PHYCTL: VBENPOL Mask               */
N
N#define OTG_PHYCTL_VBSTSPOL_Pos          (5)                                               /*!< OTG_T::PHYCTL: VBSTSPOL Position          */
N#define OTG_PHYCTL_VBSTSPOL_Msk          (0x1ul << OTG_PHYCTL_VBSTSPOL_Pos)                /*!< OTG_T::PHYCTL: VBSTSPOL Mask              */
N
N#define OTG_INTEN_ROLECHGIEN_Pos         (0)                                               /*!< OTG_T::INTEN: ROLECHGIEN Position         */
N#define OTG_INTEN_ROLECHGIEN_Msk         (0x1ul << OTG_INTEN_ROLECHGIEN_Pos)               /*!< OTG_T::INTEN: ROLECHGIEN Mask             */
N
N#define OTG_INTEN_VBEIEN_Pos             (1)                                               /*!< OTG_T::INTEN: VBEIEN Position             */
N#define OTG_INTEN_VBEIEN_Msk             (0x1ul << OTG_INTEN_VBEIEN_Pos)                   /*!< OTG_T::INTEN: VBEIEN Mask                 */
N
N#define OTG_INTEN_SRPFIEN_Pos            (2)                                               /*!< OTG_T::INTEN: SRPFIEN Position            */
N#define OTG_INTEN_SRPFIEN_Msk            (0x1ul << OTG_INTEN_SRPFIEN_Pos)                  /*!< OTG_T::INTEN: SRPFIEN Mask                */
N
N#define OTG_INTEN_HNPFIEN_Pos            (3)                                               /*!< OTG_T::INTEN: HNPFIEN Position            */
N#define OTG_INTEN_HNPFIEN_Msk            (0x1ul << OTG_INTEN_HNPFIEN_Pos)                  /*!< OTG_T::INTEN: HNPFIEN Mask                */
N
N#define OTG_INTEN_GOIDLEIEN_Pos          (4)                                               /*!< OTG_T::INTEN: GOIDLEIEN Position          */
N#define OTG_INTEN_GOIDLEIEN_Msk          (0x1ul << OTG_INTEN_GOIDLEIEN_Pos)                /*!< OTG_T::INTEN: GOIDLEIEN Mask              */
N
N#define OTG_INTEN_IDCHGIEN_Pos           (5)                                               /*!< OTG_T::INTEN: IDCHGIEN Position           */
N#define OTG_INTEN_IDCHGIEN_Msk           (0x1ul << OTG_INTEN_IDCHGIEN_Pos)                 /*!< OTG_T::INTEN: IDCHGIEN Mask               */
N
N#define OTG_INTEN_PDEVIEN_Pos            (6)                                               /*!< OTG_T::INTEN: PDEVIEN Position            */
N#define OTG_INTEN_PDEVIEN_Msk            (0x1ul << OTG_INTEN_PDEVIEN_Pos)                  /*!< OTG_T::INTEN: PDEVIEN Mask                */
N
N#define OTG_INTEN_HOSTIEN_Pos            (7)                                               /*!< OTG_T::INTEN: HOSTIEN Position            */
N#define OTG_INTEN_HOSTIEN_Msk            (0x1ul << OTG_INTEN_HOSTIEN_Pos)                  /*!< OTG_T::INTEN: HOSTIEN Mask                */
N
N#define OTG_INTEN_BVLDCHGIEN_Pos         (8)                                               /*!< OTG_T::INTEN: BVLDCHGIEN Position         */
N#define OTG_INTEN_BVLDCHGIEN_Msk         (0x1ul << OTG_INTEN_BVLDCHGIEN_Pos)               /*!< OTG_T::INTEN: BVLDCHGIEN Mask             */
N
N#define OTG_INTEN_AVLDCHGIEN_Pos         (9)                                               /*!< OTG_T::INTEN: AVLDCHGIEN Position         */
N#define OTG_INTEN_AVLDCHGIEN_Msk         (0x1ul << OTG_INTEN_AVLDCHGIEN_Pos)               /*!< OTG_T::INTEN: AVLDCHGIEN Mask             */
N
N#define OTG_INTEN_VBCHGIEN_Pos           (10)                                              /*!< OTG_T::INTEN: VBCHGIEN Position           */
N#define OTG_INTEN_VBCHGIEN_Msk           (0x1ul << OTG_INTEN_VBCHGIEN_Pos)                 /*!< OTG_T::INTEN: VBCHGIEN Mask               */
N
N#define OTG_INTEN_SECHGIEN_Pos           (11)                                              /*!< OTG_T::INTEN: SECHGIEN Position           */
N#define OTG_INTEN_SECHGIEN_Msk           (0x1ul << OTG_INTEN_SECHGIEN_Pos)                 /*!< OTG_T::INTEN: SECHGIEN Mask               */
N
N#define OTG_INTEN_SRPDETIEN_Pos          (13)                                              /*!< OTG_T::INTEN: SRPDETIEN Position          */
N#define OTG_INTEN_SRPDETIEN_Msk          (0x1ul << OTG_INTEN_SRPDETIEN_Pos)                /*!< OTG_T::INTEN: SRPDETIEN Mask              */
N
N#define OTG_INTSTS_ROLECHGIF_Pos         (0)                                               /*!< OTG_T::INTSTS: ROLECHGIF Position         */
N#define OTG_INTSTS_ROLECHGIF_Msk         (0x1ul << OTG_INTSTS_ROLECHGIF_Pos)               /*!< OTG_T::INTSTS: ROLECHGIF Mask             */
N
N#define OTG_INTSTS_VBEIF_Pos             (1)                                               /*!< OTG_T::INTSTS: VBEIF Position             */
N#define OTG_INTSTS_VBEIF_Msk             (0x1ul << OTG_INTSTS_VBEIF_Pos)                   /*!< OTG_T::INTSTS: VBEIF Mask                 */
N
N#define OTG_INTSTS_SRPFIF_Pos            (2)                                               /*!< OTG_T::INTSTS: SRPFIF Position            */
N#define OTG_INTSTS_SRPFIF_Msk            (0x1ul << OTG_INTSTS_SRPFIF_Pos)                  /*!< OTG_T::INTSTS: SRPFIF Mask                */
N
N#define OTG_INTSTS_HNPFIF_Pos            (3)                                               /*!< OTG_T::INTSTS: HNPFIF Position            */
N#define OTG_INTSTS_HNPFIF_Msk            (0x1ul << OTG_INTSTS_HNPFIF_Pos)                  /*!< OTG_T::INTSTS: HNPFIF Mask                */
N
N#define OTG_INTSTS_GOIDLEIF_Pos          (4)                                               /*!< OTG_T::INTSTS: GOIDLEIF Position          */
N#define OTG_INTSTS_GOIDLEIF_Msk          (0x1ul << OTG_INTSTS_GOIDLEIF_Pos)                /*!< OTG_T::INTSTS: GOIDLEIF Mask              */
N
N#define OTG_INTSTS_IDCHGIF_Pos           (5)                                               /*!< OTG_T::INTSTS: IDCHGIF Position           */
N#define OTG_INTSTS_IDCHGIF_Msk           (0x1ul << OTG_INTSTS_IDCHGIF_Pos)                 /*!< OTG_T::INTSTS: IDCHGIF Mask               */
N
N#define OTG_INTSTS_PDEVIF_Pos            (6)                                               /*!< OTG_T::INTSTS: PDEVIF Position            */
N#define OTG_INTSTS_PDEVIF_Msk            (0x1ul << OTG_INTSTS_PDEVIF_Pos)                  /*!< OTG_T::INTSTS: PDEVIF Mask                */
N
N#define OTG_INTSTS_HOSTIF_Pos            (7)                                               /*!< OTG_T::INTSTS: HOSTIF Position            */
N#define OTG_INTSTS_HOSTIF_Msk            (0x1ul << OTG_INTSTS_HOSTIF_Pos)                  /*!< OTG_T::INTSTS: HOSTIF Mask                */
N
N#define OTG_INTSTS_BVLDCHGIF_Pos         (8)                                               /*!< OTG_T::INTSTS: BVLDCHGIF Position         */
N#define OTG_INTSTS_BVLDCHGIF_Msk         (0x1ul << OTG_INTSTS_BVLDCHGIF_Pos)               /*!< OTG_T::INTSTS: BVLDCHGIF Mask             */
N
N#define OTG_INTSTS_AVLDCHGIF_Pos         (9)                                               /*!< OTG_T::INTSTS: AVLDCHGIF Position         */
N#define OTG_INTSTS_AVLDCHGIF_Msk         (0x1ul << OTG_INTSTS_AVLDCHGIF_Pos)               /*!< OTG_T::INTSTS: AVLDCHGIF Mask             */
N
N#define OTG_INTSTS_VBCHGIF_Pos           (10)                                              /*!< OTG_T::INTSTS: VBCHGIF Position           */
N#define OTG_INTSTS_VBCHGIF_Msk           (0x1ul << OTG_INTSTS_VBCHGIF_Pos)                 /*!< OTG_T::INTSTS: VBCHGIF Mask               */
N
N#define OTG_INTSTS_SECHGIF_Pos           (11)                                              /*!< OTG_T::INTSTS: SECHGIF Position           */
N#define OTG_INTSTS_SECHGIF_Msk           (0x1ul << OTG_INTSTS_SECHGIF_Pos)                 /*!< OTG_T::INTSTS: SECHGIF Mask               */
N
N#define OTG_INTSTS_SRPDETIF_Pos          (13)                                              /*!< OTG_T::INTSTS: SRPDETIF Position          */
N#define OTG_INTSTS_SRPDETIF_Msk          (0x1ul << OTG_INTSTS_SRPDETIF_Pos)                /*!< OTG_T::INTSTS: SRPDETIF Mask              */
N
N#define OTG_STATUS_OVERCUR_Pos           (0)                                               /*!< OTG_T::STATUS: OVERCUR Position           */
N#define OTG_STATUS_OVERCUR_Msk           (0x1ul << OTG_STATUS_OVERCUR_Pos)                 /*!< OTG_T::STATUS: OVERCUR Mask               */
N
N#define OTG_STATUS_IDSTS_Pos             (1)                                               /*!< OTG_T::STATUS: IDSTS Position             */
N#define OTG_STATUS_IDSTS_Msk             (0x1ul << OTG_STATUS_IDSTS_Pos)                   /*!< OTG_T::STATUS: IDSTS Mask                 */
N
N#define OTG_STATUS_SESSEND_Pos           (2)                                               /*!< OTG_T::STATUS: SESSEND Position           */
N#define OTG_STATUS_SESSEND_Msk           (0x1ul << OTG_STATUS_SESSEND_Pos)                 /*!< OTG_T::STATUS: SESSEND Mask               */
N
N#define OTG_STATUS_BVLD_Pos              (3)                                               /*!< OTG_T::STATUS: BVLD Position              */
N#define OTG_STATUS_BVLD_Msk              (0x1ul << OTG_STATUS_BVLD_Pos)                    /*!< OTG_T::STATUS: BVLD Mask                  */
N
N#define OTG_STATUS_AVLD_Pos              (4)                                               /*!< OTG_T::STATUS: AVLD Position              */
N#define OTG_STATUS_AVLD_Msk              (0x1ul << OTG_STATUS_AVLD_Pos)                    /*!< OTG_T::STATUS: AVLD Mask                  */
N
N#define OTG_STATUS_VBUSVLD_Pos           (5)                                               /*!< OTG_T::STATUS: VBUSVLD Position           */
N#define OTG_STATUS_VBUSVLD_Msk           (0x1ul << OTG_STATUS_VBUSVLD_Pos)                 /*!< OTG_T::STATUS: VBUSVLD Mask               */
N
N/**@}*/ /* OTG_CONST */
N/**@}*/ /* end of OTG register group */
N
N
N/*---------------------- Peripheral Direct Memory Access Controller -------------------------*/
N/**
N    @addtogroup PDMA Peripheral Direct Memory Access Controller(PDMA)
N    Memory Mapped Structure for PDMA Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var DSCT_T::CTL
N * Offset: 0x00/0x10/0x20/0x30/0x40/0x50/0x60/0x70/0x80/0x90/0xA0/0xB0  Descriptor Table Control Register of PDMA Channel 0~11
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |OPMODE    |PDMA Operation Mode Selection
N * |        |          |0 = Idle state: Channel is stopped or this table is complete, when PDMA finish channel table task, OPMODE will be cleared to idle state automatically.
N * |        |          |1 = Basic mode: The descriptor table only has one task.
N * |        |          |When this task is finished, the PDMA_INTSTS[x] will be asserted.
N * |        |          |2 = Scatter-Gather mode: When operating in this mode, user must give the next descriptor table address in PDMA_DSCT_NEXT register; PDMA controller will ignore this task, then load the next task to execute.
N * |        |          |3 = Reserved.
N * |        |          |Note: Before filling transfer task in the Descriptor Table, user must check if the descriptor table is complete.
N * |[2]     |TXTYPE    |Transfer Type
N * |        |          |0 = Burst transfer type.
N * |        |          |1 = Single transfer type.
N * |[6:4]   |BURSIZE   |Burst Size
N * |        |          |This field is used for peripheral to determine the burst size or used for determine the re-arbitration size.
N * |        |          |000 = 128 Transfers.
N * |        |          |001 = 64 Transfers.
N * |        |          |010 = 32 Transfers.
N * |        |          |011 = 16 Transfers.
N * |        |          |100 = 8 Transfers.
N * |        |          |101 = 4 Transfers.
N * |        |          |110 = 2 Transfers.
N * |        |          |111 = 1 Transfers.
N * |        |          |Note: This field is only useful in burst transfer type.
N * |[7]     |TBINTDIS  |Table Interrupt Disable
N * |        |          |This field can be used to decide whether to enable table interrupt or not.
N * |        |          |If the TBINTDIS bit is enabled when PDMA controller finishes transfer task, it will not generates interrupt.
N * |        |          |0 = Table interrupt Enabled.
N * |        |          |1 = Table interrupt Disabled.
N * |        |          |Note: If this bit set to '1', the TEMPTYF will not be set.
N * |[9:8]   |SAINC     |Source Address Increment
N * |        |          |This field is used to set the source address increment size.
N * |        |          |11 = No increment (fixed address).
N * |        |          |Others = Increment and size is depended on TXWIDTH selection.
N * |[11:10] |DAINC     |Destination Address Increment
N * |        |          |This field is used to set the destination address increment size.
N * |        |          |11 = No increment (fixed address).
N * |        |          |Others = Increment and size is depended on TXWIDTH selection.
N * |[13:12] |TXWIDTH   |Transfer Width Selection
N * |        |          |This field is used for transfer width.
N * |        |          |00 = One byte (8 bit) is transferred for every operation.
N * |        |          |01= One half-word (16 bit) is transferred for every operation.
N * |        |          |10 = One word (32-bit) is transferred for every operation.
N * |        |          |11 = Reserved.
N * |        |          |Note: The PDMA transfer source address (PDMA_DSCT_SA) and PDMA transfer destination address (PDMA_DSCT_DA) should be alignment under the TXWIDTH selection
N * |[29:16] |TXCNT     |Transfer Count
N * |        |          |The TXCNT represents the required number of PDMA transfer, the real transfer count is (TXCNT + 1); The maximum transfer count is 16384 , every transfer may be byte, half-word or word that is dependent on TXWIDTH field.
N * |        |          |Note: When PDMA finish each transfer data, this field will be decrease immediately.
N * @var DSCT_T::SA
N * Offset: 0x04/0x14/0x24/0x34/0x44/0x54/0x64/0x74/0x84/0x94/0xA4/0xB4  Source Address Register of PDMA Channel 0~11
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |SA        |PDMA Transfer Source Address Register
N * |        |          |This field indicates a 32-bit source address of PDMA controller.
N * @var DSCT_T::DA
N * Offset: 0x08/0x18/0x28/0x38/0x48/0x58/0x68/0x78/0x88/0x98/0xA8/0xB8  Destination Address Register of PDMA Channel 0~11
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |DA        |PDMA Transfer Destination Address Register
N * |        |          |This field indicates a 32-bit destination address of PDMA controller.
N * @var DSCT_T::NEXT
N * Offset: 0x0C/0x1C/0x2C/0x3C/0x4C/0x5C/0x6C/0x7C/0x8C/0x9C/0xAC/0xBC  First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 0~11
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:2]  |NEXT      |PDMA Next Descriptor Table Offset Address Register
N * |        |          |This field indicates the offset of next descriptor table address in system memory.
N * |        |          |The system memory based address is 0x2000_0000 (PDMA_SCATBA), if the next descriptor table is 0x2000_0100, then this field must fill in 0x0100.
N * |        |          |Note1: The next descriptor table address must be word boundary.
N * |        |          |Note2: Before filled transfer task in the descriptor table, user must check if the descriptor table is complete.
N */
N
N    __IO uint32_t CTL;           /* Offset: 0x00/0x10/0x20/0x30/0x40/0x50/0x60/0x70/0x80/0x90/0xA0/0xB0  Descriptor Table Control Register of PDMA Channel 0~11 */
X    volatile uint32_t CTL;            
N    __IO uint32_t SA;            /* Offset: 0x04/0x14/0x24/0x34/0x44/0x54/0x64/0x74/0x84/0x94/0xA4/0xB4  Source Address Register of PDMA Channel 0~11 */
X    volatile uint32_t SA;             
N    __IO uint32_t DA;            /* Offset: 0x08/0x18/0x28/0x38/0x48/0x58/0x68/0x78/0x88/0x98/0xA8/0xB8  Destination Address Register of PDMA Channel 0~11 */
X    volatile uint32_t DA;             
N    __IO uint32_t NEXT;          /* Offset: 0x0C/0x1C/0x2C/0x3C/0x4C/0x5C/0x6C/0x7C/0x8C/0x9C/0xAC/0xBC  First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 0~11 */
X    volatile uint32_t NEXT;           
N
N} DSCT_T;
N
N
N
N
Ntypedef struct
N{
N
N
N/**
N * @var PDMA_T::DSCT
N * Offset: 0x0000 ~ 0x00BC  DMA Embedded Description Table 0~11
N * ---------------------------------------------------------------------------------------------------
N * @var PDMA_T::CURSCAT
N * Offset: 0xC0 ~ 0xEC Current Scatter-Gather Descriptor Table Address of PDMA Channel 0~11
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |CURADDR   |PDMA Current Description Address Register (Read Only)
N * |        |          |This field indicates a 32-bit current external description address of PDMA controller.
N * |        |          |Note: This field is read only and only used for Scatter-Gather mode to indicate the current external description address.
N * @var PDMA_T::CHCTL
N * Offset: 0x400  PDMA Channel Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |CHENn     |PDMA Channel Enable Bit
N * |        |          |Set this bit to 1 to enable PDMAn operation.
N * |        |          |If each channel is not set as enabled, each channel cannot be active.
N * |        |          |0 = PDMA channel [n] Disabled.
N * |        |          |1 = PDMA channel [n] Enabled.
N * |        |          |Note1: If software stops each PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
N * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
N * @var PDMA_T::STOP
N * Offset: 0x404  PDMA Transfer Stop Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |STOPn     |PDMA Transfer Stop Control Register (Write Only)
N * |        |          |User can stop the PDMA transfer by STOPn bit field or by software reset (writing '0xFFFF_FFFF' to PDMA_STOP register).
N * |        |          |By bit field:
N * |        |          |0 = No effect.
N * |        |          |1 = Stop PDMA transfer[n].
N * |        |          |When software set PDMA_STOP bit, the operation will finish the on-going transfer channel and then clear the channel enable bit (PDMA_CHCTL [CHEN]) and request active flag.
N * |        |          |By write 0xFFFF_FFFF to PDMA_STOP:
N * |        |          |Setting all PDMA_STOP bit to "1" will generate software reset to reset internal state machine (the DSCT will not be reset).
N * |        |          |When software reset, the operation will be stopped imminently that include the on-going transfer and the channel enable bit (PDMA_CHCTL [CHEN]) and request active flag will be cleared to '0'.
N * |        |          |Note: User can poll channel enable bit to know if the on-going transfer is finished.
N * @var PDMA_T::SWREQ
N * Offset: 0x408  PDMA Software Request Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |SWREQn    |PDMA Software Request Register (Write Only)
N * |        |          |Set this bit to 1 to generate a software request to PDMA [n].
N * |        |          |0 = No effect.
N * |        |          |1 = Generate a software request.
N * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active.
N * |        |          |Active flag may be triggered by software request or peripheral request.
N * |        |          |Note2: If user does not enable each PDMA channel, the software request will be ignored.
N * @var PDMA_T::TRGSTS
N * Offset: 0x40C  PDMA Channel Request Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |REQSTSn   |PDMA Channel Request Status (Read Only)
N * |        |          |This flag indicates whether channel[n] have a request or not, no matter request from software or peripheral.
N * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
N * |        |          |0 = PDMA Channel n has no request.
N * |        |          |1 = PDMA Channel n has a request.
N * |        |          |Note1: If software stops each PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
N * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
N * @var PDMA_T::PRISET
N * Offset: 0x410  PDMA Fixed Priority Setting Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |FPRISETn  |PDMA Fixed Priority Setting Register
N * |        |          |Set this bit to 1 to enable fixed priority level.
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Set PDMA channel [n] to fixed priority channel.
N * |        |          |Read Operation:
N * |        |          |0 = Corresponding PDMA channel is round-robin priority.
N * |        |          |1 = Corresponding PDMA channel is fixed priority.
N * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
N * @var PDMA_T::PRICLR
N * Offset: 0x414  PDMA Fixed Priority Clear Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |FPRICLRn  |PDMA Fixed Priority Clear Register (Write Only)
N * |        |          |Set this bit to 1 to clear fixed priority level.
N * |        |          |0 = No effect.
N * |        |          |1 = Clear PDMA channel [n] fixed priority setting.
N * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
N * @var PDMA_T::INTEN
N * Offset: 0x418  PDMA Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |INTENn    |PDMA Interrupt Enable Register
N * |        |          |This field is used for enabling PDMA channel[n] interrupt.
N * |        |          |0 = PDMA channel n interrupt Disabled.
N * |        |          |1 = PDMA channel n interrupt Enabled.
N * |[31:12] |Reserved  |should be keep 0.
N * @var PDMA_T::INTSTS
N * Offset: 0x41C  PDMA Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ABTIF     |PDMA Read/Write Target Abort Interrupt Flag (Read-Only)
N * |        |          |This bit indicates that PDMA has target abort error; Software can read PDMA_ABTSTS register to find which channel has target abort error.
N * |        |          |0 = No AHB bus ERROR response received.
N * |        |          |1 = AHB bus ERROR response received.
N * |[1]     |TDIF      |Transfer Done Interrupt Flag (Read Only)
N * |        |          |This bit indicates that PDMA controller has finished transmission; User can read PDMA_TDSTS register to indicate which channel finished transfer.
N * |        |          |0 = Not finished yet.
N * |        |          |1 = PDMA channel has finished transmission.
N * |[2]     |TEIF      |Table Empty Interrupt Flag (Read Only)
N * |        |          |This bit indicates that PDMA controller has finished each table transmission and the operation is Stop mode.
N * |        |          |User can read TEIF register to indicate which channel finished transfer.
N * |        |          |0 = PDMA channel transfer is not finished.
N * |        |          |1 = PDMA channel transfer is finished and the operation is in idle state.
N * |[8:15]  |REQTOFn   |Request Time-out Flag For Each Channel [N](M45xD/M45xC Only)
N * |        |          |This flag indicates that PDMA controller has waited peripheral request for a period defined by PDMA_TOCn, user can write 1 to clear these bits.
N * |        |          |0 = No request time-out.
N * |        |          |1 = Peripheral request time-out.
N * @var PDMA_T::ABTSTS
N * Offset: 0x420  PDMA Channel Read/Write Target Abort Flag Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |ABTIFn    |PDMA Read/Write Target Abort Interrupt Status Flag
N * |        |          |This bit indicates which PDMA controller has target abort error; User can write 1 to clear these bits.
N * |        |          |0 = No AHB bus ERROR response received when channel n transfer.
N * |        |          |1 = AHB bus ERROR response received when channel n transfer.
N * @var PDMA_T::TDSTS
N * Offset: 0x424  PDMA Channel Transfer Done Flag Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |TDIFn     |Transfer Done Flag Register
N * |        |          |This bit indicates whether PDMA controller channel transfer has been finished or not, user can write 1 to clear these bits.
N * |        |          |0 = PDMA channel transfer has not finished.
N * |        |          |1 = PDMA channel has finished transmission.
N * @var PDMA_T::SCATSTS
N * Offset: 0x428  PDMA Scatter-Gather Table Empty Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |TEMPTYFn  |Scatter-Gather Table Empty Flag Register
N * |        |          |This bit indicates which PDMA channel n Scatter Gather table is empty when SWREQn set to high or channel has finished transmission and the operation mode is Stop mode.
N * |        |          |User can write 1 to clear these bits.
N * |        |          |0 = PDMA channel scatter-gather table is not empty.
N * |        |          |1 = PDMA channel scatter-gather table is empty and PDMA SWREQ has be set.
N * @var PDMA_T::TACTSTS
N * Offset: 0x42C  PDMA Transfer Active Flag Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |TXACTFn   |Transfer On Active Flag Register (Read Only)
N * |        |          |This bit indicates which PDMA channel is in active.
N * |        |          |0 = PDMA channel is not finished.
N * |        |          |1 = PDMA channel is active.
N * @var PDMA_T::TOUTEN
N * Offset: 0x434  PDMA Time-out Enable register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |TOUTENn   |PDMA Time-Out Enable Bits
N * |        |          |0 = PDMA Channel n time-out function Disable.
N * |        |          |1 = PDMA Channel n time-out function Enable.
N * @var PDMA_T::TOUTIEN
N * Offset: 0x438  PDMA Time-out Interrupt Enable register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |TOUTIENn  |PDMA Time-Out Interrupt Enable Bits
N * |        |          |0 = PDMA Channel n time-out interrupt Disable.
N * |        |          |1 = PDMA Channel n time-out interrupt Enable.
N * @var PDMA_T::SCATBA
N * Offset: 0x43C  PDMA Scatter-Gather Descriptor Table Base Address Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:16] |SCATBA    |PDMA Scatter-Gather Descriptor Table Address Register
N * |        |          |In Scatter-Gather mode, this is the base address for calculating the next link - list address.
N * |        |          |The next link address equation is.
N * |        |          |Next Link Address = PDMA_SCATBA + PDMA_DSCT_NEXT.
N * |        |          |Note: Only useful in Scatter-Gather mode.
N * @var PDMA_T::TOC0_1
N * Offset: 0x440  PDMA Time-out Counter Ch1 and Ch0 Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:16] |TOC1      |Time-Out Counter For Channel 1
N * |        |          |This controls the period of time-out function for channel 1. The calculation unit is based on 10 kHz clock.
N * |[15:0]  |TOC0      |Time-Out Counter For Channel 0
N * |        |          |This controls the period of time-out function for channel 0. The calculation unit is based on 10 kHz clock.
N * @var PDMA_T::TOC2_3
N * Offset: 0x444  PDMA Time-out Counter Ch3 and Ch2 Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:16] |TOC3      |Time-Out Counter For Channel 3
N * |        |          |This controls the period of time-out function for channel 3. The calculation unit is based on 10 kHz clock.
N * |[15:0]  |TOC2      |Time-Out Counter For Channel 2
N * |        |          |This controls the period of time-out function for channel 2. The calculation unit is based on 10 kHz clock.
N * @var PDMA_T::TOC4_5
N * Offset: 0x448  PDMA Time-out Counter Ch5 and Ch4 Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:16] |TOC5      |Time-Out Counter For Channel 5
N * |        |          |This controls the period of time-out function for channel 5. The calculation unit is based on 10 kHz clock.
N * |[15:0]  |TOC4      |Time-Out Counter For Channel 4
N * |        |          |This controls the period of time-out function for channel 4. The calculation unit is based on 10 kHz clock.
N * @var PDMA_T::TOC6_7
N * Offset: 0x44C  PDMA Time-out Counter Ch7 and Ch6 Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:16] |TOC7      |Time-Out Counter For Channel 7
N * |        |          |This controls the period of time-out function for channel 7. The calculation unit is based on 10 kHz clock.
N * |[15:0]  |TOC6      |Time-Out Counter For Channel 6
N * |        |          |This controls the period of time-out function for channel 6. The calculation unit is based on 10 kHz clock.
N * @var PDMA_T::REQSEL0_3
N * Offset: 0x480  PDMA Request Source Select Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[4:0]   |REQSRC0   |Channel 0 Request Source Selection
N * |        |          |This filed defines which peripheral is connected to PDMA channel 0.
N * |        |          |User can configure the peripheral by setting REQSRC0.
N * |        |          |1 = Channel connects to SPI0_TX.
N * |        |          |2 = Channel connects to SPI1_TX.
N * |        |          |3 = Channel connects to SPI2_TX.
N * |        |          |4 = Channel connects to UART0_TX.
N * |        |          |5 = Channel connects to UART1_TX.
N * |        |          |6 = Channel connects to UART2_TX.
N * |        |          |7 = Channel connects to UART3_TX.
N * |        |          |8 = Channel connects to DAC_TX.
N * |        |          |9 = Channel connects to ADC_RX.
N * |        |          |11 = Channel connects to PWM0_P1_RX.
N * |        |          |12 = Channel connects to PWM0_P2_RX.
N * |        |          |13 = Channel connects to PWM0_P3_RX.
N * |        |          |14 = Channel connects to PWM1_P1_RX.
N * |        |          |15 = Channel connects to PWM1_P2_RX.
N * |        |          |16 = Channel connects to PWM1_P3_RX.
N * |        |          |17 = Channel connects to SPI0_RX.
N * |        |          |18 = Channel connects to SPI1_RX.
N * |        |          |19 = Channel connects to SPI2_RX.
N * |        |          |20 = Channel connects to UART0_RX.
N * |        |          |21 = Channel connects to UART1_RX.
N * |        |          |22 = Channel connects to UART2_RX.
N * |        |          |23 = Channel connects to UART3_RX.
N * |        |          |31 = Disable PDMA.
N * |        |          |Others = Reserved.
N * |        |          |Note 1: A peripheral can't assign to two channels at the same time.
N * |        |          |Note 2: This field is useless when transfer between memory and memory.
N * |[12:8]  |REQSRC1   |Channel 1 Request Source Selection
N * |        |          |This filed defines which peripheral is connected to PDMA channel 1.
N * |        |          |User can configure the peripheral setting by REQSRC1.
N * |        |          |Note: The channel configuration is the same as REQSRC0 field.
N * |        |          |Please refer to the explanation of REQSRC0.
N * |[20:16] |REQSRC2   |Channel 2 Request Source Selection
N * |        |          |This filed defines which peripheral is connected to PDMA channel 2.
N * |        |          |User can configure the peripheral setting by REQSRC2.
N * |        |          |Note: The channel configuration is the same as REQSRC0 field.
N * |        |          |Please refer to the explanation of REQSRC0.
N * |[28:24] |REQSRC3   |Channel 3 Request Source Selection
N * |        |          |This filed defines which peripheral is connected to PDMA channel 3.
N * |        |          |User can configure the peripheral setting by REQSRC3.
N * |        |          |Note: The channel configuration is the same as REQSRC0 field.
N * |        |          |Please refer to the explanation of REQSRC0.
N * @var PDMA_T::REQSEL4_7
N * Offset: 0x484  PDMA Request Source Select Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[4:0]   |REQSRC4   |Channel 4 Request Source Selection
N * |        |          |This filed defines which peripheral is connected to PDMA channel 4.
N * |        |          |User can configure the peripheral setting by REQSRC4.
N * |        |          |Note: The channel configuration is the same as REQSRC0 field.
N * |        |          |Please refer to the explanation of REQSRC0.
N * |[12:8]  |REQSRC5   |Channel 5 Request Source Selection
N * |        |          |This filed defines which peripheral is connected to PDMA channel 5.
N * |        |          |User can configure the peripheral setting by REQSRC5.
N * |        |          |Note: The channel configuration is the same as REQSRC0 field.
N * |        |          |Please refer to the explanation of REQSRC0.
N * |[20:16] |REQSRC6   |Channel 6 Request Source Selection
N * |        |          |This filed defines which peripheral is connected to PDMA channel 6.
N * |        |          |User can configure the peripheral setting by REQSRC6.
N * |        |          |Note: The channel configuration is the same as REQSRC0 field.
N * |        |          |Please refer to the explanation of REQSRC0.
N * |[28:24] |REQSRC7   |Channel 7 Request Source Selection
N * |        |          |This filed defines which peripheral is connected to PDMA channel 7.
N * |        |          |User can configure the peripheral setting by REQSRC7.
N * |        |          |Note: The channel configuration is the same as REQSRC0 field.
N * |        |          |Please refer to the explanation of REQSRC0.
N * @var PDMA_T::REQSEL8_11
N * Offset: 0x488  PDMA Request Source Select Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[4:0]   |REQSRC8   |Channel 8 Request Source Selection
N * |        |          |This filed defines which peripheral is connected to PDMA channel 8.
N * |        |          |User can configure the peripheral setting by REQSRC8.
N * |        |          |Note: The channel configuration is the same as REQSRC0 field.
N * |        |          |Please refer to the explanation of REQSRC0.
N * |[12:8]  |REQSRC9   |Channel 9 Request Source Selection
N * |        |          |This filed defines which peripheral is connected to PDMA channel 9.
N * |        |          |User can configure the peripheral setting by REQSRC9.
N * |        |          |Note: The channel configuration is the same as REQSRC0 field.
N * |        |          |Please refer to the explanation of REQSRC0.
N * |[20:16] |REQSRC10  |Channel 10 Request Source Selection
N * |        |          |This filed defines which peripheral is connected to PDMA channel 10.
N * |        |          |User can configure the peripheral setting by REQSRC10.
N * |        |          |Note: The channel configuration is the same as REQSRC0 field.
N * |        |          |Please refer to the explanation of REQSRC0.
N * |[28:24] |REQSRC11  |Channel 11 Request Source Selection
N * |        |          |This filed defines which peripheral is connected to PDMA channel 11.
N * |        |          |User can configure the peripheral setting by REQSRC11.
N * |        |          |Note: The channel configuration is the same as REQSRC0 field.
N * |        |          |Please refer to the explanation of REQSRC0.
N */
N    
N    DSCT_T        DSCT[12];      /* Offset: 0x0000 ~ 0x00BC  DMA Embedded Description Table 0~11                     */             
N    __I  uint32_t CURSCAT[12];                                                                                                      
X    volatile const  uint32_t CURSCAT[12];                                                                                                      
N    __I  uint32_t RESERVE0[196]; /* Offset: 0xC0 ~ 0xEC Current Scatter-Gather Descriptor Table Address of PDMA Channel 0~11 */     
X    volatile const  uint32_t RESERVE0[196];       
N    __IO uint32_t CHCTL;         /* Offset: 0x400  PDMA Channel Control Register                                     */             
X    volatile uint32_t CHCTL;                       
N    __O  uint32_t STOP;          /* Offset: 0x404  PDMA Transfer Stop Control Register                               */             
X    volatile  uint32_t STOP;                        
N    __O  uint32_t SWREQ;         /* Offset: 0x408  PDMA Software Request Register                                    */             
X    volatile  uint32_t SWREQ;                       
N    __I  uint32_t TRGSTS;        /* Offset: 0x40C  PDMA Channel Request Status Register                              */             
X    volatile const  uint32_t TRGSTS;                      
N    __IO uint32_t PRISET;        /* Offset: 0x410  PDMA Fixed Priority Setting Register                              */             
X    volatile uint32_t PRISET;                      
N    __O  uint32_t PRICLR;        /* Offset: 0x414  PDMA Fixed Priority Clear Register                                */             
X    volatile  uint32_t PRICLR;                      
N    __IO uint32_t INTEN;         /* Offset: 0x418  PDMA Interrupt Enable Register                                    */             
X    volatile uint32_t INTEN;                       
N    __IO uint32_t INTSTS;        /* Offset: 0x41C  PDMA Interrupt Status Register                                    */             
X    volatile uint32_t INTSTS;                      
N    __IO uint32_t ABTSTS;        /* Offset: 0x420  PDMA Channel Read/Write Target Abort Flag Register                */             
X    volatile uint32_t ABTSTS;                      
N    __IO uint32_t TDSTS;         /* Offset: 0x424  PDMA Channel Transfer Done Flag Register                          */             
X    volatile uint32_t TDSTS;                       
N    __IO uint32_t SCATSTS;       /* Offset: 0x428  PDMA Scatter-Gather Table Empty Status Register                   */             
X    volatile uint32_t SCATSTS;                     
N    __I  uint32_t TACTSTS;                                                                                                          
X    volatile const  uint32_t TACTSTS;                                                                                                          
N    __I  uint32_t RESERVE1[1];   /* Offset: 0x42C  PDMA Transfer Active Flag Register                                */             
X    volatile const  uint32_t RESERVE1[1];                 
N    __IO uint32_t TOUTEN;        /* Offset: 0x434  PDMA Time-out Enable register                                     */             
X    volatile uint32_t TOUTEN;                      
N    __IO uint32_t TOUTIEN;       /* Offset: 0x438  PDMA Time-out Interrupt Enable register                           */             
X    volatile uint32_t TOUTIEN;                     
N    __IO uint32_t SCATBA;        /* Offset: 0x43C  PDMA Scatter-Gather Descriptor Table Base Address Register        */             
X    volatile uint32_t SCATBA;                      
N    __IO uint32_t TOC0_1;        /* Offset: 0x440  PDMA Time-out Counter Ch1 and Ch0 Register                        */             
X    volatile uint32_t TOC0_1;                      
N    __IO uint32_t TOC2_3;        /* Offset: 0x444  PDMA Time-out Counter Ch3 and Ch2 Register                        */             
X    volatile uint32_t TOC2_3;                      
N    __IO uint32_t TOC4_5;        /* Offset: 0x448  PDMA Time-out Counter Ch5 and Ch4 Register                        */             
X    volatile uint32_t TOC4_5;                      
N    __IO uint32_t TOC6_7;                                                                                                           
X    volatile uint32_t TOC6_7;                                                                                                           
N    __I  uint32_t RESERVE2[12];  /* Offset: 0x44C  PDMA Time-out Counter Ch7 and Ch6 Register                        */             
X    volatile const  uint32_t RESERVE2[12];                
N    __IO uint32_t REQSEL0_3;     /* Offset: 0x480  PDMA Request Source Select Register 0                             */             
X    volatile uint32_t REQSEL0_3;                   
N    __IO uint32_t REQSEL4_7;     /* Offset: 0x484  PDMA Request Source Select Register 1                             */             
X    volatile uint32_t REQSEL4_7;                   
N    __IO uint32_t REQSEL8_11;    /* Offset: 0x484  PDMA Request Source Select Register 2                             */
X    volatile uint32_t REQSEL8_11;     
N
N} PDMA_T;
N
N
N
N/**
N    @addtogroup PDMA_CONST PDMA Bit Field Definition
N    Constant Definitions for PDMA Controller
N@{ */
N
N#define PDMA_DSCT_CTL_OPMODE_Pos         (0)                                               /*!< DSCT_T::CTL: OPMODE Position              */
N#define PDMA_DSCT_CTL_OPMODE_Msk         (0x3ul << PDMA_DSCT_CTL_OPMODE_Pos)               /*!< DSCT_T::CTL: OPMODE Mask                  */
N
N#define PDMA_DSCT_CTL_TXTYPE_Pos         (2)                                               /*!< DSCT_T::CTL: TXTYPE Position              */
N#define PDMA_DSCT_CTL_TXTYPE_Msk         (1ul << PDMA_DSCT_CTL_TXTYPE_Pos)                 /*!< DSCT_T::CTL: TXTYPE Mask                  */
N
N#define PDMA_DSCT_CTL_BURSIZE_Pos        (4)                                               /*!< DSCT_T::CTL: BURSIZE Position             */
N#define PDMA_DSCT_CTL_BURSIZE_Msk        (0x7ul << PDMA_DSCT_CTL_BURSIZE_Pos)              /*!< DSCT_T::CTL: BURSIZE Mask                 */
N
N#define PDMA_DSCT_CTL_TBINTDIS_Pos       (7)                                               /*!< DSCT_T::CTL: TBINTDIS Position            */
N#define PDMA_DSCT_CTL_TBINTDIS_Msk       (1ul << PDMA_DSCT_CTL_TBINTDIS_Pos)               /*!< DSCT_T::CTL: TBINTDIS Mask                */
N
N#define PDMA_DSCT_CTL_SAINC_Pos          (8)                                               /*!< DSCT_T::CTL: SAINC Position               */
N#define PDMA_DSCT_CTL_SAINC_Msk          (0x3ul << PDMA_DSCT_CTL_SAINC_Pos)                /*!< DSCT_T::CTL: SAINC Mask                   */
N
N#define PDMA_DSCT_CTL_DAINC_Pos          (10)                                              /*!< DSCT_T::CTL: DAINC Position               */
N#define PDMA_DSCT_CTL_DAINC_Msk          (0x3ul << PDMA_DSCT_CTL_DAINC_Pos)                /*!< DSCT_T::CTL: DAINC Mask                   */
N
N#define PDMA_DSCT_CTL_TXWIDTH_Pos        (12)                                              /*!< DSCT_T::CTL: TXWIDTH Position             */
N#define PDMA_DSCT_CTL_TXWIDTH_Msk        (0x3ul << PDMA_DSCT_CTL_TXWIDTH_Pos)              /*!< DSCT_T::CTL: TXWIDTH Mask                 */
N
N#define PDMA_DSCT_CTL_TXCNT_Pos          (16)                                              /*!< DSCT_T::CTL: TXCNT Position               */
N#define PDMA_DSCT_CTL_TXCNT_Msk          (0x3FFFul << PDMA_DSCT_CTL_TXCNT_Pos)             /*!< DSCT_T::CTL: TXCNT Mask                   */
N
N#define PDMA_DSCT_SA_SA_Pos              (0)                                               /*!< DSCT_T::SA: SA Position                   */
N#define PDMA_DSCT_SA_SA_Msk              (0xFFFFFFFFul << PDMA_DSCT_SA_SA_Pos)             /*!< DSCT_T::SA: SA Mask                       */
N
N#define PDMA_DSCT_DA_DA_Pos              (0)                                               /*!< DSCT_T::DA: DA Position                   */
N#define PDMA_DSCT_DA_DA_Msk              (0xFFFFFFFFul << PDMA_DSCT_DA_DA_Pos)             /*!< DSCT_T::DA: DA Mask                       */
N
N#define PDMA_DSCT_NEXT_NEXT_Pos          (0)                                               /*!< DSCT_T::NEXT: NEXT Position               */
N#define PDMA_DSCT_NEXT_NEXT_Msk          (0xFFFFul << PDMA_DSCT_NEXT_NEXT_Pos)             /*!< DSCT_T::NEXT: NEXT Mask                   */
N
N#define PDMA_CURSCAT_CURADDR_Pos         (0)                                               /*!< PDMA_T::CURSCAT: CURADDR Position         */
N#define PDMA_CURSCAT_CURADDR_Msk         (0xfffffffful << PDMA_CURSCAT_CURADDR_Pos)        /*!< PDMA_T::CURSCAT: CURADDR Mask             */
N
N#define PDMA_CHCTL_CHENn_Pos             (0)                                               /*!< PDMA_T::CHCTL: CHENn Position             */
N#define PDMA_CHCTL_CHENn_Msk             (0xffful << PDMA_CHCTL_CHENn_Pos)                 /*!< PDMA_T::CHCTL: CHENn Mask                 */
N
N#define PDMA_STOP_STOPn_Pos              (0)                                               /*!< PDMA_T::STOP: STOPn Position              */
N#define PDMA_STOP_STOPn_Msk              (0xffful << PDMA_STOP_STOPn_Pos)                  /*!< PDMA_T::STOP: STOPn Mask                  */
N
N#define PDMA_SWREQ_SWREQn_Pos            (0)                                               /*!< PDMA_T::SWREQ: SWREQn Position            */
N#define PDMA_SWREQ_SWREQn_Msk            (0xffful << PDMA_SWREQ_SWREQn_Pos)                /*!< PDMA_T::SWREQ: SWREQn Mask                */
N
N#define PDMA_TRGSTS_REQSTSn_Pos          (0)                                               /*!< PDMA_T::TRGSTS: REQSTSn Position          */
N#define PDMA_TRGSTS_REQSTSn_Msk          (0xffful << PDMA_TRGSTS_REQSTSn_Pos)              /*!< PDMA_T::TRGSTS: REQSTSn Mask              */
N
N#define PDMA_PRISET_FPRISETn_Pos         (0)                                               /*!< PDMA_T::PRISET: FPRISETn Position         */
N#define PDMA_PRISET_FPRISETn_Msk         (0xffful << PDMA_PRISET_FPRISETn_Pos)             /*!< PDMA_T::PRISET: FPRISETn Mask             */
N
N#define PDMA_PRICLR_FPRICLRn_Pos         (0)                                               /*!< PDMA_T::PRICLR: FPRICLRn Position         */
N#define PDMA_PRICLR_FPRICLRn_Msk         (0xffful << PDMA_PRICLR_FPRICLRn_Pos)             /*!< PDMA_T::PRICLR: FPRICLRn Mask             */
N
N#define PDMA_INTEN_INTENn_Pos            (0)                                               /*!< PDMA_T::INTEN: INTENn Position            */
N#define PDMA_INTEN_INTENn_Msk            (0xffful << PDMA_INTEN_INTENn_Pos)                /*!< PDMA_T::INTEN: INTENn Mask                */
N
N#define PDMA_INTSTS_ABTIF_Pos            (0)                                               /*!< PDMA_T::INTSTS: ABTIF Position            */
N#define PDMA_INTSTS_ABTIF_Msk            (0x1ul << PDMA_INTSTS_ABTIF_Pos)                  /*!< PDMA_T::INTSTS: ABTIF Mask                */
N
N#define PDMA_INTSTS_TDIF_Pos             (1)                                               /*!< PDMA_T::INTSTS: TDIF Position             */
N#define PDMA_INTSTS_TDIF_Msk             (0x1ul << PDMA_INTSTS_TDIF_Pos)                   /*!< PDMA_T::INTSTS: TDIF Mask                 */
N
N#define PDMA_INTSTS_TEIF_Pos             (2)                                               /*!< PDMA_T::INTSTS: TEIF Position             */
N#define PDMA_INTSTS_TEIF_Msk             (0x1ul << PDMA_INTSTS_TEIF_Pos)                   /*!< PDMA_T::INTSTS: TEIF Mask                 */
N
N#define PDMA_INTSTS_REQTOFn_Pos          (8)                                               /*!< PDMA_T::INTSTS: REQTOFn Position          */
N#define PDMA_INTSTS_REQTOFn_Msk          (0xfful << PDMA_INTSTS_REQTOFn_Pos)               /*!< PDMA_T::INTSTS: REQTOFn Mask              */
N
N#define PDMA_ABTSTS_ABTIFn_Pos           (0)                                               /*!< PDMA_T::ABTSTS: ABTIFn Position           */
N#define PDMA_ABTSTS_ABTIFn_Msk           (0xffful << PDMA_ABTSTS_ABTIFn_Pos)               /*!< PDMA_T::ABTSTS: ABTIFn Mask               */
N
N#define PDMA_TDSTS_TDIFn_Pos             (0)                                               /*!< PDMA_T::TDSTS: TDIFn Position             */
N#define PDMA_TDSTS_TDIFn_Msk             (0xffful << PDMA_TDSTS_TDIFn_Pos)                 /*!< PDMA_T::TDSTS: TDIFn Mask                 */
N
N#define PDMA_SCATSTS_TEMPTYFn_Pos        (0)                                               /*!< PDMA_T::SCATSTS: TEMPTYFn Position        */
N#define PDMA_SCATSTS_TEMPTYFn_Msk        (0xffful << PDMA_SCATSTS_TEMPTYFn_Pos)            /*!< PDMA_T::SCATSTS: TEMPTYFn Mask            */
N
N#define PDMA_TACTSTS_TXACTFn_Pos         (0)                                               /*!< PDMA_T::TACTSTS: TXACTFn Position         */
N#define PDMA_TACTSTS_TXACTFn_Msk         (0xffful << PDMA_TACTSTS_TXACTFn_Pos)             /*!< PDMA_T::TACTSTS: TXACTFn Mask             */
N
N#define PDMA_TOUTEN_TOUTENn_Pos          (0)                                               /*!< PDMA_T::TOUTEN: TOUTENn Position          */
N#define PDMA_TOUTEN_TOUTENn_Msk          (0xfful << PDMA_TOUTEN_TOUTENn_Pos)               /*!< PDMA_T::TOUTEN: TOUTENn Mask              */
N
N#define PDMA_TOUTIEN_TOUTIENn_Pos        (0)                                               /*!< PDMA_T::TOUTIEN: TOUTIENn Position        */
N#define PDMA_TOUTIEN_TOUTIENn_Msk        (0xfful << PDMA_TOUTIEN_TOUTIENn_Pos)             /*!< PDMA_T::TOUTIEN: TOUTIENn Mask            */
N
N#define PDMA_SCATBA_SCATBA_Pos           (16)                                              /*!< PDMA_T::SCATBA: SCATBA Position           */
N#define PDMA_SCATBA_SCATBA_Msk           (0xfffful << PDMA_SCATBA_SCATBA_Pos)              /*!< PDMA_T::SCATBA: SCATBA Mask               */
N
N#define PDMA_TOC0_1_TOC0_Pos             (0)                                               /*!< PDMA_T::TOC0_1: TOC0 Position             */
N#define PDMA_TOC0_1_TOC0_Msk             (0xfffful << PDMA_TOC0_1_TOC0_Pos)                /*!< PDMA_T::TOC0_1: TOC0 Mask                 */
N
N#define PDMA_TOC0_1_TOC1_Pos             (16)                                              /*!< PDMA_T::TOC0_1: TOC1 Position             */
N#define PDMA_TOC0_1_TOC1_Msk             (0xfffful << PDMA_TOC0_1_TOC1_Pos)                /*!< PDMA_T::TOC0_1: TOC1 Mask                 */
N
N#define PDMA_TOC2_3_TOC2_Pos             (0)                                               /*!< PDMA_T::TOC2_3: TOC2 Position             */
N#define PDMA_TOC2_3_TOC2_Msk             (0xfffful << PDMA_TOC2_3_TOC2_Pos)                /*!< PDMA_T::TOC2_3: TOC2 Mask                 */
N
N#define PDMA_TOC2_3_TOC3_Pos             (16)                                              /*!< PDMA_T::TOC2_3: TOC3 Position             */
N#define PDMA_TOC2_3_TOC3_Msk             (0xfffful << PDMA_TOC2_3_TOC3_Pos)                /*!< PDMA_T::TOC2_3: TOC3 Mask                 */
N
N#define PDMA_TOC4_5_TOC4_Pos             (0)                                               /*!< PDMA_T::TOC4_5: TOC4 Position             */
N#define PDMA_TOC4_5_TOC4_Msk             (0xfffful << PDMA_TOC4_5_TOC4_Pos)                /*!< PDMA_T::TOC4_5: TOC4 Mask                 */
N
N#define PDMA_TOC4_5_TOC5_Pos             (16)                                              /*!< PDMA_T::TOC4_5: TOC5 Position             */
N#define PDMA_TOC4_5_TOC5_Msk             (0xfffful << PDMA_TOC4_5_TOC5_Pos)                /*!< PDMA_T::TOC4_5: TOC5 Mask                 */
N
N#define PDMA_TOC6_7_TOC6_Pos             (0)                                               /*!< PDMA_T::TOC6_7: TOC6 Position             */
N#define PDMA_TOC6_7_TOC6_Msk             (0xfffful << PDMA_TOC6_7_TOC6_Pos)                /*!< PDMA_T::TOC6_7: TOC6 Mask                 */
N
N#define PDMA_TOC6_7_TOC7_Pos             (16)                                              /*!< PDMA_T::TOC6_7: TOC7 Position             */
N#define PDMA_TOC6_7_TOC7_Msk             (0xfffful << PDMA_TOC6_7_TOC7_Pos)                /*!< PDMA_T::TOC6_7: TOC7 Mask                 */
N
N#define PDMA_REQSEL0_3_REQSRC0_Pos       (0)                                               /*!< PDMA_T::REQSEL0_3: REQSRC0 Position       */
N#define PDMA_REQSEL0_3_REQSRC0_Msk       (0x1ful << PDMA_REQSEL0_3_REQSRC0_Pos)            /*!< PDMA_T::REQSEL0_3: REQSRC0 Mask           */
N
N#define PDMA_REQSEL0_3_REQSRC1_Pos       (8)                                               /*!< PDMA_T::REQSEL0_3: REQSRC1 Position       */
N#define PDMA_REQSEL0_3_REQSRC1_Msk       (0x1ful << PDMA_REQSEL0_3_REQSRC1_Pos)            /*!< PDMA_T::REQSEL0_3: REQSRC1 Mask           */
N
N#define PDMA_REQSEL0_3_REQSRC2_Pos       (16)                                              /*!< PDMA_T::REQSEL0_3: REQSRC2 Position       */
N#define PDMA_REQSEL0_3_REQSRC2_Msk       (0x1ful << PDMA_REQSEL0_3_REQSRC2_Pos)            /*!< PDMA_T::REQSEL0_3: REQSRC2 Mask           */
N
N#define PDMA_REQSEL0_3_REQSRC3_Pos       (24)                                              /*!< PDMA_T::REQSEL0_3: REQSRC3 Position       */
N#define PDMA_REQSEL0_3_REQSRC3_Msk       (0x1ful << PDMA_REQSEL0_3_REQSRC3_Pos)            /*!< PDMA_T::REQSEL0_3: REQSRC3 Mask           */
N
N#define PDMA_REQSEL4_7_REQSRC4_Pos       (0)                                               /*!< PDMA_T::REQSEL4_7: REQSRC4 Position       */
N#define PDMA_REQSEL4_7_REQSRC4_Msk       (0x1ful << PDMA_REQSEL4_7_REQSRC4_Pos)            /*!< PDMA_T::REQSEL4_7: REQSRC4 Mask           */
N
N#define PDMA_REQSEL4_7_REQSRC5_Pos       (8)                                               /*!< PDMA_T::REQSEL4_7: REQSRC5 Position       */
N#define PDMA_REQSEL4_7_REQSRC5_Msk       (0x1ful << PDMA_REQSEL4_7_REQSRC5_Pos)            /*!< PDMA_T::REQSEL4_7: REQSRC5 Mask           */
N
N#define PDMA_REQSEL4_7_REQSRC6_Pos       (16)                                              /*!< PDMA_T::REQSEL4_7: REQSRC6 Position       */
N#define PDMA_REQSEL4_7_REQSRC6_Msk       (0x1ful << PDMA_REQSEL4_7_REQSRC6_Pos)            /*!< PDMA_T::REQSEL4_7: REQSRC6 Mask           */
N
N#define PDMA_REQSEL4_7_REQSRC7_Pos       (24)                                              /*!< PDMA_T::REQSEL4_7: REQSRC7 Position       */
N#define PDMA_REQSEL4_7_REQSRC7_Msk       (0x1ful << PDMA_REQSEL4_7_REQSRC7_Pos)            /*!< PDMA_T::REQSEL4_7: REQSRC7 Mask           */
N
N#define PDMA_REQSEL8_11_REQSRC8_Pos      (0)                                               /*!< PDMA_T::REQSEL8_11: REQSRC8 Position      */
N#define PDMA_REQSEL8_11_REQSRC8_Msk      (0x1ful << PDMA_REQSEL8_11_REQSRC8_Pos)           /*!< PDMA_T::REQSEL8_11: REQSRC8 Mask          */
N
N#define PDMA_REQSEL8_11_REQSRC9_Pos      (8)                                               /*!< PDMA_T::REQSEL8_11: REQSRC9 Position      */
N#define PDMA_REQSEL8_11_REQSRC9_Msk      (0x1ful << PDMA_REQSEL8_11_REQSRC9_Pos)           /*!< PDMA_T::REQSEL8_11: REQSRC9 Mask          */
N
N#define PDMA_REQSEL8_11_REQSRC10_Pos     (16)                                              /*!< PDMA_T::REQSEL8_11: REQSRC10 Position     */
N#define PDMA_REQSEL8_11_REQSRC10_Msk     (0x1ful << PDMA_REQSEL8_11_REQSRC10_Pos)          /*!< PDMA_T::REQSEL8_11: REQSRC10 Mask         */
N
N#define PDMA_REQSEL8_11_REQSRC11_Pos     (24)                                              /*!< PDMA_T::REQSEL8_11: REQSRC11 Position     */
N#define PDMA_REQSEL8_11_REQSRC11_Msk     (0x1ful << PDMA_REQSEL8_11_REQSRC11_Pos)          /*!< PDMA_T::REQSEL8_11: REQSRC11 Mask         */
N
N/**@}*/ /* PDMA_CONST */
N/**@}*/ /* end of PDMA register group */
N
N
N/*---------------------- Pulse Width Modulation Controller -------------------------*/
N/**
N    @addtogroup PWM Pulse Width Modulation Controller(PWM)
N    Memory Mapped Structure for PWM Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var PWM_T::CTL0
N * Offset: 0x00  PWM Control Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |CTRLDn    |Center Re-Load
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |In up-down counter type, PERIOD will load to PBUF at the end point of each period.
N * |        |          |CMPDAT will load to CMPBUF at the center point of a period.
N * |[13:8]  |WINLDENn  |Window Load Enable
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |0 = PERIOD will load to PBUF at the end point of each period.
N * |        |          |CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
N * |        |          |1 = PERIOD will load to PBUF at the end point of each period.
N * |        |          |CMPDAT will load to CMPBUF at the end point of each period when valid reload window is set.
N * |        |          |The valid reload window is set by software write 1 to PWM_LOAD register and cleared by hardware after load success.
N * |[21:16] |IMMLDENn  |Immediately Load Enable
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |0 = PERIOD will load to PBUF at the end point of each period.
N * |        |          |CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
N * |        |          |1 = PERIOD/CMPDAT will load to PBUF and CMPBUF immediately when software update PERIOD/CMPDAT.
N * |        |          |Note: If IMMLDENn is enabled, WINLDENn and CTRLDn will be invalid.
N * |[24]    |GROUPEN   |Group Function Enable
N * |        |          |0 = The output waveform of each PWM channel are independent.
N * |        |          |1 = Unify the PWM_CH2 and PWM_CH4 to output the same waveform as PWM_CH0 and unify the PWM_CH3 and PWM_CH5 to output the same waveform as PWM_CH1.
N * |[30]    |DBGHALT   |ICE Debug Mode Counter Halt (Write Protect)
N * |        |          |If counter halt is enabled, PWM all counters will keep current value until exit ICE debug mode.
N * |        |          |0 = ICE debug mode counter halt disable.
N * |        |          |1 = ICE debug mode counter halt enable.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[31]    |DBGTRIOFF |ICE Debug Mode Acknowledge Disable (Write Protect)
N * |        |          |0 = ICE debug mode acknowledgement effects PWM output.
N * |        |          |PWM pin will be forced as tri-state while ICE debug mode acknowledged.
N * |        |          |1 = ICE debug mode acknowledgement disabled.
N * |        |          |PWM pin will keep output no matter ICE debug mode acknowledged or not.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * @var PWM_T::CTL1
N * Offset: 0x04  PWM Control Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |CNTTYPEn  |PWM Counter Behavior Type
N * |        |          |Each bit n controls corresponding PWM channel n.
N * |        |          |00 = Up counter type (supports in capture mode).
N * |        |          |01 = Down count type (supports in capture mode).
N * |        |          |10 = Up-down counter type.
N * |        |          |11 = Reserved.
N * |[21:16] |CNTMODEn  |PWM Counter Mode
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |0 = Auto-reload mode.
N * |        |          |1 = One-shot mode.
N * |[26:24] |OUTMODEn  |PWM Output Mode
N * |        |          |Each bit n controls the
N * |        |          |output mode of
N * |        |          |corresponding PWM channel n.
N * |        |          |0 = PWM independent mode.
N * |        |          |1 = PWM complementary mode.
N * |        |          |Note: When operating in group function, these bits must all set to the same mode.
N * @var PWM_T::SYNC
N * Offset: 0x08  PWM Synchronization Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2:0]   |PHSENn    |SYNC Phase Enable
N * |        |          |Each bit n controls corresponding PWM channel n.
N * |        |          |0 = PWM counter disable to load PHS value.
N * |        |          |1 = PWM counter enable to load PHS value.
N * |[13:8]  |SINSRCn   |PWM_SYNC_IN Source Selection
N * |        |          |Each bit n controls corresponding PWM channel n.
N * |        |          |00 = Synchronize source from SYNC_IN or SWSYNC.
N * |        |          |01 = Counter equal to 0.
N * |        |          |10 = Counter equal to PWM_CMPDATm, m denotes 1, 3, 5.
N * |        |          |11 = SYNC_OUT will not be generated.
N * |[16]    |SNFLTEN   |PWM_SYNC_IN Noise Filter Enable
N * |        |          |0 = Noise filter of input pin PWM_SYNC_IN is Disabled.
N * |        |          |1 = Noise filter of input pin PWM_SYNC_IN is Enabled.
N * |[19:17] |SFLTCSEL  |SYNC Edge Detector Filter Clock Selection
N * |        |          |000 = Filter clock = HCLK.
N * |        |          |001 = Filter clock = HCLK/2.
N * |        |          |010 = Filter clock = HCLK/4.
N * |        |          |011 = Filter clock = HCLK/8.
N * |        |          |100 = Filter clock = HCLK/16.
N * |        |          |101 = Filter clock = HCLK/32.
N * |        |          |110 = Filter clock = HCLK/64.
N * |        |          |111 = Filter clock = HCLK/128.
N * |[22:20] |SFLTCNT   |SYNC Edge Detector Filter Count
N * |        |          |The register bits control the counter number of edge detector.
N * |[23]    |SINPINV   |SYNC Input Pin Inverse
N * |        |          |0 = The state of pin SYNC is passed to the negative edge detector.
N * |        |          |1 = The inverted state of pin SYNC is passed to the negative edge detector.
N * |[26:24] |PHSDIRn   |PWM Phase Direction Control
N * |        |          |Each bit n controls corresponding PWM channel n.
N * |        |          |0 = Control PWM counter count decrement after synchronizing.
N * |        |          |1 = Control PWM counter count increment after synchronizing.
N * @var PWM_T::SWSYNC
N * Offset: 0x0C  PWM Software Control Synchronization Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2:0]   |SWSYNCn   |Software SYNC Function
N * |        |          |Each bit n controls corresponding PWM channel n.
N * |        |          |When SINSRCn (PWM_SYNC[13:8]) is selected to 0, SYNC_OUT source is come from SYNC_IN or this bit.
N * @var PWM_T::CLKSRC
N * Offset: 0x10  PWM Clock Source Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2:0]   |ECLKSRC0  |PWM_CH01 External Clock Source Select
N * |        |          |000 = PWMx_CLK, x denotes 0 or 1.
N * |        |          |001 = TIMER0 overflow.
N * |        |          |010 = TIMER1 overflow.
N * |        |          |011 = TIMER2 overflow.
N * |        |          |100 = TIMER3 overflow.
N * |        |          |Others = Reserved.
N * |[10:8]  |ECLKSRC2  |PWM_CH23 External Clock Source Select
N * |        |          |000 = PWMx_CLK, x denotes 0 or 1.
N * |        |          |001 = TIMER0 overflow.
N * |        |          |010 = TIMER1 overflow.
N * |        |          |011 = TIMER2 overflow.
N * |        |          |100 = TIMER3 overflow.
N * |        |          |Others = Reserved.
N * |[18:16] |ECLKSRC4  |PWM_CH45 External Clock Source Select
N * |        |          |000 = PWMx_CLK, x denotes 0 or 1.
N * |        |          |001 = TIMER0 overflow.
N * |        |          |010 = TIMER1 overflow.
N * |        |          |011 = TIMER2 overflow.
N * |        |          |100 = TIMER3 overflow.
N * |        |          |Others = Reserved.
N * @var PWM_T::CLKPSC0_1
N * Offset: 0x14  PWM Clock Pre-scale Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-Scale
N * |        |          |The clock of PWM counter is decided by clock prescaler.
N * |        |          |Each PWM pair share one PWM counter clock prescaler.
N * |        |          |The clock of PWM counter is divided by (CLKPSC+ 1).
N * @var PWM_T::CLKPSC2_3
N * Offset: 0x18  PWM Clock Pre-scale Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-Scale
N * |        |          |The clock of PWM counter is decided by clock prescaler.
N * |        |          |Each PWM pair share one PWM counter clock prescaler.
N * |        |          |The clock of PWM counter is divided by (CLKPSC+ 1).
N * @var PWM_T::CLKPSC4_5
N * Offset: 0x1C  PWM Clock Pre-scale Register 4
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-Scale
N * |        |          |The clock of PWM counter is decided by clock prescaler.
N * |        |          |Each PWM pair share one PWM counter clock prescaler.
N * |        |          |The clock of PWM counter is divided by (CLKPSC+ 1).
N * @var PWM_T::CNTEN
N * Offset: 0x20  PWM Counter Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |CNTENn    |PWM Counter Enable
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |0 = PWM Counter and clock prescaler Stop Running.
N * |        |          |1 = PWM Counter and clock prescaler Start Running.
N * @var PWM_T::CNTCLR
N * Offset: 0x24  PWM Clear Counter Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |CNTCLRn   |Clear PWM Counter Control Bit
N * |        |          |It is automatically cleared by hardware. Each bit n controls the corresponding PWM channel n.
N * |        |          |0 = No effect.
N * |        |          |1 = Clear 16-bit PWM counter to 0000H.
N * @var PWM_T::LOAD
N * Offset: 0x28  PWM Load Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |LOADn     |Re-Load PWM Comparator Register (CMPDAT) Control Bit
N * |        |          |This bit is software write, hardware clear when current PWM period end.
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Set load window of window loading mode.
N * |        |          |Read Operation:
N * |        |          |0 = No load window is set.
N * |        |          |1 = Load window is set.
N * |        |          |Note: This bit only use in window loading mode, WINLDENn(PWM_CTL0[13:8]) = 1.
N * @var PWM_T::PERIOD
N * Offset: 0x30~0x44  PWM Period Register 0~5
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |PERIOD    |PWM Period Register
N * |        |          |Up-Count mode: In this mode, PWM counter counts from 0 to PERIOD, and restarts from 0.
N * |        |          |Down-Count mode: In this mode, PWM counter counts from PERIOD to 0, and restarts from PERIOD.
N * |        |          |PWM period time = (PERIOD+1) * PWM_CLK period.
N * |        |          |Up-Down-Count mode: In this mode, PWM counter counts from 0 to PERIOD, then decrements to 0 and repeats again.
N * |        |          |PWM period time = 2 * PERIOD * PWM_CLK period.
N * @var PWM_T::CMPDAT
N * Offset: 0x50~0x64  PWM Comparator Register 0~5
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CMP       |PWM Comparator Register
N * |        |          |CMP use to compare with CNTR to generate PWM waveform, interrupt and trigger EADC/DAC.
N * |        |          |In independent mode, CMPDAT0~5 denote as 6 independent PWM_CH0~5 compared point.
N * |        |          |In complementary mode, CMPDAT0, 2, 4 denote as first compared point, and CMPDAT1, 3, 5 denote as second compared point for the corresponding 3 complementary pairs PWM_CH0 and PWM_CH1, PWM_CH2 and PWM_CH3, PWM_CH4 and PWM_CH5.
N * @var PWM_T::DTCTL0_1
N * Offset: 0x70  PWM Dead-Time Control Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |DTCNT     |Dead-Time Counter (Write Protect)
N * |        |          |The dead-time can be calculated from the following formula:
N * |        |          |Dead-time = (DTCNT[11:0]+1) * PWM_CLK period.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[16]    |DTEN      |Enable Dead-Time Insertion For PWM Pair (PWM_CH0, PWM_CH1) (PWM_CH2, PWM_CH3) (PWM_CH4, PWM_CH5) (Write Protect)
N * |        |          |Dead-time insertion is only active when this pair of complementary PWM is enabled.
N * |        |          |If dead- time insertion is inactive, the outputs of pin pair are complementary without any delay.
N * |        |          |0 = Dead-time insertion Disabled on the pin pair.
N * |        |          |1 = Dead-time insertion Enabled on the pin pair.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[24]    |DTCKSEL   |Dead-Time Clock Select (Write Protect) (M45xD/M45xC Only)
N * |        |          |0 = Dead-time clock source from PWM_CLK.
N * |        |          |1 = Dead-time clock source from prescaler output.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * @var PWM_T::DTCTL2_3
N * Offset: 0x74  PWM Dead-Time Control Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |DTCNT     |Dead-Time Counter (Write Protect)
N * |        |          |The dead-time can be calculated from the following formula:
N * |        |          |Dead-time = (DTCNT[11:0]+1) * PWM_CLK period.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[16]    |DTEN      |Enable Dead-Time Insertion For PWM Pair (PWM_CH0, PWM_CH1) (PWM_CH2, PWM_CH3) (PWM_CH4, PWM_CH5) (Write Protect)
N * |        |          |Dead-time insertion is only active when this pair of complementary PWM is enabled.
N * |        |          |If dead- time insertion is inactive, the outputs of pin pair are complementary without any delay.
N * |        |          |0 = Dead-time insertion Disabled on the pin pair.
N * |        |          |1 = Dead-time insertion Enabled on the pin pair.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[24]    |DTCKSEL   |Dead-Time Clock Select (Write Protect) (M45xD/M45xC Only)
N * |        |          |0 = Dead-time clock source from PWM_CLK.
N * |        |          |1 = Dead-time clock source from prescaler output.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * @var PWM_T::DTCTL4_5
N * Offset: 0x78  PWM Dead-Time Control Register 4
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |DTCNT     |Dead-Time Counter (Write Protect)
N * |        |          |The dead-time can be calculated from the following formula:
N * |        |          |Dead-time = (DTCNT[11:0]+1) * PWM_CLK period.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[16]    |DTEN      |Enable Dead-Time Insertion For PWM Pair (PWM_CH0, PWM_CH1) (PWM_CH2, PWM_CH3) (PWM_CH4, PWM_CH5) (Write Protect)
N * |        |          |Dead-time insertion is only active when this pair of complementary PWM is enabled.
N * |        |          |If dead- time insertion is inactive, the outputs of pin pair are complementary without any delay.
N * |        |          |0 = Dead-time insertion Disabled on the pin pair.
N * |        |          |1 = Dead-time insertion Enabled on the pin pair.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[24]    |DTCKSEL   |Dead-Time Clock Select (Write Protect) (M45xD/M45xC Only)
N * |        |          |0 = Dead-time clock source from PWM_CLK.
N * |        |          |1 = Dead-time clock source from prescaler output.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * @var PWM_T::PHS0_1
N * Offset: 0x80  PWM Counter Phase Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |PHS       |PWM Synchronous Start Phase Bits
N * |        |          |PHS determines the PWM synchronous start phase value. These bits only use in synchronous function.
N * @var PWM_T::PHS2_3
N * Offset: 0x84  PWM Counter Phase Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |PHS       |PWM Synchronous Start Phase Bits
N * |        |          |PHS determines the PWM synchronous start phase value. These bits only use in synchronous function.
N * @var PWM_T::PHS4_5
N * Offset: 0x88  PWM Counter Phase Register 4
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |PHS       |PWM Synchronous Start Phase Bits
N * |        |          |PHS determines the PWM synchronous start phase value. These bits only use in synchronous function.
N * @var PWM_T::CNT
N * Offset: 0x90~0xA4  PWM Counter Register 0~5
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CNT       |PWM Data Register (Read Only)
N * |        |          |User can monitor CNTR to know the current value in 16-bit period counter.
N * |[16]    |DIRF      |PWM Direction Indicator Flag (Read Only)
N * |        |          |0 = Counter is Down count.
N * |        |          |1 = Counter is UP count.
N * @var PWM_T::WGCTL0
N * Offset: 0xB0  PWM Generation Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |ZPCTLn    |PWM Zero Point Control
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |00 = Do nothing.
N * |        |          |01 = PWM zero point output Low.
N * |        |          |10 = PWM zero point output High.
N * |        |          |11 = PWM zero point output Toggle.
N * |        |          |PWM can control output level when PWM counter count to zero.
N * |[27:16] |PRDPCTLn  |PWM Period (Center) Point Control
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |00 = Do nothing.
N * |        |          |01 = PWM period (center) point output Low.
N * |        |          |10 = PWM period (center) point output High.
N * |        |          |11 = PWM period (center) point output Toggle.
N * |        |          |PWM can control output level when PWM counter count to (PERIODn+1).
N * |        |          |Note: This bit is center point control when PWM counter operating in up-down counter type.
N * @var PWM_T::WGCTL1
N * Offset: 0xB4  PWM Generation Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |CMPUCTLn  |PWM Compare Up Point Control
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |00 = Do nothing.
N * |        |          |01 = PWM compare up point output Low.
N * |        |          |10 = PWM compare up point output High.
N * |        |          |11 = PWM compare up point output Toggle.
N * |        |          |PWM can control output level when PWM counter up count to CMPDAT.
N * |        |          |Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
N * |[27:16] |CMPDCTLn  |PWM Compare Down Point Control
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |00 = Do nothing.
N * |        |          |01 = PWM compare down point output Low.
N * |        |          |10 = PWM compare down point output High.
N * |        |          |11 = PWM compare down point output Toggle.
N * |        |          |PWM can control output level when PWM counter down count to CMPDAT.
N * |        |          |Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
N * @var PWM_T::MSKEN
N * Offset: 0xB8  PWM Mask Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |MSKENn    |PWM Mask Enable
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |The PWM output signal will be masked when this bit is enabled.
N * |        |          |The corresponding PWM channel n will output MSKDATn (PWM_MSK[5:0]) data.
N * |        |          |0 = PWM output signal is non-masked.
N * |        |          |1 = PWM output signal is masked and output MSKDATn data.
N * @var PWM_T::MSK
N * Offset: 0xBC  PWM Mask Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |MSKDATn   |PWM Mask Data Bit
N * |        |          |This data bit control the state of PWMn output pin, if corresponding mask function is enabled.
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |0 = Output logic low to PWMn.
N * |        |          |1 = Output logic high to PWMn.
N * @var PWM_T::BNF
N * Offset: 0xC0  PWM Brake Noise Filter Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |BRK0NFEN  |PWM Brake 0 Noise Filter Enable
N * |        |          |0 = Noise filter of PWM Brake 0 Disabled.
N * |        |          |1 = Noise filter of PWM Brake 0 Enabled.
N * |[3:1]   |BRK0NFSEL |Brake 0 Edge Detector Filter Clock Selection
N * |        |          |000 = Filter clock = HCLK.
N * |        |          |001 = Filter clock = HCLK/2.
N * |        |          |010 = Filter clock = HCLK/4.
N * |        |          |011 = Filter clock = HCLK/8.
N * |        |          |100 = Filter clock = HCLK/16.
N * |        |          |101 = Filter clock = HCLK/32.
N * |        |          |110 = Filter clock = HCLK/64.
N * |        |          |111 = Filter clock = HCLK/128.
N * |[6:4]   |BRK0FCNT  |Brake 0 Edge Detector Filter Count
N * |        |          |The register bits control the Brake0 filter counter to count from 0 to BRK1FCNT.
N * |[7]     |BRK0PINV  |Brake 0 Pin Inverse
N * |        |          |0 = The state of pin PWMx_BRAKE0 is passed to the negative edge detector.
N * |        |          |1 = The inverted state of pin PWMx_BRAKE10 is passed to the negative edge detector.
N * |[8]     |BRK1NFEN  |PWM Brake 1 Noise Filter Enable
N * |        |          |0 = Noise filter of PWM Brake 1 Disabled.
N * |        |          |1 = Noise filter of PWM Brake 1 Enabled.
N * |[11:9]  |BRK1NFSEL |Brake 1 Edge Detector Filter Clock Selection
N * |        |          |000 = Filter clock = HCLK.
N * |        |          |001 = Filter clock = HCLK/2.
N * |        |          |010 = Filter clock = HCLK/4.
N * |        |          |011 = Filter clock = HCLK/8.
N * |        |          |100 = Filter clock = HCLK/16.
N * |        |          |101 = Filter clock = HCLK/32.
N * |        |          |110 = Filter clock = HCLK/64.
N * |        |          |111 = Filter clock = HCLK/128.
N * |[14:12] |BRK1FCNT  |Brake 1 Edge Detector Filter Count
N * |        |          |The register bits control the Brake1 filter counter to count from 0 to BRK1FCNT.
N * |[15]    |BRK1PINV  |Brake 1 Pin Inverse
N * |        |          |0 = The state of pin PWMx_BRAKE1 is passed to the negative edge detector.
N * |        |          |1 = The inverted state of pin PWMx_BRAKE1 is passed to the negative edge detector.
N * |[16]    |BK0SRC    |Brake 0 Pin Source Select (M45xD/M45xC Only)
N * |        |          |For PWM0 setting:
N * |        |          |0 = Brake 0 pin source come from PWM0_BRAKE0.
N * |        |          |1 = Brake 0 pin source come from PWM1_BRAKE0.
N * |        |          |For PWM1 setting:
N * |        |          |0 = Brake 0 pin source come from PWM1_BRAKE0.
N * |        |          |1 = Brake 0 pin source come from PWM0_BRAKE0.
N * |[24]    |BK1SRC    |Brake 1 Pin Source Select (M45xD/M45xC Only)
N * |        |          |For PWM0 setting:
N * |        |          |0 = Brake 1 pin source come from PWM0_BRAKE1.
N * |        |          |1 = Brake 1 pin source come from PWM1_BRAKE1.
N * |        |          |For PWM1 setting:
N * |        |          |0 = Brake 1 pin source come from PWM1_BRAKE1.
N * |        |          |1 = Brake 1 pin source come from PWM0_BRAKE1.
N * @var PWM_T::FAILBRK
N * Offset: 0xC4  PWM System Fail Brake Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CSSBRKEN  |Clock Security System Detection Trigger PWM Brake Function 0 Enable
N * |        |          |0 = Brake Function triggered by CSS detection Disabled.
N * |        |          |1 = Brake Function triggered by CSS detection Enabled.
N * |[1]     |BODBRKEN  |Brown-Out Detection Trigger PWM Brake Function 0 Enable
N * |        |          |0 = Brake Function triggered by BOD Disabled.
N * |        |          |1 = Brake Function triggered by BOD Enabled.
N * |[2]     |RAMBRKEN  |SRAM Parity Error Detection Trigger PWM Brake Function 0 Enable
N * |        |          |0 = Brake Function triggered by SRAM parity error detection Disabled.
N * |        |          |1 = Brake Function triggered by SRAM parity error detection Enabled.
N * |[3]     |CORBRKEN  |Core Lockup Detection Trigger PWM Brake Function 0 Enable
N * |        |          |0 = Brake Function triggered by Core lockup detection Disabled.
N * |        |          |1 = Brake Function triggered by Core lockup detection Enabled.
N * @var PWM_T::BRKCTL0_1
N * Offset: 0xC8  PWM Brake Edge Detect Control Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CPO0EBEN  |Enable ACMP0_O Digital Output As Edge-Detect Brake Source (Write Protect)
N * |        |          |0 = ACMP0_O as edge-detect brake source Disabled.
N * |        |          |1 = ACMP0_O as edge-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[1]     |CPO1EBEN  |Enable ACMP1_O Digital Output As Edge-Detect Brake Source (Write Protect)
N * |        |          |0 = ACMP1_O as edge-detect brake source Disabled.
N * |        |          |1 = ACMP1_O as edge-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[4]     |BRKP0EEN  |Enable PWMx_BRAKE0 Pin As Edge-Detect Brake Source (Write Protect)
N * |        |          |0 = BKP0 pin as edge-detect brake source Disabled.
N * |        |          |1 = BKP0 pin as edge-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[5]     |BRKP1EEN  |Enable PWMx_BRAKE1 Pin As Edge-Detect Brake Source (Write Protect)
N * |        |          |0 = BKP1 pin as edge-detect brake source Disabled.
N * |        |          |1 = BKP1 pin as edge-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[7]     |SYSEBEN   |Enable System Fail As Edge-Detect Brake Source (Write Protect)
N * |        |          |0 = System Fail condition as edge-detect brake source Disabled.
N * |        |          |1 = System Fail condition as edge-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[8]     |CPO0LBEN  |Enable ACMP0_O Digital Output As Level-Detect Brake Source (Write Protect)
N * |        |          |0 = ACMP0_O as level-detect brake source Disabled.
N * |        |          |1 = ACMP0_O as level-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[9]     |CPO1LBEN  |Enable ACMP1_O Digital Output As Level-Detect Brake Source (Write Protect)
N * |        |          |0 = ACMP1_O as level-detect brake source Disabled.
N * |        |          |1 = ACMP1_O as level-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[12]    |BRKP0LEN  |Enable BKP0 Pin As Level-Detect Brake Source (Write Protect)
N * |        |          |0 = PWMx_BRAKE0 pin as level-detect brake source Disabled.
N * |        |          |1 = PWMx_BRAKE0 pin as level-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[13]    |BRKP1LEN  |Enable BKP1 Pin As Level-Detect Brake Source (Write Protect)
N * |        |          |0 = PWMx_BRAKE1 pin as level-detect brake source Disabled.
N * |        |          |1 = PWMx_BRAKE1 pin as level-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[15]    |SYSLBEN   |Enable System Fail As Level-Detect Brake Source (Write Protect)
N * |        |          |0 = System Fail condition as level-detect brake source Disabled.
N * |        |          |1 = System Fail condition as level-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[17:16] |BRKAEVEN  |PWM Brake Action Select For Even Channel (Write Protect)
N * |        |          |00 = PWM even channel level-detect brake function not affect channel output.
N * |        |          |01 = PWM even channel output tri-state when level-detect brake happened.
N * |        |          |10 = PWM even channel output low level when level-detect brake happened.
N * |        |          |11 = PWM even channel output high level when level-detect brake happened.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[19:18] |BRKAODD   |PWM Brake Action Select For Odd Channel (Write Protect)
N * |        |          |00 = PWM odd channel level-detect brake function not affect channel output.
N * |        |          |01 = PWM odd channel output tri-state when level-detect brake happened.
N * |        |          |10 = PWM odd channel output low level when level-detect brake happened.
N * |        |          |11 = PWM odd channel output high level when level-detect brake happened.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * @var PWM_T::BRKCTL2_3
N * Offset: 0xCC  PWM Brake Edge Detect Control Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CPO0EBEN  |Enable ACMP0_O Digital Output As Edge-Detect Brake Source (Write Protect)
N * |        |          |0 = ACMP0_O as edge-detect brake source Disabled.
N * |        |          |1 = ACMP0_O as edge-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[1]     |CPO1EBEN  |Enable ACMP1_O Digital Output As Edge-Detect Brake Source (Write Protect)
N * |        |          |0 = ACMP1_O as edge-detect brake source Disabled.
N * |        |          |1 = ACMP1_O as edge-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[4]     |BRKP0EEN  |Enable PWMx_BRAKE0 Pin As Edge-Detect Brake Source (Write Protect)
N * |        |          |0 = BKP0 pin as edge-detect brake source Disabled.
N * |        |          |1 = BKP0 pin as edge-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[5]     |BRKP1EEN  |Enable PWMx_BRAKE1 Pin As Edge-Detect Brake Source (Write Protect)
N * |        |          |0 = BKP1 pin as edge-detect brake source Disabled.
N * |        |          |1 = BKP1 pin as edge-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[7]     |SYSEBEN   |Enable System Fail As Edge-Detect Brake Source (Write Protect)
N * |        |          |0 = System Fail condition as edge-detect brake source Disabled.
N * |        |          |1 = System Fail condition as edge-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[8]     |CPO0LBEN  |Enable ACMP0_O Digital Output As Level-Detect Brake Source (Write Protect)
N * |        |          |0 = ACMP0_O as level-detect brake source Disabled.
N * |        |          |1 = ACMP0_O as level-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[9]     |CPO1LBEN  |Enable ACMP1_O Digital Output As Level-Detect Brake Source (Write Protect)
N * |        |          |0 = ACMP1_O as level-detect brake source Disabled.
N * |        |          |1 = ACMP1_O as level-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[12]    |BRKP0LEN  |Enable BKP0 Pin As Level-Detect Brake Source (Write Protect)
N * |        |          |0 = PWMx_BRAKE0 pin as level-detect brake source Disabled.
N * |        |          |1 = PWMx_BRAKE0 pin as level-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[13]    |BRKP1LEN  |Enable BKP1 Pin As Level-Detect Brake Source (Write Protect)
N * |        |          |0 = PWMx_BRAKE1 pin as level-detect brake source Disabled.
N * |        |          |1 = PWMx_BRAKE1 pin as level-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[15]    |SYSLBEN   |Enable System Fail As Level-Detect Brake Source (Write Protect)
N * |        |          |0 = System Fail condition as level-detect brake source Disabled.
N * |        |          |1 = System Fail condition as level-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[17:16] |BRKAEVEN  |PWM Brake Action Select For Even Channel (Write Protect)
N * |        |          |00 = PWM even channel level-detect brake function not affect channel output.
N * |        |          |01 = PWM even channel output tri-state when level-detect brake happened.
N * |        |          |10 = PWM even channel output low level when level-detect brake happened.
N * |        |          |11 = PWM even channel output high level when level-detect brake happened.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[19:18] |BRKAODD   |PWM Brake Action Select For Odd Channel (Write Protect)
N * |        |          |00 = PWM odd channel level-detect brake function not affect channel output.
N * |        |          |01 = PWM odd channel output tri-state when level-detect brake happened.
N * |        |          |10 = PWM odd channel output low level when level-detect brake happened.
N * |        |          |11 = PWM odd channel output high level when level-detect brake happened.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * @var PWM_T::BRKCTL4_5
N * Offset: 0xD0  PWM Brake Edge Detect Control Register 4
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CPO0EBEN  |Enable ACMP0_O Digital Output As Edge-Detect Brake Source (Write Protect)
N * |        |          |0 = ACMP0_O as edge-detect brake source Disabled.
N * |        |          |1 = ACMP0_O as edge-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[1]     |CPO1EBEN  |Enable ACMP1_O Digital Output As Edge-Detect Brake Source (Write Protect)
N * |        |          |0 = ACMP1_O as edge-detect brake source Disabled.
N * |        |          |1 = ACMP1_O as edge-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[4]     |BRKP0EEN  |Enable PWMx_BRAKE0 Pin As Edge-Detect Brake Source (Write Protect)
N * |        |          |0 = BKP0 pin as edge-detect brake source Disabled.
N * |        |          |1 = BKP0 pin as edge-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[5]     |BRKP1EEN  |Enable PWMx_BRAKE1 Pin As Edge-Detect Brake Source (Write Protect)
N * |        |          |0 = BKP1 pin as edge-detect brake source Disabled.
N * |        |          |1 = BKP1 pin as edge-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[7]     |SYSEBEN   |Enable System Fail As Edge-Detect Brake Source (Write Protect)
N * |        |          |0 = System Fail condition as edge-detect brake source Disabled.
N * |        |          |1 = System Fail condition as edge-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[8]     |CPO0LBEN  |Enable ACMP0_O Digital Output As Level-Detect Brake Source (Write Protect)
N * |        |          |0 = ACMP0_O as level-detect brake source Disabled.
N * |        |          |1 = ACMP0_O as level-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[9]     |CPO1LBEN  |Enable ACMP1_O Digital Output As Level-Detect Brake Source (Write Protect)
N * |        |          |0 = ACMP1_O as level-detect brake source Disabled.
N * |        |          |1 = ACMP1_O as level-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[12]    |BRKP0LEN  |Enable BKP0 Pin As Level-Detect Brake Source (Write Protect)
N * |        |          |0 = PWMx_BRAKE0 pin as level-detect brake source Disabled.
N * |        |          |1 = PWMx_BRAKE0 pin as level-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[13]    |BRKP1LEN  |Enable BKP1 Pin As Level-Detect Brake Source (Write Protect)
N * |        |          |0 = PWMx_BRAKE1 pin as level-detect brake source Disabled.
N * |        |          |1 = PWMx_BRAKE1 pin as level-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[15]    |SYSLBEN   |Enable System Fail As Level-Detect Brake Source (Write Protect)
N * |        |          |0 = System Fail condition as level-detect brake source Disabled.
N * |        |          |1 = System Fail condition as level-detect brake source Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[17:16] |BRKAEVEN  |PWM Brake Action Select For Even Channel (Write Protect)
N * |        |          |00 = PWM even channel level-detect brake function not affect channel output.
N * |        |          |01 = PWM even channel output tri-state when level-detect brake happened.
N * |        |          |10 = PWM even channel output low level when level-detect brake happened.
N * |        |          |11 = PWM even channel output high level when level-detect brake happened.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[19:18] |BRKAODD   |PWM Brake Action Select For Odd Channel (Write Protect)
N * |        |          |00 = PWM odd channel level-detect brake function not affect channel output.
N * |        |          |01 = PWM odd channel output tri-state when level-detect brake happened.
N * |        |          |10 = PWM odd channel output low level when level-detect brake happened.
N * |        |          |11 = PWM odd channel output high level when level-detect brake happened.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * @var PWM_T::POLCTL
N * Offset: 0xD4  PWM Pin Polar Inverse Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |PINVn     |PWM PIN Polar Inverse Control
N * |        |          |The register controls polarity state of PWM output.
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |0 = PWM output polar inverse Disabled.
N * |        |          |1 = PWM output polar inverse Enabled.
N * @var PWM_T::POEN
N * Offset: 0xD8  PWM Output Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |POENn     |PWM Pin Output Enable
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |0 = PWM pin at tri-state.
N * |        |          |1 = PWM pin in output mode.
N * @var PWM_T::SWBRK
N * Offset: 0xDC  PWM Software Brake Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2:0]   |BRKETRGn  |PWM Edge Brake Software Trigger (Write Only) (Write Protect) (M45xD/M45xC Only)
N * |        |          |Each bit n controls the corresponding PWM pair n.
N * |        |          |Write 1 to this bit will trigger edge brake, and set BRKEIFn to 1 in PWM_INTSTS1 register.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[10:8]  |BRKLTRGn  |PWM Level Brake Software Trigger (Write Only) (Write Protect)
N * |        |          |Each bit n controls the corresponding PWM pair n.
N * |        |          |Write 1 to this bit will trigger level brake, and set BRKLIFn to 1 in PWM_INTSTS1 register.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * @var PWM_T::INTEN0
N * Offset: 0xE0  PWM Interrupt Enable Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |ZIENn     |PWM Zero Point Interrupt Enable
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |0 = Zero point interrupt Disabled.
N * |        |          |1 = Zero point interrupt Enabled.
N * |        |          |Note: Odd channels will read always 0 at complementary mode.
N * |[7]     |IFAIEN0_1 |PWM_CH0/1 Interrupt Flag Accumulator Interrupt Enable
N * |        |          |0 = Interrupt Flag accumulator interrupt Disabled.
N * |        |          |1 = Interrupt Flag accumulator interrupt Enabled.
N * |[13:8]  |PIENn     |PWM Period Point Interrupt Enable
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |0 = Period point interrupt Disabled.
N * |        |          |1 = Period point interrupt Enabled.
N * |        |          |Note1: When up-down counter type period point means center point.
N * |        |          |Note2: Odd channels will read always 0 at complementary mode.
N * |[15]    |IFAIEN2_3 |PWM_CH2/3 Interrupt Flag Accumulator Interrupt Enable
N * |        |          |0 = Interrupt Flag accumulator interrupt Disabled.
N * |        |          |1 = Interrupt Flag accumulator interrupt Enabled.
N * |[21:16] |CMPUIENn  |PWM Compare Up Count Interrupt Enable
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |0 = Compare up count interrupt Disabled.
N * |        |          |1 = Compare up count interrupt Enabled.
N * |        |          |Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
N * |[23]    |IFAIEN4_5 |PWM_CH4/5 Interrupt Flag Accumulator Interrupt Enable
N * |        |          |0 = Interrupt Flag accumulator interrupt Disabled.
N * |        |          |1 = Interrupt Flag accumulator interrupt Enabled.
N * |[29:24] |CMPDIENn  |PWM Compare Down Count Interrupt Enable
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |0 = Compare down count interrupt Disabled.
N * |        |          |1 = Compare down count interrupt Enabled.
N * |        |          |Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
N * @var PWM_T::INTEN1
N * Offset: 0xE4  PWM Interrupt Enable Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |BRKEIEN0_1|PWM Edge-Detect Brake Interrupt Enable For Channel0/1 (Write Protect)
N * |        |          |0 = Edge-detect Brake interrupt for channel0/1 Disabled.
N * |        |          |1 = Edge-detect Brake interrupt for channel0/1 Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[1]     |BRKEIEN2_3|PWM Edge-Detect Brake Interrupt Enable For Channel2/3 (Write Protect)
N * |        |          |0 = Edge-detect Brake interrupt for channel2/3 Disabled.
N * |        |          |1 = Edge-detect Brake interrupt for channel2/3 Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[2]     |BRKEIEN4_5|PWM Edge-Detect Brake Interrupt Enable For Channel4/5 (Write Protect)
N * |        |          |0 = Edge-detect Brake interrupt for channel4/5 Disabled.
N * |        |          |1 = Edge-detect Brake interrupt for channel4/5 Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[8]     |BRKLIEN0_1|PWM Level-Detect Brake Interrupt Enable For Channel0/1 (Write Protect)
N * |        |          |0 = Level-detect Brake interrupt for channel0/1 Disabled.
N * |        |          |1 = Level-detect Brake interrupt for channel0/1 Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[9]     |BRKLIEN2_3|PWM Level-Detect Brake Interrupt Enable For Channel2/3 (Write Protect)
N * |        |          |0 = Level-detect Brake interrupt for channel2/3 Disabled.
N * |        |          |1 = Level-detect Brake interrupt for channel2/3 Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[10]    |BRKLIEN4_5|PWM Level-Detect Brake Interrupt Enable For Channel4/5 (Write Protect)
N * |        |          |0 = Level-detect Brake interrupt for channel4/5 Disabled.
N * |        |          |1 = Level-detect Brake interrupt for channel4/5 Enabled.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * @var PWM_T::INTSTS0
N * Offset: 0xE8  PWM Interrupt Flag Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |ZIFn      |PWM Zero Point Interrupt Flag
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |This bit is set by hardware when PWM counter reaches zero, software can write 1 to clear this bit to zero.
N * |[7]     |IFAIF0_1  |PWM_CH0/1 Interrupt Flag Accumulator Interrupt Flag
N * |        |          |Flag is set by hardware when condition match IFSEL0_1 in PWM_IFA register, software can clear this bit by writing 1 to it.
N * |[13:8]  |PIFn      |PWM Period Point Interrupt Flag
N * |        |          |This bit is set by hardware when PWM counter reaches PWM_PERIODn, software can write 1 to clear this bit to zero.
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |[15]    |IFAIF2_3  |PWM_CH2/3 Interrupt Flag Accumulator Interrupt Flag
N * |        |          |Flag is set by hardware when condition match IFSEL2_3 in PWM_IFA register, software can clear this bit by writing 1 to it.
N * |[21:16] |CMPUIFn   |PWM Compare Up Count Interrupt Flag
N * |        |          |Flag is set by hardware when PWM counter up count and reaches PWM_CMPDATn, software can clear this bit by writing 1 to it.
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
N * |        |          |Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
N * |[23]    |IFAIF4_5  |PWM_CH4/5 Interrupt Flag Accumulator Interrupt Flag
N * |        |          |Flag is set by hardware when condition match IFSEL4_5 in PWM_IFA register, software can clear this bit by writing 1 to it.
N * |[29:24] |CMPDIFn   |PWM Compare Down Count Interrupt Flag
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |Flag is set by hardware when PWM counter down count and reaches PWM_CMPDATn, software can clear this bit by writing 1 to it.
N * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in down counter type selection.
N * |        |          |Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
N * @var PWM_T::INTSTS1
N * Offset: 0xEC  PWM Interrupt Flag Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |BRKEIF0   |PWM Channel0 Edge-Detect Brake Interrupt Flag (Write Protect)
N * |        |          |0 = PWM channel0 edge-detect brake event do not happened.
N * |        |          |1 = When PWM channel0 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[1]     |BRKEIF1   |PWM Channel1 Edge-Detect Brake Interrupt Flag (Write Protect)
N * |        |          |0 = PWM channel1 edge-detect brake event do not happened.
N * |        |          |1 = When PWM channel1 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[2]     |BRKEIF2   |PWM Channel2 Edge-Detect Brake Interrupt Flag (Write Protect)
N * |        |          |0 = PWM channel2 edge-detect brake event do not happened.
N * |        |          |1 = When PWM channel2 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[3]     |BRKEIF3   |PWM Channel3 Edge-Detect Brake Interrupt Flag (Write Protect)
N * |        |          |0 = PWM channel3 edge-detect brake event do not happened.
N * |        |          |1 = When PWM channel3 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[4]     |BRKEIF4   |PWM Channel4 Edge-Detect Brake Interrupt Flag (Write Protect)
N * |        |          |0 = PWM channel4 edge-detect brake event do not happened.
N * |        |          |1 = When PWM channel4 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[5]     |BRKEIF5   |PWM Channel5 Edge-Detect Brake Interrupt Flag (Write Protect)
N * |        |          |0 = PWM channel5 edge-detect brake event do not happened.
N * |        |          |1 = When PWM channel5 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[8]     |BRKLIF0   |PWM Channel0 Level-Detect Brake Interrupt Flag (Write Protect)
N * |        |          |0 = PWM channel0 level-detect brake event do not happened.
N * |        |          |1 = When PWM channel0 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[9]     |BRKLIF1   |PWM Channel1 Level-Detect Brake Interrupt Flag (Write Protect)
N * |        |          |0 = PWM channel1 level-detect brake event do not happened.
N * |        |          |1 = When PWM channel1 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[10]    |BRKLIF2   |PWM Channel2 Level-Detect Brake Interrupt Flag (Write Protect)
N * |        |          |0 = PWM channel2 level-detect brake event do not happened.
N * |        |          |1 = When PWM channel2 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[11]    |BRKLIF3   |PWM Channel3 Level-Detect Brake Interrupt Flag (Write Protect)
N * |        |          |0 = PWM channel3 level-detect brake event do not happened.
N * |        |          |1 = When PWM channel3 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[12]    |BRKLIF4   |PWM Channel4 Level-Detect Brake Interrupt Flag (Write Protect)
N * |        |          |0 = PWM channel4 level-detect brake event do not happened.
N * |        |          |1 = When PWM channel4 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[13]    |BRKLIF5   |PWM Channel5 Level-Detect Brake Interrupt Flag (Write Protect)
N * |        |          |0 = PWM channel5 level-detect brake event do not happened.
N * |        |          |1 = When PWM channel5 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
N * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
N * |[16]    |BRKESTS0  |PWM Channel0 Edge-Detect Brake Status
N * |        |          |0 = PWM channel0 edge-detect brake state is released.
N * |        |          |1 = When PWM channel0 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel0 at brake state, writing 1 to clear.
N * |[17]    |BRKESTS1  |PWM Channel1 Edge-Detect Brake Status
N * |        |          |0 = PWM channel1 edge-detect brake state is released.
N * |        |          |1 = When PWM channel1 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel1 at brake state, writing 1 to clear.
N * |[18]    |BRKESTS2  |PWM Channel2 Edge-Detect Brake Status
N * |        |          |0 = PWM channel2 edge-detect brake state is released.
N * |        |          |1 = When PWM channel2 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel2 at brake state, writing 1 to clear.
N * |[19]    |BRKESTS3  |PWM Channel3 Edge-Detect Brake Status
N * |        |          |0 = PWM channel3 edge-detect brake state is released.
N * |        |          |1 = When PWM channel3 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel3 at brake state, writing 1 to clear.
N * |[20]    |BRKESTS4  |PWM Channel4 Edge-Detect Brake Status
N * |        |          |0 = PWM channel4 edge-detect brake state is released.
N * |        |          |1 = When PWM channel4 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel4 at brake state, writing 1 to clear.
N * |[21]    |BRKESTS5  |PWM Channel5 Edge-Detect Brake Status
N * |        |          |0 = PWM channel5 edge-detect brake state is released.
N * |        |          |1 = When PWM channel5 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel5 at brake state, writing 1 to clear.
N * |[24]    |BRKLSTS0  |PWM Channel0 Level-Detect Brake Status (Read Only)
N * |        |          |0 = PWM channel0 level-detect brake state is released.
N * |        |          |1 = When PWM channel0 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel0 at brake state.
N * |        |          |Note: This bit is read only and auto cleared by hardware.
N * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished.
N * |        |          |The PWM waveform will start output from next full PWM period.
N * |[25]    |BRKLSTS1  |PWM Channel1 Level-Detect Brake Status (Read Only)
N * |        |          |0 = PWM channel1 level-detect brake state is released.
N * |        |          |1 = When PWM channel1 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel1 at brake state.
N * |        |          |Note: This bit is read only and auto cleared by hardware.
N * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished.
N * |        |          |The PWM waveform will start output from next full PWM period.
N * |[26]    |BRKLSTS2  |PWM Channel2 Level-Detect Brake Status (Read Only)
N * |        |          |0 = PWM channel2 level-detect brake state is released.
N * |        |          |1 = When PWM channel2 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel2 at brake state.
N * |        |          |Note: This bit is read only and auto cleared by hardware.
N * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished.
N * |        |          |The PWM waveform will start output from next full PWM period.
N * |[27]    |BRKLSTS3  |PWM Channel3 Level-Detect Brake Status (Read Only)
N * |        |          |0 = PWM channel3 level-detect brake state is released.
N * |        |          |1 = When PWM channel3 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel3 at brake state.
N * |        |          |Note: This bit is read only and auto cleared by hardware.
N * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished.
N * |        |          |The PWM waveform will start output from next full PWM period.
N * |[28]    |BRKLSTS4  |PWM Channel4 Level-Detect Brake Status (Read Only)
N * |        |          |0 = PWM channel4 level-detect brake state is released.
N * |        |          |1 = When PWM channel4 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel4 at brake state.
N * |        |          |Note: This bit is read only and auto cleared by hardware.
N * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished.
N * |        |          |The PWM waveform will start output from next full PWM period.
N * |[29]    |BRKLSTS5  |PWM Channel5 Level-Detect Brake Status (Read Only)
N * |        |          |0 = PWM channel5 level-detect brake state is released.
N * |        |          |1 = When PWM channel5 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel5 at brake state.
N * |        |          |Note: This bit is read only and auto cleared by hardware.
N * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished.
N * |        |          |The PWM waveform will start output from next full PWM period.
N * @var PWM_T::IFA
N * Offset: 0xF0  PWM Interrupt Flag Accumulator Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |IFCNT0_1  |PWM_CH0 And PWM_CH1 Interrupt Flag Counter
N * |        |          |The register sets the count number which defines how many times of PWM_CH0 and PWM_CH1 period occurs to set bit IFAIF0_1 to request the PWM period interrupt.
N * |        |          |PWM flag will be set in every IFCNT0_1 [3:0] times of PWM period.
N * |[6:4]   |IFSEL0_1  |PWM_CH0 And PWM_CH1 Interrupt Flag Accumulator Source Select
N * |        |          |000 = CNT equal to Zero in channel 0.
N * |        |          |001 = CNT equal to PERIOD in channel 0.
N * |        |          |010 = CNT equal to CMPU in channel 0.
N * |        |          |011 = CNT equal to CMPD in channel 0.
N * |        |          |100 = CNT equal to Zero in channel 1.
N * |        |          |101 = CNT equal to PERIOD in channel 1.
N * |        |          |110 = CNT equal to CMPU in channel 1.
N * |        |          |111 = CNT equal to CMPD in channel 1.
N * |[7]     |IFAEN0_1  |PWM_CH0 And PWM_CH1 Interrupt Flag Accumulator Enable
N * |        |          |0 = PWM_CH0 and PWM_CH1 interrupt flag accumulator disable.
N * |        |          |1 = PWM_CH0 and PWM_CH1 interrupt flag accumulator enable.
N * |[11:8]  |IFCNT2_3  |PWM_CH2 And PWM_CH3 Interrupt Flag Counter
N * |        |          |The register sets the count number which defines how many times of PWM_CH2 and PWM_CH3 period occurs to set bit IFAIF2_3 to request the PWM period interrupt.
N * |        |          |PWM flag will be set in every IFCNT2_3[3:0] times of PWM period.
N * |[14:12] |IFSEL2_3  |PWM_CH2 And PWM_CH3 Interrupt Flag Accumulator Source Select
N * |        |          |000 = CNT equal to Zero in channel 2.
N * |        |          |001 = CNT equal to PERIOD in channel 2.
N * |        |          |010 = CNT equal to CMPU in channel 2.
N * |        |          |011 = CNT equal to CMPD in channel 2.
N * |        |          |100 = CNT equal to Zero in channel 3.
N * |        |          |101 = CNT equal to PERIOD in channel 3.
N * |        |          |110 = CNT equal to CMPU in channel 3.
N * |        |          |111 = CNT equal to CMPD in channel 3.
N * |[15]    |IFAEN2_3  |PWM_CH2 And PWM_CH3 Interrupt Flag Accumulator Enable
N * |        |          |0 = PWM_CH2 and PWM_CH3 interrupt flag accumulator disable.
N * |        |          |1 = PWM_CH2 and PWM_CH3 interrupt flag accumulator enable.
N * |[19:16] |IFCNT4_5  |PWM_CH4 And PWM_CH5 Interrupt Flag Counter
N * |        |          |The register sets the count number which defines how many times of PWM_CH4 and PWM_CH5 period occurs to set bit IFAIF4_5 to request the PWM period interrupt.
N * |        |          |PWM flag will be set in every IFCNT4_5[3:0] times of PWM period.
N * |[22:20] |IFSEL4_5  |PWM_CH4 And PWM_CH5 Interrupt Flag Accumulator Source Select
N * |        |          |000 = CNT equal to Zero in channel 4.
N * |        |          |001 = CNT equal to PERIOD in channel 4.
N * |        |          |010 = CNT equal to CMPU in channel 4.
N * |        |          |011 = CNT equal to CMPD in channel 4.
N * |        |          |100 = CNT equal to Zero in channel 5.
N * |        |          |101 = CNT equal to PERIOD in channel 5.
N * |        |          |110 = CNT equal to CMPU in channel 5.
N * |        |          |111 = CNT equal to CMPD in channel 5.
N * |[23]    |IFAEN4_5  |PWM_CH4 And PWM_CH5 Interrupt Flag Accumulator Enable
N * |        |          |0 = PWM_CH4 and PWM_CH5 interrupt flag accumulator disable.
N * |        |          |1 = PWM_CH4 and PWM_CH5 interrupt flag accumulator enable.
N * @var PWM_T::DACTRGEN
N * Offset: 0xF4  PWM Trigger DAC Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |ZTEn      |PWM Zero Point Trigger DAC Enable
N * |        |          |0 = PWM period point trigger DAC function Disabled.
N * |        |          |1 = PWM period point trigger DAC function Enabled.
N * |        |          |PWM can trigger EADC/DAC/DMA to start action when PWM counter down count to zero if this bit is set to 1.
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |[13:8]  |PTEn      |PWM Period Point Trigger DAC Enable
N * |        |          |0 = PWM period point trigger DAC function Disabled.
N * |        |          |1 = PWM period point trigger DAC function Enabled.
N * |        |          |PWM can trigger DAC to start action when PWM counter up count to (PERIODn+1) if this bit is set to 1.
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |[21:16] |CUTRGEn   |PWM Compare Up Count Point Trigger DAC Enable
N * |        |          |0 = PWM Compare Up point trigger DAC function Disabled.
N * |        |          |1 = PWM Compare Up point trigger DAC function Enabled.
N * |        |          |PWM can trigger DAC to start action when PWM counter up count to CMPDAT if this bit is set to 1.
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |Note1: This bit should keep at 0 when PWM counter operating in down counter type.
N * |        |          |Note2: In complementary mode, CUTRGE1, 3, 5 use as another CUTRGE for channel 0, 2, 4.
N * |[29:24] |CDTRGEn   |PWM Compare Down Count Point Trigger DAC Enable
N * |        |          |0 = PWM Compare Down count point trigger DAC function Disabled.
N * |        |          |1 = PWM Compare Down count point trigger DAC function Enabled.
N * |        |          |PWM can trigger DAC to start action when PWM counter down count to CMPDAT if this bit is set to 1.
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |Note1: This bit should keep at 0 when PWM counter operating in up counter type.
N * |        |          |Note2: In complementary mode, CDTRGE1, 3, 5 use as another CDTRGE for channel 0, 2, 4.
N * @var PWM_T::EADCTS0
N * Offset: 0xF8  PWM Trigger EADC Source Select Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |TRGSEL0   |PWM_CH0 Trigger EADC Source Select
N * |        |          |0000 = PWM_CH0 zero point.
N * |        |          |0001 = PWM_CH0 period point.
N * |        |          |0010 = PWM_CH0 zero or period point.
N * |        |          |0011 = PWM_CH0 up-count CMPDAT point.
N * |        |          |0100 = PWM_CH0 down-count CMPDAT point.
N * |        |          |0101 = PWM_CH1 zero point.
N * |        |          |0110 = PWM_CH1 period point.
N * |        |          |0111 = PWM_CH1 zero or period point.
N * |        |          |1000 = PWM_CH1 up-count CMPDAT point.
N * |        |          |1001 = PWM_CH1 down-count CMPDAT point.
N * |        |          |1010 = PWM_CH0 up-count free CMPDAT point.
N * |        |          |1011 = PWM_CH0 down-count free CMPDAT point.
N * |        |          |1100 = PWM_CH2 up-count free CMPDAT point.
N * |        |          |1101 = PWM_CH2 down-count free CMPDAT point.
N * |        |          |1110 = PWM_CH4 up-count free CMPDAT point.
N * |        |          |1111 = PWM_CH4 down-count free CMPDAT point.
N * |[7]     |TRGEN0    |PWM_CH0 Trigger EADC enable bit
N * |[11:8]  |TRGSEL1   |PWM_CH1 Trigger EADC Source Select
N * |        |          |0000 = PWM_CH0 zero point.
N * |        |          |0001 = PWM_CH0 period point.
N * |        |          |0010 = PWM_CH0 zero or period point.
N * |        |          |0011 = PWM_CH0 up-count CMPDAT point.
N * |        |          |0100 = PWM_CH0 down-count CMPDAT point.
N * |        |          |0101 = PWM_CH1 zero point.
N * |        |          |0110 = PWM_CH1 period point.
N * |        |          |0111 = PWM_CH1 zero or period point.
N * |        |          |1000 = PWM_CH1 up-count CMPDAT point.
N * |        |          |1001 = PWM_CH1 down-count CMPDAT point.
N * |        |          |1010 = PWM_CH0 up-count free CMPDAT point.
N * |        |          |1011 = PWM_CH0 down-count free CMPDAT point.
N * |        |          |1100 = PWM_CH2 up-count free CMPDAT point.
N * |        |          |1101 = PWM_CH2 down-count free CMPDAT point.
N * |        |          |1110 = PWM_CH4 up-count free CMPDAT point.
N * |        |          |1111 = PWM_CH4 down-count free CMPDAT point.
N * |[15]    |TRGEN1    |PWM_CH1 Trigger EADC enable bit
N * |[19:16] |TRGSEL2   |PWM_CH2 Trigger EADC Source Select
N * |        |          |0000 = PWM_CH2 zero point.
N * |        |          |0001 = PWM_CH2 period point.
N * |        |          |0010 = PWM_CH2 zero or period point.
N * |        |          |0011 = PWM_CH2 up-count CMPDAT point.
N * |        |          |0100 = PWM_CH2 down-count CMPDAT point.
N * |        |          |0101 = PWM_CH3 zero point.
N * |        |          |0110 = PWM_CH3 period point.
N * |        |          |0111 = PWM_CH3 zero or period point.
N * |        |          |1000 = PWM_CH3 up-count CMPDAT point.
N * |        |          |1001 = PWM_CH3 down-count CMPDAT point.
N * |        |          |1010 = PWM_CH0 up-count free CMPDAT point.
N * |        |          |1011 = PWM_CH0 down-count free CMPDAT point.
N * |        |          |1100 = PWM_CH2 up-count free CMPDAT point.
N * |        |          |1101 = PWM_CH2 down-count free CMPDAT point.
N * |        |          |1110 = PWM_CH4 up-count free CMPDAT point.
N * |        |          |1111 = PWM_CH4 down-count free CMPDAT point.
N * |[23]    |TRGEN2    |PWM_CH2 Trigger EADC enable bit
N * |[27:24] |TRGSEL3   |PWM_CH3 Trigger EADC Source Select
N * |        |          |0000 = PWM_CH2 zero point.
N * |        |          |0001 = PWM_CH2 period point.
N * |        |          |0010 = PWM_CH2 zero or period point.
N * |        |          |0011 = PWM_CH2 up-count CMPDAT point.
N * |        |          |0100 = PWM_CH2 down-count CMPDAT point.
N * |        |          |0101 = PWM_CH3 zero point.
N * |        |          |0110 = PWM_CH3 period point.
N * |        |          |0111 = PWM_CH3 zero or period point.
N * |        |          |1000 = PWM_CH3 up-count CMPDAT point.
N * |        |          |1001 = PWM_CH3 down-count CMPDAT point.
N * |        |          |1010 = PWM_CH0 up-count free CMPDAT point.
N * |        |          |1011 = PWM_CH0 down-count free CMPDAT point.
N * |        |          |1100 = PWM_CH2 up-count free CMPDAT point.
N * |        |          |1101 = PWM_CH2 down-count free CMPDAT point.
N * |        |          |1110 = PWM_CH4 up-count free CMPDAT point.
N * |        |          |1111 = PWM_CH4 down-count free CMPDAT point.
N * |[31]    |TRGEN3    |PWM_CH3 Trigger EADC enable bit
N * @var PWM_T::EADCTS1
N * Offset: 0xFC  PWM Trigger EADC Source Select Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |TRGSEL4   |PWM_CH4 Trigger EADC Source Select
N * |        |          |0000 = PWM_CH4 zero point.
N * |        |          |0001 = PWM_CH4 period point.
N * |        |          |0010 = PWM_CH4 zero or period point.
N * |        |          |0011 = PWM_CH4 up-count CMPDAT point.
N * |        |          |0100 = PWM_CH4 down-count CMPDAT point.
N * |        |          |0101 = PWM_CH5 zero point.
N * |        |          |0110 = PWM_CH5 period point.
N * |        |          |0111 = PWM_CH5 zero or period point.
N * |        |          |1000 = PWM_CH5 up-count CMPDAT point.
N * |        |          |1001 = PWM_CH5 down-count CMPDAT point.
N * |        |          |1010 = PWM_CH0 up-count free CMPDAT point.
N * |        |          |1011 = PWM_CH0 down-count free CMPDAT point.
N * |        |          |1100 = PWM_CH2 up-count free CMPDAT point.
N * |        |          |1101 = PWM_CH2 down-count free CMPDAT point.
N * |        |          |1110 = PWM_CH4 up-count free CMPDAT point.
N * |        |          |1111 = PWM_CH4 down-count free CMPDAT point.
N * |[7]     |TRGEN4    |PWM_CH4 Trigger EADC enable bit
N * |[11:8]  |TRGSEL5   |PWM_CH5 Trigger EADC Source Select
N * |        |          |0000 = PWM_CH4 zero point.
N * |        |          |0001 = PWM_CH4 period point.
N * |        |          |0010 = PWM_CH4 zero or period point.
N * |        |          |0011 = PWM_CH4 up-count CMPDAT point.
N * |        |          |0100 = PWM_CH4 down-count CMPDAT point.
N * |        |          |0101 = PWM_CH5 zero point.
N * |        |          |0110 = PWM_CH5 period point.
N * |        |          |0111 = PWM_CH5 zero or period point.
N * |        |          |1000 = PWM_CH5 up-count CMPDAT point.
N * |        |          |1001 = PWM_CH5 down-count CMPDAT point.
N * |        |          |1010 = PWM_CH0 up-count free CMPDAT point.
N * |        |          |1011 = PWM_CH0 down-count free CMPDAT point.
N * |        |          |1100 = PWM_CH2 up-count free CMPDAT point.
N * |        |          |1101 = PWM_CH2 down-count free CMPDAT point.
N * |        |          |1110 = PWM_CH4 up-count free CMPDAT point.
N * |        |          |1111 = PWM_CH4 down-count free CMPDAT point.
N * |[15]    |TRGEN5    |PWM_CH5 Trigger EADC enable bit
N * @var PWM_T::FTCMPDAT0_1
N * Offset: 0x100  PWM Free Trigger Compare Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |FTCMP     |PWM Free Trigger Compare Register
N * |        |          |FTCMP use to compare with even CNTR to trigger EADC.
N * |        |          |FTCMPDAT0, 2, 4 corresponding complementary pairs PWM_CH0and PWM_CH1, PWM_CH2 and PWM_CH3, PWM_CH4 and PWM_CH5.
N * @var PWM_T::FTCMPDAT2_3
N * Offset: 0x104  PWM Free Trigger Compare Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |FTCMP     |PWM Free Trigger Compare Register
N * |        |          |FTCMP use to compare with even CNTR to trigger EADC.
N * |        |          |FTCMPDAT0, 2, 4 corresponding complementary pairs PWM_CH0and PWM_CH1, PWM_CH2 and PWM_CH3, PWM_CH4 and PWM_CH5.
N * @var PWM_T::FTCMPDAT4_5
N * Offset: 0x108  PWM Free Trigger Compare Register 4
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |FTCMP     |PWM Free Trigger Compare Register
N * |        |          |FTCMP use to compare with even CNTR to trigger EADC.
N * |        |          |FTCMPDAT0, 2, 4 corresponding complementary pairs PWM_CH0and PWM_CH1, PWM_CH2 and PWM_CH3, PWM_CH4 and PWM_CH5.
N * @var PWM_T::SSCTL
N * Offset: 0x110  PWM Synchronous Start Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |SSENn     |PWM Synchronous Start Function Enable
N * |        |          |When synchronous start function is enabled, the PWM counter enable register (PWM_CNTEN) can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |0 = PWM synchronous start function Disabled.
N * |        |          |1 = PWM synchronous start function Enabled.
N * @var PWM_T::SSTRG
N * Offset: 0x114  PWM Synchronous Start Trigger Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CNTSEN    |PWM Counter Synchronous Start Enable (Write Only)
N * |        |          |PMW counter synchronous enable function is used to make selected PWM channels (include PWM0_CHx and PWM1_CHx) start counting at the same time.
N * |        |          |Writing this bit to 1 will also set the counter enable bit (CNTENn, n denotes channel 0 to 5) if correlated PWM channel counter synchronous start function is enabled.
N * |        |          |Note: This bit only present in PWM0_BA.
N * @var PWM_T::STATUS
N * Offset: 0x120  PWM Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |CNTMAXFn  |Time-Base Counter Equal To 0xFFFF Latched Flag
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |0 = indicates the time-base counter never reached its maximum value 0xFFFF.
N * |        |          |1 = indicates the time-base counter reached its maximum value, software can write 1 to clear this bit.
N * |[10:8]  |SYNCINFn  |Input Synchronization Latched Flag
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |0 = Indicates no SYNC_IN event has occurred.
N * |        |          |1 = Indicates an SYNC_IN event has occurred, software can write 1 to clear this bit.
N * |[21:16] |ADCTRGFn  |EADC Start Of Conversion Flag
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |0 = Indicates no EADC start of conversion trigger event has occurred.
N * |        |          |1 = Indicates an EADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
N * |[24]    |DACTRGF   |DAC Start Of Conversion Flag
N * |        |          |0 = Indicates no DAC start of conversion trigger event has occurred.
N * |        |          |1 = Indicates an DAC start of conversion trigger event has occurred, software can write 1 to clear this bit
N * @var PWM_T::CAPINEN
N * Offset: 0x200  PWM Capture Input Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |CAPINENn  |Capture Input Enable
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |0 = PWM Channel capture input path Disabled.
N * |        |          |The input of PWM channel capture function is always regarded as 0.
N * |        |          |1 = PWM Channel capture input path Enabled.
N * |        |          |The input of PWM channel capture function comes from correlative multifunction pin.
N * @var PWM_T::CAPCTL
N * Offset: 0x204  PWM Capture Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |CAPENn    |Capture Function Enable
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |0 = Capture function Disabled. RCAPDAT/FCAPDAT register will not be updated.
N * |        |          |1 = Capture function Enabled.
N * |        |          |Capture latched the PWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch).
N * |[13:8]  |CAPINVn   |Capture Inverter Enable
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |0 = Capture source inverter Disabled.
N * |        |          |1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
N * |[21:16] |RCRLDENn  |Rising Capture Reload Enable
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |0 = Rising capture reload counter Disabled.
N * |        |          |1 = Rising capture reload counter Enabled.
N * |[29:24] |FCRLDENn  |Falling Capture Reload Enable
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |0 = Falling capture reload counter Disabled.
N * |        |          |1 = Falling capture reload counter Enabled.
N * @var PWM_T::CAPSTS
N * Offset: 0x208  PWM Capture Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |CRLIFOVn  |Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
N * |        |          |This flag indicates if rising latch happened when the corresponding CRLIF is 1.
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |Note: This bit will be cleared automatically when user clear corresponding CRLIF.
N * |[13:8]  |CFLIFOVn  |Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
N * |        |          |This flag indicates if falling latch happened when the corresponding CFLIF is 1.
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |Note: This bit will be cleared automatically when user clear corresponding CFLIF.
N * @var PWM_T::RCAPDAT0
N * Offset: 0x20C  PWM Rising Capture Data Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
N * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
N * @var PWM_T::FCAPDAT0
N * Offset: 0x210  PWM Falling Capture Data Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
N * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
N * @var PWM_T::RCAPDAT1
N * Offset: 0x214  PWM Rising Capture Data Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
N * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
N * @var PWM_T::FCAPDAT1
N * Offset: 0x218  PWM Falling Capture Data Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
N * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
N * @var PWM_T::RCAPDAT2
N * Offset: 0x21C  PWM Rising Capture Data Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
N * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
N * @var PWM_T::FCAPDAT2
N * Offset: 0x220  PWM Falling Capture Data Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
N * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
N * @var PWM_T::RCAPDAT3
N * Offset: 0x224  PWM Rising Capture Data Register 3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
N * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
N * @var PWM_T::FCAPDAT3
N * Offset: 0x228  PWM Falling Capture Data Register 3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
N * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
N * @var PWM_T::RCAPDAT4
N * Offset: 0x22C  PWM Rising Capture Data Register 4
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
N * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
N * @var PWM_T::FCAPDAT4
N * Offset: 0x230  PWM Falling Capture Data Register 4
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
N * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
N * @var PWM_T::RCAPDAT5
N * Offset: 0x234  PWM Rising Capture Data Register 5
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
N * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
N * @var PWM_T::FCAPDAT5
N * Offset: 0x238  PWM Falling Capture Data Register 5
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
N * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
N * @var PWM_T::PDMACTL
N * Offset: 0x23C  PWM PDMA Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CHEN0_1   |Channel 0/1 PDMA Enable
N * |        |          |0 = Channel 0/1 PDMA function Disabled.
N * |        |          |1 = Channel 0/1 PDMA function Enabled for the channel 0/1 captured data and transfer to memory.
N * |[2:1]   |CAPMOD0_1 |Select PWM_RCAPDAT0/1 Or PWM_FCAPDAT0/1 To Do PDMA Transfer
N * |        |          |00 = Reserved.
N * |        |          |01 = PWM_RCAPDAT0/1.
N * |        |          |10 = PWM_FCAPDAT0/1.
N * |        |          |11 = Both PWM_RCAPDAT0/1 and PWM_FCAPDAT0/1.
N * |[3]     |CAPORD0_1 |Capture Channel 0/1 Rising/Falling Order
N * |        |          |Set this bit to determine whether the PWM_RCAPDAT0/1 or PWM_FCAPDAT0/1 is the first captured data transferred to memory through PDMA when CAPMOD0_1 = 11.
N * |        |          |0 = PWM_FCAPDAT0/1 is the first captured data to memory.
N * |        |          |1 = PWM_RCAPDAT0/1 is the first captured data to memory.
N * |[4]     |CHSEL0_1  |Select Channel 0/1 To Do PDMA Transfer
N * |        |          |0 = Channel0.
N * |        |          |1 = Channel1.
N * |[8]     |CHEN2_3   |Channel 2/3 PDMA Enable
N * |        |          |0 = Channel 2/3 PDMA function Disabled.
N * |        |          |1 = Channel 2/3 PDMA function Enabled for the channel 2/3 captured data and transfer to memory.
N * |[10:9]  |CAPMOD2_3 |Select PWM_RCAPDAT2/3 Or PWM_FCAODAT2/3 To Do PDMA Transfer
N * |        |          |00 = Reserved.
N * |        |          |01 = PWM_RCAPDAT2/3.
N * |        |          |10 = PWM_FCAPDAT2/3.
N * |        |          |11 = Both PWM_RCAPDAT2/3 and PWM_FCAPDAT2/3.
N * |[11]    |CAPORD2_3 |Capture Channel 2/3 Rising/Falling Order
N * |        |          |Set this bit to determine whether the PWM_RCAPDAT2/3 or PWM_FCAPDAT2/3 is the first captured data transferred to memory through PDMA when CAPMOD2_3 = 11.
N * |        |          |0 = PWM_FCAPDAT2/3 is the first captured data to memory.
N * |        |          |1 = PWM_RCAPDAT2/3 is the first captured data to memory.
N * |[12]    |CHSEL2_3  |Select Channel 2/3 To Do PDMA Transfer
N * |        |          |0 = Channel2.
N * |        |          |1 = Channel3.
N * |[16]    |CHEN4_5   |Channel 4/5 PDMA Enable
N * |        |          |0 = Channel 4/5 PDMA function Disabled.
N * |        |          |1 = Channel 4/5 PDMA function Enabled for the channel 4/5 captured data and transfer to memory.
N * |[18:17] |CAPMOD4_5 |Select PWM_RCAPDAT4/5 Or PWM_FCAPDAT4/5 To Do PDMA Transfer
N * |        |          |00 = Reserved.
N * |        |          |01 = PWM_RCAPDAT4/5.
N * |        |          |10 = PWM_FCAPDAT4/5.
N * |        |          |11 = Both PWM_RCAPDAT4/5 and PWM_FCAPDAT4/5.
N * |[19]    |CAPORD4_5 |Capture Channel 4/5 Rising/Falling Order
N * |        |          |Set this bit to determine whether the PWM_RCAPDAT4/5 or PWM_FCAPDAT4/5 is the first captured data transferred to memory through PDMA when CAPMOD4_5 = 11.
N * |        |          |0 = PWM_FCAPDAT4/5 is the first captured data to memory.
N * |        |          |1 = PWM_RCAPDAT4/5 is the first captured data to memory.
N * |[20]    |CHSEL4_5  |Select Channel 4/5 To Do PDMA Transfer
N * |        |          |0 = Channel4.
N * |        |          |1 = Channel5.
N * @var PWM_T::PDMACAP0_1
N * Offset: 0x240  PWM Capture Channel 01 PDMA Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CAPBUF    |PWM Capture PDMA Register
N * |        |          |(Read Only)
N * |        |          |This register is use as a buffer to transfer PWM capture rising or falling data to memory by PDMA.
N * @var PWM_T::PDMACAP2_3
N * Offset: 0x244  PWM Capture Channel 23 PDMA Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CAPBUF    |PWM Capture PDMA Register
N * |        |          |(Read Only)
N * |        |          |This register is use as a buffer to transfer PWM capture rising or falling data to memory by PDMA.
N * @var PWM_T::PDMACAP4_5
N * Offset: 0x248  PWM Capture Channel 45 PDMA Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CAPBUF    |PWM Capture PDMA Register
N * |        |          |(Read Only)
N * |        |          |This register is use as a buffer to transfer PWM capture rising or falling data to memory by PDMA.
N * @var PWM_T::CAPIEN
N * Offset: 0x250  PWM Capture Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |CAPRIENn  |PWM Capture Rising Latch Interrupt Enable
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |0 = Capture rising edge latch interrupt Disabled.
N * |        |          |1 = Capture rising edge latch interrupt Enabled.
N * |        |          |Note: When Capture with PDMA operating, CINTENR corresponding channel CAPRIEN must be disabled.
N * |[13:8]  |CAPFIENn  |PWM Capture Falling Latch Interrupt Enable
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |        |          |0 = Capture falling edge latch interrupt Disabled.
N * |        |          |1 = Capture falling edge latch interrupt Enabled.
N * |        |          |Note: When Capture with PDMA operating, CINTENR corresponding channel CAPFIEN must be disabled.
N * @var PWM_T::CAPIF
N * Offset: 0x254  PWM Capture Interrupt Flag Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |CRLIFn    |PWM Capture Rising Latch Interrupt Flag
N * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
N * |        |          |0 = No capture rising latch condition happened.
N * |        |          |1 = Capture rising latch condition happened, this flag will be set to high.
N * |        |          |Note: When Capture with PDMA operating, CIFR corresponding channel CRLIF will cleared by hardware after PDMA transfer data.
N * |[13:8]  |CFLIFn    |PWM Capture Falling Latch Interrupt Flag
N * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
N * |        |          |0 = No capture falling latch condition happened.
N * |        |          |1 = Capture falling latch condition happened, this flag will be set to high.
N * |        |          |Note: When Capture with PDMA operating, CIFR corresponding channel CFLIF will cleared by hardware after PDMA transfer data.
N * @var PWM_T::PBUF
N * Offset: 0x304~0x318  PWM PERIOD0~5 Buffer
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |PBUF      |PWM Period Register Buffer
N * |        |          |(Read Only)
N * |        |          |Used as PERIOD active register.
N * @var PWM_T::CMPBUF
N * Offset: 0x31C~0x330  PWM CMPDAT0~5 Buffer
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CMPBUF    |PWM Comparator Register Buffer
N * |        |          |(Read Only)
N * |        |          |Used as CMP active register.
N * @var PWM_T::FTCBUF0_1
N * Offset: 0x340  PWM FTCMPDAT0_1 Buffer
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |FTCMPBUF  |PWM FTCMPDAT Buffer (Read Only)
N * |        |          |Used as FTCMPDAT active register.
N * @var PWM_T::FTCBUF2_3
N * Offset: 0x344  PWM FTCMPDAT2_3 Buffer
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |FTCMPBUF  |PWM FTCMPDAT Buffer (Read Only)
N * |        |          |Used as FTCMPDAT active register.
N * @var PWM_T::FTCBUF4_5
N * Offset: 0x348  PWM FTCMPDAT4_5 Buffer
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |FTCMPBUF  |PWM FTCMPDAT Buffer (Read Only)
N * |        |          |Used as FTCMPDAT active register.
N * @var PWM_T::FTCI
N * Offset: 0x34C  PWM FTCMPDAT Indicator Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2:0]   |FTCMUn    |PWM FTCMPDAT Up Indicator
N * |        |          |Indicator will be set to high when FTCMPDATn equal to PERIODn and DIRF=1, software can write 1 to clear this bit.
N * |        |          |Each bit n controls the corresponding PWM channel n.
N * |[10:8]  |FTCMDn    |PWM FTCMPDAT Down Indicator
N * |        |          |Indicator will be set to high when FTCMPDATn equal to PERIODn and DIRF=0, software can write 1 to clear this bit.
N * |        |          |Each bit n controls the corresponding PWM channel n.
N */
N
N    __IO uint32_t CTL0;          /* Offset: 0x00  PWM Control Register 0                                             */
X    volatile uint32_t CTL0;           
N    __IO uint32_t CTL1;          /* Offset: 0x04  PWM Control Register 1                                             */
X    volatile uint32_t CTL1;           
N    __IO uint32_t SYNC;          /* Offset: 0x08  PWM Synchronization Register                                       */
X    volatile uint32_t SYNC;           
N    __IO uint32_t SWSYNC;        /* Offset: 0x0C  PWM Software Control Synchronization Register                      */
X    volatile uint32_t SWSYNC;         
N    __IO uint32_t CLKSRC;        /* Offset: 0x10  PWM Clock Source Register                                          */
X    volatile uint32_t CLKSRC;         
N    __IO uint32_t CLKPSC0_1;     /* Offset: 0x14  PWM Clock Pre-scale Register 0                                     */
X    volatile uint32_t CLKPSC0_1;      
N    __IO uint32_t CLKPSC2_3;     /* Offset: 0x18  PWM Clock Pre-scale Register 2                                     */
X    volatile uint32_t CLKPSC2_3;      
N    __IO uint32_t CLKPSC4_5;     /* Offset: 0x1C  PWM Clock Pre-scale Register 4                                     */
X    volatile uint32_t CLKPSC4_5;      
N    __IO uint32_t CNTEN;         /* Offset: 0x20  PWM Counter Enable Register                                        */
X    volatile uint32_t CNTEN;          
N    __IO uint32_t CNTCLR;        /* Offset: 0x24  PWM Clear Counter Register                                         */
X    volatile uint32_t CNTCLR;         
N    __IO uint32_t LOAD;          /* Offset: 0x28  PWM Load Register                                                  */
X    volatile uint32_t LOAD;           
N    __I  uint32_t RESERVE0[1];  
X    volatile const  uint32_t RESERVE0[1];  
N    __IO uint32_t PERIOD[6];     /* Offset: 0x30~0x44  PWM Period Register 0~5                                       */
X    volatile uint32_t PERIOD[6];      
N    __I  uint32_t RESERVE1[2];  
X    volatile const  uint32_t RESERVE1[2];  
N    __IO uint32_t CMPDAT[6];     /* Offset: 0x50~0x64  PWM Comparator Register 0~5                                   */
X    volatile uint32_t CMPDAT[6];      
N    __I  uint32_t RESERVE2[2];  
X    volatile const  uint32_t RESERVE2[2];  
N    __IO uint32_t DTCTL0_1;      /* Offset: 0x70  PWM Dead-Time Control Register 0                                   */
X    volatile uint32_t DTCTL0_1;       
N    __IO uint32_t DTCTL2_3;      /* Offset: 0x74  PWM Dead-Time Control Register 2                                   */
X    volatile uint32_t DTCTL2_3;       
N    __IO uint32_t DTCTL4_5;      /* Offset: 0x78  PWM Dead-Time Control Register 4                                   */
X    volatile uint32_t DTCTL4_5;       
N    __I  uint32_t RESERVE3[1];  
X    volatile const  uint32_t RESERVE3[1];  
N    __IO uint32_t PHS0_1;        /* Offset: 0x80  PWM Counter Phase Register 0                                       */
X    volatile uint32_t PHS0_1;         
N    __IO uint32_t PHS2_3;        /* Offset: 0x84  PWM Counter Phase Register 2                                       */
X    volatile uint32_t PHS2_3;         
N    __IO uint32_t PHS4_5;        /* Offset: 0x88  PWM Counter Phase Register 4                                       */
X    volatile uint32_t PHS4_5;         
N    __I  uint32_t RESERVE4[1];  
X    volatile const  uint32_t RESERVE4[1];  
N    __I  uint32_t CNT[6];        /* Offset: 0x90~0xA4  PWM Counter Register 0~5                                      */
X    volatile const  uint32_t CNT[6];         
N    __I  uint32_t RESERVE5[2];  
X    volatile const  uint32_t RESERVE5[2];  
N    __IO uint32_t WGCTL0;        /* Offset: 0xB0  PWM Generation Register 0                                          */
X    volatile uint32_t WGCTL0;         
N    __IO uint32_t WGCTL1;        /* Offset: 0xB4  PWM Generation Register 1                                          */
X    volatile uint32_t WGCTL1;         
N    __IO uint32_t MSKEN;         /* Offset: 0xB8  PWM Mask Enable Register                                           */
X    volatile uint32_t MSKEN;          
N    __IO uint32_t MSK;           /* Offset: 0xBC  PWM Mask Data Register                                             */
X    volatile uint32_t MSK;            
N    __IO uint32_t BNF;           /* Offset: 0xC0  PWM Brake Noise Filter Register                                    */
X    volatile uint32_t BNF;            
N    __IO uint32_t FAILBRK;       /* Offset: 0xC4  PWM System Fail Brake Control Register                             */
X    volatile uint32_t FAILBRK;        
N    __IO uint32_t BRKCTL0_1;     /* Offset: 0xC8  PWM Brake Edge Detect Control Register 0                           */
X    volatile uint32_t BRKCTL0_1;      
N    __IO uint32_t BRKCTL2_3;     /* Offset: 0xCC  PWM Brake Edge Detect Control Register 2                           */
X    volatile uint32_t BRKCTL2_3;      
N    __IO uint32_t BRKCTL4_5;     /* Offset: 0xD0  PWM Brake Edge Detect Control Register 4                           */
X    volatile uint32_t BRKCTL4_5;      
N    __IO uint32_t POLCTL;        /* Offset: 0xD4  PWM Pin Polar Inverse Register                                     */
X    volatile uint32_t POLCTL;         
N    __IO uint32_t POEN;          /* Offset: 0xD8  PWM Output Enable Register                                         */
X    volatile uint32_t POEN;           
N    __O  uint32_t SWBRK;         /* Offset: 0xDC  PWM Software Brake Control Register                                */
X    volatile  uint32_t SWBRK;          
N    __IO uint32_t INTEN0;        /* Offset: 0xE0  PWM Interrupt Enable Register 0                                    */
X    volatile uint32_t INTEN0;         
N    __IO uint32_t INTEN1;        /* Offset: 0xE4  PWM Interrupt Enable Register 1                                    */
X    volatile uint32_t INTEN1;         
N    __IO uint32_t INTSTS0;       /* Offset: 0xE8  PWM Interrupt Flag Register 0                                      */
X    volatile uint32_t INTSTS0;        
N    __IO uint32_t INTSTS1;       /* Offset: 0xEC  PWM Interrupt Flag Register 1                                      */
X    volatile uint32_t INTSTS1;        
N    __IO uint32_t IFA;           /* Offset: 0xF0  PWM Interrupt Flag Accumulator Register                            */
X    volatile uint32_t IFA;            
N    __IO uint32_t DACTRGEN;      /* Offset: 0xF4  PWM Trigger DAC Enable Register                                    */
X    volatile uint32_t DACTRGEN;       
N    __IO uint32_t EADCTS0;       /* Offset: 0xF8  PWM Trigger EADC Source Select Register 0                          */
X    volatile uint32_t EADCTS0;        
N    __IO uint32_t EADCTS1;       /* Offset: 0xFC  PWM Trigger EADC Source Select Register 1                          */
X    volatile uint32_t EADCTS1;        
N    __IO uint32_t FTCMPDAT0_1;   /* Offset: 0x100  PWM Free Trigger Compare Register 0                               */
X    volatile uint32_t FTCMPDAT0_1;    
N    __IO uint32_t FTCMPDAT2_3;   /* Offset: 0x104  PWM Free Trigger Compare Register 2                               */
X    volatile uint32_t FTCMPDAT2_3;    
N    __IO uint32_t FTCMPDAT4_5;   /* Offset: 0x108  PWM Free Trigger Compare Register 4                               */
X    volatile uint32_t FTCMPDAT4_5;    
N    __I  uint32_t RESERVE6[1];  
X    volatile const  uint32_t RESERVE6[1];  
N    __IO uint32_t SSCTL;         /* Offset: 0x110  PWM Synchronous Start Control Register                            */
X    volatile uint32_t SSCTL;          
N    __O  uint32_t SSTRG;         /* Offset: 0x114  PWM Synchronous Start Trigger Register                            */
X    volatile  uint32_t SSTRG;          
N    __I  uint32_t RESERVE7[2];  
X    volatile const  uint32_t RESERVE7[2];  
N    __IO uint32_t STATUS;        /* Offset: 0x120  PWM Status Register                                               */
X    volatile uint32_t STATUS;         
N    __I  uint32_t RESERVE8[55]; 
X    volatile const  uint32_t RESERVE8[55]; 
N    __IO uint32_t CAPINEN;       /* Offset: 0x200  PWM Capture Input Enable Register                                 */
X    volatile uint32_t CAPINEN;        
N    __IO uint32_t CAPCTL;        /* Offset: 0x204  PWM Capture Control Register                                      */
X    volatile uint32_t CAPCTL;         
N    __I  uint32_t CAPSTS;        /* Offset: 0x208  PWM Capture Status Register                                       */
X    volatile const  uint32_t CAPSTS;         
N    __I  uint32_t RCAPDAT0;      /* Offset: 0x20C  PWM Rising Capture Data Register 0                                */
X    volatile const  uint32_t RCAPDAT0;       
N    __I  uint32_t FCAPDAT0;      /* Offset: 0x210  PWM Falling Capture Data Register 0                               */
X    volatile const  uint32_t FCAPDAT0;       
N    __I  uint32_t RCAPDAT1;      /* Offset: 0x214  PWM Rising Capture Data Register 1                                */
X    volatile const  uint32_t RCAPDAT1;       
N    __I  uint32_t FCAPDAT1;      /* Offset: 0x218  PWM Falling Capture Data Register 1                               */
X    volatile const  uint32_t FCAPDAT1;       
N    __I  uint32_t RCAPDAT2;      /* Offset: 0x21C  PWM Rising Capture Data Register 2                                */
X    volatile const  uint32_t RCAPDAT2;       
N    __I  uint32_t FCAPDAT2;      /* Offset: 0x220  PWM Falling Capture Data Register 2                               */
X    volatile const  uint32_t FCAPDAT2;       
N    __I  uint32_t RCAPDAT3;      /* Offset: 0x224  PWM Rising Capture Data Register 3                                */
X    volatile const  uint32_t RCAPDAT3;       
N    __I  uint32_t FCAPDAT3;      /* Offset: 0x228  PWM Falling Capture Data Register 3                               */
X    volatile const  uint32_t FCAPDAT3;       
N    __I  uint32_t RCAPDAT4;      /* Offset: 0x22C  PWM Rising Capture Data Register 4                                */
X    volatile const  uint32_t RCAPDAT4;       
N    __I  uint32_t FCAPDAT4;      /* Offset: 0x230  PWM Falling Capture Data Register 4                               */
X    volatile const  uint32_t FCAPDAT4;       
N    __I  uint32_t RCAPDAT5;      /* Offset: 0x234  PWM Rising Capture Data Register 5                                */
X    volatile const  uint32_t RCAPDAT5;       
N    __I  uint32_t FCAPDAT5;      /* Offset: 0x238  PWM Falling Capture Data Register 5                               */
X    volatile const  uint32_t FCAPDAT5;       
N    __IO uint32_t PDMACTL;       /* Offset: 0x23C  PWM PDMA Control Register                                         */
X    volatile uint32_t PDMACTL;        
N    __I  uint32_t PDMACAP0_1;    /* Offset: 0x240  PWM Capture Channel 01 PDMA Register                              */
X    volatile const  uint32_t PDMACAP0_1;     
N    __I  uint32_t PDMACAP2_3;    /* Offset: 0x244  PWM Capture Channel 23 PDMA Register                              */
X    volatile const  uint32_t PDMACAP2_3;     
N    __I  uint32_t PDMACAP4_5;    /* Offset: 0x248  PWM Capture Channel 45 PDMA Register                              */
X    volatile const  uint32_t PDMACAP4_5;     
N    __I  uint32_t RESERVE9[1];  
X    volatile const  uint32_t RESERVE9[1];  
N    __IO uint32_t CAPIEN;        /* Offset: 0x250  PWM Capture Interrupt Enable Register                             */
X    volatile uint32_t CAPIEN;         
N    __IO uint32_t CAPIF;         /* Offset: 0x254  PWM Capture Interrupt Flag Register                               */
X    volatile uint32_t CAPIF;          
N    __I  uint32_t RESERVE10[43];
X    volatile const  uint32_t RESERVE10[43];
N    __I  uint32_t PBUF[6];       /* Offset: 0x304~0x318  PWM PERIOD0~5 Buffer                                        */
X    volatile const  uint32_t PBUF[6];        
N    __I  uint32_t CMPBUF[6];     /* Offset: 0x31C~0x330  PWM CMPDAT0~5 Buffer                                        */
X    volatile const  uint32_t CMPBUF[6];      
N    __I  uint32_t RESERVE11[3]; 
X    volatile const  uint32_t RESERVE11[3]; 
N    __I  uint32_t FTCBUF0_1;     /* Offset: 0x340  PWM FTCMPDAT0_1 Buffer                                            */
X    volatile const  uint32_t FTCBUF0_1;      
N    __I  uint32_t FTCBUF2_3;     /* Offset: 0x344  PWM FTCMPDAT2_3 Buffer                                            */
X    volatile const  uint32_t FTCBUF2_3;      
N    __I  uint32_t FTCBUF4_5;     /* Offset: 0x348  PWM FTCMPDAT4_5 Buffer                                            */
X    volatile const  uint32_t FTCBUF4_5;      
N    __IO uint32_t FTCI;          /* Offset: 0x34C  PWM FTCMPDAT Indicator Register                                   */
X    volatile uint32_t FTCI;           
N
N} PWM_T;
N
N
N
N/**
N    @addtogroup PWM_CONST PWM Bit Field Definition
N    Constant Definitions for PWM Controller
N@{ */
N
N#define PWM_CTL0_CTRLDn_Pos              (0)                                               /*!< PWM_T::CTL0: CTRLDn Position              */
N#define PWM_CTL0_CTRLDn_Msk              (0x3ful << PWM_CTL0_CTRLDn_Pos)                   /*!< PWM_T::CTL0: CTRLDn Mask                  */
N
N#define PWM_CTL0_CTRLD0_Pos              (0)                                               /*!< PWM_T::CTL0: CTRLD0 Position              */
N#define PWM_CTL0_CTRLD0_Msk              (0x1ul << PWM_CTL0_CTRLD0_Pos)                    /*!< PWM_T::CTL0: CTRLD0 Mask                  */
N
N#define PWM_CTL0_CTRLD1_Pos              (1)                                               /*!< PWM_T::CTL0: CTRLD1 Position              */
N#define PWM_CTL0_CTRLD1_Msk              (0x1ul << PWM_CTL0_CTRLD1_Pos)                    /*!< PWM_T::CTL0: CTRLD1 Mask                  */
N
N#define PWM_CTL0_CTRLD2_Pos              (2)                                               /*!< PWM_T::CTL0: CTRLD2 Position              */
N#define PWM_CTL0_CTRLD2_Msk              (0x1ul << PWM_CTL0_CTRLD2_Pos)                    /*!< PWM_T::CTL0: CTRLD2 Mask                  */
N
N#define PWM_CTL0_CTRLD3_Pos              (3)                                               /*!< PWM_T::CTL0: CTRLD3 Position              */
N#define PWM_CTL0_CTRLD3_Msk              (0x1ul << PWM_CTL0_CTRLD3_Pos)                    /*!< PWM_T::CTL0: CTRLD3 Mask                  */
N
N#define PWM_CTL0_CTRLD4_Pos              (4)                                               /*!< PWM_T::CTL0: CTRLD4 Position              */
N#define PWM_CTL0_CTRLD4_Msk              (0x1ul << PWM_CTL0_CTRLD4_Pos)                    /*!< PWM_T::CTL0: CTRLD4 Mask                  */
N
N#define PWM_CTL0_CTRLD5_Pos              (5)                                               /*!< PWM_T::CTL0: CTRLD5 Position              */
N#define PWM_CTL0_CTRLD5_Msk              (0x1ul << PWM_CTL0_CTRLD5_Pos)                    /*!< PWM_T::CTL0: CTRLD5 Mask                  */
N
N#define PWM_CTL0_WINLDENn_Pos            (8)                                               /*!< PWM_T::CTL0: WINLDENn Position            */
N#define PWM_CTL0_WINLDENn_Msk            (0x3ful << PWM_CTL0_WINLDENn_Pos)                 /*!< PWM_T::CTL0: WINLDENn Mask                */
N
N#define PWM_CTL0_WINLDEN0_Pos            (8)                                               /*!< PWM_T::CTL0: WINLDEN0 Position            */
N#define PWM_CTL0_WINLDEN0_Msk            (0x1ul << PWM_CTL0_WINLDEN0_Pos)                  /*!< PWM_T::CTL0: WINLDEN0 Mask                */
N
N#define PWM_CTL0_WINLDEN1_Pos            (9)                                               /*!< PWM_T::CTL0: WINLDEN1 Position            */
N#define PWM_CTL0_WINLDEN1_Msk            (0x1ul << PWM_CTL0_WINLDEN1_Pos)                  /*!< PWM_T::CTL0: WINLDEN1 Mask                */
N
N#define PWM_CTL0_WINLDEN2_Pos            (10)                                              /*!< PWM_T::CTL0: WINLDEN2 Position            */
N#define PWM_CTL0_WINLDEN2_Msk            (0x1ul << PWM_CTL0_WINLDEN2_Pos)                  /*!< PWM_T::CTL0: WINLDEN2 Mask                */
N
N#define PWM_CTL0_WINLDEN3_Pos            (11)                                              /*!< PWM_T::CTL0: WINLDEN3 Position            */
N#define PWM_CTL0_WINLDEN3_Msk            (0x1ul << PWM_CTL0_WINLDEN3_Pos)                  /*!< PWM_T::CTL0: WINLDEN3 Mask                */
N
N#define PWM_CTL0_WINLDEN4_Pos            (12)                                              /*!< PWM_T::CTL0: WINLDEN4 Position            */
N#define PWM_CTL0_WINLDEN4_Msk            (0x1ul << PWM_CTL0_WINLDEN4_Pos)                  /*!< PWM_T::CTL0: WINLDEN4 Mask                */
N
N#define PWM_CTL0_WINLDEN5_Pos            (13)                                              /*!< PWM_T::CTL0: WINLDEN5 Position            */
N#define PWM_CTL0_WINLDEN5_Msk            (0x1ul << PWM_CTL0_WINLDEN5_Pos)                  /*!< PWM_T::CTL0: WINLDEN5 Mask                */
N
N#define PWM_CTL0_IMMLDENn_Pos            (16)                                              /*!< PWM_T::CTL0: IMMLDENn Position            */
N#define PWM_CTL0_IMMLDENn_Msk            (0x3ful << PWM_CTL0_IMMLDENn_Pos)                 /*!< PWM_T::CTL0: IMMLDENn Mask                */
N
N#define PWM_CTL0_IMMLDEN0_Pos            (16)                                              /*!< PWM_T::CTL0: IMMLDEN0 Position            */
N#define PWM_CTL0_IMMLDEN0_Msk            (0x1ul << PWM_CTL0_IMMLDEN0_Pos)                  /*!< PWM_T::CTL0: IMMLDEN0 Mask                */
N
N#define PWM_CTL0_IMMLDEN1_Pos            (17)                                              /*!< PWM_T::CTL0: IMMLDEN1 Position            */
N#define PWM_CTL0_IMMLDEN1_Msk            (0x1ul << PWM_CTL0_IMMLDEN1_Pos)                  /*!< PWM_T::CTL0: IMMLDEN1 Mask                */
N
N#define PWM_CTL0_IMMLDEN2_Pos            (18)                                              /*!< PWM_T::CTL0: IMMLDEN2 Position            */
N#define PWM_CTL0_IMMLDEN2_Msk            (0x1ul << PWM_CTL0_IMMLDEN2_Pos)                  /*!< PWM_T::CTL0: IMMLDEN2 Mask                */
N
N#define PWM_CTL0_IMMLDEN3_Pos            (19)                                              /*!< PWM_T::CTL0: IMMLDEN3 Position            */
N#define PWM_CTL0_IMMLDEN3_Msk            (0x1ul << PWM_CTL0_IMMLDEN3_Pos)                  /*!< PWM_T::CTL0: IMMLDEN3 Mask                */
N
N#define PWM_CTL0_IMMLDEN4_Pos            (20)                                              /*!< PWM_T::CTL0: IMMLDEN4 Position            */
N#define PWM_CTL0_IMMLDEN4_Msk            (0x1ul << PWM_CTL0_IMMLDEN4_Pos)                  /*!< PWM_T::CTL0: IMMLDEN4 Mask                */
N
N#define PWM_CTL0_IMMLDEN5_Pos            (21)                                              /*!< PWM_T::CTL0: IMMLDEN5 Position            */
N#define PWM_CTL0_IMMLDEN5_Msk            (0x1ul << PWM_CTL0_IMMLDEN5_Pos)                  /*!< PWM_T::CTL0: IMMLDEN5 Mask                */
N
N#define PWM_CTL0_GROUPEN_Pos             (24)                                              /*!< PWM_T::CTL0: GROUPEN Position             */
N#define PWM_CTL0_GROUPEN_Msk             (0x1ul << PWM_CTL0_GROUPEN_Pos)                   /*!< PWM_T::CTL0: GROUPEN Mask                 */
N
N#define PWM_CTL0_DBGHALT_Pos             (30)                                              /*!< PWM_T::CTL0: DBGHALT Position             */
N#define PWM_CTL0_DBGHALT_Msk             (0x1ul << PWM_CTL0_DBGHALT_Pos)                   /*!< PWM_T::CTL0: DBGHALT Mask                 */
N
N#define PWM_CTL0_DBGTRIOFF_Pos           (31)                                              /*!< PWM_T::CTL0: DBGTRIOFF Position           */
N#define PWM_CTL0_DBGTRIOFF_Msk           (0x1ul << PWM_CTL0_DBGTRIOFF_Pos)                 /*!< PWM_T::CTL0: DBGTRIOFF Mask               */
N
N#define PWM_CTL1_CNTTYPEn_Pos            (0)                                               /*!< PWM_T::CTL1: CNTTYPEn Position            */
N#define PWM_CTL1_CNTTYPEn_Msk            (0xffful << PWM_CTL1_CNTTYPEn_Pos)                /*!< PWM_T::CTL1: CNTTYPEn Mask                */
N
N#define PWM_CTL1_CNTTYPE0_Pos            (0)                                               /*!< PWM_T::CTL1: CNTTYPE0 Position            */
N#define PWM_CTL1_CNTTYPE0_Msk            (0x3ul << PWM_CTL1_CNTTYPE0_Pos)                  /*!< PWM_T::CTL1: CNTTYPE0 Mask                */
N
N#define PWM_CTL1_CNTTYPE1_Pos            (2)                                               /*!< PWM_T::CTL1: CNTTYPE1 Position            */
N#define PWM_CTL1_CNTTYPE1_Msk            (0x3ul << PWM_CTL1_CNTTYPE1_Pos)                  /*!< PWM_T::CTL1: CNTTYPE1 Mask                */
N
N#define PWM_CTL1_CNTTYPE2_Pos            (4)                                               /*!< PWM_T::CTL1: CNTTYPE2 Position            */
N#define PWM_CTL1_CNTTYPE2_Msk            (0x3ul << PWM_CTL1_CNTTYPE2_Pos)                  /*!< PWM_T::CTL1: CNTTYPE2 Mask                */
N
N#define PWM_CTL1_CNTTYPE3_Pos            (6)                                               /*!< PWM_T::CTL1: CNTTYPE3 Position            */
N#define PWM_CTL1_CNTTYPE3_Msk            (0x3ul << PWM_CTL1_CNTTYPE3_Pos)                  /*!< PWM_T::CTL1: CNTTYPE3 Mask                */
N
N#define PWM_CTL1_CNTTYPE4_Pos            (8)                                               /*!< PWM_T::CTL1: CNTTYPE4 Position            */
N#define PWM_CTL1_CNTTYPE4_Msk            (0x3ul << PWM_CTL1_CNTTYPE4_Pos)                  /*!< PWM_T::CTL1: CNTTYPE4 Mask                */
N
N#define PWM_CTL1_CNTTYPE5_Pos            (10)                                              /*!< PWM_T::CTL1: CNTTYPE5 Position            */
N#define PWM_CTL1_CNTTYPE5_Msk            (0x3ul << PWM_CTL1_CNTTYPE5_Pos)                  /*!< PWM_T::CTL1: CNTTYPE5 Mask                */
N
N#define PWM_CTL1_CNTMODEn_Pos            (16)                                              /*!< PWM_T::CTL1: CNTMODEn Position            */
N#define PWM_CTL1_CNTMODEn_Msk            (0x3ful << PWM_CTL1_CNTMODEn_Pos)                 /*!< PWM_T::CTL1: CNTMODEn Mask                */
N
N#define PWM_CTL1_CNTMODE0_Pos            (16)                                              /*!< PWM_T::CTL1: CNTMODE0 Position            */
N#define PWM_CTL1_CNTMODE0_Msk            (0x1ul << PWM_CTL1_CNTMODE0_Pos)                  /*!< PWM_T::CTL1: CNTMODE0 Mask                */
N
N#define PWM_CTL1_CNTMODE1_Pos            (17)                                              /*!< PWM_T::CTL1: CNTMODE1 Position            */
N#define PWM_CTL1_CNTMODE1_Msk            (0x1ul << PWM_CTL1_CNTMODE1_Pos)                  /*!< PWM_T::CTL1: CNTMODE1 Mask                */
N
N#define PWM_CTL1_CNTMODE2_Pos            (18)                                              /*!< PWM_T::CTL1: CNTMODE2 Position            */
N#define PWM_CTL1_CNTMODE2_Msk            (0x1ul << PWM_CTL1_CNTMODE2_Pos)                  /*!< PWM_T::CTL1: CNTMODE2 Mask                */
N
N#define PWM_CTL1_CNTMODE3_Pos            (19)                                              /*!< PWM_T::CTL1: CNTMODE3 Position            */
N#define PWM_CTL1_CNTMODE3_Msk            (0x1ul << PWM_CTL1_CNTMODE3_Pos)                  /*!< PWM_T::CTL1: CNTMODE3 Mask                */
N
N#define PWM_CTL1_CNTMODE4_Pos            (20)                                              /*!< PWM_T::CTL1: CNTMODE4 Position            */
N#define PWM_CTL1_CNTMODE4_Msk            (0x1ul << PWM_CTL1_CNTMODE4_Pos)                  /*!< PWM_T::CTL1: CNTMODE4 Mask                */
N
N#define PWM_CTL1_CNTMODE5_Pos            (21)                                              /*!< PWM_T::CTL1: CNTMODE5 Position            */
N#define PWM_CTL1_CNTMODE5_Msk            (0x1ul << PWM_CTL1_CNTMODE5_Pos)                  /*!< PWM_T::CTL1: CNTMODE5 Mask                */
N
N#define PWM_CTL1_OUTMODEn_Pos            (24)                                              /*!< PWM_T::CTL1: OUTMODEn Position            */
N#define PWM_CTL1_OUTMODEn_Msk            (0x7ul << PWM_CTL1_OUTMODEn_Pos)                  /*!< PWM_T::CTL1: OUTMODEn Mask                */
N
N#define PWM_CTL1_OUTMODE0_Pos            (24)                                              /*!< PWM_T::CTL1: OUTMODE0 Position            */
N#define PWM_CTL1_OUTMODE0_Msk            (0x1ul << PWM_CTL1_OUTMODE0_Pos)                  /*!< PWM_T::CTL1: OUTMODE0 Mask                */
N
N#define PWM_CTL1_OUTMODE2_Pos            (25)                                              /*!< PWM_T::CTL1: OUTMODE2 Position            */
N#define PWM_CTL1_OUTMODE2_Msk            (0x1ul << PWM_CTL1_OUTMODE2_Pos)                  /*!< PWM_T::CTL1: OUTMODE2 Mask                */
N
N#define PWM_CTL1_OUTMODE4_Pos            (26)                                              /*!< PWM_T::CTL1: OUTMODE4 Position            */
N#define PWM_CTL1_OUTMODE4_Msk            (0x1ul << PWM_CTL1_OUTMODE4_Pos)                  /*!< PWM_T::CTL1: OUTMODE4 Mask                */
N
N#define PWM_SYNC_PHSENn_Pos              (0)                                               /*!< PWM_T::SYNC: PHSENn Position              */
N#define PWM_SYNC_PHSENn_Msk              (0x7ul << PWM_SYNC_PHSENn_Pos)                    /*!< PWM_T::SYNC: PHSENn Mask                  */
N
N#define PWM_SYNC_PHSEN0_Pos              (0)                                               /*!< PWM_T::SYNC: PHSEN0 Position              */
N#define PWM_SYNC_PHSEN0_Msk              (0x1ul << PWM_SYNC_PHSEN0_Pos)                    /*!< PWM_T::SYNC: PHSEN0 Mask                  */
N
N#define PWM_SYNC_PHSEN2_Pos              (1)                                               /*!< PWM_T::SYNC: PHSEN2 Position              */
N#define PWM_SYNC_PHSEN2_Msk              (0x1ul << PWM_SYNC_PHSEN2_Pos)                    /*!< PWM_T::SYNC: PHSEN2 Mask                  */
N
N#define PWM_SYNC_PHSEN4_Pos              (2)                                               /*!< PWM_T::SYNC: PHSEN4 Position              */
N#define PWM_SYNC_PHSEN4_Msk              (0x1ul << PWM_SYNC_PHSEN4_Pos)                    /*!< PWM_T::SYNC: PHSEN4 Mask                  */
N
N#define PWM_SYNC_SINSRCn_Pos             (8)                                               /*!< PWM_T::SYNC: SINSRCn Position             */
N#define PWM_SYNC_SINSRCn_Msk             (0x3ful << PWM_SYNC_SINSRCn_Pos)                  /*!< PWM_T::SYNC: SINSRCn Mask                 */
N
N#define PWM_SYNC_SINSRC0_Pos             (8)                                               /*!< PWM_T::SYNC: SINSRC0 Position             */
N#define PWM_SYNC_SINSRC0_Msk             (0x3ul << PWM_SYNC_SINSRC0_Pos)                   /*!< PWM_T::SYNC: SINSRC0 Mask                 */
N
N#define PWM_SYNC_SINSRC2_Pos             (10)                                              /*!< PWM_T::SYNC: SINSRC2 Position             */
N#define PWM_SYNC_SINSRC2_Msk             (0x3ul << PWM_SYNC_SINSRC2_Pos)                   /*!< PWM_T::SYNC: SINSRC2 Mask                 */
N
N#define PWM_SYNC_SINSRC4_Pos             (12)                                              /*!< PWM_T::SYNC: SINSRC4 Position             */
N#define PWM_SYNC_SINSRC4_Msk             (0x3ul << PWM_SYNC_SINSRC4_Pos)                   /*!< PWM_T::SYNC: SINSRC4 Mask                 */
N
N#define PWM_SYNC_SNFLTEN_Pos             (16)                                              /*!< PWM_T::SYNC: SNFLTEN Position             */
N#define PWM_SYNC_SNFLTEN_Msk             (0x1ul << PWM_SYNC_SNFLTEN_Pos)                   /*!< PWM_T::SYNC: SNFLTEN Mask                 */
N
N#define PWM_SYNC_SFLTCSEL_Pos            (17)                                              /*!< PWM_T::SYNC: SFLTCSEL Position            */
N#define PWM_SYNC_SFLTCSEL_Msk            (0x7ul << PWM_SYNC_SFLTCSEL_Pos)                  /*!< PWM_T::SYNC: SFLTCSEL Mask                */
N
N#define PWM_SYNC_SFLTCNT_Pos             (20)                                              /*!< PWM_T::SYNC: SFLTCNT Position             */
N#define PWM_SYNC_SFLTCNT_Msk             (0x7ul << PWM_SYNC_SFLTCNT_Pos)                   /*!< PWM_T::SYNC: SFLTCNT Mask                 */
N
N#define PWM_SYNC_SINPINV_Pos             (23)                                              /*!< PWM_T::SYNC: SINPINV Position             */
N#define PWM_SYNC_SINPINV_Msk             (0x1ul << PWM_SYNC_SINPINV_Pos)                   /*!< PWM_T::SYNC: SINPINV Mask                 */
N
N#define PWM_SYNC_PHSDIRn_Pos             (24)                                              /*!< PWM_T::SYNC: PHSDIRn Position             */
N#define PWM_SYNC_PHSDIRn_Msk             (0x7ul << PWM_SYNC_PHSDIRn_Pos)                   /*!< PWM_T::SYNC: PHSDIRn Mask                 */
N
N#define PWM_SYNC_PHSDIR0_Pos             (24)                                              /*!< PWM_T::SYNC: PHSDIR0 Position             */
N#define PWM_SYNC_PHSDIR0_Msk             (0x1ul << PWM_SYNC_PHSDIR0_Pos)                   /*!< PWM_T::SYNC: PHSDIR0 Mask                 */
N
N#define PWM_SYNC_PHSDIR2_Pos             (25)                                              /*!< PWM_T::SYNC: PHSDIR2 Position             */
N#define PWM_SYNC_PHSDIR2_Msk             (0x1ul << PWM_SYNC_PHSDIR2_Pos)                   /*!< PWM_T::SYNC: PHSDIR2 Mask                 */
N
N#define PWM_SYNC_PHSDIR4_Pos             (26)                                              /*!< PWM_T::SYNC: PHSDIR4 Position             */
N#define PWM_SYNC_PHSDIR4_Msk             (0x1ul << PWM_SYNC_PHSDIR4_Pos)                   /*!< PWM_T::SYNC: PHSDIR4 Mask                 */
N
N#define PWM_SWSYNC_SWSYNCn_Pos           (0)                                               /*!< PWM_T::SWSYNC: SWSYNCn Position           */
N#define PWM_SWSYNC_SWSYNCn_Msk           (0x7ul << PWM_SWSYNC_SWSYNCn_Pos)                 /*!< PWM_T::SWSYNC: SWSYNCn Mask               */
N
N#define PWM_SWSYNC_SWSYNC0_Pos           (0)                                               /*!< PWM_T::SWSYNC: SWSYNC0 Position           */
N#define PWM_SWSYNC_SWSYNC0_Msk           (0x1ul << PWM_SWSYNC_SWSYNC0_Pos)                 /*!< PWM_T::SWSYNC: SWSYNC0 Mask               */
N
N#define PWM_SWSYNC_SWSYNC2_Pos           (1)                                               /*!< PWM_T::SWSYNC: SWSYNC2 Position           */
N#define PWM_SWSYNC_SWSYNC2_Msk           (0x1ul << PWM_SWSYNC_SWSYNC2_Pos)                 /*!< PWM_T::SWSYNC: SWSYNC2 Mask               */
N
N#define PWM_SWSYNC_SWSYNC4_Pos           (2)                                               /*!< PWM_T::SWSYNC: SWSYNC4 Position           */
N#define PWM_SWSYNC_SWSYNC4_Msk           (0x1ul << PWM_SWSYNC_SWSYNC4_Pos)                 /*!< PWM_T::SWSYNC: SWSYNC4 Mask               */
N
N#define PWM_CLKSRC_ECLKSRC0_Pos          (0)                                               /*!< PWM_T::CLKSRC: ECLKSRC0 Position          */
N#define PWM_CLKSRC_ECLKSRC0_Msk          (0x7ul << PWM_CLKSRC_ECLKSRC0_Pos)                /*!< PWM_T::CLKSRC: ECLKSRC0 Mask              */
N
N#define PWM_CLKSRC_ECLKSRC2_Pos          (8)                                               /*!< PWM_T::CLKSRC: ECLKSRC2 Position          */
N#define PWM_CLKSRC_ECLKSRC2_Msk          (0x7ul << PWM_CLKSRC_ECLKSRC2_Pos)                /*!< PWM_T::CLKSRC: ECLKSRC2 Mask              */
N
N#define PWM_CLKSRC_ECLKSRC4_Pos          (16)                                              /*!< PWM_T::CLKSRC: ECLKSRC4 Position          */
N#define PWM_CLKSRC_ECLKSRC4_Msk          (0x7ul << PWM_CLKSRC_ECLKSRC4_Pos)                /*!< PWM_T::CLKSRC: ECLKSRC4 Mask              */
N
N#define PWM_CLKPSC0_1_CLKPSC_Pos         (0)                                               /*!< PWM_T::CLKPSC0_1: CLKPSC Position         */
N#define PWM_CLKPSC0_1_CLKPSC_Msk         (0xffful << PWM_CLKPSC0_1_CLKPSC_Pos)             /*!< PWM_T::CLKPSC0_1: CLKPSC Mask             */
N
N#define PWM_CLKPSC2_3_CLKPSC_Pos         (0)                                               /*!< PWM_T::CLKPSC2_3: CLKPSC Position         */
N#define PWM_CLKPSC2_3_CLKPSC_Msk         (0xffful << PWM_CLKPSC2_3_CLKPSC_Pos)             /*!< PWM_T::CLKPSC2_3: CLKPSC Mask             */
N
N#define PWM_CLKPSC4_5_CLKPSC_Pos         (0)                                               /*!< PWM_T::CLKPSC4_5: CLKPSC Position         */
N#define PWM_CLKPSC4_5_CLKPSC_Msk         (0xffful << PWM_CLKPSC4_5_CLKPSC_Pos)             /*!< PWM_T::CLKPSC4_5: CLKPSC Mask             */
N
N#define PWM_CNTEN_CNTENn_Pos             (0)                                               /*!< PWM_T::CNTEN: CNTENn Position             */
N#define PWM_CNTEN_CNTENn_Msk             (0x3ful << PWM_CNTEN_CNTENn_Pos)                  /*!< PWM_T::CNTEN: CNTENn Mask                 */
N
N#define PWM_CNTEN_CNTEN0_Pos             (0)                                               /*!< PWM_T::CNTEN: CNTEN0 Position             */
N#define PWM_CNTEN_CNTEN0_Msk             (0x1ul << PWM_CNTEN_CNTEN0_Pos)                   /*!< PWM_T::CNTEN: CNTEN0 Mask                 */
N
N#define PWM_CNTEN_CNTEN1_Pos             (1)                                               /*!< PWM_T::CNTEN: CNTEN1 Position             */
N#define PWM_CNTEN_CNTEN1_Msk             (0x1ul << PWM_CNTEN_CNTEN1_Pos)                   /*!< PWM_T::CNTEN: CNTEN1 Mask                 */
N
N#define PWM_CNTEN_CNTEN2_Pos             (2)                                               /*!< PWM_T::CNTEN: CNTEN2 Position             */
N#define PWM_CNTEN_CNTEN2_Msk             (0x1ul << PWM_CNTEN_CNTEN2_Pos)                   /*!< PWM_T::CNTEN: CNTEN2 Mask                 */
N
N#define PWM_CNTEN_CNTEN3_Pos             (3)                                               /*!< PWM_T::CNTEN: CNTEN3 Position             */
N#define PWM_CNTEN_CNTEN3_Msk             (0x1ul << PWM_CNTEN_CNTEN3_Pos)                   /*!< PWM_T::CNTEN: CNTEN3 Mask                 */
N
N#define PWM_CNTEN_CNTEN4_Pos             (4)                                               /*!< PWM_T::CNTEN: CNTEN4 Position             */
N#define PWM_CNTEN_CNTEN4_Msk             (0x1ul << PWM_CNTEN_CNTEN4_Pos)                   /*!< PWM_T::CNTEN: CNTEN4 Mask                 */
N
N#define PWM_CNTEN_CNTEN5_Pos             (5)                                               /*!< PWM_T::CNTEN: CNTEN5 Position             */
N#define PWM_CNTEN_CNTEN5_Msk             (0x1ul << PWM_CNTEN_CNTEN5_Pos)                   /*!< PWM_T::CNTEN: CNTEN5 Mask                 */
N
N#define PWM_CNTCLR_CNTCLRn_Pos           (0)                                               /*!< PWM_T::CNTCLR: CNTCLRn Position           */
N#define PWM_CNTCLR_CNTCLRn_Msk           (0x3ful << PWM_CNTCLR_CNTCLRn_Pos)                /*!< PWM_T::CNTCLR: CNTCLRn Mask               */
N
N#define PWM_CNTCLR_CNTCLR0_Pos           (0)                                               /*!< PWM_T::CNTCLR: CNTCLR0 Position           */
N#define PWM_CNTCLR_CNTCLR0_Msk           (0x1ul << PWM_CNTCLR_CNTCLR0_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR0 Mask               */
N
N#define PWM_CNTCLR_CNTCLR1_Pos           (1)                                               /*!< PWM_T::CNTCLR: CNTCLR1 Position           */
N#define PWM_CNTCLR_CNTCLR1_Msk           (0x1ul << PWM_CNTCLR_CNTCLR1_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR1 Mask               */
N
N#define PWM_CNTCLR_CNTCLR2_Pos           (2)                                               /*!< PWM_T::CNTCLR: CNTCLR2 Position           */
N#define PWM_CNTCLR_CNTCLR2_Msk           (0x1ul << PWM_CNTCLR_CNTCLR2_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR2 Mask               */
N
N#define PWM_CNTCLR_CNTCLR3_Pos           (3)                                               /*!< PWM_T::CNTCLR: CNTCLR3 Position           */
N#define PWM_CNTCLR_CNTCLR3_Msk           (0x1ul << PWM_CNTCLR_CNTCLR3_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR3 Mask               */
N
N#define PWM_CNTCLR_CNTCLR4_Pos           (4)                                               /*!< PWM_T::CNTCLR: CNTCLR4 Position           */
N#define PWM_CNTCLR_CNTCLR4_Msk           (0x1ul << PWM_CNTCLR_CNTCLR4_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR4 Mask               */
N
N#define PWM_CNTCLR_CNTCLR5_Pos           (5)                                               /*!< PWM_T::CNTCLR: CNTCLR5 Position           */
N#define PWM_CNTCLR_CNTCLR5_Msk           (0x1ul << PWM_CNTCLR_CNTCLR5_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR5 Mask               */
N
N#define PWM_LOAD_LOADn_Pos               (0)                                               /*!< PWM_T::LOAD: LOADn Position               */
N#define PWM_LOAD_LOADn_Msk               (0x3ful << PWM_LOAD_LOADn_Pos)                    /*!< PWM_T::LOAD: LOADn Mask                   */
N
N#define PWM_LOAD_LOAD0_Pos               (0)                                               /*!< PWM_T::LOAD: LOAD0 Position               */
N#define PWM_LOAD_LOAD0_Msk               (0x1ul << PWM_LOAD_LOAD0_Pos)                     /*!< PWM_T::LOAD: LOAD0 Mask                   */
N
N#define PWM_LOAD_LOAD1_Pos               (1)                                               /*!< PWM_T::LOAD: LOAD1 Position               */
N#define PWM_LOAD_LOAD1_Msk               (0x1ul << PWM_LOAD_LOAD1_Pos)                     /*!< PWM_T::LOAD: LOAD1 Mask                   */
N
N#define PWM_LOAD_LOAD2_Pos               (2)                                               /*!< PWM_T::LOAD: LOAD2 Position               */
N#define PWM_LOAD_LOAD2_Msk               (0x1ul << PWM_LOAD_LOAD2_Pos)                     /*!< PWM_T::LOAD: LOAD2 Mask                   */
N
N#define PWM_LOAD_LOAD3_Pos               (3)                                               /*!< PWM_T::LOAD: LOAD3 Position               */
N#define PWM_LOAD_LOAD3_Msk               (0x1ul << PWM_LOAD_LOAD3_Pos)                     /*!< PWM_T::LOAD: LOAD3 Mask                   */
N
N#define PWM_LOAD_LOAD4_Pos               (4)                                               /*!< PWM_T::LOAD: LOAD4 Position               */
N#define PWM_LOAD_LOAD4_Msk               (0x1ul << PWM_LOAD_LOAD4_Pos)                     /*!< PWM_T::LOAD: LOAD4 Mask                   */
N
N#define PWM_LOAD_LOAD5_Pos               (5)                                               /*!< PWM_T::LOAD: LOAD5 Position               */
N#define PWM_LOAD_LOAD5_Msk               (0x1ul << PWM_LOAD_LOAD5_Pos)                     /*!< PWM_T::LOAD: LOAD5 Mask                   */
N
N#define PWM_PERIOD_PERIOD_Pos            (0)                                               /*!< PWM_T::PERIOD: PERIOD Position            */
N#define PWM_PERIOD_PERIOD_Msk            (0xfffful << PWM_PERIOD_PERIOD_Pos)               /*!< PWM_T::PERIOD: PERIOD Mask                */
N
N#define PWM_CMPDAT_CMP_Pos               (0)                                               /*!< PWM_T::CMPDAT: CMP Position               */
N#define PWM_CMPDAT_CMP_Msk               (0xfffful << PWM_CMPDAT_CMP_Pos)                  /*!< PWM_T::CMPDAT: CMP Mask                   */
N
N#define PWM_DTCTL0_1_DTCNT_Pos           (0)                                               /*!< PWM_T::DTCTL0_1: DTCNT Position           */
N#define PWM_DTCTL0_1_DTCNT_Msk           (0xffful << PWM_DTCTL0_1_DTCNT_Pos)               /*!< PWM_T::DTCTL0_1: DTCNT Mask               */
N
N#define PWM_DTCTL0_1_DTEN_Pos            (16)                                              /*!< PWM_T::DTCTL0_1: DTEN Position            */
N#define PWM_DTCTL0_1_DTEN_Msk            (0x1ul << PWM_DTCTL0_1_DTEN_Pos)                  /*!< PWM_T::DTCTL0_1: DTEN Mask                */
N
N#define PWM_DTCTL0_1_DTCKSEL_Pos         (24)                                              /*!< PWM_T::DTCTL0_1: DTCKSEL Position         */
N#define PWM_DTCTL0_1_DTCKSEL_Msk         (0x1ul << PWM_DTCTL0_1_DTCKSEL_Pos)               /*!< PWM_T::DTCTL0_1: DTCKSEL Mask             */
N
N#define PWM_DTCTL2_3_DTCNT_Pos           (0)                                               /*!< PWM_T::DTCTL2_3: DTCNT Position           */
N#define PWM_DTCTL2_3_DTCNT_Msk           (0xffful << PWM_DTCTL2_3_DTCNT_Pos)               /*!< PWM_T::DTCTL2_3: DTCNT Mask               */
N
N#define PWM_DTCTL2_3_DTEN_Pos            (16)                                              /*!< PWM_T::DTCTL2_3: DTEN Position            */
N#define PWM_DTCTL2_3_DTEN_Msk            (0x1ul << PWM_DTCTL2_3_DTEN_Pos)                  /*!< PWM_T::DTCTL2_3: DTEN Mask                */
N
N#define PWM_DTCTL2_3_DTCKSEL_Pos         (24)                                              /*!< PWM_T::DTCTL2_3: DTCKSEL Position         */
N#define PWM_DTCTL2_3_DTCKSEL_Msk         (0x1ul << PWM_DTCTL2_3_DTCKSEL_Pos)               /*!< PWM_T::DTCTL2_3: DTCKSEL Mask             */
N
N#define PWM_DTCTL4_5_DTCNT_Pos           (0)                                               /*!< PWM_T::DTCTL4_5: DTCNT Position           */
N#define PWM_DTCTL4_5_DTCNT_Msk           (0xffful << PWM_DTCTL4_5_DTCNT_Pos)               /*!< PWM_T::DTCTL4_5: DTCNT Mask               */
N
N#define PWM_DTCTL4_5_DTEN_Pos            (16)                                              /*!< PWM_T::DTCTL4_5: DTEN Position            */
N#define PWM_DTCTL4_5_DTEN_Msk            (0x1ul << PWM_DTCTL4_5_DTEN_Pos)                  /*!< PWM_T::DTCTL4_5: DTEN Mask                */
N
N#define PWM_DTCTL4_5_DTCKSEL_Pos         (24)                                              /*!< PWM_T::DTCTL4_5: DTCKSEL Position         */
N#define PWM_DTCTL4_5_DTCKSEL_Msk         (0x1ul << PWM_DTCTL4_5_DTCKSEL_Pos)               /*!< PWM_T::DTCTL4_5: DTCKSEL Mask             */
N
N#define PWM_PHS0_1_PHS_Pos               (0)                                               /*!< PWM_T::PHS0_1: PHS Position               */
N#define PWM_PHS0_1_PHS_Msk               (0xfffful << PWM_PHS0_1_PHS_Pos)                  /*!< PWM_T::PHS0_1: PHS Mask                   */
N
N#define PWM_PHS2_3_PHS_Pos               (0)                                               /*!< PWM_T::PHS2_3: PHS Position               */
N#define PWM_PHS2_3_PHS_Msk               (0xfffful << PWM_PHS2_3_PHS_Pos)                  /*!< PWM_T::PHS2_3: PHS Mask                   */
N
N#define PWM_PHS4_5_PHS_Pos               (0)                                               /*!< PWM_T::PHS4_5: PHS Position               */
N#define PWM_PHS4_5_PHS_Msk               (0xfffful << PWM_PHS4_5_PHS_Pos)                  /*!< PWM_T::PHS4_5: PHS Mask                   */
N
N#define PWM_CNT_CNT_Pos                  (0)                                               /*!< PWM_T::CNT: CNT Position                  */
N#define PWM_CNT_CNT_Msk                  (0xfffful << PWM_CNT_CNT_Pos)                     /*!< PWM_T::CNT: CNT Mask                      */
N
N#define PWM_CNT_DIRF_Pos                 (16)                                              /*!< PWM_T::CNT: DIRF Position                 */
N#define PWM_CNT_DIRF_Msk                 (0x1ul << PWM_CNT_DIRF_Pos)                       /*!< PWM_T::CNT: DIRF Mask                     */
N
N#define PWM_WGCTL0_ZPCTLn_Pos            (0)                                               /*!< PWM_T::WGCTL0: ZPCTLn Position            */
N#define PWM_WGCTL0_ZPCTLn_Msk            (0xffful << PWM_WGCTL0_ZPCTLn_Pos)                /*!< PWM_T::WGCTL0: ZPCTLn Mask                */
N
N#define PWM_WGCTL0_ZPCTL0_Pos            (0)                                               /*!< PWM_T::WGCTL0: ZPCTL0 Position            */
N#define PWM_WGCTL0_ZPCTL0_Msk            (0x3ul << PWM_WGCTL0_ZPCTL0_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL0 Mask                */
N
N#define PWM_WGCTL0_ZPCTL1_Pos            (2)                                               /*!< PWM_T::WGCTL0: ZPCTL1 Position            */
N#define PWM_WGCTL0_ZPCTL1_Msk            (0x3ul << PWM_WGCTL0_ZPCTL1_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL1 Mask                */
N
N#define PWM_WGCTL0_ZPCTL2_Pos            (4)                                               /*!< PWM_T::WGCTL0: ZPCTL2 Position            */
N#define PWM_WGCTL0_ZPCTL2_Msk            (0x3ul << PWM_WGCTL0_ZPCTL2_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL2 Mask                */
N
N#define PWM_WGCTL0_ZPCTL3_Pos            (6)                                               /*!< PWM_T::WGCTL0: ZPCTL3 Position            */
N#define PWM_WGCTL0_ZPCTL3_Msk            (0x3ul << PWM_WGCTL0_ZPCTL3_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL3 Mask                */
N
N#define PWM_WGCTL0_ZPCTL4_Pos            (8)                                               /*!< PWM_T::WGCTL0: ZPCTL4 Position            */
N#define PWM_WGCTL0_ZPCTL4_Msk            (0x3ul << PWM_WGCTL0_ZPCTL4_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL4 Mask                */
N
N#define PWM_WGCTL0_ZPCTL5_Pos            (10)                                              /*!< PWM_T::WGCTL0: ZPCTL5 Position            */
N#define PWM_WGCTL0_ZPCTL5_Msk            (0x3ul << PWM_WGCTL0_ZPCTL5_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL5 Mask                */
N
N#define PWM_WGCTL0_PRDPCTLn_Pos          (16)                                              /*!< PWM_T::WGCTL0: PRDPCTLn Position          */
N#define PWM_WGCTL0_PRDPCTLn_Msk          (0xffful << PWM_WGCTL0_PRDPCTLn_Pos)              /*!< PWM_T::WGCTL0: PRDPCTLn Mask              */
N
N#define PWM_WGCTL0_PRDPCTL0_Pos          (16)                                              /*!< PWM_T::WGCTL0: PRDPCTL0 Position          */
N#define PWM_WGCTL0_PRDPCTL0_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL0_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL0 Mask              */
N
N#define PWM_WGCTL0_PRDPCTL1_Pos          (18)                                              /*!< PWM_T::WGCTL0: PRDPCTL1 Position          */
N#define PWM_WGCTL0_PRDPCTL1_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL1_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL1 Mask              */
N
N#define PWM_WGCTL0_PRDPCTL2_Pos          (20)                                              /*!< PWM_T::WGCTL0: PRDPCTL2 Position          */
N#define PWM_WGCTL0_PRDPCTL2_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL2_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL2 Mask              */
N
N#define PWM_WGCTL0_PRDPCTL3_Pos          (22)                                              /*!< PWM_T::WGCTL0: PRDPCTL3 Position          */
N#define PWM_WGCTL0_PRDPCTL3_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL3_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL3 Mask              */
N
N#define PWM_WGCTL0_PRDPCTL4_Pos          (24)                                              /*!< PWM_T::WGCTL0: PRDPCTL4 Position          */
N#define PWM_WGCTL0_PRDPCTL4_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL4_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL4 Mask              */
N
N#define PWM_WGCTL0_PRDPCTL5_Pos          (26)                                              /*!< PWM_T::WGCTL0: PRDPCTL5 Position          */
N#define PWM_WGCTL0_PRDPCTL5_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL5_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL5 Mask              */
N
N#define PWM_WGCTL1_CMPUCTLn_Pos          (0)                                               /*!< PWM_T::WGCTL1: CMPUCTLn Position          */
N#define PWM_WGCTL1_CMPUCTLn_Msk          (0xffful << PWM_WGCTL1_CMPUCTLn_Pos)              /*!< PWM_T::WGCTL1: CMPUCTLn Mask              */
N
N#define PWM_WGCTL1_CMPUCTL0_Pos          (0)                                               /*!< PWM_T::WGCTL1: CMPUCTL0 Position          */
N#define PWM_WGCTL1_CMPUCTL0_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL0_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL0 Mask              */
N
N#define PWM_WGCTL1_CMPUCTL1_Pos          (2)                                               /*!< PWM_T::WGCTL1: CMPUCTL1 Position          */
N#define PWM_WGCTL1_CMPUCTL1_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL1_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL1 Mask              */
N
N#define PWM_WGCTL1_CMPUCTL2_Pos          (4)                                               /*!< PWM_T::WGCTL1: CMPUCTL2 Position          */
N#define PWM_WGCTL1_CMPUCTL2_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL2_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL2 Mask              */
N
N#define PWM_WGCTL1_CMPUCTL3_Pos          (6)                                               /*!< PWM_T::WGCTL1: CMPUCTL3 Position          */
N#define PWM_WGCTL1_CMPUCTL3_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL3_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL3 Mask              */
N
N#define PWM_WGCTL1_CMPUCTL4_Pos          (8)                                               /*!< PWM_T::WGCTL1: CMPUCTL4 Position          */
N#define PWM_WGCTL1_CMPUCTL4_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL4_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL4 Mask              */
N
N#define PWM_WGCTL1_CMPUCTL5_Pos          (10)                                              /*!< PWM_T::WGCTL1: CMPUCTL5 Position          */
N#define PWM_WGCTL1_CMPUCTL5_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL5_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL5 Mask              */
N
N#define PWM_WGCTL1_CMPDCTLn_Pos          (16)                                              /*!< PWM_T::WGCTL1: CMPDCTLn Position          */
N#define PWM_WGCTL1_CMPDCTLn_Msk          (0xffful << PWM_WGCTL1_CMPDCTLn_Pos)              /*!< PWM_T::WGCTL1: CMPDCTLn Mask              */
N
N#define PWM_WGCTL1_CMPDCTL0_Pos          (16)                                              /*!< PWM_T::WGCTL1: CMPDCTL0 Position          */
N#define PWM_WGCTL1_CMPDCTL0_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL0_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL0 Mask              */
N
N#define PWM_WGCTL1_CMPDCTL1_Pos          (18)                                              /*!< PWM_T::WGCTL1: CMPDCTL1 Position          */
N#define PWM_WGCTL1_CMPDCTL1_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL1_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL1 Mask              */
N
N#define PWM_WGCTL1_CMPDCTL2_Pos          (20)                                              /*!< PWM_T::WGCTL1: CMPDCTL2 Position          */
N#define PWM_WGCTL1_CMPDCTL2_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL2_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL2 Mask              */
N
N#define PWM_WGCTL1_CMPDCTL3_Pos          (22)                                              /*!< PWM_T::WGCTL1: CMPDCTL3 Position          */
N#define PWM_WGCTL1_CMPDCTL3_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL3_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL3 Mask              */
N
N#define PWM_WGCTL1_CMPDCTL4_Pos          (24)                                              /*!< PWM_T::WGCTL1: CMPDCTL4 Position          */
N#define PWM_WGCTL1_CMPDCTL4_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL4_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL4 Mask              */
N
N#define PWM_WGCTL1_CMPDCTL5_Pos          (26)                                              /*!< PWM_T::WGCTL1: CMPDCTL5 Position          */
N#define PWM_WGCTL1_CMPDCTL5_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL5_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL5 Mask              */
N
N#define PWM_MSKEN_MSKENn_Pos             (0)                                               /*!< PWM_T::MSKEN: MSKENn Position             */
N#define PWM_MSKEN_MSKENn_Msk             (0x3ful << PWM_MSKEN_MSKENn_Pos)                  /*!< PWM_T::MSKEN: MSKENn Mask                 */
N
N#define PWM_MSKEN_MSKEN0_Pos             (0)                                               /*!< PWM_T::MSKEN: MSKEN0 Position             */
N#define PWM_MSKEN_MSKEN0_Msk             (0x1ul << PWM_MSKEN_MSKEN0_Pos)                   /*!< PWM_T::MSKEN: MSKEN0 Mask                 */
N
N#define PWM_MSKEN_MSKEN1_Pos             (1)                                               /*!< PWM_T::MSKEN: MSKEN1 Position             */
N#define PWM_MSKEN_MSKEN1_Msk             (0x1ul << PWM_MSKEN_MSKEN1_Pos)                   /*!< PWM_T::MSKEN: MSKEN1 Mask                 */
N
N#define PWM_MSKEN_MSKEN2_Pos             (2)                                               /*!< PWM_T::MSKEN: MSKEN2 Position             */
N#define PWM_MSKEN_MSKEN2_Msk             (0x1ul << PWM_MSKEN_MSKEN2_Pos)                   /*!< PWM_T::MSKEN: MSKEN2 Mask                 */
N
N#define PWM_MSKEN_MSKEN3_Pos             (3)                                               /*!< PWM_T::MSKEN: MSKEN3 Position             */
N#define PWM_MSKEN_MSKEN3_Msk             (0x1ul << PWM_MSKEN_MSKEN3_Pos)                   /*!< PWM_T::MSKEN: MSKEN3 Mask                 */
N
N#define PWM_MSKEN_MSKEN4_Pos             (4)                                               /*!< PWM_T::MSKEN: MSKEN4 Position             */
N#define PWM_MSKEN_MSKEN4_Msk             (0x1ul << PWM_MSKEN_MSKEN4_Pos)                   /*!< PWM_T::MSKEN: MSKEN4 Mask                 */
N
N#define PWM_MSKEN_MSKEN5_Pos             (5)                                               /*!< PWM_T::MSKEN: MSKEN5 Position             */
N#define PWM_MSKEN_MSKEN5_Msk             (0x1ul << PWM_MSKEN_MSKEN5_Pos)                   /*!< PWM_T::MSKEN: MSKEN5 Mask                 */
N
N#define PWM_MSK_MSKDATn_Pos              (0)                                               /*!< PWM_T::MSK: MSKDATn Position              */
N#define PWM_MSK_MSKDATn_Msk              (0x3ful << PWM_MSK_MSKDATn_Pos)                   /*!< PWM_T::MSK: MSKDATn Mask                  */
N
N#define PWM_MSK_MSKDAT0_Pos              (0)                                               /*!< PWM_T::MSK: MSKDAT0 Position              */
N#define PWM_MSK_MSKDAT0_Msk              (0x1ul << PWM_MSK_MSKDAT0_Pos)                    /*!< PWM_T::MSK: MSKDAT0 Mask                  */
N
N#define PWM_MSK_MSKDAT1_Pos              (1)                                               /*!< PWM_T::MSK: MSKDAT1 Position              */
N#define PWM_MSK_MSKDAT1_Msk              (0x1ul << PWM_MSK_MSKDAT1_Pos)                    /*!< PWM_T::MSK: MSKDAT1 Mask                  */
N
N#define PWM_MSK_MSKDAT2_Pos              (2)                                               /*!< PWM_T::MSK: MSKDAT2 Position              */
N#define PWM_MSK_MSKDAT2_Msk              (0x1ul << PWM_MSK_MSKDAT2_Pos)                    /*!< PWM_T::MSK: MSKDAT2 Mask                  */
N
N#define PWM_MSK_MSKDAT3_Pos              (3)                                               /*!< PWM_T::MSK: MSKDAT3 Position              */
N#define PWM_MSK_MSKDAT3_Msk              (0x1ul << PWM_MSK_MSKDAT3_Pos)                    /*!< PWM_T::MSK: MSKDAT3 Mask                  */
N
N#define PWM_MSK_MSKDAT4_Pos              (4)                                               /*!< PWM_T::MSK: MSKDAT4 Position              */
N#define PWM_MSK_MSKDAT4_Msk              (0x1ul << PWM_MSK_MSKDAT4_Pos)                    /*!< PWM_T::MSK: MSKDAT4 Mask                  */
N
N#define PWM_MSK_MSKDAT5_Pos              (5)                                               /*!< PWM_T::MSK: MSKDAT5 Position              */
N#define PWM_MSK_MSKDAT5_Msk              (0x1ul << PWM_MSK_MSKDAT5_Pos)                    /*!< PWM_T::MSK: MSKDAT5 Mask                  */
N
N#define PWM_BNF_BRK0NFEN_Pos             (0)                                               /*!< PWM_T::BNF: BRK0NFEN Position             */
N#define PWM_BNF_BRK0NFEN_Msk             (0x1ul << PWM_BNF_BRK0NFEN_Pos)                   /*!< PWM_T::BNF: BRK0NFEN Mask                 */
N
N#define PWM_BNF_BRK0NFSEL_Pos            (1)                                               /*!< PWM_T::BNF: BRK0NFSEL Position            */
N#define PWM_BNF_BRK0NFSEL_Msk            (0x7ul << PWM_BNF_BRK0NFSEL_Pos)                  /*!< PWM_T::BNF: BRK0NFSEL Mask                */
N
N#define PWM_BNF_BRK0FCNT_Pos             (4)                                               /*!< PWM_T::BNF: BRK0FCNT Position             */
N#define PWM_BNF_BRK0FCNT_Msk             (0x7ul << PWM_BNF_BRK0FCNT_Pos)                   /*!< PWM_T::BNF: BRK0FCNT Mask                 */
N
N#define PWM_BNF_BRK0PINV_Pos             (7)                                               /*!< PWM_T::BNF: BRK0PINV Position             */
N#define PWM_BNF_BRK0PINV_Msk             (0x1ul << PWM_BNF_BRK0PINV_Pos)                   /*!< PWM_T::BNF: BRK0PINV Mask                 */
N
N#define PWM_BNF_BRK1NFEN_Pos             (8)                                               /*!< PWM_T::BNF: BRK1NFEN Position             */
N#define PWM_BNF_BRK1NFEN_Msk             (0x1ul << PWM_BNF_BRK1NFEN_Pos)                   /*!< PWM_T::BNF: BRK1NFEN Mask                 */
N
N#define PWM_BNF_BRK1NFSEL_Pos            (9)                                               /*!< PWM_T::BNF: BRK1NFSEL Position            */
N#define PWM_BNF_BRK1NFSEL_Msk            (0x7ul << PWM_BNF_BRK1NFSEL_Pos)                  /*!< PWM_T::BNF: BRK1NFSEL Mask                */
N
N#define PWM_BNF_BRK1FCNT_Pos             (12)                                              /*!< PWM_T::BNF: BRK1FCNT Position             */
N#define PWM_BNF_BRK1FCNT_Msk             (0x7ul << PWM_BNF_BRK1FCNT_Pos)                   /*!< PWM_T::BNF: BRK1FCNT Mask                 */
N
N#define PWM_BNF_BRK1PINV_Pos             (15)                                              /*!< PWM_T::BNF: BRK1PINV Position             */
N#define PWM_BNF_BRK1PINV_Msk             (0x1ul << PWM_BNF_BRK1PINV_Pos)                   /*!< PWM_T::BNF: BRK1PINV Mask                 */
N
N#define PWM_BNF_BK0SRC_Pos               (16)                                              /*!< PWM_T::BNF: BK0SRC Position               */
N#define PWM_BNF_BK0SRC_Msk               (0x1ul << PWM_BNF_BK0SRC_Pos)                     /*!< PWM_T::BNF: BK0SRC Mask                   */
N
N#define PWM_BNF_BK1SRC_Pos               (24)                                              /*!< PWM_T::BNF: BK1SRC Position               */
N#define PWM_BNF_BK1SRC_Msk               (0x1ul << PWM_BNF_BK1SRC_Pos)                     /*!< PWM_T::BNF: BK1SRC Mask                   */
N
N#define PWM_FAILBRK_CSSBRKEN_Pos         (0)                                               /*!< PWM_T::FAILBRK: CSSBRKEN Position         */
N#define PWM_FAILBRK_CSSBRKEN_Msk         (0x1ul << PWM_FAILBRK_CSSBRKEN_Pos)               /*!< PWM_T::FAILBRK: CSSBRKEN Mask             */
N
N#define PWM_FAILBRK_BODBRKEN_Pos         (1)                                               /*!< PWM_T::FAILBRK: BODBRKEN Position         */
N#define PWM_FAILBRK_BODBRKEN_Msk         (0x1ul << PWM_FAILBRK_BODBRKEN_Pos)               /*!< PWM_T::FAILBRK: BODBRKEN Mask             */
N
N#define PWM_FAILBRK_RAMBRKEN_Pos         (2)                                               /*!< PWM_T::FAILBRK: RAMBRKEN Position         */
N#define PWM_FAILBRK_RAMBRKEN_Msk         (0x1ul << PWM_FAILBRK_RAMBRKEN_Pos)               /*!< PWM_T::FAILBRK: RAMBRKEN Mask             */
N
N#define PWM_FAILBRK_CORBRKEN_Pos         (3)                                               /*!< PWM_T::FAILBRK: CORBRKEN Position         */
N#define PWM_FAILBRK_CORBRKEN_Msk         (0x1ul << PWM_FAILBRK_CORBRKEN_Pos)               /*!< PWM_T::FAILBRK: CORBRKEN Mask             */
N
N#define PWM_BRKCTL0_1_CPO0EBEN_Pos       (0)                                               /*!< PWM_T::BRKCTL0_1: CPO0EBEN Position       */
N#define PWM_BRKCTL0_1_CPO0EBEN_Msk       (0x1ul << PWM_BRKCTL0_1_CPO0EBEN_Pos)             /*!< PWM_T::BRKCTL0_1: CPO0EBEN Mask           */
N
N#define PWM_BRKCTL0_1_CPO1EBEN_Pos       (1)                                               /*!< PWM_T::BRKCTL0_1: CPO1EBEN Position       */
N#define PWM_BRKCTL0_1_CPO1EBEN_Msk       (0x1ul << PWM_BRKCTL0_1_CPO1EBEN_Pos)             /*!< PWM_T::BRKCTL0_1: CPO1EBEN Mask           */
N
N#define PWM_BRKCTL0_1_BRKP0EEN_Pos       (4)                                               /*!< PWM_T::BRKCTL0_1: BRKP0EEN Position       */
N#define PWM_BRKCTL0_1_BRKP0EEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP0EEN_Pos)             /*!< PWM_T::BRKCTL0_1: BRKP0EEN Mask           */
N
N#define PWM_BRKCTL0_1_BRKP1EEN_Pos       (5)                                               /*!< PWM_T::BRKCTL0_1: BRKP1EEN Position       */
N#define PWM_BRKCTL0_1_BRKP1EEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP1EEN_Pos)             /*!< PWM_T::BRKCTL0_1: BRKP1EEN Mask           */
N
N#define PWM_BRKCTL0_1_SYSEBEN_Pos        (7)                                               /*!< PWM_T::BRKCTL0_1: SYSEBEN Position        */
N#define PWM_BRKCTL0_1_SYSEBEN_Msk        (0x1ul << PWM_BRKCTL0_1_SYSEBEN_Pos)              /*!< PWM_T::BRKCTL0_1: SYSEBEN Mask            */
N
N#define PWM_BRKCTL0_1_CPO0LBEN_Pos       (8)                                               /*!< PWM_T::BRKCTL0_1: CPO0LBEN Position       */
N#define PWM_BRKCTL0_1_CPO0LBEN_Msk       (0x1ul << PWM_BRKCTL0_1_CPO0LBEN_Pos)             /*!< PWM_T::BRKCTL0_1: CPO0LBEN Mask           */
N
N#define PWM_BRKCTL0_1_CPO1LBEN_Pos       (9)                                               /*!< PWM_T::BRKCTL0_1: CPO1LBEN Position       */
N#define PWM_BRKCTL0_1_CPO1LBEN_Msk       (0x1ul << PWM_BRKCTL0_1_CPO1LBEN_Pos)             /*!< PWM_T::BRKCTL0_1: CPO1LBEN Mask           */
N
N#define PWM_BRKCTL0_1_BRKP0LEN_Pos       (12)                                              /*!< PWM_T::BRKCTL0_1: BRKP0LEN Position       */
N#define PWM_BRKCTL0_1_BRKP0LEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP0LEN_Pos)             /*!< PWM_T::BRKCTL0_1: BRKP0LEN Mask           */
N
N#define PWM_BRKCTL0_1_BRKP1LEN_Pos       (13)                                              /*!< PWM_T::BRKCTL0_1: BRKP1LEN Position       */
N#define PWM_BRKCTL0_1_BRKP1LEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP1LEN_Pos)             /*!< PWM_T::BRKCTL0_1: BRKP1LEN Mask           */
N
N#define PWM_BRKCTL0_1_SYSLBEN_Pos        (15)                                              /*!< PWM_T::BRKCTL0_1: SYSLBEN Position        */
N#define PWM_BRKCTL0_1_SYSLBEN_Msk        (0x1ul << PWM_BRKCTL0_1_SYSLBEN_Pos)              /*!< PWM_T::BRKCTL0_1: SYSLBEN Mask            */
N
N#define PWM_BRKCTL0_1_BRKAEVEN_Pos       (16)                                              /*!< PWM_T::BRKCTL0_1: BRKAEVEN Position       */
N#define PWM_BRKCTL0_1_BRKAEVEN_Msk       (0x3ul << PWM_BRKCTL0_1_BRKAEVEN_Pos)             /*!< PWM_T::BRKCTL0_1: BRKAEVEN Mask           */
N
N#define PWM_BRKCTL0_1_BRKAODD_Pos        (18)                                              /*!< PWM_T::BRKCTL0_1: BRKAODD Position        */
N#define PWM_BRKCTL0_1_BRKAODD_Msk        (0x3ul << PWM_BRKCTL0_1_BRKAODD_Pos)              /*!< PWM_T::BRKCTL0_1: BRKAODD Mask            */
N
N#define PWM_BRKCTL2_3_CPO0EBEN_Pos       (0)                                               /*!< PWM_T::BRKCTL2_3: CPO0EBEN Position       */
N#define PWM_BRKCTL2_3_CPO0EBEN_Msk       (0x1ul << PWM_BRKCTL2_3_CPO0EBEN_Pos)             /*!< PWM_T::BRKCTL2_3: CPO0EBEN Mask           */
N
N#define PWM_BRKCTL2_3_CPO1EBEN_Pos       (1)                                               /*!< PWM_T::BRKCTL2_3: CPO1EBEN Position       */
N#define PWM_BRKCTL2_3_CPO1EBEN_Msk       (0x1ul << PWM_BRKCTL2_3_CPO1EBEN_Pos)             /*!< PWM_T::BRKCTL2_3: CPO1EBEN Mask           */
N
N#define PWM_BRKCTL2_3_BRKP0EEN_Pos       (4)                                               /*!< PWM_T::BRKCTL2_3: BRKP0EEN Position       */
N#define PWM_BRKCTL2_3_BRKP0EEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP0EEN_Pos)             /*!< PWM_T::BRKCTL2_3: BRKP0EEN Mask           */
N
N#define PWM_BRKCTL2_3_BRKP1EEN_Pos       (5)                                               /*!< PWM_T::BRKCTL2_3: BRKP1EEN Position       */
N#define PWM_BRKCTL2_3_BRKP1EEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP1EEN_Pos)             /*!< PWM_T::BRKCTL2_3: BRKP1EEN Mask           */
N
N#define PWM_BRKCTL2_3_SYSEBEN_Pos        (7)                                               /*!< PWM_T::BRKCTL2_3: SYSEBEN Position        */
N#define PWM_BRKCTL2_3_SYSEBEN_Msk        (0x1ul << PWM_BRKCTL2_3_SYSEBEN_Pos)              /*!< PWM_T::BRKCTL2_3: SYSEBEN Mask            */
N
N#define PWM_BRKCTL2_3_CPO0LBEN_Pos       (8)                                               /*!< PWM_T::BRKCTL2_3: CPO0LBEN Position       */
N#define PWM_BRKCTL2_3_CPO0LBEN_Msk       (0x1ul << PWM_BRKCTL2_3_CPO0LBEN_Pos)             /*!< PWM_T::BRKCTL2_3: CPO0LBEN Mask           */
N
N#define PWM_BRKCTL2_3_CPO1LBEN_Pos       (9)                                               /*!< PWM_T::BRKCTL2_3: CPO1LBEN Position       */
N#define PWM_BRKCTL2_3_CPO1LBEN_Msk       (0x1ul << PWM_BRKCTL2_3_CPO1LBEN_Pos)             /*!< PWM_T::BRKCTL2_3: CPO1LBEN Mask           */
N
N#define PWM_BRKCTL2_3_BRKP0LEN_Pos       (12)                                              /*!< PWM_T::BRKCTL2_3: BRKP0LEN Position       */
N#define PWM_BRKCTL2_3_BRKP0LEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP0LEN_Pos)             /*!< PWM_T::BRKCTL2_3: BRKP0LEN Mask           */
N
N#define PWM_BRKCTL2_3_BRKP1LEN_Pos       (13)                                              /*!< PWM_T::BRKCTL2_3: BRKP1LEN Position       */
N#define PWM_BRKCTL2_3_BRKP1LEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP1LEN_Pos)             /*!< PWM_T::BRKCTL2_3: BRKP1LEN Mask           */
N
N#define PWM_BRKCTL2_3_SYSLBEN_Pos        (15)                                              /*!< PWM_T::BRKCTL2_3: SYSLBEN Position        */
N#define PWM_BRKCTL2_3_SYSLBEN_Msk        (0x1ul << PWM_BRKCTL2_3_SYSLBEN_Pos)              /*!< PWM_T::BRKCTL2_3: SYSLBEN Mask            */
N
N#define PWM_BRKCTL2_3_BRKAEVEN_Pos       (16)                                              /*!< PWM_T::BRKCTL2_3: BRKAEVEN Position       */
N#define PWM_BRKCTL2_3_BRKAEVEN_Msk       (0x3ul << PWM_BRKCTL2_3_BRKAEVEN_Pos)             /*!< PWM_T::BRKCTL2_3: BRKAEVEN Mask           */
N
N#define PWM_BRKCTL2_3_BRKAODD_Pos        (18)                                              /*!< PWM_T::BRKCTL2_3: BRKAODD Position        */
N#define PWM_BRKCTL2_3_BRKAODD_Msk        (0x3ul << PWM_BRKCTL2_3_BRKAODD_Pos)              /*!< PWM_T::BRKCTL2_3: BRKAODD Mask            */
N
N#define PWM_BRKCTL4_5_CPO0EBEN_Pos       (0)                                               /*!< PWM_T::BRKCTL4_5: CPO0EBEN Position       */
N#define PWM_BRKCTL4_5_CPO0EBEN_Msk       (0x1ul << PWM_BRKCTL4_5_CPO0EBEN_Pos)             /*!< PWM_T::BRKCTL4_5: CPO0EBEN Mask           */
N
N#define PWM_BRKCTL4_5_CPO1EBEN_Pos       (1)                                               /*!< PWM_T::BRKCTL4_5: CPO1EBEN Position       */
N#define PWM_BRKCTL4_5_CPO1EBEN_Msk       (0x1ul << PWM_BRKCTL4_5_CPO1EBEN_Pos)             /*!< PWM_T::BRKCTL4_5: CPO1EBEN Mask           */
N
N#define PWM_BRKCTL4_5_BRKP0EEN_Pos       (4)                                               /*!< PWM_T::BRKCTL4_5: BRKP0EEN Position       */
N#define PWM_BRKCTL4_5_BRKP0EEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP0EEN_Pos)             /*!< PWM_T::BRKCTL4_5: BRKP0EEN Mask           */
N
N#define PWM_BRKCTL4_5_BRKP1EEN_Pos       (5)                                               /*!< PWM_T::BRKCTL4_5: BRKP1EEN Position       */
N#define PWM_BRKCTL4_5_BRKP1EEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP1EEN_Pos)             /*!< PWM_T::BRKCTL4_5: BRKP1EEN Mask           */
N
N#define PWM_BRKCTL4_5_SYSEBEN_Pos        (7)                                               /*!< PWM_T::BRKCTL4_5: SYSEBEN Position        */
N#define PWM_BRKCTL4_5_SYSEBEN_Msk        (0x1ul << PWM_BRKCTL4_5_SYSEBEN_Pos)              /*!< PWM_T::BRKCTL4_5: SYSEBEN Mask            */
N
N#define PWM_BRKCTL4_5_CPO0LBEN_Pos       (8)                                               /*!< PWM_T::BRKCTL4_5: CPO0LBEN Position       */
N#define PWM_BRKCTL4_5_CPO0LBEN_Msk       (0x1ul << PWM_BRKCTL4_5_CPO0LBEN_Pos)             /*!< PWM_T::BRKCTL4_5: CPO0LBEN Mask           */
N
N#define PWM_BRKCTL4_5_CPO1LBEN_Pos       (9)                                               /*!< PWM_T::BRKCTL4_5: CPO1LBEN Position       */
N#define PWM_BRKCTL4_5_CPO1LBEN_Msk       (0x1ul << PWM_BRKCTL4_5_CPO1LBEN_Pos)             /*!< PWM_T::BRKCTL4_5: CPO1LBEN Mask           */
N
N#define PWM_BRKCTL4_5_BRKP0LEN_Pos       (12)                                              /*!< PWM_T::BRKCTL4_5: BRKP0LEN Position       */
N#define PWM_BRKCTL4_5_BRKP0LEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP0LEN_Pos)             /*!< PWM_T::BRKCTL4_5: BRKP0LEN Mask           */
N
N#define PWM_BRKCTL4_5_BRKP1LEN_Pos       (13)                                              /*!< PWM_T::BRKCTL4_5: BRKP1LEN Position       */
N#define PWM_BRKCTL4_5_BRKP1LEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP1LEN_Pos)             /*!< PWM_T::BRKCTL4_5: BRKP1LEN Mask           */
N
N#define PWM_BRKCTL4_5_SYSLBEN_Pos        (15)                                              /*!< PWM_T::BRKCTL4_5: SYSLBEN Position        */
N#define PWM_BRKCTL4_5_SYSLBEN_Msk        (0x1ul << PWM_BRKCTL4_5_SYSLBEN_Pos)              /*!< PWM_T::BRKCTL4_5: SYSLBEN Mask            */
N
N#define PWM_BRKCTL4_5_BRKAEVEN_Pos       (16)                                              /*!< PWM_T::BRKCTL4_5: BRKAEVEN Position       */
N#define PWM_BRKCTL4_5_BRKAEVEN_Msk       (0x3ul << PWM_BRKCTL4_5_BRKAEVEN_Pos)             /*!< PWM_T::BRKCTL4_5: BRKAEVEN Mask           */
N
N#define PWM_BRKCTL4_5_BRKAODD_Pos        (18)                                              /*!< PWM_T::BRKCTL4_5: BRKAODD Position        */
N#define PWM_BRKCTL4_5_BRKAODD_Msk        (0x3ul << PWM_BRKCTL4_5_BRKAODD_Pos)              /*!< PWM_T::BRKCTL4_5: BRKAODD Mask            */
N
N#define PWM_POLCTL_PINVn_Pos             (0)                                               /*!< PWM_T::POLCTL: PINVn Position             */
N#define PWM_POLCTL_PINVn_Msk             (0x3ful << PWM_POLCTL_PINVn_Pos)                  /*!< PWM_T::POLCTL: PINVn Mask                 */
N
N#define PWM_POLCTL_PINV0_Pos             (0)                                               /*!< PWM_T::POLCTL: PINV0 Position             */
N#define PWM_POLCTL_PINV0_Msk             (0x1ul << PWM_POLCTL_PINV0_Pos)                   /*!< PWM_T::POLCTL: PINV0 Mask                 */
N
N#define PWM_POLCTL_PINV1_Pos             (1)                                               /*!< PWM_T::POLCTL: PINV1 Position             */
N#define PWM_POLCTL_PINV1_Msk             (0x1ul << PWM_POLCTL_PINV1_Pos)                   /*!< PWM_T::POLCTL: PINV1 Mask                 */
N
N#define PWM_POLCTL_PINV2_Pos             (2)                                               /*!< PWM_T::POLCTL: PINV2 Position             */
N#define PWM_POLCTL_PINV2_Msk             (0x1ul << PWM_POLCTL_PINV2_Pos)                   /*!< PWM_T::POLCTL: PINV2 Mask                 */
N
N#define PWM_POLCTL_PINV3_Pos             (3)                                               /*!< PWM_T::POLCTL: PINV3 Position             */
N#define PWM_POLCTL_PINV3_Msk             (0x1ul << PWM_POLCTL_PINV3_Pos)                   /*!< PWM_T::POLCTL: PINV3 Mask                 */
N
N#define PWM_POLCTL_PINV4_Pos             (4)                                               /*!< PWM_T::POLCTL: PINV4 Position             */
N#define PWM_POLCTL_PINV4_Msk             (0x1ul << PWM_POLCTL_PINV4_Pos)                   /*!< PWM_T::POLCTL: PINV4 Mask                 */
N
N#define PWM_POLCTL_PINV5_Pos             (5)                                               /*!< PWM_T::POLCTL: PINV5 Position             */
N#define PWM_POLCTL_PINV5_Msk             (0x1ul << PWM_POLCTL_PINV5_Pos)                   /*!< PWM_T::POLCTL: PINV5 Mask                 */
N
N#define PWM_POEN_POENn_Pos               (0)                                               /*!< PWM_T::POEN: POENn Position               */
N#define PWM_POEN_POENn_Msk               (0x3ful << PWM_POEN_POENn_Pos)                    /*!< PWM_T::POEN: POENn Mask                   */
N
N#define PWM_POEN_POEN0_Pos               (0)                                               /*!< PWM_T::POEN: POEN0 Position               */
N#define PWM_POEN_POEN0_Msk               (0x1ul << PWM_POEN_POEN0_Pos)                     /*!< PWM_T::POEN: POEN0 Mask                   */
N
N#define PWM_POEN_POEN1_Pos               (1)                                               /*!< PWM_T::POEN: POEN1 Position               */
N#define PWM_POEN_POEN1_Msk               (0x1ul << PWM_POEN_POEN1_Pos)                     /*!< PWM_T::POEN: POEN1 Mask                   */
N
N#define PWM_POEN_POEN2_Pos               (2)                                               /*!< PWM_T::POEN: POEN2 Position               */
N#define PWM_POEN_POEN2_Msk               (0x1ul << PWM_POEN_POEN2_Pos)                     /*!< PWM_T::POEN: POEN2 Mask                   */
N
N#define PWM_POEN_POEN3_Pos               (3)                                               /*!< PWM_T::POEN: POEN3 Position               */
N#define PWM_POEN_POEN3_Msk               (0x1ul << PWM_POEN_POEN3_Pos)                     /*!< PWM_T::POEN: POEN3 Mask                   */
N
N#define PWM_POEN_POEN4_Pos               (4)                                               /*!< PWM_T::POEN: POEN4 Position               */
N#define PWM_POEN_POEN4_Msk               (0x1ul << PWM_POEN_POEN4_Pos)                     /*!< PWM_T::POEN: POEN4 Mask                   */
N
N#define PWM_POEN_POEN5_Pos               (5)                                               /*!< PWM_T::POEN: POEN5 Position               */
N#define PWM_POEN_POEN5_Msk               (0x1ul << PWM_POEN_POEN5_Pos)                     /*!< PWM_T::POEN: POEN5 Mask                   */
N
N#define PWM_SWBRK_BRKETRGn_Pos           (0)                                               /*!< PWM_T::SWBRK: BRKETRGn Position           */
N#define PWM_SWBRK_BRKETRGn_Msk           (0x7ul << PWM_SWBRK_BRKETRGn_Pos)                 /*!< PWM_T::SWBRK: BRKETRGn Mask               */
N
N#define PWM_SWBRK_BRKETRG0_Pos           (0)                                               /*!< PWM_T::SWBRK: BRKETRG0 Position           */
N#define PWM_SWBRK_BRKETRG0_Msk           (0x1ul << PWM_SWBRK_BRKETRG0_Pos)                 /*!< PWM_T::SWBRK: BRKETRG0 Mask               */
N
N#define PWM_SWBRK_BRKETRG2_Pos           (1)                                               /*!< PWM_T::SWBRK: BRKETRG2 Position           */
N#define PWM_SWBRK_BRKETRG2_Msk           (0x1ul << PWM_SWBRK_BRKETRG2_Pos)                 /*!< PWM_T::SWBRK: BRKETRG2 Mask               */
N
N#define PWM_SWBRK_BRKETRG4_Pos           (2)                                               /*!< PWM_T::SWBRK: BRKETRG4 Position           */
N#define PWM_SWBRK_BRKETRG4_Msk           (0x1ul << PWM_SWBRK_BRKETRG4_Pos)                 /*!< PWM_T::SWBRK: BRKETRG4 Mask               */
N
N#define PWM_SWBRK_BRKLTRGn_Pos           (8)                                               /*!< PWM_T::SWBRK: BRKLTRGn Position           */
N#define PWM_SWBRK_BRKLTRGn_Msk           (0x7ul << PWM_SWBRK_BRKLTRGn_Pos)                 /*!< PWM_T::SWBRK: BRKLTRGn Mask               */
N
N#define PWM_SWBRK_BRKLTRG0_Pos           (8)                                               /*!< PWM_T::SWBRK: BRKLTRG0 Position           */
N#define PWM_SWBRK_BRKLTRG0_Msk           (0x1ul << PWM_SWBRK_BRKLTRG0_Pos)                 /*!< PWM_T::SWBRK: BRKLTRG0 Mask               */
N
N#define PWM_SWBRK_BRKLTRG2_Pos           (9)                                               /*!< PWM_T::SWBRK: BRKLTRG2 Position           */
N#define PWM_SWBRK_BRKLTRG2_Msk           (0x1ul << PWM_SWBRK_BRKLTRG2_Pos)                 /*!< PWM_T::SWBRK: BRKLTRG2 Mask               */
N
N#define PWM_SWBRK_BRKLTRG4_Pos           (10)                                              /*!< PWM_T::SWBRK: BRKLTRG4 Position           */
N#define PWM_SWBRK_BRKLTRG4_Msk           (0x1ul << PWM_SWBRK_BRKLTRG4_Pos)                 /*!< PWM_T::SWBRK: BRKLTRG4 Mask               */
N
N#define PWM_INTEN0_ZIENn_Pos             (0)                                               /*!< PWM_T::INTEN0: ZIENn Position             */
N#define PWM_INTEN0_ZIENn_Msk             (0x3ful << PWM_INTEN0_ZIENn_Pos)                  /*!< PWM_T::INTEN0: ZIENn Mask                 */
N
N#define PWM_INTEN0_ZIEN0_Pos             (0)                                               /*!< PWM_T::INTEN0: ZIEN0 Position             */
N#define PWM_INTEN0_ZIEN0_Msk             (0x1ul << PWM_INTEN0_ZIEN0_Pos)                   /*!< PWM_T::INTEN0: ZIEN0 Mask                 */
N
N#define PWM_INTEN0_ZIEN1_Pos             (1)                                               /*!< PWM_T::INTEN0: ZIEN1 Position             */
N#define PWM_INTEN0_ZIEN1_Msk             (0x1ul << PWM_INTEN0_ZIEN1_Pos)                   /*!< PWM_T::INTEN0: ZIEN1 Mask                 */
N
N#define PWM_INTEN0_ZIEN2_Pos             (2)                                               /*!< PWM_T::INTEN0: ZIEN2 Position             */
N#define PWM_INTEN0_ZIEN2_Msk             (0x1ul << PWM_INTEN0_ZIEN2_Pos)                   /*!< PWM_T::INTEN0: ZIEN2 Mask                 */
N
N#define PWM_INTEN0_ZIEN3_Pos             (3)                                               /*!< PWM_T::INTEN0: ZIEN3 Position             */
N#define PWM_INTEN0_ZIEN3_Msk             (0x1ul << PWM_INTEN0_ZIEN3_Pos)                   /*!< PWM_T::INTEN0: ZIEN3 Mask                 */
N
N#define PWM_INTEN0_ZIEN4_Pos             (4)                                               /*!< PWM_T::INTEN0: ZIEN4 Position             */
N#define PWM_INTEN0_ZIEN4_Msk             (0x1ul << PWM_INTEN0_ZIEN4_Pos)                   /*!< PWM_T::INTEN0: ZIEN4 Mask                 */
N
N#define PWM_INTEN0_ZIEN5_Pos             (5)                                               /*!< PWM_T::INTEN0: ZIEN5 Position             */
N#define PWM_INTEN0_ZIEN5_Msk             (0x1ul << PWM_INTEN0_ZIEN5_Pos)                   /*!< PWM_T::INTEN0: ZIEN5 Mask                 */
N
N#define PWM_INTEN0_IFAIEN0_1_Pos         (7)                                               /*!< PWM_T::INTEN0: IFAIEN0_1 Position         */
N#define PWM_INTEN0_IFAIEN0_1_Msk         (0x1ul << PWM_INTEN0_IFAIEN0_1_Pos)               /*!< PWM_T::INTEN0: IFAIEN0_1 Mask             */
N
N#define PWM_INTEN0_PIENn_Pos             (8)                                               /*!< PWM_T::INTEN0: PIENn Position             */
N#define PWM_INTEN0_PIENn_Msk             (0x3ful << PWM_INTEN0_PIENn_Pos)                  /*!< PWM_T::INTEN0: PIENn Mask                 */
N
N#define PWM_INTEN0_PIEN0_Pos             (8)                                               /*!< PWM_T::INTEN0: PIEN0 Position             */
N#define PWM_INTEN0_PIEN0_Msk             (0x1ul << PWM_INTEN0_PIEN0_Pos)                   /*!< PWM_T::INTEN0: PIEN0 Mask                 */
N
N#define PWM_INTEN0_PIEN1_Pos             (9)                                               /*!< PWM_T::INTEN0: PIEN1 Position             */
N#define PWM_INTEN0_PIEN1_Msk             (0x1ul << PWM_INTEN0_PIEN1_Pos)                   /*!< PWM_T::INTEN0: PIEN1 Mask                 */
N
N#define PWM_INTEN0_PIEN2_Pos             (10)                                              /*!< PWM_T::INTEN0: PIEN2 Position             */
N#define PWM_INTEN0_PIEN2_Msk             (0x1ul << PWM_INTEN0_PIEN2_Pos)                   /*!< PWM_T::INTEN0: PIEN2 Mask                 */
N
N#define PWM_INTEN0_PIEN3_Pos             (11)                                              /*!< PWM_T::INTEN0: PIEN3 Position             */
N#define PWM_INTEN0_PIEN3_Msk             (0x1ul << PWM_INTEN0_PIEN3_Pos)                   /*!< PWM_T::INTEN0: PIEN3 Mask                 */
N
N#define PWM_INTEN0_PIEN4_Pos             (12)                                              /*!< PWM_T::INTEN0: PIEN4 Position             */
N#define PWM_INTEN0_PIEN4_Msk             (0x1ul << PWM_INTEN0_PIEN4_Pos)                   /*!< PWM_T::INTEN0: PIEN4 Mask                 */
N
N#define PWM_INTEN0_PIEN5_Pos             (13)                                              /*!< PWM_T::INTEN0: PIEN5 Position             */
N#define PWM_INTEN0_PIEN5_Msk             (0x1ul << PWM_INTEN0_PIEN5_Pos)                   /*!< PWM_T::INTEN0: PIEN5 Mask                 */
N
N#define PWM_INTEN0_IFAIEN2_3_Pos         (15)                                              /*!< PWM_T::INTEN0: IFAIEN2_3 Position         */
N#define PWM_INTEN0_IFAIEN2_3_Msk         (0x1ul << PWM_INTEN0_IFAIEN2_3_Pos)               /*!< PWM_T::INTEN0: IFAIEN2_3 Mask             */
N
N#define PWM_INTEN0_CMPUIENn_Pos          (16)                                              /*!< PWM_T::INTEN0: CMPUIENn Position          */
N#define PWM_INTEN0_CMPUIENn_Msk          (0x3ful << PWM_INTEN0_CMPUIENn_Pos)               /*!< PWM_T::INTEN0: CMPUIENn Mask              */
N
N#define PWM_INTEN0_CMPUIEN0_Pos          (16)                                              /*!< PWM_T::INTEN0: CMPUIEN0 Position          */
N#define PWM_INTEN0_CMPUIEN0_Msk          (0x1ul << PWM_INTEN0_CMPUIEN0_Pos)                /*!< PWM_T::INTEN0: CMPUIEN0 Mask              */
N
N#define PWM_INTEN0_CMPUIEN1_Pos          (17)                                              /*!< PWM_T::INTEN0: CMPUIEN1 Position          */
N#define PWM_INTEN0_CMPUIEN1_Msk          (0x1ul << PWM_INTEN0_CMPUIEN1_Pos)                /*!< PWM_T::INTEN0: CMPUIEN1 Mask              */
N
N#define PWM_INTEN0_CMPUIEN2_Pos          (18)                                              /*!< PWM_T::INTEN0: CMPUIEN2 Position          */
N#define PWM_INTEN0_CMPUIEN2_Msk          (0x1ul << PWM_INTEN0_CMPUIEN2_Pos)                /*!< PWM_T::INTEN0: CMPUIEN2 Mask              */
N
N#define PWM_INTEN0_CMPUIEN3_Pos          (19)                                              /*!< PWM_T::INTEN0: CMPUIEN3 Position          */
N#define PWM_INTEN0_CMPUIEN3_Msk          (0x1ul << PWM_INTEN0_CMPUIEN3_Pos)                /*!< PWM_T::INTEN0: CMPUIEN3 Mask              */
N
N#define PWM_INTEN0_CMPUIEN4_Pos          (20)                                              /*!< PWM_T::INTEN0: CMPUIEN4 Position          */
N#define PWM_INTEN0_CMPUIEN4_Msk          (0x1ul << PWM_INTEN0_CMPUIEN4_Pos)                /*!< PWM_T::INTEN0: CMPUIEN4 Mask              */
N
N#define PWM_INTEN0_CMPUIEN5_Pos          (21)                                              /*!< PWM_T::INTEN0: CMPUIEN5 Position          */
N#define PWM_INTEN0_CMPUIEN5_Msk          (0x1ul << PWM_INTEN0_CMPUIEN5_Pos)                /*!< PWM_T::INTEN0: CMPUIEN5 Mask              */
N
N#define PWM_INTEN0_IFAIEN4_5_Pos         (23)                                              /*!< PWM_T::INTEN0: IFAIEN4_5 Position         */
N#define PWM_INTEN0_IFAIEN4_5_Msk         (0x1ul << PWM_INTEN0_IFAIEN4_5_Pos)               /*!< PWM_T::INTEN0: IFAIEN4_5 Mask             */
N
N#define PWM_INTEN0_CMPDIENn_Pos          (24)                                              /*!< PWM_T::INTEN0: CMPDIENn Position          */
N#define PWM_INTEN0_CMPDIENn_Msk          (0x3ful << PWM_INTEN0_CMPDIENn_Pos)               /*!< PWM_T::INTEN0: CMPDIENn Mask              */
N
N#define PWM_INTEN0_CMPDIEN0_Pos          (24)                                              /*!< PWM_T::INTEN0: CMPDIEN0 Position          */
N#define PWM_INTEN0_CMPDIEN0_Msk          (0x1ul << PWM_INTEN0_CMPDIEN0_Pos)                /*!< PWM_T::INTEN0: CMPDIEN0 Mask              */
N
N#define PWM_INTEN0_CMPDIEN1_Pos          (25)                                              /*!< PWM_T::INTEN0: CMPDIEN1 Position          */
N#define PWM_INTEN0_CMPDIEN1_Msk          (0x1ul << PWM_INTEN0_CMPDIEN1_Pos)                /*!< PWM_T::INTEN0: CMPDIEN1 Mask              */
N
N#define PWM_INTEN0_CMPDIEN2_Pos          (26)                                              /*!< PWM_T::INTEN0: CMPDIEN2 Position          */
N#define PWM_INTEN0_CMPDIEN2_Msk          (0x1ul << PWM_INTEN0_CMPDIEN2_Pos)                /*!< PWM_T::INTEN0: CMPDIEN2 Mask              */
N
N#define PWM_INTEN0_CMPDIEN3_Pos          (27)                                              /*!< PWM_T::INTEN0: CMPDIEN3 Position          */
N#define PWM_INTEN0_CMPDIEN3_Msk          (0x1ul << PWM_INTEN0_CMPDIEN3_Pos)                /*!< PWM_T::INTEN0: CMPDIEN3 Mask              */
N
N#define PWM_INTEN0_CMPDIEN4_Pos          (28)                                              /*!< PWM_T::INTEN0: CMPDIEN4 Position          */
N#define PWM_INTEN0_CMPDIEN4_Msk          (0x1ul << PWM_INTEN0_CMPDIEN4_Pos)                /*!< PWM_T::INTEN0: CMPDIEN4 Mask              */
N
N#define PWM_INTEN0_CMPDIEN5_Pos          (29)                                              /*!< PWM_T::INTEN0: CMPDIEN5 Position          */
N#define PWM_INTEN0_CMPDIEN5_Msk          (0x1ul << PWM_INTEN0_CMPDIEN5_Pos)                /*!< PWM_T::INTEN0: CMPDIEN5 Mask              */
N
N#define PWM_INTEN1_BRKEIEN0_1_Pos        (0)                                               /*!< PWM_T::INTEN1: BRKEIEN0_1 Position        */
N#define PWM_INTEN1_BRKEIEN0_1_Msk        (0x1ul << PWM_INTEN1_BRKEIEN0_1_Pos)              /*!< PWM_T::INTEN1: BRKEIEN0_1 Mask            */
N
N#define PWM_INTEN1_BRKEIEN2_3_Pos        (1)                                               /*!< PWM_T::INTEN1: BRKEIEN2_3 Position        */
N#define PWM_INTEN1_BRKEIEN2_3_Msk        (0x1ul << PWM_INTEN1_BRKEIEN2_3_Pos)              /*!< PWM_T::INTEN1: BRKEIEN2_3 Mask            */
N
N#define PWM_INTEN1_BRKEIEN4_5_Pos        (2)                                               /*!< PWM_T::INTEN1: BRKEIEN4_5 Position        */
N#define PWM_INTEN1_BRKEIEN4_5_Msk        (0x1ul << PWM_INTEN1_BRKEIEN4_5_Pos)              /*!< PWM_T::INTEN1: BRKEIEN4_5 Mask            */
N
N#define PWM_INTEN1_BRKLIEN0_1_Pos        (8)                                               /*!< PWM_T::INTEN1: BRKLIEN0_1 Position        */
N#define PWM_INTEN1_BRKLIEN0_1_Msk        (0x1ul << PWM_INTEN1_BRKLIEN0_1_Pos)              /*!< PWM_T::INTEN1: BRKLIEN0_1 Mask            */
N
N#define PWM_INTEN1_BRKLIEN2_3_Pos        (9)                                               /*!< PWM_T::INTEN1: BRKLIEN2_3 Position        */
N#define PWM_INTEN1_BRKLIEN2_3_Msk        (0x1ul << PWM_INTEN1_BRKLIEN2_3_Pos)              /*!< PWM_T::INTEN1: BRKLIEN2_3 Mask            */
N
N#define PWM_INTEN1_BRKLIEN4_5_Pos        (10)                                              /*!< PWM_T::INTEN1: BRKLIEN4_5 Position        */
N#define PWM_INTEN1_BRKLIEN4_5_Msk        (0x1ul << PWM_INTEN1_BRKLIEN4_5_Pos)              /*!< PWM_T::INTEN1: BRKLIEN4_5 Mask            */
N
N#define PWM_INTSTS0_ZIFn_Pos             (0)                                               /*!< PWM_T::INTSTS0: ZIFn Position             */
N#define PWM_INTSTS0_ZIFn_Msk             (0x3ful << PWM_INTSTS0_ZIFn_Pos)                  /*!< PWM_T::INTSTS0: ZIFn Mask                 */
N
N#define PWM_INTSTS0_ZIF0_Pos             (0)                                               /*!< PWM_T::INTSTS0: ZIF0 Position             */
N#define PWM_INTSTS0_ZIF0_Msk             (0x1ul << PWM_INTSTS0_ZIF0_Pos)                   /*!< PWM_T::INTSTS0: ZIF0 Mask                 */
N
N#define PWM_INTSTS0_ZIF1_Pos             (1)                                               /*!< PWM_T::INTSTS0: ZIF1 Position             */
N#define PWM_INTSTS0_ZIF1_Msk             (0x1ul << PWM_INTSTS0_ZIF1_Pos)                   /*!< PWM_T::INTSTS0: ZIF1 Mask                 */
N
N#define PWM_INTSTS0_ZIF2_Pos             (2)                                               /*!< PWM_T::INTSTS0: ZIF2 Position             */
N#define PWM_INTSTS0_ZIF2_Msk             (0x1ul << PWM_INTSTS0_ZIF2_Pos)                   /*!< PWM_T::INTSTS0: ZIF2 Mask                 */
N
N#define PWM_INTSTS0_ZIF3_Pos             (3)                                               /*!< PWM_T::INTSTS0: ZIF3 Position             */
N#define PWM_INTSTS0_ZIF3_Msk             (0x1ul << PWM_INTSTS0_ZIF3_Pos)                   /*!< PWM_T::INTSTS0: ZIF3 Mask                 */
N
N#define PWM_INTSTS0_ZIF4_Pos             (4)                                               /*!< PWM_T::INTSTS0: ZIF4 Position             */
N#define PWM_INTSTS0_ZIF4_Msk             (0x1ul << PWM_INTSTS0_ZIF4_Pos)                   /*!< PWM_T::INTSTS0: ZIF4 Mask                 */
N
N#define PWM_INTSTS0_ZIF5_Pos             (5)                                               /*!< PWM_T::INTSTS0: ZIF5 Position             */
N#define PWM_INTSTS0_ZIF5_Msk             (0x1ul << PWM_INTSTS0_ZIF5_Pos)                   /*!< PWM_T::INTSTS0: ZIF5 Mask                 */
N
N#define PWM_INTSTS0_IFAIF0_1_Pos         (7)                                               /*!< PWM_T::INTSTS0: IFAIF0_1 Position         */
N#define PWM_INTSTS0_IFAIF0_1_Msk         (0x1ul << PWM_INTSTS0_IFAIF0_1_Pos)               /*!< PWM_T::INTSTS0: IFAIF0_1 Mask             */
N
N#define PWM_INTSTS0_PIFn_Pos             (8)                                               /*!< PWM_T::INTSTS0: PIFn Position             */
N#define PWM_INTSTS0_PIFn_Msk             (0x3ful << PWM_INTSTS0_PIFn_Pos)                  /*!< PWM_T::INTSTS0: PIFn Mask                 */
N
N#define PWM_INTSTS0_PIF0_Pos             (8)                                               /*!< PWM_T::INTSTS0: PIF0 Position             */
N#define PWM_INTSTS0_PIF0_Msk             (0x1ul << PWM_INTSTS0_PIF0_Pos)                   /*!< PWM_T::INTSTS0: PIF0 Mask                 */
N
N#define PWM_INTSTS0_PIF1_Pos             (9)                                               /*!< PWM_T::INTSTS0: PIF1 Position             */
N#define PWM_INTSTS0_PIF1_Msk             (0x1ul << PWM_INTSTS0_PIF1_Pos)                   /*!< PWM_T::INTSTS0: PIF1 Mask                 */
N
N#define PWM_INTSTS0_PIF2_Pos             (10)                                              /*!< PWM_T::INTSTS0: PIF2 Position             */
N#define PWM_INTSTS0_PIF2_Msk             (0x1ul << PWM_INTSTS0_PIF2_Pos)                   /*!< PWM_T::INTSTS0: PIF2 Mask                 */
N
N#define PWM_INTSTS0_PIF3_Pos             (11)                                              /*!< PWM_T::INTSTS0: PIF3 Position             */
N#define PWM_INTSTS0_PIF3_Msk             (0x1ul << PWM_INTSTS0_PIF3_Pos)                   /*!< PWM_T::INTSTS0: PIF3 Mask                 */
N
N#define PWM_INTSTS0_PIF4_Pos             (12)                                              /*!< PWM_T::INTSTS0: PIF4 Position             */
N#define PWM_INTSTS0_PIF4_Msk             (0x1ul << PWM_INTSTS0_PIF4_Pos)                   /*!< PWM_T::INTSTS0: PIF4 Mask                 */
N
N#define PWM_INTSTS0_PIF5_Pos             (13)                                              /*!< PWM_T::INTSTS0: PIF5 Position             */
N#define PWM_INTSTS0_PIF5_Msk             (0x1ul << PWM_INTSTS0_PIF5_Pos)                   /*!< PWM_T::INTSTS0: PIF5 Mask                 */
N
N#define PWM_INTSTS0_IFAIF2_3_Pos         (15)                                              /*!< PWM_T::INTSTS0: IFAIF2_3 Position         */
N#define PWM_INTSTS0_IFAIF2_3_Msk         (0x1ul << PWM_INTSTS0_IFAIF2_3_Pos)               /*!< PWM_T::INTSTS0: IFAIF2_3 Mask             */
N
N#define PWM_INTSTS0_CMPUIFn_Pos          (16)                                              /*!< PWM_T::INTSTS0: CMPUIFn Position          */
N#define PWM_INTSTS0_CMPUIFn_Msk          (0x3ful << PWM_INTSTS0_CMPUIFn_Pos)               /*!< PWM_T::INTSTS0: CMPUIFn Mask              */
N
N#define PWM_INTSTS0_CMPUIF0_Pos          (16)                                              /*!< PWM_T::INTSTS0: CMPUIF0 Position          */
N#define PWM_INTSTS0_CMPUIF0_Msk          (0x1ul << PWM_INTSTS0_CMPUIF0_Pos)                /*!< PWM_T::INTSTS0: CMPUIF0 Mask              */
N
N#define PWM_INTSTS0_CMPUIF1_Pos          (17)                                              /*!< PWM_T::INTSTS0: CMPUIF1 Position          */
N#define PWM_INTSTS0_CMPUIF1_Msk          (0x1ul << PWM_INTSTS0_CMPUIF1_Pos)                /*!< PWM_T::INTSTS0: CMPUIF1 Mask              */
N
N#define PWM_INTSTS0_CMPUIF2_Pos          (18)                                              /*!< PWM_T::INTSTS0: CMPUIF2 Position          */
N#define PWM_INTSTS0_CMPUIF2_Msk          (0x1ul << PWM_INTSTS0_CMPUIF2_Pos)                /*!< PWM_T::INTSTS0: CMPUIF2 Mask              */
N
N#define PWM_INTSTS0_CMPUIF3_Pos          (19)                                              /*!< PWM_T::INTSTS0: CMPUIF3 Position          */
N#define PWM_INTSTS0_CMPUIF3_Msk          (0x1ul << PWM_INTSTS0_CMPUIF3_Pos)                /*!< PWM_T::INTSTS0: CMPUIF3 Mask              */
N
N#define PWM_INTSTS0_CMPUIF4_Pos          (20)                                              /*!< PWM_T::INTSTS0: CMPUIF4 Position          */
N#define PWM_INTSTS0_CMPUIF4_Msk          (0x1ul << PWM_INTSTS0_CMPUIF4_Pos)                /*!< PWM_T::INTSTS0: CMPUIF4 Mask              */
N
N#define PWM_INTSTS0_CMPUIF5_Pos          (21)                                              /*!< PWM_T::INTSTS0: CMPUIF5 Position          */
N#define PWM_INTSTS0_CMPUIF5_Msk          (0x1ul << PWM_INTSTS0_CMPUIF5_Pos)                /*!< PWM_T::INTSTS0: CMPUIF5 Mask              */
N
N#define PWM_INTSTS0_IFAIF4_5_Pos         (23)                                              /*!< PWM_T::INTSTS0: IFAIF4_5 Position         */
N#define PWM_INTSTS0_IFAIF4_5_Msk         (0x1ul << PWM_INTSTS0_IFAIF4_5_Pos)               /*!< PWM_T::INTSTS0: IFAIF4_5 Mask             */
N
N#define PWM_INTSTS0_CMPDIFn_Pos          (24)                                              /*!< PWM_T::INTSTS0: CMPDIFn Position          */
N#define PWM_INTSTS0_CMPDIFn_Msk          (0x3ful << PWM_INTSTS0_CMPDIFn_Pos)               /*!< PWM_T::INTSTS0: CMPDIFn Mask              */
N
N#define PWM_INTSTS0_CMPDIF0_Pos          (24)                                              /*!< PWM_T::INTSTS0: CMPDIF0 Position          */
N#define PWM_INTSTS0_CMPDIF0_Msk          (0x1ul << PWM_INTSTS0_CMPDIF0_Pos)                /*!< PWM_T::INTSTS0: CMPDIF0 Mask              */
N
N#define PWM_INTSTS0_CMPDIF1_Pos          (25)                                              /*!< PWM_T::INTSTS0: CMPDIF1 Position          */
N#define PWM_INTSTS0_CMPDIF1_Msk          (0x1ul << PWM_INTSTS0_CMPDIF1_Pos)                /*!< PWM_T::INTSTS0: CMPDIF1 Mask              */
N
N#define PWM_INTSTS0_CMPDIF2_Pos          (26)                                              /*!< PWM_T::INTSTS0: CMPDIF2 Position          */
N#define PWM_INTSTS0_CMPDIF2_Msk          (0x1ul << PWM_INTSTS0_CMPDIF2_Pos)                /*!< PWM_T::INTSTS0: CMPDIF2 Mask              */
N
N#define PWM_INTSTS0_CMPDIF3_Pos          (27)                                              /*!< PWM_T::INTSTS0: CMPDIF3 Position          */
N#define PWM_INTSTS0_CMPDIF3_Msk          (0x1ul << PWM_INTSTS0_CMPDIF3_Pos)                /*!< PWM_T::INTSTS0: CMPDIF3 Mask              */
N
N#define PWM_INTSTS0_CMPDIF4_Pos          (28)                                              /*!< PWM_T::INTSTS0: CMPDIF4 Position          */
N#define PWM_INTSTS0_CMPDIF4_Msk          (0x1ul << PWM_INTSTS0_CMPDIF4_Pos)                /*!< PWM_T::INTSTS0: CMPDIF4 Mask              */
N
N#define PWM_INTSTS0_CMPDIF5_Pos          (29)                                              /*!< PWM_T::INTSTS0: CMPDIF5 Position          */
N#define PWM_INTSTS0_CMPDIF5_Msk          (0x1ul << PWM_INTSTS0_CMPDIF5_Pos)                /*!< PWM_T::INTSTS0: CMPDIF5 Mask              */
N
N#define PWM_INTSTS1_BRKEIFn_Pos          (0)                                               /*!< PWM_T::INTSTS1: BRKEIFn Position          */
N#define PWM_INTSTS1_BRKEIFn_Msk          (0x3ful << PWM_INTSTS1_BRKEIFn_Pos)               /*!< PWM_T::INTSTS1: BRKEIFn Mask              */
N
N#define PWM_INTSTS1_BRKEIF0_Pos          (0)                                               /*!< PWM_T::INTSTS1: BRKEIF0 Position          */
N#define PWM_INTSTS1_BRKEIF0_Msk          (0x1ul << PWM_INTSTS1_BRKEIF0_Pos)                /*!< PWM_T::INTSTS1: BRKEIF0 Mask              */
N
N#define PWM_INTSTS1_BRKEIF1_Pos          (1)                                               /*!< PWM_T::INTSTS1: BRKEIF1 Position          */
N#define PWM_INTSTS1_BRKEIF1_Msk          (0x1ul << PWM_INTSTS1_BRKEIF1_Pos)                /*!< PWM_T::INTSTS1: BRKEIF1 Mask              */
N
N#define PWM_INTSTS1_BRKEIF2_Pos          (2)                                               /*!< PWM_T::INTSTS1: BRKEIF2 Position          */
N#define PWM_INTSTS1_BRKEIF2_Msk          (0x1ul << PWM_INTSTS1_BRKEIF2_Pos)                /*!< PWM_T::INTSTS1: BRKEIF2 Mask              */
N
N#define PWM_INTSTS1_BRKEIF3_Pos          (3)                                               /*!< PWM_T::INTSTS1: BRKEIF3 Position          */
N#define PWM_INTSTS1_BRKEIF3_Msk          (0x1ul << PWM_INTSTS1_BRKEIF3_Pos)                /*!< PWM_T::INTSTS1: BRKEIF3 Mask              */
N
N#define PWM_INTSTS1_BRKEIF4_Pos          (4)                                               /*!< PWM_T::INTSTS1: BRKEIF4 Position          */
N#define PWM_INTSTS1_BRKEIF4_Msk          (0x1ul << PWM_INTSTS1_BRKEIF4_Pos)                /*!< PWM_T::INTSTS1: BRKEIF4 Mask              */
N
N#define PWM_INTSTS1_BRKEIF5_Pos          (5)                                               /*!< PWM_T::INTSTS1: BRKEIF5 Position          */
N#define PWM_INTSTS1_BRKEIF5_Msk          (0x1ul << PWM_INTSTS1_BRKEIF5_Pos)                /*!< PWM_T::INTSTS1: BRKEIF5 Mask              */
N
N#define PWM_INTSTS1_BRKLIFn_Pos          (8)                                               /*!< PWM_T::INTSTS1: BRKLIFn Position          */
N#define PWM_INTSTS1_BRKLIFn_Msk          (0x3ful << PWM_INTSTS1_BRKLIFn_Pos)               /*!< PWM_T::INTSTS1: BRKLIFn Mask              */
N
N#define PWM_INTSTS1_BRKLIF0_Pos          (8)                                               /*!< PWM_T::INTSTS1: BRKLIF0 Position          */
N#define PWM_INTSTS1_BRKLIF0_Msk          (0x1ul << PWM_INTSTS1_BRKLIF0_Pos)                /*!< PWM_T::INTSTS1: BRKLIF0 Mask              */
N
N#define PWM_INTSTS1_BRKLIF1_Pos          (9)                                               /*!< PWM_T::INTSTS1: BRKLIF1 Position          */
N#define PWM_INTSTS1_BRKLIF1_Msk          (0x1ul << PWM_INTSTS1_BRKLIF1_Pos)                /*!< PWM_T::INTSTS1: BRKLIF1 Mask              */
N
N#define PWM_INTSTS1_BRKLIF2_Pos          (10)                                              /*!< PWM_T::INTSTS1: BRKLIF2 Position          */
N#define PWM_INTSTS1_BRKLIF2_Msk          (0x1ul << PWM_INTSTS1_BRKLIF2_Pos)                /*!< PWM_T::INTSTS1: BRKLIF2 Mask              */
N
N#define PWM_INTSTS1_BRKLIF3_Pos          (11)                                              /*!< PWM_T::INTSTS1: BRKLIF3 Position          */
N#define PWM_INTSTS1_BRKLIF3_Msk          (0x1ul << PWM_INTSTS1_BRKLIF3_Pos)                /*!< PWM_T::INTSTS1: BRKLIF3 Mask              */
N
N#define PWM_INTSTS1_BRKLIF4_Pos          (12)                                              /*!< PWM_T::INTSTS1: BRKLIF4 Position          */
N#define PWM_INTSTS1_BRKLIF4_Msk          (0x1ul << PWM_INTSTS1_BRKLIF4_Pos)                /*!< PWM_T::INTSTS1: BRKLIF4 Mask              */
N
N#define PWM_INTSTS1_BRKLIF5_Pos          (13)                                              /*!< PWM_T::INTSTS1: BRKLIF5 Position          */
N#define PWM_INTSTS1_BRKLIF5_Msk          (0x1ul << PWM_INTSTS1_BRKLIF5_Pos)                /*!< PWM_T::INTSTS1: BRKLIF5 Mask              */
N
N#define PWM_INTSTS1_BRKESTS0_Pos         (16)                                              /*!< PWM_T::INTSTS1: BRKESTS0 Position         */
N#define PWM_INTSTS1_BRKESTS0_Msk         (0x1ul << PWM_INTSTS1_BRKESTS0_Pos)               /*!< PWM_T::INTSTS1: BRKESTS0 Mask             */
N
N#define PWM_INTSTS1_BRKESTS1_Pos         (17)                                              /*!< PWM_T::INTSTS1: BRKESTS1 Position         */
N#define PWM_INTSTS1_BRKESTS1_Msk         (0x1ul << PWM_INTSTS1_BRKESTS1_Pos)               /*!< PWM_T::INTSTS1: BRKESTS1 Mask             */
N
N#define PWM_INTSTS1_BRKESTS2_Pos         (18)                                              /*!< PWM_T::INTSTS1: BRKESTS2 Position         */
N#define PWM_INTSTS1_BRKESTS2_Msk         (0x1ul << PWM_INTSTS1_BRKESTS2_Pos)               /*!< PWM_T::INTSTS1: BRKESTS2 Mask             */
N
N#define PWM_INTSTS1_BRKESTS3_Pos         (19)                                              /*!< PWM_T::INTSTS1: BRKESTS3 Position         */
N#define PWM_INTSTS1_BRKESTS3_Msk         (0x1ul << PWM_INTSTS1_BRKESTS3_Pos)               /*!< PWM_T::INTSTS1: BRKESTS3 Mask             */
N
N#define PWM_INTSTS1_BRKESTS4_Pos         (20)                                              /*!< PWM_T::INTSTS1: BRKESTS4 Position         */
N#define PWM_INTSTS1_BRKESTS4_Msk         (0x1ul << PWM_INTSTS1_BRKESTS4_Pos)               /*!< PWM_T::INTSTS1: BRKESTS4 Mask             */
N
N#define PWM_INTSTS1_BRKESTS5_Pos         (21)                                              /*!< PWM_T::INTSTS1: BRKESTS5 Position         */
N#define PWM_INTSTS1_BRKESTS5_Msk         (0x1ul << PWM_INTSTS1_BRKESTS5_Pos)               /*!< PWM_T::INTSTS1: BRKESTS5 Mask             */
N
N#define PWM_INTSTS1_BRKLSTS0_Pos         (24)                                              /*!< PWM_T::INTSTS1: BRKLSTS0 Position         */
N#define PWM_INTSTS1_BRKLSTS0_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS0_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS0 Mask             */
N
N#define PWM_INTSTS1_BRKLSTS1_Pos         (25)                                              /*!< PWM_T::INTSTS1: BRKLSTS1 Position         */
N#define PWM_INTSTS1_BRKLSTS1_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS1_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS1 Mask             */
N
N#define PWM_INTSTS1_BRKLSTS2_Pos         (26)                                              /*!< PWM_T::INTSTS1: BRKLSTS2 Position         */
N#define PWM_INTSTS1_BRKLSTS2_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS2_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS2 Mask             */
N
N#define PWM_INTSTS1_BRKLSTS3_Pos         (27)                                              /*!< PWM_T::INTSTS1: BRKLSTS3 Position         */
N#define PWM_INTSTS1_BRKLSTS3_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS3_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS3 Mask             */
N
N#define PWM_INTSTS1_BRKLSTS4_Pos         (28)                                              /*!< PWM_T::INTSTS1: BRKLSTS4 Position         */
N#define PWM_INTSTS1_BRKLSTS4_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS4_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS4 Mask             */
N
N#define PWM_INTSTS1_BRKLSTS5_Pos         (29)                                              /*!< PWM_T::INTSTS1: BRKLSTS5 Position         */
N#define PWM_INTSTS1_BRKLSTS5_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS5_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS5 Mask             */
N
N#define PWM_IFA_IFCNT0_1_Pos             (0)                                               /*!< PWM_T::IFA: IFCNT0_1 Position             */
N#define PWM_IFA_IFCNT0_1_Msk             (0xful << PWM_IFA_IFCNT0_1_Pos)                   /*!< PWM_T::IFA: IFCNT0_1 Mask                 */
N
N#define PWM_IFA_IFSEL0_1_Pos             (4)                                               /*!< PWM_T::IFA: IFSEL0_1 Position             */
N#define PWM_IFA_IFSEL0_1_Msk             (0x7ul << PWM_IFA_IFSEL0_1_Pos)                   /*!< PWM_T::IFA: IFSEL0_1 Mask                 */
N
N#define PWM_IFA_IFAEN0_1_Pos             (7)                                               /*!< PWM_T::IFA: IFAEN0_1 Position             */
N#define PWM_IFA_IFAEN0_1_Msk             (0x1ul << PWM_IFA_IFAEN0_1_Pos)                   /*!< PWM_T::IFA: IFAEN0_1 Mask                 */
N
N#define PWM_IFA_IFCNT2_3_Pos             (8)                                               /*!< PWM_T::IFA: IFCNT2_3 Position             */
N#define PWM_IFA_IFCNT2_3_Msk             (0xful << PWM_IFA_IFCNT2_3_Pos)                   /*!< PWM_T::IFA: IFCNT2_3 Mask                 */
N
N#define PWM_IFA_IFSEL2_3_Pos             (12)                                              /*!< PWM_T::IFA: IFSEL2_3 Position             */
N#define PWM_IFA_IFSEL2_3_Msk             (0x7ul << PWM_IFA_IFSEL2_3_Pos)                   /*!< PWM_T::IFA: IFSEL2_3 Mask                 */
N
N#define PWM_IFA_IFAEN2_3_Pos             (15)                                              /*!< PWM_T::IFA: IFAEN2_3 Position             */
N#define PWM_IFA_IFAEN2_3_Msk             (0x1ul << PWM_IFA_IFAEN2_3_Pos)                   /*!< PWM_T::IFA: IFAEN2_3 Mask                 */
N
N#define PWM_IFA_IFCNT4_5_Pos             (16)                                              /*!< PWM_T::IFA: IFCNT4_5 Position             */
N#define PWM_IFA_IFCNT4_5_Msk             (0xful << PWM_IFA_IFCNT4_5_Pos)                   /*!< PWM_T::IFA: IFCNT4_5 Mask                 */
N
N#define PWM_IFA_IFSEL4_5_Pos             (20)                                              /*!< PWM_T::IFA: IFSEL4_5 Position             */
N#define PWM_IFA_IFSEL4_5_Msk             (0x7ul << PWM_IFA_IFSEL4_5_Pos)                   /*!< PWM_T::IFA: IFSEL4_5 Mask                 */
N
N#define PWM_IFA_IFAEN4_5_Pos             (23)                                              /*!< PWM_T::IFA: IFAEN4_5 Position             */
N#define PWM_IFA_IFAEN4_5_Msk             (0x1ul << PWM_IFA_IFAEN4_5_Pos)                   /*!< PWM_T::IFA: IFAEN4_5 Mask                 */
N
N#define PWM_DACTRGEN_ZTEn_Pos            (0)                                               /*!< PWM_T::DACTRGEN: ZTEn Position            */
N#define PWM_DACTRGEN_ZTEn_Msk            (0x3ful << PWM_DACTRGEN_ZTEn_Pos)                 /*!< PWM_T::DACTRGEN: ZTEn Mask                */
N
N#define PWM_DACTRGEN_ZTE0_Pos            (0)                                               /*!< PWM_T::DACTRGEN: ZTE0 Position            */
N#define PWM_DACTRGEN_ZTE0_Msk            (0x1ul << PWM_DACTRGEN_ZTE0_Pos)                  /*!< PWM_T::DACTRGEN: ZTE0 Mask                */
N
N#define PWM_DACTRGEN_ZTE1_Pos            (1)                                               /*!< PWM_T::DACTRGEN: ZTE1 Position            */
N#define PWM_DACTRGEN_ZTE1_Msk            (0x1ul << PWM_DACTRGEN_ZTE1_Pos)                  /*!< PWM_T::DACTRGEN: ZTE1 Mask                */
N
N#define PWM_DACTRGEN_ZTE2_Pos            (2)                                               /*!< PWM_T::DACTRGEN: ZTE2 Position            */
N#define PWM_DACTRGEN_ZTE2_Msk            (0x1ul << PWM_DACTRGEN_ZTE2_Pos)                  /*!< PWM_T::DACTRGEN: ZTE2 Mask                */
N
N#define PWM_DACTRGEN_ZTE3_Pos            (3)                                               /*!< PWM_T::DACTRGEN: ZTE3 Position            */
N#define PWM_DACTRGEN_ZTE3_Msk            (0x1ul << PWM_DACTRGEN_ZTE3_Pos)                  /*!< PWM_T::DACTRGEN: ZTE3 Mask                */
N
N#define PWM_DACTRGEN_ZTE4_Pos            (4)                                               /*!< PWM_T::DACTRGEN: ZTE4 Position            */
N#define PWM_DACTRGEN_ZTE4_Msk            (0x1ul << PWM_DACTRGEN_ZTE4_Pos)                  /*!< PWM_T::DACTRGEN: ZTE4 Mask                */
N
N#define PWM_DACTRGEN_ZTE5_Pos            (5)                                               /*!< PWM_T::DACTRGEN: ZTE5 Position            */
N#define PWM_DACTRGEN_ZTE5_Msk            (0x1ul << PWM_DACTRGEN_ZTE5_Pos)                  /*!< PWM_T::DACTRGEN: ZTE5 Mask                */
N
N#define PWM_DACTRGEN_PTEn_Pos            (8)                                               /*!< PWM_T::DACTRGEN: PTEn Position            */
N#define PWM_DACTRGEN_PTEn_Msk            (0x3ful << PWM_DACTRGEN_PTEn_Pos)                 /*!< PWM_T::DACTRGEN: PTEn Mask                */
N
N#define PWM_DACTRGEN_PTE0_Pos            (8)                                               /*!< PWM_T::DACTRGEN: PTE0 Position            */
N#define PWM_DACTRGEN_PTE0_Msk            (0x1ul << PWM_DACTRGEN_PTE0_Pos)                  /*!< PWM_T::DACTRGEN: PTE0 Mask                */
N
N#define PWM_DACTRGEN_PTE1_Pos            (9)                                               /*!< PWM_T::DACTRGEN: PTE1 Position            */
N#define PWM_DACTRGEN_PTE1_Msk            (0x1ul << PWM_DACTRGEN_PTE1_Pos)                  /*!< PWM_T::DACTRGEN: PTE1 Mask                */
N
N#define PWM_DACTRGEN_PTE2_Pos            (10)                                              /*!< PWM_T::DACTRGEN: PTE2 Position            */
N#define PWM_DACTRGEN_PTE2_Msk            (0x1ul << PWM_DACTRGEN_PTE2_Pos)                  /*!< PWM_T::DACTRGEN: PTE2 Mask                */
N
N#define PWM_DACTRGEN_PTE3_Pos            (11)                                              /*!< PWM_T::DACTRGEN: PTE3 Position            */
N#define PWM_DACTRGEN_PTE3_Msk            (0x1ul << PWM_DACTRGEN_PTE3_Pos)                  /*!< PWM_T::DACTRGEN: PTE3 Mask                */
N
N#define PWM_DACTRGEN_PTE4_Pos            (12)                                              /*!< PWM_T::DACTRGEN: PTE4 Position            */
N#define PWM_DACTRGEN_PTE4_Msk            (0x1ul << PWM_DACTRGEN_PTE4_Pos)                  /*!< PWM_T::DACTRGEN: PTE4 Mask                */
N
N#define PWM_DACTRGEN_PTE5_Pos            (13)                                              /*!< PWM_T::DACTRGEN: PTE5 Position            */
N#define PWM_DACTRGEN_PTE5_Msk            (0x1ul << PWM_DACTRGEN_PTE5_Pos)                  /*!< PWM_T::DACTRGEN: PTE5 Mask                */
N
N#define PWM_DACTRGEN_CUTRGEn_Pos         (16)                                              /*!< PWM_T::DACTRGEN: CUTRGEn Position         */
N#define PWM_DACTRGEN_CUTRGEn_Msk         (0x3ful << PWM_DACTRGEN_CUTRGEn_Pos)              /*!< PWM_T::DACTRGEN: CUTRGEn Mask             */
N
N#define PWM_DACTRGEN_CUTRGE0_Pos         (16)                                              /*!< PWM_T::DACTRGEN: CUTRGE0 Position         */
N#define PWM_DACTRGEN_CUTRGE0_Msk         (0x1ul << PWM_DACTRGEN_CUTRGE0_Pos)               /*!< PWM_T::DACTRGEN: CUTRGE0 Mask             */
N
N#define PWM_DACTRGEN_CUTRGE1_Pos         (17)                                              /*!< PWM_T::DACTRGEN: CUTRGE1 Position         */
N#define PWM_DACTRGEN_CUTRGE1_Msk         (0x1ul << PWM_DACTRGEN_CUTRGE1_Pos)               /*!< PWM_T::DACTRGEN: CUTRGE1 Mask             */
N
N#define PWM_DACTRGEN_CUTRGE2_Pos         (18)                                              /*!< PWM_T::DACTRGEN: CUTRGE2 Position         */
N#define PWM_DACTRGEN_CUTRGE2_Msk         (0x1ul << PWM_DACTRGEN_CUTRGE2_Pos)               /*!< PWM_T::DACTRGEN: CUTRGE2 Mask             */
N
N#define PWM_DACTRGEN_CUTRGE3_Pos         (19)                                              /*!< PWM_T::DACTRGEN: CUTRGE3 Position         */
N#define PWM_DACTRGEN_CUTRGE3_Msk         (0x1ul << PWM_DACTRGEN_CUTRGE3_Pos)               /*!< PWM_T::DACTRGEN: CUTRGE3 Mask             */
N
N#define PWM_DACTRGEN_CUTRGE4_Pos         (20)                                              /*!< PWM_T::DACTRGEN: CUTRGE4 Position         */
N#define PWM_DACTRGEN_CUTRGE4_Msk         (0x1ul << PWM_DACTRGEN_CUTRGE4_Pos)               /*!< PWM_T::DACTRGEN: CUTRGE4 Mask             */
N
N#define PWM_DACTRGEN_CUTRGE5_Pos         (21)                                              /*!< PWM_T::DACTRGEN: CUTRGE5 Position         */
N#define PWM_DACTRGEN_CUTRGE5_Msk         (0x1ul << PWM_DACTRGEN_CUTRGE5_Pos)               /*!< PWM_T::DACTRGEN: CUTRGE5 Mask             */
N
N#define PWM_DACTRGEN_CDTRGEn_Pos         (24)                                              /*!< PWM_T::DACTRGEN: CDTRGEn Position         */
N#define PWM_DACTRGEN_CDTRGEn_Msk         (0x3ful << PWM_DACTRGEN_CDTRGEn_Pos)              /*!< PWM_T::DACTRGEN: CDTRGEn Mask             */
N
N#define PWM_DACTRGEN_CDTRGE0_Pos         (24)                                              /*!< PWM_T::DACTRGEN: CDTRGE0 Position         */
N#define PWM_DACTRGEN_CDTRGE0_Msk         (0x1ul << PWM_DACTRGEN_CDTRGE0_Pos)               /*!< PWM_T::DACTRGEN: CDTRGE0 Mask             */
N
N#define PWM_DACTRGEN_CDTRGE1_Pos         (25)                                              /*!< PWM_T::DACTRGEN: CDTRGE1 Position         */
N#define PWM_DACTRGEN_CDTRGE1_Msk         (0x1ul << PWM_DACTRGEN_CDTRGE1_Pos)               /*!< PWM_T::DACTRGEN: CDTRGE1 Mask             */
N
N#define PWM_DACTRGEN_CDTRGE2_Pos         (26)                                              /*!< PWM_T::DACTRGEN: CDTRGE2 Position         */
N#define PWM_DACTRGEN_CDTRGE2_Msk         (0x1ul << PWM_DACTRGEN_CDTRGE2_Pos)               /*!< PWM_T::DACTRGEN: CDTRGE2 Mask             */
N
N#define PWM_DACTRGEN_CDTRGE3_Pos         (27)                                              /*!< PWM_T::DACTRGEN: CDTRGE3 Position         */
N#define PWM_DACTRGEN_CDTRGE3_Msk         (0x1ul << PWM_DACTRGEN_CDTRGE3_Pos)               /*!< PWM_T::DACTRGEN: CDTRGE3 Mask             */
N
N#define PWM_DACTRGEN_CDTRGE4_Pos         (28)                                              /*!< PWM_T::DACTRGEN: CDTRGE4 Position         */
N#define PWM_DACTRGEN_CDTRGE4_Msk         (0x1ul << PWM_DACTRGEN_CDTRGE4_Pos)               /*!< PWM_T::DACTRGEN: CDTRGE4 Mask             */
N
N#define PWM_DACTRGEN_CDTRGE5_Pos         (29)                                              /*!< PWM_T::DACTRGEN: CDTRGE5 Position         */
N#define PWM_DACTRGEN_CDTRGE5_Msk         (0x1ul << PWM_DACTRGEN_CDTRGE5_Pos)               /*!< PWM_T::DACTRGEN: CDTRGE5 Mask             */
N
N#define PWM_EADCTS0_TRGSEL0_Pos          (0)                                               /*!< PWM_T::EADCTS0: TRGSEL0 Position          */
N#define PWM_EADCTS0_TRGSEL0_Msk          (0xful << PWM_EADCTS0_TRGSEL0_Pos)                /*!< PWM_T::EADCTS0: TRGSEL0 Mask              */
N
N#define PWM_EADCTS0_TRGEN0_Pos           (7)                                               /*!< PWM_T::EADCTS0: TRGEN0 Position           */
N#define PWM_EADCTS0_TRGEN0_Msk           (0x1ul << PWM_EADCTS0_TRGEN0_Pos)                 /*!< PWM_T::EADCTS0: TRGEN0 Mask               */
N
N#define PWM_EADCTS0_TRGSEL1_Pos          (8)                                               /*!< PWM_T::EADCTS0: TRGSEL1 Position          */
N#define PWM_EADCTS0_TRGSEL1_Msk          (0xful << PWM_EADCTS0_TRGSEL1_Pos)                /*!< PWM_T::EADCTS0: TRGSEL1 Mask              */
N
N#define PWM_EADCTS0_TRGEN1_Pos           (15)                                              /*!< PWM_T::EADCTS0: TRGEN1 Position           */
N#define PWM_EADCTS0_TRGEN1_Msk           (0x1ul << PWM_EADCTS0_TRGEN1_Pos)                 /*!< PWM_T::EADCTS0: TRGEN1 Mask               */
N
N#define PWM_EADCTS0_TRGSEL2_Pos          (16)                                              /*!< PWM_T::EADCTS0: TRGSEL2 Position          */
N#define PWM_EADCTS0_TRGSEL2_Msk          (0xful << PWM_EADCTS0_TRGSEL2_Pos)                /*!< PWM_T::EADCTS0: TRGSEL2 Mask              */
N
N#define PWM_EADCTS0_TRGEN2_Pos           (23)                                              /*!< PWM_T::EADCTS0: TRGEN2 Position           */
N#define PWM_EADCTS0_TRGEN2_Msk           (0x1ul << PWM_EADCTS0_TRGEN2_Pos)                 /*!< PWM_T::EADCTS0: TRGEN2 Mask               */
N
N#define PWM_EADCTS0_TRGSEL3_Pos          (24)                                              /*!< PWM_T::EADCTS0: TRGSEL3 Position          */
N#define PWM_EADCTS0_TRGSEL3_Msk          (0xful << PWM_EADCTS0_TRGSEL3_Pos)                /*!< PWM_T::EADCTS0: TRGSEL3 Mask              */
N
N#define PWM_EADCTS0_TRGEN3_Pos           (31)                                              /*!< PWM_T::EADCTS0: TRGEN3 Position           */
N#define PWM_EADCTS0_TRGEN3_Msk           (0x1ul << PWM_EADCTS0_TRGEN3_Pos)                 /*!< PWM_T::EADCTS0: TRGEN3 Mask               */
N
N#define PWM_EADCTS1_TRGSEL4_Pos          (0)                                               /*!< PWM_T::EADCTS1: TRGSEL4 Position          */
N#define PWM_EADCTS1_TRGSEL4_Msk          (0xful << PWM_EADCTS1_TRGSEL4_Pos)                /*!< PWM_T::EADCTS1: TRGSEL4 Mask              */
N
N#define PWM_EADCTS1_TRGEN4_Pos           (7)                                               /*!< PWM_T::EADCTS1: TRGEN4 Position           */
N#define PWM_EADCTS1_TRGEN4_Msk           (0x1ul << PWM_EADCTS1_TRGEN4_Pos)                 /*!< PWM_T::EADCTS1: TRGEN4 Mask               */
N
N#define PWM_EADCTS1_TRGSEL5_Pos          (8)                                               /*!< PWM_T::EADCTS1: TRGSEL5 Position          */
N#define PWM_EADCTS1_TRGSEL5_Msk          (0xful << PWM_EADCTS1_TRGSEL5_Pos)                /*!< PWM_T::EADCTS1: TRGSEL5 Mask              */
N
N#define PWM_EADCTS1_TRGEN5_Pos           (15)                                              /*!< PWM_T::EADCTS1: TRGEN5 Position           */
N#define PWM_EADCTS1_TRGEN5_Msk           (0x1ul << PWM_EADCTS1_TRGEN5_Pos)                 /*!< PWM_T::EADCTS1: TRGEN5 Mask               */
N
N#define PWM_FTCMPDAT0_1_FTCMP_Pos        (0)                                               /*!< PWM_T::FTCMPDAT0_1: FTCMP Position        */
N#define PWM_FTCMPDAT0_1_FTCMP_Msk        (0xfffful << PWM_FTCMPDAT0_1_FTCMP_Pos)           /*!< PWM_T::FTCMPDAT0_1: FTCMP Mask            */
N
N#define PWM_FTCMPDAT2_3_FTCMP_Pos        (0)                                               /*!< PWM_T::FTCMPDAT2_3: FTCMP Position        */
N#define PWM_FTCMPDAT2_3_FTCMP_Msk        (0xfffful << PWM_FTCMPDAT2_3_FTCMP_Pos)           /*!< PWM_T::FTCMPDAT2_3: FTCMP Mask            */
N
N#define PWM_FTCMPDAT4_5_FTCMP_Pos        (0)                                               /*!< PWM_T::FTCMPDAT4_5: FTCMP Position        */
N#define PWM_FTCMPDAT4_5_FTCMP_Msk        (0xfffful << PWM_FTCMPDAT4_5_FTCMP_Pos)           /*!< PWM_T::FTCMPDAT4_5: FTCMP Mask            */
N
N#define PWM_SSCTL_SSENn_Pos              (0)                                               /*!< PWM_T::SSCTL: SSENn Position              */
N#define PWM_SSCTL_SSENn_Msk              (0x3ful << PWM_SSCTL_SSENn_Pos)                   /*!< PWM_T::SSCTL: SSENn Mask                  */
N
N#define PWM_SSCTL_SSEN0_Pos              (0)                                               /*!< PWM_T::SSCTL: SSEN0 Position              */
N#define PWM_SSCTL_SSEN0_Msk              (0x1ul << PWM_SSCTL_SSEN0_Pos)                    /*!< PWM_T::SSCTL: SSEN0 Mask                  */
N
N#define PWM_SSCTL_SSEN1_Pos              (1)                                               /*!< PWM_T::SSCTL: SSEN1 Position              */
N#define PWM_SSCTL_SSEN1_Msk              (0x1ul << PWM_SSCTL_SSEN1_Pos)                    /*!< PWM_T::SSCTL: SSEN1 Mask                  */
N
N#define PWM_SSCTL_SSEN2_Pos              (2)                                               /*!< PWM_T::SSCTL: SSEN2 Position              */
N#define PWM_SSCTL_SSEN2_Msk              (0x1ul << PWM_SSCTL_SSEN2_Pos)                    /*!< PWM_T::SSCTL: SSEN2 Mask                  */
N
N#define PWM_SSCTL_SSEN3_Pos              (3)                                               /*!< PWM_T::SSCTL: SSEN3 Position              */
N#define PWM_SSCTL_SSEN3_Msk              (0x1ul << PWM_SSCTL_SSEN3_Pos)                    /*!< PWM_T::SSCTL: SSEN3 Mask                  */
N
N#define PWM_SSCTL_SSEN4_Pos              (4)                                               /*!< PWM_T::SSCTL: SSEN4 Position              */
N#define PWM_SSCTL_SSEN4_Msk              (0x1ul << PWM_SSCTL_SSEN4_Pos)                    /*!< PWM_T::SSCTL: SSEN4 Mask                  */
N
N#define PWM_SSCTL_SSEN5_Pos              (5)                                               /*!< PWM_T::SSCTL: SSEN5 Position              */
N#define PWM_SSCTL_SSEN5_Msk              (0x1ul << PWM_SSCTL_SSEN5_Pos)                    /*!< PWM_T::SSCTL: SSEN5 Mask                  */
N
N#define PWM_SSTRG_CNTSEN_Pos             (0)                                               /*!< PWM_T::SSTRG: CNTSEN Position             */
N#define PWM_SSTRG_CNTSEN_Msk             (0x1ul << PWM_SSTRG_CNTSEN_Pos)                   /*!< PWM_T::SSTRG: CNTSEN Mask                 */
N
N#define PWM_STATUS_CNTMAXFn_Pos          (0)                                               /*!< PWM_T::STATUS: CNTMAXFn Position          */
N#define PWM_STATUS_CNTMAXFn_Msk          (0x3ful << PWM_STATUS_CNTMAXFn_Pos)               /*!< PWM_T::STATUS: CNTMAXFn Mask              */
N
N#define PWM_STATUS_CNTMAXF0_Pos          (0)                                               /*!< PWM_T::STATUS: CNTMAXF0 Position          */
N#define PWM_STATUS_CNTMAXF0_Msk          (0x1ul << PWM_STATUS_CNTMAXF0_Pos)                /*!< PWM_T::STATUS: CNTMAXF0 Mask              */
N
N#define PWM_STATUS_CNTMAXF1_Pos          (1)                                               /*!< PWM_T::STATUS: CNTMAXF1 Position          */
N#define PWM_STATUS_CNTMAXF1_Msk          (0x1ul << PWM_STATUS_CNTMAXF1_Pos)                /*!< PWM_T::STATUS: CNTMAXF1 Mask              */
N
N#define PWM_STATUS_CNTMAXF2_Pos          (2)                                               /*!< PWM_T::STATUS: CNTMAXF2 Position          */
N#define PWM_STATUS_CNTMAXF2_Msk          (0x1ul << PWM_STATUS_CNTMAXF2_Pos)                /*!< PWM_T::STATUS: CNTMAXF2 Mask              */
N
N#define PWM_STATUS_CNTMAXF3_Pos          (3)                                               /*!< PWM_T::STATUS: CNTMAXF3 Position          */
N#define PWM_STATUS_CNTMAXF3_Msk          (0x1ul << PWM_STATUS_CNTMAXF3_Pos)                /*!< PWM_T::STATUS: CNTMAXF3 Mask              */
N
N#define PWM_STATUS_CNTMAXF4_Pos          (4)                                               /*!< PWM_T::STATUS: CNTMAXF4 Position          */
N#define PWM_STATUS_CNTMAXF4_Msk          (0x1ul << PWM_STATUS_CNTMAXF4_Pos)                /*!< PWM_T::STATUS: CNTMAXF4 Mask              */
N
N#define PWM_STATUS_CNTMAXF5_Pos          (5)                                               /*!< PWM_T::STATUS: CNTMAXF5 Position          */
N#define PWM_STATUS_CNTMAXF5_Msk          (0x1ul << PWM_STATUS_CNTMAXF5_Pos)                /*!< PWM_T::STATUS: CNTMAXF5 Mask              */
N
N#define PWM_STATUS_SYNCINFn_Pos          (8)                                               /*!< PWM_T::STATUS: SYNCINFn Position          */
N#define PWM_STATUS_SYNCINFn_Msk          (0x7ul << PWM_STATUS_SYNCINFn_Pos)                /*!< PWM_T::STATUS: SYNCINFn Mask              */
N
N#define PWM_STATUS_SYNCINF0_Pos          (8)                                               /*!< PWM_T::STATUS: SYNCINF0 Position          */
N#define PWM_STATUS_SYNCINF0_Msk          (0x1ul << PWM_STATUS_SYNCINF0_Pos)                /*!< PWM_T::STATUS: SYNCINF0 Mask              */
N
N#define PWM_STATUS_SYNCINF2_Pos          (9)                                               /*!< PWM_T::STATUS: SYNCINF2 Position          */
N#define PWM_STATUS_SYNCINF2_Msk          (0x1ul << PWM_STATUS_SYNCINF2_Pos)                /*!< PWM_T::STATUS: SYNCINF2 Mask              */
N
N#define PWM_STATUS_SYNCINF4_Pos          (10)                                              /*!< PWM_T::STATUS: SYNCINF4 Position          */
N#define PWM_STATUS_SYNCINF4_Msk          (0x1ul << PWM_STATUS_SYNCINF4_Pos)                /*!< PWM_T::STATUS: SYNCINF4 Mask              */
N
N#define PWM_STATUS_ADCTRGFn_Pos          (16)                                              /*!< PWM_T::STATUS: ADCTRGFn Position          */
N#define PWM_STATUS_ADCTRGFn_Msk          (0x3ful << PWM_STATUS_ADCTRGFn_Pos)               /*!< PWM_T::STATUS: ADCTRGFn Mask              */
N
N#define PWM_STATUS_ADCTRGF0_Pos          (16)                                              /*!< PWM_T::STATUS: ADCTRGF0 Position          */
N#define PWM_STATUS_ADCTRGF0_Msk          (0x1ul << PWM_STATUS_ADCTRGF0_Pos)                /*!< PWM_T::STATUS: ADCTRGF0 Mask              */
N
N#define PWM_STATUS_ADCTRGF1_Pos          (17)                                              /*!< PWM_T::STATUS: ADCTRGF1 Position          */
N#define PWM_STATUS_ADCTRGF1_Msk          (0x1ul << PWM_STATUS_ADCTRGF1_Pos)                /*!< PWM_T::STATUS: ADCTRGF1 Mask              */
N
N#define PWM_STATUS_ADCTRGF2_Pos          (18)                                              /*!< PWM_T::STATUS: ADCTRGF2 Position          */
N#define PWM_STATUS_ADCTRGF2_Msk          (0x1ul << PWM_STATUS_ADCTRGF2_Pos)                /*!< PWM_T::STATUS: ADCTRGF2 Mask              */
N
N#define PWM_STATUS_ADCTRGF3_Pos          (19)                                              /*!< PWM_T::STATUS: ADCTRGF3 Position          */
N#define PWM_STATUS_ADCTRGF3_Msk          (0x1ul << PWM_STATUS_ADCTRGF3_Pos)                /*!< PWM_T::STATUS: ADCTRGF3 Mask              */
N
N#define PWM_STATUS_ADCTRGF4_Pos          (20)                                              /*!< PWM_T::STATUS: ADCTRGF4 Position          */
N#define PWM_STATUS_ADCTRGF4_Msk          (0x1ul << PWM_STATUS_ADCTRGF4_Pos)                /*!< PWM_T::STATUS: ADCTRGF4 Mask              */
N
N#define PWM_STATUS_ADCTRGF5_Pos          (21)                                              /*!< PWM_T::STATUS: ADCTRGF5 Position          */
N#define PWM_STATUS_ADCTRGF5_Msk          (0x1ul << PWM_STATUS_ADCTRGF5_Pos)                /*!< PWM_T::STATUS: ADCTRGF5 Mask              */
N
N#define PWM_STATUS_DACTRGF_Pos           (24)                                              /*!< PWM_T::STATUS: DACTRGF Position           */
N#define PWM_STATUS_DACTRGF_Msk           (0x1ul << PWM_STATUS_DACTRGF_Pos)                 /*!< PWM_T::STATUS: DACTRGF Mask               */
N
N#define PWM_CAPINEN_CAPINENn_Pos         (0)                                               /*!< PWM_T::CAPINEN: CAPINENn Position         */
N#define PWM_CAPINEN_CAPINENn_Msk         (0x3ful << PWM_CAPINEN_CAPINENn_Pos)              /*!< PWM_T::CAPINEN: CAPINENn Mask             */
N
N#define PWM_CAPINEN_CAPINEN0_Pos         (0)                                               /*!< PWM_T::CAPINEN: CAPINEN0 Position         */
N#define PWM_CAPINEN_CAPINEN0_Msk         (0x1ul << PWM_CAPINEN_CAPINEN0_Pos)               /*!< PWM_T::CAPINEN: CAPINEN0 Mask             */
N
N#define PWM_CAPINEN_CAPINEN1_Pos         (1)                                               /*!< PWM_T::CAPINEN: CAPINEN1 Position         */
N#define PWM_CAPINEN_CAPINEN1_Msk         (0x1ul << PWM_CAPINEN_CAPINEN1_Pos)               /*!< PWM_T::CAPINEN: CAPINEN1 Mask             */
N
N#define PWM_CAPINEN_CAPINEN2_Pos         (2)                                               /*!< PWM_T::CAPINEN: CAPINEN2 Position         */
N#define PWM_CAPINEN_CAPINEN2_Msk         (0x1ul << PWM_CAPINEN_CAPINEN2_Pos)               /*!< PWM_T::CAPINEN: CAPINEN2 Mask             */
N
N#define PWM_CAPINEN_CAPINEN3_Pos         (3)                                               /*!< PWM_T::CAPINEN: CAPINEN3 Position         */
N#define PWM_CAPINEN_CAPINEN3_Msk         (0x1ul << PWM_CAPINEN_CAPINEN3_Pos)               /*!< PWM_T::CAPINEN: CAPINEN3 Mask             */
N
N#define PWM_CAPINEN_CAPINEN4_Pos         (4)                                               /*!< PWM_T::CAPINEN: CAPINEN4 Position         */
N#define PWM_CAPINEN_CAPINEN4_Msk         (0x1ul << PWM_CAPINEN_CAPINEN4_Pos)               /*!< PWM_T::CAPINEN: CAPINEN4 Mask             */
N
N#define PWM_CAPINEN_CAPINEN5_Pos         (5)                                               /*!< PWM_T::CAPINEN: CAPINEN5 Position         */
N#define PWM_CAPINEN_CAPINEN5_Msk         (0x1ul << PWM_CAPINEN_CAPINEN5_Pos)               /*!< PWM_T::CAPINEN: CAPINEN5 Mask             */
N
N#define PWM_CAPCTL_CAPENn_Pos            (0)                                               /*!< PWM_T::CAPCTL: CAPENn Position            */
N#define PWM_CAPCTL_CAPENn_Msk            (0x3ful << PWM_CAPCTL_CAPENn_Pos)                 /*!< PWM_T::CAPCTL: CAPENn Mask                */
N
N#define PWM_CAPCTL_CAPEN0_Pos            (0)                                               /*!< PWM_T::CAPCTL: CAPEN0 Position            */
N#define PWM_CAPCTL_CAPEN0_Msk            (0x1ul << PWM_CAPCTL_CAPEN0_Pos)                  /*!< PWM_T::CAPCTL: CAPEN0 Mask                */
N
N#define PWM_CAPCTL_CAPEN1_Pos            (1)                                               /*!< PWM_T::CAPCTL: CAPEN1 Position            */
N#define PWM_CAPCTL_CAPEN1_Msk            (0x1ul << PWM_CAPCTL_CAPEN1_Pos)                  /*!< PWM_T::CAPCTL: CAPEN1 Mask                */
N
N#define PWM_CAPCTL_CAPEN2_Pos            (2)                                               /*!< PWM_T::CAPCTL: CAPEN2 Position            */
N#define PWM_CAPCTL_CAPEN2_Msk            (0x1ul << PWM_CAPCTL_CAPEN2_Pos)                  /*!< PWM_T::CAPCTL: CAPEN2 Mask                */
N
N#define PWM_CAPCTL_CAPEN3_Pos            (3)                                               /*!< PWM_T::CAPCTL: CAPEN3 Position            */
N#define PWM_CAPCTL_CAPEN3_Msk            (0x1ul << PWM_CAPCTL_CAPEN3_Pos)                  /*!< PWM_T::CAPCTL: CAPEN3 Mask                */
N
N#define PWM_CAPCTL_CAPEN4_Pos            (4)                                               /*!< PWM_T::CAPCTL: CAPEN4 Position            */
N#define PWM_CAPCTL_CAPEN4_Msk            (0x1ul << PWM_CAPCTL_CAPEN4_Pos)                  /*!< PWM_T::CAPCTL: CAPEN4 Mask                */
N
N#define PWM_CAPCTL_CAPEN5_Pos            (5)                                               /*!< PWM_T::CAPCTL: CAPEN5 Position            */
N#define PWM_CAPCTL_CAPEN5_Msk            (0x1ul << PWM_CAPCTL_CAPEN5_Pos)                  /*!< PWM_T::CAPCTL: CAPEN5 Mask                */
N
N#define PWM_CAPCTL_CAPINVn_Pos           (8)                                               /*!< PWM_T::CAPCTL: CAPINVn Position           */
N#define PWM_CAPCTL_CAPINVn_Msk           (0x3ful << PWM_CAPCTL_CAPINVn_Pos)                /*!< PWM_T::CAPCTL: CAPINVn Mask               */
N
N#define PWM_CAPCTL_CAPINV0_Pos           (8)                                               /*!< PWM_T::CAPCTL: CAPINV0 Position           */
N#define PWM_CAPCTL_CAPINV0_Msk           (0x1ul << PWM_CAPCTL_CAPINV0_Pos)                 /*!< PWM_T::CAPCTL: CAPINV0 Mask               */
N
N#define PWM_CAPCTL_CAPINV1_Pos           (9)                                               /*!< PWM_T::CAPCTL: CAPINV1 Position           */
N#define PWM_CAPCTL_CAPINV1_Msk           (0x1ul << PWM_CAPCTL_CAPINV1_Pos)                 /*!< PWM_T::CAPCTL: CAPINV1 Mask               */
N
N#define PWM_CAPCTL_CAPINV2_Pos           (10)                                              /*!< PWM_T::CAPCTL: CAPINV2 Position           */
N#define PWM_CAPCTL_CAPINV2_Msk           (0x1ul << PWM_CAPCTL_CAPINV2_Pos)                 /*!< PWM_T::CAPCTL: CAPINV2 Mask               */
N
N#define PWM_CAPCTL_CAPINV3_Pos           (11)                                              /*!< PWM_T::CAPCTL: CAPINV3 Position           */
N#define PWM_CAPCTL_CAPINV3_Msk           (0x1ul << PWM_CAPCTL_CAPINV3_Pos)                 /*!< PWM_T::CAPCTL: CAPINV3 Mask               */
N
N#define PWM_CAPCTL_CAPINV4_Pos           (12)                                              /*!< PWM_T::CAPCTL: CAPINV4 Position           */
N#define PWM_CAPCTL_CAPINV4_Msk           (0x1ul << PWM_CAPCTL_CAPINV4_Pos)                 /*!< PWM_T::CAPCTL: CAPINV4 Mask               */
N
N#define PWM_CAPCTL_CAPINV5_Pos           (13)                                              /*!< PWM_T::CAPCTL: CAPINV5 Position           */
N#define PWM_CAPCTL_CAPINV5_Msk           (0x1ul << PWM_CAPCTL_CAPINV5_Pos)                 /*!< PWM_T::CAPCTL: CAPINV5 Mask               */
N
N#define PWM_CAPCTL_RCRLDENn_Pos          (16)                                              /*!< PWM_T::CAPCTL: RCRLDENn Position          */
N#define PWM_CAPCTL_RCRLDENn_Msk          (0x3ful << PWM_CAPCTL_RCRLDENn_Pos)               /*!< PWM_T::CAPCTL: RCRLDENn Mask              */
N
N#define PWM_CAPCTL_RCRLDEN0_Pos          (16)                                              /*!< PWM_T::CAPCTL: RCRLDEN0 Position          */
N#define PWM_CAPCTL_RCRLDEN0_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN0_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN0 Mask              */
N
N#define PWM_CAPCTL_RCRLDEN1_Pos          (17)                                              /*!< PWM_T::CAPCTL: RCRLDEN1 Position          */
N#define PWM_CAPCTL_RCRLDEN1_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN1_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN1 Mask              */
N
N#define PWM_CAPCTL_RCRLDEN2_Pos          (18)                                              /*!< PWM_T::CAPCTL: RCRLDEN2 Position          */
N#define PWM_CAPCTL_RCRLDEN2_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN2_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN2 Mask              */
N
N#define PWM_CAPCTL_RCRLDEN3_Pos          (19)                                              /*!< PWM_T::CAPCTL: RCRLDEN3 Position          */
N#define PWM_CAPCTL_RCRLDEN3_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN3_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN3 Mask              */
N
N#define PWM_CAPCTL_RCRLDEN4_Pos          (20)                                              /*!< PWM_T::CAPCTL: RCRLDEN4 Position          */
N#define PWM_CAPCTL_RCRLDEN4_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN4_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN4 Mask              */
N
N#define PWM_CAPCTL_RCRLDEN5_Pos          (21)                                              /*!< PWM_T::CAPCTL: RCRLDEN5 Position          */
N#define PWM_CAPCTL_RCRLDEN5_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN5_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN5 Mask              */
N
N#define PWM_CAPCTL_FCRLDENn_Pos          (24)                                              /*!< PWM_T::CAPCTL: FCRLDENn Position          */
N#define PWM_CAPCTL_FCRLDENn_Msk          (0x3ful << PWM_CAPCTL_FCRLDENn_Pos)               /*!< PWM_T::CAPCTL: FCRLDENn Mask              */
N
N#define PWM_CAPCTL_FCRLDEN0_Pos          (24)                                              /*!< PWM_T::CAPCTL: FCRLDEN0 Position          */
N#define PWM_CAPCTL_FCRLDEN0_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN0_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN0 Mask              */
N
N#define PWM_CAPCTL_FCRLDEN1_Pos          (25)                                              /*!< PWM_T::CAPCTL: FCRLDEN1 Position          */
N#define PWM_CAPCTL_FCRLDEN1_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN1_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN1 Mask              */
N
N#define PWM_CAPCTL_FCRLDEN2_Pos          (26)                                              /*!< PWM_T::CAPCTL: FCRLDEN2 Position          */
N#define PWM_CAPCTL_FCRLDEN2_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN2_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN2 Mask              */
N
N#define PWM_CAPCTL_FCRLDEN3_Pos          (27)                                              /*!< PWM_T::CAPCTL: FCRLDEN3 Position          */
N#define PWM_CAPCTL_FCRLDEN3_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN3_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN3 Mask              */
N
N#define PWM_CAPCTL_FCRLDEN4_Pos          (28)                                              /*!< PWM_T::CAPCTL: FCRLDEN4 Position          */
N#define PWM_CAPCTL_FCRLDEN4_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN4_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN4 Mask              */
N
N#define PWM_CAPCTL_FCRLDEN5_Pos          (29)                                              /*!< PWM_T::CAPCTL: FCRLDEN5 Position          */
N#define PWM_CAPCTL_FCRLDEN5_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN5_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN5 Mask              */
N
N#define PWM_CAPSTS_CRLIFOVn_Pos          (0)                                               /*!< PWM_T::CAPSTS: CRLIFOVn Position          */
N#define PWM_CAPSTS_CRLIFOVn_Msk          (0x3ful << PWM_CAPSTS_CRLIFOVn_Pos)               /*!< PWM_T::CAPSTS: CRLIFOVn Mask              */
N
N#define PWM_CAPSTS_CRLIFOV0_Pos          (0)                                               /*!< PWM_T::CAPSTS: CRLIFOV0 Position          */
N#define PWM_CAPSTS_CRLIFOV0_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV0_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV0 Mask              */
N
N#define PWM_CAPSTS_CRLIFOV1_Pos          (1)                                               /*!< PWM_T::CAPSTS: CRLIFOV1 Position          */
N#define PWM_CAPSTS_CRLIFOV1_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV1_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV1 Mask              */
N
N#define PWM_CAPSTS_CRLIFOV2_Pos          (2)                                               /*!< PWM_T::CAPSTS: CRLIFOV2 Position          */
N#define PWM_CAPSTS_CRLIFOV2_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV2_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV2 Mask              */
N
N#define PWM_CAPSTS_CRLIFOV3_Pos          (3)                                               /*!< PWM_T::CAPSTS: CRLIFOV3 Position          */
N#define PWM_CAPSTS_CRLIFOV3_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV3_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV3 Mask              */
N
N#define PWM_CAPSTS_CRLIFOV4_Pos          (4)                                               /*!< PWM_T::CAPSTS: CRLIFOV4 Position          */
N#define PWM_CAPSTS_CRLIFOV4_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV4_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV4 Mask              */
N
N#define PWM_CAPSTS_CRLIFOV5_Pos          (5)                                               /*!< PWM_T::CAPSTS: CRLIFOV5 Position          */
N#define PWM_CAPSTS_CRLIFOV5_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV5_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV5 Mask              */
N
N#define PWM_CAPSTS_CFLIFOVn_Pos          (8)                                               /*!< PWM_T::CAPSTS: CFLIFOVn Position          */
N#define PWM_CAPSTS_CFLIFOVn_Msk          (0x3ful << PWM_CAPSTS_CFLIFOVn_Pos)               /*!< PWM_T::CAPSTS: CFLIFOVn Mask              */
N
N#define PWM_CAPSTS_CFLIFOV0_Pos          (8)                                               /*!< PWM_T::CAPSTS: CFLIFOV0 Position          */
N#define PWM_CAPSTS_CFLIFOV0_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV0_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV0 Mask              */
N
N#define PWM_CAPSTS_CFLIFOV1_Pos          (9)                                               /*!< PWM_T::CAPSTS: CFLIFOV1 Position          */
N#define PWM_CAPSTS_CFLIFOV1_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV1_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV1 Mask              */
N
N#define PWM_CAPSTS_CFLIFOV2_Pos          (10)                                              /*!< PWM_T::CAPSTS: CFLIFOV2 Position          */
N#define PWM_CAPSTS_CFLIFOV2_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV2_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV2 Mask              */
N
N#define PWM_CAPSTS_CFLIFOV3_Pos          (11)                                              /*!< PWM_T::CAPSTS: CFLIFOV3 Position          */
N#define PWM_CAPSTS_CFLIFOV3_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV3_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV3 Mask              */
N
N#define PWM_CAPSTS_CFLIFOV4_Pos          (12)                                              /*!< PWM_T::CAPSTS: CFLIFOV4 Position          */
N#define PWM_CAPSTS_CFLIFOV4_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV4_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV4 Mask              */
N
N#define PWM_CAPSTS_CFLIFOV5_Pos          (13)                                              /*!< PWM_T::CAPSTS: CFLIFOV5 Position          */
N#define PWM_CAPSTS_CFLIFOV5_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV5_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV5 Mask              */
N
N#define PWM_RCAPDAT0_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT0: RCAPDAT Position         */
N#define PWM_RCAPDAT0_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT0_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT0: RCAPDAT Mask             */
N
N#define PWM_FCAPDAT0_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT0: FCAPDAT Position         */
N#define PWM_FCAPDAT0_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT0_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT0: FCAPDAT Mask             */
N
N#define PWM_RCAPDAT1_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT1: RCAPDAT Position         */
N#define PWM_RCAPDAT1_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT1_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT1: RCAPDAT Mask             */
N
N#define PWM_FCAPDAT1_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT1: FCAPDAT Position         */
N#define PWM_FCAPDAT1_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT1_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT1: FCAPDAT Mask             */
N
N#define PWM_RCAPDAT2_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT2: RCAPDAT Position         */
N#define PWM_RCAPDAT2_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT2_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT2: RCAPDAT Mask             */
N
N#define PWM_FCAPDAT2_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT2: FCAPDAT Position         */
N#define PWM_FCAPDAT2_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT2_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT2: FCAPDAT Mask             */
N
N#define PWM_RCAPDAT3_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT3: RCAPDAT Position         */
N#define PWM_RCAPDAT3_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT3_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT3: RCAPDAT Mask             */
N
N#define PWM_FCAPDAT3_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT3: FCAPDAT Position         */
N#define PWM_FCAPDAT3_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT3_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT3: FCAPDAT Mask             */
N
N#define PWM_RCAPDAT4_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT4: RCAPDAT Position         */
N#define PWM_RCAPDAT4_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT4_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT4: RCAPDAT Mask             */
N
N#define PWM_FCAPDAT4_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT4: FCAPDAT Position         */
N#define PWM_FCAPDAT4_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT4_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT4: FCAPDAT Mask             */
N
N#define PWM_RCAPDAT5_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT5: RCAPDAT Position         */
N#define PWM_RCAPDAT5_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT5_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT5: RCAPDAT Mask             */
N
N#define PWM_FCAPDAT5_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT5: FCAPDAT Position         */
N#define PWM_FCAPDAT5_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT5_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT5: FCAPDAT Mask             */
N
N#define PWM_PDMACTL_CHEN0_1_Pos          (0)                                               /*!< PWM_T::PDMACTL: CHEN0_1 Position          */
N#define PWM_PDMACTL_CHEN0_1_Msk          (0x1ul << PWM_PDMACTL_CHEN0_1_Pos)                /*!< PWM_T::PDMACTL: CHEN0_1 Mask              */
N
N#define PWM_PDMACTL_CAPMOD0_1_Pos        (1)                                               /*!< PWM_T::PDMACTL: CAPMOD0_1 Position        */
N#define PWM_PDMACTL_CAPMOD0_1_Msk        (0x3ul << PWM_PDMACTL_CAPMOD0_1_Pos)              /*!< PWM_T::PDMACTL: CAPMOD0_1 Mask            */
N
N#define PWM_PDMACTL_CAPORD0_1_Pos        (3)                                               /*!< PWM_T::PDMACTL: CAPORD0_1 Position        */
N#define PWM_PDMACTL_CAPORD0_1_Msk        (0x1ul << PWM_PDMACTL_CAPORD0_1_Pos)              /*!< PWM_T::PDMACTL: CAPORD0_1 Mask            */
N
N#define PWM_PDMACTL_CHSEL0_1_Pos         (4)                                               /*!< PWM_T::PDMACTL: CHSEL0_1 Position         */
N#define PWM_PDMACTL_CHSEL0_1_Msk         (0x1ul << PWM_PDMACTL_CHSEL0_1_Pos)               /*!< PWM_T::PDMACTL: CHSEL0_1 Mask             */
N
N#define PWM_PDMACTL_CHEN2_3_Pos          (8)                                               /*!< PWM_T::PDMACTL: CHEN2_3 Position          */
N#define PWM_PDMACTL_CHEN2_3_Msk          (0x1ul << PWM_PDMACTL_CHEN2_3_Pos)                /*!< PWM_T::PDMACTL: CHEN2_3 Mask              */
N
N#define PWM_PDMACTL_CAPMOD2_3_Pos        (9)                                               /*!< PWM_T::PDMACTL: CAPMOD2_3 Position        */
N#define PWM_PDMACTL_CAPMOD2_3_Msk        (0x3ul << PWM_PDMACTL_CAPMOD2_3_Pos)              /*!< PWM_T::PDMACTL: CAPMOD2_3 Mask            */
N
N#define PWM_PDMACTL_CAPORD2_3_Pos        (11)                                              /*!< PWM_T::PDMACTL: CAPORD2_3 Position        */
N#define PWM_PDMACTL_CAPORD2_3_Msk        (0x1ul << PWM_PDMACTL_CAPORD2_3_Pos)              /*!< PWM_T::PDMACTL: CAPORD2_3 Mask            */
N
N#define PWM_PDMACTL_CHSEL2_3_Pos         (12)                                              /*!< PWM_T::PDMACTL: CHSEL2_3 Position         */
N#define PWM_PDMACTL_CHSEL2_3_Msk         (0x1ul << PWM_PDMACTL_CHSEL2_3_Pos)               /*!< PWM_T::PDMACTL: CHSEL2_3 Mask             */
N
N#define PWM_PDMACTL_CHEN4_5_Pos          (16)                                              /*!< PWM_T::PDMACTL: CHEN4_5 Position          */
N#define PWM_PDMACTL_CHEN4_5_Msk          (0x1ul << PWM_PDMACTL_CHEN4_5_Pos)                /*!< PWM_T::PDMACTL: CHEN4_5 Mask              */
N
N#define PWM_PDMACTL_CAPMOD4_5_Pos        (17)                                              /*!< PWM_T::PDMACTL: CAPMOD4_5 Position        */
N#define PWM_PDMACTL_CAPMOD4_5_Msk        (0x3ul << PWM_PDMACTL_CAPMOD4_5_Pos)              /*!< PWM_T::PDMACTL: CAPMOD4_5 Mask            */
N
N#define PWM_PDMACTL_CAPORD4_5_Pos        (19)                                              /*!< PWM_T::PDMACTL: CAPORD4_5 Position        */
N#define PWM_PDMACTL_CAPORD4_5_Msk        (0x1ul << PWM_PDMACTL_CAPORD4_5_Pos)              /*!< PWM_T::PDMACTL: CAPORD4_5 Mask            */
N
N#define PWM_PDMACTL_CHSEL4_5_Pos         (20)                                              /*!< PWM_T::PDMACTL: CHSEL4_5 Position         */
N#define PWM_PDMACTL_CHSEL4_5_Msk         (0x1ul << PWM_PDMACTL_CHSEL4_5_Pos)               /*!< PWM_T::PDMACTL: CHSEL4_5 Mask             */
N
N#define PWM_PDMACAP0_1_CAPBUF_Pos        (0)                                               /*!< PWM_T::PDMACAP0_1: CAPBUF Position        */
N#define PWM_PDMACAP0_1_CAPBUF_Msk        (0xfffful << PWM_PDMACAP0_1_CAPBUF_Pos)           /*!< PWM_T::PDMACAP0_1: CAPBUF Mask            */
N
N#define PWM_PDMACAP2_3_CAPBUF_Pos        (0)                                               /*!< PWM_T::PDMACAP2_3: CAPBUF Position        */
N#define PWM_PDMACAP2_3_CAPBUF_Msk        (0xfffful << PWM_PDMACAP2_3_CAPBUF_Pos)           /*!< PWM_T::PDMACAP2_3: CAPBUF Mask            */
N
N#define PWM_PDMACAP4_5_CAPBUF_Pos        (0)                                               /*!< PWM_T::PDMACAP4_5: CAPBUF Position        */
N#define PWM_PDMACAP4_5_CAPBUF_Msk        (0xfffful << PWM_PDMACAP4_5_CAPBUF_Pos)           /*!< PWM_T::PDMACAP4_5: CAPBUF Mask            */
N
N#define PWM_CAPIEN_CAPRIENn_Pos          (0)                                               /*!< PWM_T::CAPIEN: CAPRIENn Position          */
N#define PWM_CAPIEN_CAPRIENn_Msk          (0x3ful << PWM_CAPIEN_CAPRIENn_Pos)               /*!< PWM_T::CAPIEN: CAPRIENn Mask              */
N
N#define PWM_CAPIEN_CAPRIEN0_Pos          (0)                                               /*!< PWM_T::CAPIEN: CAPRIEN0 Position          */
N#define PWM_CAPIEN_CAPRIEN0_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN0_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN0 Mask              */
N
N#define PWM_CAPIEN_CAPRIEN1_Pos          (1)                                               /*!< PWM_T::CAPIEN: CAPRIEN1 Position          */
N#define PWM_CAPIEN_CAPRIEN1_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN1_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN1 Mask              */
N
N#define PWM_CAPIEN_CAPRIEN2_Pos          (2)                                               /*!< PWM_T::CAPIEN: CAPRIEN2 Position          */
N#define PWM_CAPIEN_CAPRIEN2_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN2_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN2 Mask              */
N
N#define PWM_CAPIEN_CAPRIEN3_Pos          (3)                                               /*!< PWM_T::CAPIEN: CAPRIEN3 Position          */
N#define PWM_CAPIEN_CAPRIEN3_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN3_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN3 Mask              */
N
N#define PWM_CAPIEN_CAPRIEN4_Pos          (4)                                               /*!< PWM_T::CAPIEN: CAPRIEN4 Position          */
N#define PWM_CAPIEN_CAPRIEN4_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN4_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN4 Mask              */
N
N#define PWM_CAPIEN_CAPRIEN5_Pos          (5)                                               /*!< PWM_T::CAPIEN: CAPRIEN5 Position          */
N#define PWM_CAPIEN_CAPRIEN5_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN5_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN5 Mask              */
N
N#define PWM_CAPIEN_CAPFIENn_Pos          (8)                                               /*!< PWM_T::CAPIEN: CAPFIENn Position          */
N#define PWM_CAPIEN_CAPFIENn_Msk          (0x3ful << PWM_CAPIEN_CAPFIENn_Pos)               /*!< PWM_T::CAPIEN: CAPFIENn Mask              */
N
N#define PWM_CAPIEN_CAPFIEN0_Pos          (8)                                               /*!< PWM_T::CAPIEN: CAPFIEN0 Position          */
N#define PWM_CAPIEN_CAPFIEN0_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN0_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN0 Mask              */
N
N#define PWM_CAPIEN_CAPFIEN1_Pos          (9)                                               /*!< PWM_T::CAPIEN: CAPFIEN1 Position          */
N#define PWM_CAPIEN_CAPFIEN1_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN1_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN1 Mask              */
N
N#define PWM_CAPIEN_CAPFIEN2_Pos          (10)                                              /*!< PWM_T::CAPIEN: CAPFIEN2 Position          */
N#define PWM_CAPIEN_CAPFIEN2_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN2_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN2 Mask              */
N
N#define PWM_CAPIEN_CAPFIEN3_Pos          (11)                                              /*!< PWM_T::CAPIEN: CAPFIEN3 Position          */
N#define PWM_CAPIEN_CAPFIEN3_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN3_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN3 Mask              */
N
N#define PWM_CAPIEN_CAPFIEN4_Pos          (12)                                              /*!< PWM_T::CAPIEN: CAPFIEN4 Position          */
N#define PWM_CAPIEN_CAPFIEN4_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN4_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN4 Mask              */
N
N#define PWM_CAPIEN_CAPFIEN5_Pos          (13)                                              /*!< PWM_T::CAPIEN: CAPFIEN5 Position          */
N#define PWM_CAPIEN_CAPFIEN5_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN5_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN5 Mask              */
N
N#define PWM_CAPIF_CRLIFn_Pos             (0)                                               /*!< PWM_T::CAPIF: CRLIFn Position             */
N#define PWM_CAPIF_CRLIFn_Msk             (0x3ful << PWM_CAPIF_CRLIFn_Pos)                  /*!< PWM_T::CAPIF: CRLIFn Mask                 */
N
N#define PWM_CAPIF_CRLIF0_Pos             (0)                                               /*!< PWM_T::CAPIF: CRLIF0 Position             */
N#define PWM_CAPIF_CRLIF0_Msk             (0x1ul << PWM_CAPIF_CRLIF0_Pos)                   /*!< PWM_T::CAPIF: CRLIF0 Mask                 */
N
N#define PWM_CAPIF_CRLIF1_Pos             (1)                                               /*!< PWM_T::CAPIF: CRLIF1 Position             */
N#define PWM_CAPIF_CRLIF1_Msk             (0x1ul << PWM_CAPIF_CRLIF1_Pos)                   /*!< PWM_T::CAPIF: CRLIF1 Mask                 */
N
N#define PWM_CAPIF_CRLIF2_Pos             (2)                                               /*!< PWM_T::CAPIF: CRLIF2 Position             */
N#define PWM_CAPIF_CRLIF2_Msk             (0x1ul << PWM_CAPIF_CRLIF2_Pos)                   /*!< PWM_T::CAPIF: CRLIF2 Mask                 */
N
N#define PWM_CAPIF_CRLIF3_Pos             (3)                                               /*!< PWM_T::CAPIF: CRLIF3 Position             */
N#define PWM_CAPIF_CRLIF3_Msk             (0x1ul << PWM_CAPIF_CRLIF3_Pos)                   /*!< PWM_T::CAPIF: CRLIF3 Mask                 */
N
N#define PWM_CAPIF_CRLIF4_Pos             (4)                                               /*!< PWM_T::CAPIF: CRLIF4 Position             */
N#define PWM_CAPIF_CRLIF4_Msk             (0x1ul << PWM_CAPIF_CRLIF4_Pos)                   /*!< PWM_T::CAPIF: CRLIF4 Mask                 */
N
N#define PWM_CAPIF_CRLIF5_Pos             (5)                                               /*!< PWM_T::CAPIF: CRLIF5 Position             */
N#define PWM_CAPIF_CRLIF5_Msk             (0x1ul << PWM_CAPIF_CRLIF5_Pos)                   /*!< PWM_T::CAPIF: CRLIF5 Mask                 */
N
N#define PWM_CAPIF_CFLIFn_Pos             (8)                                               /*!< PWM_T::CAPIF: CFLIFn Position             */
N#define PWM_CAPIF_CFLIFn_Msk             (0x3ful << PWM_CAPIF_CFLIFn_Pos)                  /*!< PWM_T::CAPIF: CFLIFn Mask                 */
N
N#define PWM_CAPIF_CFLIF0_Pos             (8)                                               /*!< PWM_T::CAPIF: CFLIF0 Position             */
N#define PWM_CAPIF_CFLIF0_Msk             (0x1ul << PWM_CAPIF_CFLIF0_Pos)                   /*!< PWM_T::CAPIF: CFLIF0 Mask                 */
N
N#define PWM_CAPIF_CFLIF1_Pos             (9)                                               /*!< PWM_T::CAPIF: CFLIF1 Position             */
N#define PWM_CAPIF_CFLIF1_Msk             (0x1ul << PWM_CAPIF_CFLIF1_Pos)                   /*!< PWM_T::CAPIF: CFLIF1 Mask                 */
N
N#define PWM_CAPIF_CFLIF2_Pos             (10)                                              /*!< PWM_T::CAPIF: CFLIF2 Position             */
N#define PWM_CAPIF_CFLIF2_Msk             (0x1ul << PWM_CAPIF_CFLIF2_Pos)                   /*!< PWM_T::CAPIF: CFLIF2 Mask                 */
N
N#define PWM_CAPIF_CFLIF3_Pos             (11)                                              /*!< PWM_T::CAPIF: CFLIF3 Position             */
N#define PWM_CAPIF_CFLIF3_Msk             (0x1ul << PWM_CAPIF_CFLIF3_Pos)                   /*!< PWM_T::CAPIF: CFLIF3 Mask                 */
N
N#define PWM_CAPIF_CFLIF4_Pos             (12)                                              /*!< PWM_T::CAPIF: CFLIF4 Position             */
N#define PWM_CAPIF_CFLIF4_Msk             (0x1ul << PWM_CAPIF_CFLIF4_Pos)                   /*!< PWM_T::CAPIF: CFLIF4 Mask                 */
N
N#define PWM_CAPIF_CFLIF5_Pos             (13)                                              /*!< PWM_T::CAPIF: CFLIF5 Position             */
N#define PWM_CAPIF_CFLIF5_Msk             (0x1ul << PWM_CAPIF_CFLIF5_Pos)                   /*!< PWM_T::CAPIF: CFLIF5 Mask                 */
N
N#define PWM_PBUF_PBUF_Pos                (0)                                               /*!< PWM_T::PBUF: PBUF Position                */
N#define PWM_PBUF_PBUF_Msk                (0xfffful << PWM_PBUF_PBUF_Pos)                   /*!< PWM_T::PBUF: PBUF Mask                    */
N
N#define PWM_CMPBUF_CMPBUF_Pos            (0)                                               /*!< PWM_T::CMPBUF: CMPBUF Position            */
N#define PWM_CMPBUF_CMPBUF_Msk            (0xfffful << PWM_CMPBUF_CMPBUF_Pos)               /*!< PWM_T::CMPBUF: CMPBUF Mask                */
N
N#define PWM_FTCBUF0_1_FTCMPBUF_Pos       (0)                                               /*!< PWM_T::FTCBUF0_1: FTCMPBUF Position       */
N#define PWM_FTCBUF0_1_FTCMPBUF_Msk       (0xfffful << PWM_FTCBUF0_1_FTCMPBUF_Pos)          /*!< PWM_T::FTCBUF0_1: FTCMPBUF Mask           */
N
N#define PWM_FTCBUF2_3_FTCMPBUF_Pos       (0)                                               /*!< PWM_T::FTCBUF2_3: FTCMPBUF Position       */
N#define PWM_FTCBUF2_3_FTCMPBUF_Msk       (0xfffful << PWM_FTCBUF2_3_FTCMPBUF_Pos)          /*!< PWM_T::FTCBUF2_3: FTCMPBUF Mask           */
N
N#define PWM_FTCBUF4_5_FTCMPBUF_Pos       (0)                                               /*!< PWM_T::FTCBUF4_5: FTCMPBUF Position       */
N#define PWM_FTCBUF4_5_FTCMPBUF_Msk       (0xfffful << PWM_FTCBUF4_5_FTCMPBUF_Pos)          /*!< PWM_T::FTCBUF4_5: FTCMPBUF Mask           */
N
N#define PWM_FTCI_FTCMUn_Pos              (0)                                               /*!< PWM_T::FTCI: FTCMUn Position              */
N#define PWM_FTCI_FTCMUn_Msk              (0x7ul << PWM_FTCI_FTCMUn_Pos)                    /*!< PWM_T::FTCI: FTCMUn Mask                  */
N
N#define PWM_FTCI_FTCMU0_Pos              (0)                                               /*!< PWM_T::FTCI: FTCMU0 Position              */
N#define PWM_FTCI_FTCMU0_Msk              (0x1ul << PWM_FTCI_FTCMU0_Pos)                    /*!< PWM_T::FTCI: FTCMU0 Mask                  */
N
N#define PWM_FTCI_FTCMU2_Pos              (1)                                               /*!< PWM_T::FTCI: FTCMU2 Position              */
N#define PWM_FTCI_FTCMU2_Msk              (0x1ul << PWM_FTCI_FTCMU2_Pos)                    /*!< PWM_T::FTCI: FTCMU2 Mask                  */
N
N#define PWM_FTCI_FTCMU4_Pos              (2)                                               /*!< PWM_T::FTCI: FTCMU4 Position              */
N#define PWM_FTCI_FTCMU4_Msk              (0x1ul << PWM_FTCI_FTCMU4_Pos)                    /*!< PWM_T::FTCI: FTCMU4 Mask                  */
N
N#define PWM_FTCI_FTCMDn_Pos              (8)                                               /*!< PWM_T::FTCI: FTCMDn Position              */
N#define PWM_FTCI_FTCMDn_Msk              (0x7ul << PWM_FTCI_FTCMDn_Pos)                    /*!< PWM_T::FTCI: FTCMDn Mask                  */
N
N#define PWM_FTCI_FTCMD0_Pos              (8)                                               /*!< PWM_T::FTCI: FTCMD0 Position              */
N#define PWM_FTCI_FTCMD0_Msk              (0x1ul << PWM_FTCI_FTCMD0_Pos)                    /*!< PWM_T::FTCI: FTCMD0 Mask                  */
N
N#define PWM_FTCI_FTCMD2_Pos              (9)                                               /*!< PWM_T::FTCI: FTCMD2 Position              */
N#define PWM_FTCI_FTCMD2_Msk              (0x1ul << PWM_FTCI_FTCMD2_Pos)                    /*!< PWM_T::FTCI: FTCMD2 Mask                  */
N
N#define PWM_FTCI_FTCMD4_Pos              (10)                                              /*!< PWM_T::FTCI: FTCMD4 Position              */
N#define PWM_FTCI_FTCMD4_Msk              (0x1ul << PWM_FTCI_FTCMD4_Pos)                    /*!< PWM_T::FTCI: FTCMD4 Mask                  */
N
N/**@}*/ /* PWM_CONST */
N/**@}*/ /* end of PWM register group */
N
N
N/*---------------------- Real Time Clock Controller -------------------------*/
N/**
N    @addtogroup RTC Real Time Clock Controller(RTC)
N    Memory Mapped Structure for RTC Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N
N
N/**
N * @var RTC_T::INIT
N * Offset: 0x00  RTC Initiation Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |INIT[0]/ACTIVE|RTC Active Status (Read Only)
N * |        |          |0 = RTC is at reset state.
N * |        |          |1 = RTC is at normal active state.
N * |[31:1]  |INIT[31:1]|RTC Initiation
N * |        |          |When RTC block is powered on, RTC is at reset state.
N * |        |          |User has to write a number (0x a5eb1357) to INIT to make RTC leaving reset state.
N * |        |          |Once the INIT is written as 0xa5eb1357, the RTC will be in un-reset state permanently.
N * |        |          |The INIT is a write-only field and read value will be always 0.
N * @var RTC_T::RWEN
N * Offset: 0x04  RTC Access Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |RWEN      |RTC Register Access Enable Password (Write Only)
N * |        |          |Writing 0xA965 to this register will enable RTC access and keep 1024 RTC clock.
N * |[16]    |RWENF     |RTC Register Access Enable Flag (Read Only)
N * |        |          |0 = RTC register read/write Disabled.
N * |        |          |1 = RTC register read/write Enabled.
N * |        |          |This bit will be set after RTC_RWEN[15:0] register is load a 0xA965, and be cleared automatically after 1024 RTC clock.
N * @var RTC_T::FREQADJ
N * Offset: 0x08  RTC Frequency Compensation Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |FRACTION  |Fraction Part
N * |        |          |Formula = (fraction part of detected value) x 60.
N * |        |          |Note: Digit in RTC_FREQADJ must be expressed as hexadecimal number.
N * |[11:8]  |INTEGER   |Integer Part
N * @var RTC_T::TIME
N * Offset: 0x0C  Time Loading Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |SEC       |1-Sec Time Digit (0~9)
N * |[6:4]   |TENSEC    |10-Sec Time Digit (0~5)
N * |[11:8]  |MIN       |1-Min Time Digit (0~9)
N * |[14:12] |TENMIN    |10-Min Time Digit (0~5)
N * |[19:16] |HR        |1-Hour Time Digit (0~9)
N * |[21:20] |TENHR     |10-Hour Time Digit (0~2)
N * @var RTC_T::CAL
N * Offset: 0x10  RTC Calendar Loading Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |DAY       |1-Day Calendar Digit (0~9)
N * |[5:4]   |TENDAY    |10-Day Calendar Digit (0~3)
N * |[11:8]  |MON       |1-Month Calendar Digit (0~9)
N * |[12]    |TENMON    |10-Month Calendar Digit (0~1)
N * |[19:16] |YEAR      |1-Year Calendar Digit (0~9)
N * |[23:20] |TENYEAR   |10-Year Calendar Digit (0~9)
N * @var RTC_T::CLKFMT
N * Offset: 0x14  Time Scale Selection Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |24HEN     |24-Hour / 12-Hour Time Scale Selection
N * |        |          |Indicates that RTC_TIME and RTC_TALM are in 24-hour time scale or 12-hour time scale
N * |        |          |0 = 12-hour time scale with AM and PM indication selected.
N * |        |          |1 = 24-hour time scale selected.
N * @var RTC_T::WEEKDAY
N * Offset: 0x18  Day of the Week Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2:0]   |WEEKDAY   |Day Of The Week Register
N * |        |          |000 = Sunday.
N * |        |          |001 = Monday.
N * |        |          |010 = Tuesday.
N * |        |          |011 = Wednesday.
N * |        |          |100 = Thursday.
N * |        |          |101 = Friday.
N * |        |          |110 = Saturday.
N * |        |          |111 = Reserved.
N * @var RTC_T::TALM
N * Offset: 0x1C  Time Alarm Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |SEC       |1-Sec Time Digit of Alarm Setting (0~9)
N * |[6:4]   |TENSEC    |10-Sec Time Digit of Alarm Setting (0~5)
N * |[11:8]  |MIN       |1-Min Time Digit of Alarm Setting (0~9)
N * |[14:12] |TENMIN    |10-Min Time Digit of Alarm Setting (0~5)
N * |[19:16] |HR        |1-Hour Time Digit of Alarm Setting (0~9)
N * |[21:20] |TENHR     |10-Hour Time Digit of Alarm Setting (0~2)
N * @var RTC_T::CALM
N * Offset: 0x20  Calendar Alarm Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |DAY       |1-Day Calendar Digit of Alarm Setting (0~9)
N * |[5:4]   |TENDAY    |10-Day Calendar Digit of Alarm Setting (0~3)
N * |[11:8]  |MON       |1-Month Calendar Digit of Alarm Setting (0~9)
N * |[12]    |TENMON    |10-Month Calendar Digit of Alarm Setting (0~1)
N * |[19:16] |YEAR      |1-Year Calendar Digit of Alarm Setting (0~9)
N * |[23:20] |TENYEAR   |10-Year Calendar Digit of Alarm Setting (0~9)
N * @var RTC_T::LEAPYEAR
N * Offset: 0x24  RTC Leap Year Indicator Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |LEAPYEAR  |Leap Year Indication Register (Read Only)
N * |        |          |0 = This year is not a leap year.
N * |        |          |1 = This year is leap year.
N * @var RTC_T::INTEN
N * Offset: 0x28  RTC Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ALMIEN    |Alarm Interrupt Enable Bit
N * |        |          |0 = RTC Alarm interrupt Disabled.
N * |        |          |1 = RTC Alarm interrupt Enabled.
N * |[1]     |TICKIEN   |Time Tick Interrupt Enable Bit
N * |        |          |0 = RTC Time Tick interrupt Disabled.
N * |        |          |1 = RTC Time Tick interrupt Enabled.
N * |[2]     |SNPDIEN   |Snoop Detection Interrupt Enable Bit
N * |        |          |0 = Snoop detected interrupt Disabled.
N * |        |          |1 = Snoop detected interrupt Enabled.
N * @var RTC_T::INTSTS
N * Offset: 0x2C  RTC Interrupt Indicator Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ALMIF     |RTC Alarm Interrupt Flag
N * |        |          |When RTC time counters RTC_TIME and RTC_CAL match the alarm setting time registers RTC_TALM and RTC_CALM, this bit will be set to 1 and an interrupt will be generated if RTC Alarm Interrupt enabled ALMIEN (RTC_INTEN[0]) is set to 1.
N * |        |          |Chip will be waken up if RTC Alarm Interrupt is enabled when chip is at Power-down mode.
N * |        |          |0 = Alarm condition is not matched.
N * |        |          |1 = Alarm condition is matched.
N * |        |          |Note: Write 1 to clear this bit.
N * |[1]     |TICKIF    |RTC Time Tick Interrupt Flag
N * |        |          |When RTC time tick happened, this bit will be set to 1 and an interrupt will be generated if RTC Tick Interrupt enabled TICKIEN (RTC_INTEN[1]) is set to 1.
N * |        |          |Chip will also be waken up if RTC Tick Interrupt is enabled and this bit is set to 1 when chip is running at Power-down mode.
N * |        |          |0 = Tick condition does not occur.
N * |        |          |1 = Tick condition occur.
N * |        |          |Note: Write 1 to clear to clear this bit.
N * |[2]     |SNPDIF    |Snoop Detect Interrupt Flag
N * |        |          |When tamper pin transition event is detected, this bit is set to 1 and an interrupt is generated if Snoop Detection Interrupt enabled SNPDIEN (RTC_INTEN[2]) is set to1.
N * |        |          |Chip will be waken up from Power-down mode if spare register snooper detect interrupt is enabled.
N * |        |          |0 = No snoop event is detected.
N * |        |          |1 = Snoop event is detected.
N * |        |          |Note: Write 1 to clear this bit.
N * @var RTC_T::TICK
N * Offset: 0x30  RTC Time Tick Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2:0]   |TICK      |Time Tick Register
N * |        |          |These bits are used to select RTC time tick period for Periodic Time Tick Interrupt request.
N * |        |          |000 = Time tick is 1 second.
N * |        |          |001 = Time tick is 1/2 second.
N * |        |          |010 = Time tick is 1/4 second.
N * |        |          |011 = Time tick is 1/8 second.
N * |        |          |100 = Time tick is 1/16 second.
N * |        |          |101 = Time tick is 1/32 second.
N * |        |          |110 = Time tick is 1/64 second.
N * |        |          |111 = Time tick is 1/28 second.
N * |        |          |Note: This register can be read back after the RTC register access enable bit RWENF (RTC_RWEN[16]) is active.
N * @var RTC_T::TAMSK
N * Offset: 0x34  Time Alarm Mask Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |MSEC      |Mask 1-Sec Time Digit of Alarm Setting (0~9)
N * |[1]     |MTENSEC   |Mask 10-Sec Time Digit of Alarm Setting (0~5)
N * |[2]     |MMIN      |Mask 1-Min Time Digit of Alarm Setting (0~9)
N * |[3]     |MTENMIN   |Mask 10-Min Time Digit of Alarm Setting (0~5)
N * |[4]     |MHR       |Mask 1-Hour Time Digit of Alarm Setting (0~9)
N * |[5]     |MTENHR    |Mask 10-Hour Time Digit of Alarm Setting (0~2)
N * @var RTC_T::CAMSK
N * Offset: 0x38  Calendar Alarm Mask Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |MDAY      |Mask 1-Day Calendar Digit of Alarm Setting (0~9)
N * |[1]     |MTENDAY   |Mask 10-Day Calendar Digit of Alarm Setting (0~3)
N * |[2]     |MMON      |Mask 1-Month Calendar Digit of Alarm Setting (0~9)
N * |[3]     |MTENMON   |Mask 10-Month Calendar Digit of Alarm Setting (0~1)
N * |[4]     |MYEAR     |Mask 1-Year Calendar Digit of Alarm Setting (0~9)
N * |[5]     |MTENYEAR  |Mask 10-Year Calendar Digit of Alarm Setting (0~9)
N * @var RTC_T::SPRCTL
N * Offset: 0x3C  RTC Spare Functional Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |SNPDEN    |Snoop Detection Enable Bit
N * |        |          |0 = TAMPER pin detection is Disabled.
N * |        |          |1 = TAMPER pin detection is Enabled.
N * |[1]     |SNPTYPE0  |Snoop Detection Level
N * |        |          |This bit controls TAMPER detect event is high level/rising edge or low level/falling edge.
N * |        |          |0 = Low level/Falling edge detection.
N * |        |          |1 = High level/Rising edge detection.
N * |[2]     |SPRRWEN   |Spare Register Enable Bit
N * |        |          |0 = Spare register is Disabled.
N * |        |          |1 = Spare register is Enabled.
N * |        |          |Note: When spare register is disabled, RTC_SPR0 ~ RTC_SPR19 cannot be accessed.
N * |[3]     |SNPTYPE1  |Snoop Detection Mode
N * |        |          |This bit controls TAMPER pin is edge or level detection
N * |        |          |0 = Level detection.
N * |        |          |1 = Edge detection.
N * |[5]     |SPRCSTS   |SPR Clear Flag
N * |        |          |This bit indicates if the RTC_SPR0 ~RTC_SPR19 content is cleared when specify snoop event is detected.
N * |        |          |0 = Spare register content is not cleared.
N * |        |          |1 = Spare register content is cleared.
N * |        |          |Writes 1 to clear this bit.
N * |[7]     |SPRRWRDY  |SPR Register Ready
N * |        |          |This bit indicates if the registers RTC_SPRCTL, RTC_SPR0 ~ RTC_SPR19 are ready to be accessed.
N * |        |          |After user writing registers RTC_SPRCTL, RTC_SPR0 ~ RTC_SPR19, read this bit to check if these registers are updated done is necessary.
N * |        |          |0 = RTC_SPRCTL, RTC_SPR0 ~ RTC_SPR19 updating is in progress.
N * |        |          |1 = RTC_SPRCTL, RTC_SPR0 ~ RTC_SPR19 are updated done and ready to be accessed.
N * |        |          |Note: This bit is read only and any write to it won't take any effect.
N * @var RTC_T::SPR
N * Offset: 0x40 ~ 0x8C  RTC Spare Register 0 ~ 19
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |SPARE     |Spare Register
N * |        |          |This field is used to store back-up information defined by user.
N * |        |          |This field will be cleared by hardware automatically once a snooper pin event is detected.
N * |        |          |Before storing back-up information in to RTC_SPRx register, user should write 0xA965 to RTC_RWEN[15:0] to make sure register read/write enable bit REWNF (RTC_RWEN[16]) is enabled.
N * @var RTC_T::LXTCTL
N * Offset: 0x100  RTC 32.768 kHz Oscillator Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |LXTEN     |Backup Domain 32K Oscillator Enable Bit
N * |        |          |0 = Oscillator is Disabled.
N * |        |          |1 = Oscillator is Enabled.
N * |        |          |This bit controls 32 kHz oscillator on/off.
N * |        |          |User can set either LXTEN in RTC domain or system manager control register CLK_PWRCTL[1] (LXTEN) to enable 32 kHz oscillator.
N * |        |          |If this bit is set 1, X32 kHz oscillator keep running after system power is turned off, if this bit is clear to 0, oscillator is turned off when system power is turned off.
N * |[3:1]   |GAIN      |Oscillator Gain Option
N * |        |          |User can select oscillator gain according to crystal external loading and operating temperature range.
N * |        |          |The larger gain value corresponding to stronger driving capability and higher power consumption.
N * |        |          |000 = L0 mode.
N * |        |          |001 = L1 mode.
N * |        |          |010 = L2 mode.
N * |        |          |011 = L3 mode.
N * |        |          |100 = L4 mode.
N * |        |          |101 = L5 mode.
N * |        |          |110 = L6 mode.
N * |        |          |111 = L7 mode (Default).
N * @var RTC_T::LXTOCTL
N * Offset: 0x104  X32KO Pin Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |OPMODE    |GPF0 Operation Mode
N * |        |          |00 = X32KO (PF.0) is input only mode, without pull-up resistor.
N * |        |          |01 = X32KO (PF.0) is output push pull mode.
N * |        |          |10 = X32KO (PF.0) is open drain mode.
N * |        |          |11 = X32KO (PF.0) is input only mode with internal pull up.
N * |[2]     |DOUT      |IO Output Data
N * |        |          |0 = X32KO (PF.0) output low.
N * |        |          |1 = X32KO (PF.0) output high.
N * |[3]     |CTLSEL    |IO Pin State Backup Selection
N * |        |          |When low speed 32 kHz oscillator is disabled, X32KO (PF.0) pin can be used as GPIO function.
N * |        |          |User can program CTLSEL bit to decide X32KO (PF.0) I/O function is controlled by system power domain GPIO module or VBAT power domain RTC_LXTOCTL control register.
N * |        |          |0 = X32KO (PF.0) pin I/O function is controlled by GPIO module.
N * |        |          |It becomes floating when system power is turned off.
N * |        |          |1 = X32KO (PF.0) pin I/O function is controlled by VBAT power domain, X32KO (PF.0) pin function and I/O status are controlled by OPMODE[1:0] and DOUT after CTLSEL it set to 1.
N * |        |          |I/O pin keeps the previous state after system power is turned off.
N * @var RTC_T::LXTICTL
N * Offset: 0x108  X32KI Pin Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |OPMODE    |IO Operation Mode
N * |        |          |00 = X32KI (PF.1) is input only mode, without pull-up resistor.
N * |        |          |01 = X32KI (PF.1) is output push pull mode.
N * |        |          |10 = X32KI (PF.1) is open drain mode.
N * |        |          |11 = X32KI (PF.1) is input only mode with internal pull up.
N * |[2]     |DOUT      |IO Output Data
N * |        |          |0 = X32KI (PF.1) output low.
N * |        |          |1 = X32KI (PF.1) output high.
N * |[3]     |CTLSEL    |IO Pin State Backup Selection
N * |        |          |When low speed 32 kHz oscillator is disabled, X32KI (PF.1) pin can be used as GPIO function.
N * |        |          |User can program CTLSEL bit to decide X32KI (PF.1) I/O function is controlled by system power domain GPIO module or VBAT power domain RTC_LXTICTL control register.
N * |        |          |0 = X32KI (PF.1) pin I/O function is controlled by GPIO module.
N * |        |          |It becomes floating state when system power is turned off.
N * |        |          |1 = X32KI (PF.1) pin I/O function is controlled by VBAT power domain, X32KI (PF.1) pin function and I/O status are controlled by OPMODE[1:0] and DOUT after CTLSEL it set to 1.
N * |        |          |I/O pin keeps the previous state after system power is turned off.
N * @var RTC_T::TAMPCTL
N * Offset: 0x10C  TAMPER Pin Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |OPMODE    |IO Operation Mode
N * |        |          |00 = TAMPER (PF.2) is input only mode, without pull-up resistor.
N * |        |          |01 = TAMPER (PF.2) is output push pull mode.
N * |        |          |10 = TAMPER (PF.2) is open drain mode.
N * |        |          |11 = TAMPER (PF.2) is input only mode with internal pull up.
N * |[2]     |DOUT      |IO Output Data
N * |        |          |0 = TAMPER (PF.2) output low.
N * |        |          |1 = TAMPER (PF.2) output high.
N * |[3]     |CTLSEL    |IO Pin State Backup Selection
N * |        |          |When tamper function is disabled, TAMPER pin can be used as GPIO function.
N * |        |          |User can program CTLSEL bit to decide PF.2 I/O function is controlled by system power domain GPIO module or VBAT power domain RTC_TAMPCTL control register.
N * |        |          |0 =TAMPER (PF.2) I/O function is controlled by GPIO module.
N * |        |          |It becomes floating state when system power is turned off.
N * |        |          |1 =TAMPER (PF.2) I/O function is controlled by VBAT power domain.
N * |        |          |PF.2 function and I/O status are controlled by OPMODE[1:0] and DOUT after CTLSEL it set to 1.
N * |        |          |I/O pin state keeps previous state after system power is turned off.
N */
N
N    __IO uint32_t INIT;          /* Offset: 0x00  RTC Initiation Register                                            */
X    volatile uint32_t INIT;           
N    __O  uint32_t RWEN;          /* Offset: 0x04  RTC Access Enable Register                                         */
X    volatile  uint32_t RWEN;           
N    __IO uint32_t FREQADJ;       /* Offset: 0x08  RTC Frequency Compensation Register                                */
X    volatile uint32_t FREQADJ;        
N    __IO uint32_t TIME;          /* Offset: 0x0C  Time Loading Register                                              */
X    volatile uint32_t TIME;           
N    __IO uint32_t CAL;           /* Offset: 0x10  RTC Calendar Loading Register                                      */
X    volatile uint32_t CAL;            
N    __IO uint32_t CLKFMT;        /* Offset: 0x14  Time Scale Selection Register                                      */
X    volatile uint32_t CLKFMT;         
N    __IO uint32_t WEEKDAY;       /* Offset: 0x18  Day of the Week Register                                           */
X    volatile uint32_t WEEKDAY;        
N    __IO uint32_t TALM;          /* Offset: 0x1C  Time Alarm Register                                                */
X    volatile uint32_t TALM;           
N    __IO uint32_t CALM;          /* Offset: 0x20  Calendar Alarm Register                                            */
X    volatile uint32_t CALM;           
N    __I  uint32_t LEAPYEAR;      /* Offset: 0x24  RTC Leap Year Indicator Register                                   */
X    volatile const  uint32_t LEAPYEAR;       
N    __IO uint32_t INTEN;         /* Offset: 0x28  RTC Interrupt Enable Register                                      */
X    volatile uint32_t INTEN;          
N    __IO uint32_t INTSTS;        /* Offset: 0x2C  RTC Interrupt Indicator Register                                   */
X    volatile uint32_t INTSTS;         
N    __IO uint32_t TICK;          /* Offset: 0x30  RTC Time Tick Register                                             */
X    volatile uint32_t TICK;           
N    __IO uint32_t TAMSK;         /* Offset: 0x34  Time Alarm Mask Register                                           */
X    volatile uint32_t TAMSK;          
N    __IO uint32_t CAMSK;         /* Offset: 0x38  Calendar Alarm Mask Register                                       */
X    volatile uint32_t CAMSK;          
N    __IO uint32_t SPRCTL;        /* Offset: 0x3C  RTC Spare Functional Control Register                              */
X    volatile uint32_t SPRCTL;         
N    __IO uint32_t SPR[20];       /* Offset: 0x40 ~ 0x8C  RTC Spare Register 0 ~ 19                                   */
X    volatile uint32_t SPR[20];        
N    __I  uint32_t RESERVE0[28]; 
X    volatile const  uint32_t RESERVE0[28]; 
N    __IO uint32_t LXTCTL;        /* Offset: 0x100  RTC 32.768 kHz Oscillator Control Register                        */
X    volatile uint32_t LXTCTL;         
N    __IO uint32_t LXTOCTL;       /* Offset: 0x104  X32KO Pin Control Register                                        */
X    volatile uint32_t LXTOCTL;        
N    __IO uint32_t LXTICTL;       /* Offset: 0x108  X32KI Pin Control Register                                        */
X    volatile uint32_t LXTICTL;        
N    __IO uint32_t TAMPCTL;       /* Offset: 0x10C  TAMPER Pin Control Register                                       */
X    volatile uint32_t TAMPCTL;        
N
N} RTC_T;
N
N
N
N/**
N    @addtogroup RTC_CONST RTC Bit Field Definition
N    Constant Definitions for RTC Controller
N@{ */
N
N#define RTC_INIT_ACTIVE_Pos              (0)                                               /*!< RTC_T::INIT: ACTIVE Position              */
N#define RTC_INIT_ACTIVE_Msk              (0x1ul << RTC_INIT_ACTIVE_Pos)                    /*!< RTC_T::INIT: ACTIVE Mask                  */
N
N#define RTC_INIT_INIT_Pos                (0)                                               /*!< RTC_T::INIT: INIT Position                */
N#define RTC_INIT_INIT_Msk                (0xfffffffful << RTC_INIT_INIT_Pos)               /*!< RTC_T::INIT: INIT Mask                    */
N
N#define RTC_RWEN_RWEN_Pos                (0)                                               /*!< RTC_T::RWEN: RWEN Position                */
N#define RTC_RWEN_RWEN_Msk                (0xfffful << RTC_RWEN_RWEN_Pos)                   /*!< RTC_T::RWEN: RWEN Mask                    */
N
N#define RTC_RWEN_RWENF_Pos               (16)                                              /*!< RTC_T::RWEN: RWENF Position               */
N#define RTC_RWEN_RWENF_Msk               (0x1ul << RTC_RWEN_RWENF_Pos)                     /*!< RTC_T::RWEN: RWENF Mask                   */
N
N#define RTC_FREQADJ_FRACTION_Pos         (0)                                               /*!< RTC_T::FREQADJ: FRACTION Position         */
N#define RTC_FREQADJ_FRACTION_Msk         (0x3ful << RTC_FREQADJ_FRACTION_Pos)              /*!< RTC_T::FREQADJ: FRACTION Mask             */
N
N#define RTC_FREQADJ_INTEGER_Pos          (8)                                               /*!< RTC_T::FREQADJ: INTEGER Position          */
N#define RTC_FREQADJ_INTEGER_Msk          (0xful << RTC_FREQADJ_INTEGER_Pos)                /*!< RTC_T::FREQADJ: INTEGER Mask              */
N
N#define RTC_TIME_SEC_Pos                 (0)                                               /*!< RTC_T::TIME: SEC Position                 */
N#define RTC_TIME_SEC_Msk                 (0xful << RTC_TIME_SEC_Pos)                       /*!< RTC_T::TIME: SEC Mask                     */
N
N#define RTC_TIME_TENSEC_Pos              (4)                                               /*!< RTC_T::TIME: TENSEC Position              */
N#define RTC_TIME_TENSEC_Msk              (0x7ul << RTC_TIME_TENSEC_Pos)                    /*!< RTC_T::TIME: TENSEC Mask                  */
N
N#define RTC_TIME_MIN_Pos                 (8)                                               /*!< RTC_T::TIME: MIN Position                 */
N#define RTC_TIME_MIN_Msk                 (0xful << RTC_TIME_MIN_Pos)                       /*!< RTC_T::TIME: MIN Mask                     */
N
N#define RTC_TIME_TENMIN_Pos              (12)                                              /*!< RTC_T::TIME: TENMIN Position              */
N#define RTC_TIME_TENMIN_Msk              (0x7ul << RTC_TIME_TENMIN_Pos)                    /*!< RTC_T::TIME: TENMIN Mask                  */
N
N#define RTC_TIME_HR_Pos                  (16)                                              /*!< RTC_T::TIME: HR Position                  */
N#define RTC_TIME_HR_Msk                  (0xful << RTC_TIME_HR_Pos)                        /*!< RTC_T::TIME: HR Mask                      */
N
N#define RTC_TIME_TENHR_Pos               (20)                                              /*!< RTC_T::TIME: TENHR Position               */
N#define RTC_TIME_TENHR_Msk               (0x3ul << RTC_TIME_TENHR_Pos)                     /*!< RTC_T::TIME: TENHR Mask                   */
N
N#define RTC_CAL_DAY_Pos                  (0)                                               /*!< RTC_T::CAL: DAY Position                  */
N#define RTC_CAL_DAY_Msk                  (0xful << RTC_CAL_DAY_Pos)                        /*!< RTC_T::CAL: DAY Mask                      */
N
N#define RTC_CAL_TENDAY_Pos               (4)                                               /*!< RTC_T::CAL: TENDAY Position               */
N#define RTC_CAL_TENDAY_Msk               (0x3ul << RTC_CAL_TENDAY_Pos)                     /*!< RTC_T::CAL: TENDAY Mask                   */
N
N#define RTC_CAL_MON_Pos                  (8)                                               /*!< RTC_T::CAL: MON Position                  */
N#define RTC_CAL_MON_Msk                  (0xful << RTC_CAL_MON_Pos)                        /*!< RTC_T::CAL: MON Mask                      */
N
N#define RTC_CAL_TENMON_Pos               (12)                                              /*!< RTC_T::CAL: TENMON Position               */
N#define RTC_CAL_TENMON_Msk               (0x1ul << RTC_CAL_TENMON_Pos)                     /*!< RTC_T::CAL: TENMON Mask                   */
N
N#define RTC_CAL_YEAR_Pos                 (16)                                              /*!< RTC_T::CAL: YEAR Position                 */
N#define RTC_CAL_YEAR_Msk                 (0xful << RTC_CAL_YEAR_Pos)                       /*!< RTC_T::CAL: YEAR Mask                     */
N
N#define RTC_CAL_TENYEAR_Pos              (20)                                              /*!< RTC_T::CAL: TENYEAR Position              */
N#define RTC_CAL_TENYEAR_Msk              (0xful << RTC_CAL_TENYEAR_Pos)                    /*!< RTC_T::CAL: TENYEAR Mask                  */
N
N#define RTC_CLKFMT_24HEN_Pos             (0)                                               /*!< RTC_T::CLKFMT: 24HEN Position             */
N#define RTC_CLKFMT_24HEN_Msk             (0x1ul << RTC_CLKFMT_24HEN_Pos)                   /*!< RTC_T::CLKFMT: 24HEN Mask                 */
N
N#define RTC_WEEKDAY_WEEKDAY_Pos          (0)                                               /*!< RTC_T::WEEKDAY: WEEKDAY Position          */
N#define RTC_WEEKDAY_WEEKDAY_Msk          (0x7ul << RTC_WEEKDAY_WEEKDAY_Pos)                /*!< RTC_T::WEEKDAY: WEEKDAY Mask              */
N
N#define RTC_TALM_SEC_Pos                 (0)                                               /*!< RTC_T::TALM: SEC Position                 */
N#define RTC_TALM_SEC_Msk                 (0xful << RTC_TALM_SEC_Pos)                       /*!< RTC_T::TALM: SEC Mask                     */
N
N#define RTC_TALM_TENSEC_Pos              (4)                                               /*!< RTC_T::TALM: TENSEC Position              */
N#define RTC_TALM_TENSEC_Msk              (0x7ul << RTC_TALM_TENSEC_Pos)                    /*!< RTC_T::TALM: TENSEC Mask                  */
N
N#define RTC_TALM_MIN_Pos                 (8)                                               /*!< RTC_T::TALM: MIN Position                 */
N#define RTC_TALM_MIN_Msk                 (0xful << RTC_TALM_MIN_Pos)                       /*!< RTC_T::TALM: MIN Mask                     */
N
N#define RTC_TALM_TENMIN_Pos              (12)                                              /*!< RTC_T::TALM: TENMIN Position              */
N#define RTC_TALM_TENMIN_Msk              (0x7ul << RTC_TALM_TENMIN_Pos)                    /*!< RTC_T::TALM: TENMIN Mask                  */
N
N#define RTC_TALM_HR_Pos                  (16)                                              /*!< RTC_T::TALM: HR Position                  */
N#define RTC_TALM_HR_Msk                  (0xful << RTC_TALM_HR_Pos)                        /*!< RTC_T::TALM: HR Mask                      */
N
N#define RTC_TALM_TENHR_Pos               (20)                                              /*!< RTC_T::TALM: TENHR Position               */
N#define RTC_TALM_TENHR_Msk               (0x3ul << RTC_TALM_TENHR_Pos)                     /*!< RTC_T::TALM: TENHR Mask                   */
N
N#define RTC_CALM_DAY_Pos                 (0)                                               /*!< RTC_T::CALM: DAY Position                 */
N#define RTC_CALM_DAY_Msk                 (0xful << RTC_CALM_DAY_Pos)                       /*!< RTC_T::CALM: DAY Mask                     */
N
N#define RTC_CALM_TENDAY_Pos              (4)                                               /*!< RTC_T::CALM: TENDAY Position              */
N#define RTC_CALM_TENDAY_Msk              (0x3ul << RTC_CALM_TENDAY_Pos)                    /*!< RTC_T::CALM: TENDAY Mask                  */
N
N#define RTC_CALM_MON_Pos                 (8)                                               /*!< RTC_T::CALM: MON Position                 */
N#define RTC_CALM_MON_Msk                 (0xful << RTC_CALM_MON_Pos)                       /*!< RTC_T::CALM: MON Mask                     */
N
N#define RTC_CALM_TENMON_Pos              (12)                                              /*!< RTC_T::CALM: TENMON Position              */
N#define RTC_CALM_TENMON_Msk              (0x1ul << RTC_CALM_TENMON_Pos)                    /*!< RTC_T::CALM: TENMON Mask                  */
N
N#define RTC_CALM_YEAR_Pos                (16)                                              /*!< RTC_T::CALM: YEAR Position                */
N#define RTC_CALM_YEAR_Msk                (0xful << RTC_CALM_YEAR_Pos)                      /*!< RTC_T::CALM: YEAR Mask                    */
N
N#define RTC_CALM_TENYEAR_Pos             (20)                                              /*!< RTC_T::CALM: TENYEAR Position             */
N#define RTC_CALM_TENYEAR_Msk             (0xful << RTC_CALM_TENYEAR_Pos)                   /*!< RTC_T::CALM: TENYEAR Mask                 */
N
N#define RTC_LEAPYEAR_LEAPYEAR_Pos        (0)                                               /*!< RTC_T::LEAPYEAR: LEAPYEAR Position        */
N#define RTC_LEAPYEAR_LEAPYEAR_Msk        (0x1ul << RTC_LEAPYEAR_LEAPYEAR_Pos)              /*!< RTC_T::LEAPYEAR: LEAPYEAR Mask            */
N
N#define RTC_INTEN_ALMIEN_Pos             (0)                                               /*!< RTC_T::INTEN: ALMIEN Position             */
N#define RTC_INTEN_ALMIEN_Msk             (0x1ul << RTC_INTEN_ALMIEN_Pos)                   /*!< RTC_T::INTEN: ALMIEN Mask                 */
N
N#define RTC_INTEN_TICKIEN_Pos            (1)                                               /*!< RTC_T::INTEN: TICKIEN Position            */
N#define RTC_INTEN_TICKIEN_Msk            (0x1ul << RTC_INTEN_TICKIEN_Pos)                  /*!< RTC_T::INTEN: TICKIEN Mask                */
N
N#define RTC_INTEN_SNPDIEN_Pos            (2)                                               /*!< RTC_T::INTEN: SNPDIEN Position            */
N#define RTC_INTEN_SNPDIEN_Msk            (0x1ul << RTC_INTEN_SNPDIEN_Pos)                  /*!< RTC_T::INTEN: SNPDIEN Mask                */
N
N#define RTC_INTSTS_ALMIF_Pos             (0)                                               /*!< RTC_T::INTSTS: ALMIF Position             */
N#define RTC_INTSTS_ALMIF_Msk             (0x1ul << RTC_INTSTS_ALMIF_Pos)                   /*!< RTC_T::INTSTS: ALMIF Mask                 */
N
N#define RTC_INTSTS_TICKIF_Pos            (1)                                               /*!< RTC_T::INTSTS: TICKIF Position            */
N#define RTC_INTSTS_TICKIF_Msk            (0x1ul << RTC_INTSTS_TICKIF_Pos)                  /*!< RTC_T::INTSTS: TICKIF Mask                */
N
N#define RTC_INTSTS_SNPDIF_Pos            (2)                                               /*!< RTC_T::INTSTS: SNPDIF Position            */
N#define RTC_INTSTS_SNPDIF_Msk            (0x1ul << RTC_INTSTS_SNPDIF_Pos)                  /*!< RTC_T::INTSTS: SNPDIF Mask                */
N
N#define RTC_TICK_TICK_Pos                (0)                                               /*!< RTC_T::TICK: TICK Position                */
N#define RTC_TICK_TICK_Msk                (0x7ul << RTC_TICK_TICK_Pos)                      /*!< RTC_T::TICK: TICK Mask                    */
N
N#define RTC_TAMSK_MSEC_Pos               (0)                                               /*!< RTC_T::TAMSK: MSEC Position               */
N#define RTC_TAMSK_MSEC_Msk               (0x1ul << RTC_TAMSK_MSEC_Pos)                     /*!< RTC_T::TAMSK: MSEC Mask                   */
N
N#define RTC_TAMSK_MTENSEC_Pos            (1)                                               /*!< RTC_T::TAMSK: MTENSEC Position            */
N#define RTC_TAMSK_MTENSEC_Msk            (0x1ul << RTC_TAMSK_MTENSEC_Pos)                  /*!< RTC_T::TAMSK: MTENSEC Mask                */
N
N#define RTC_TAMSK_MMIN_Pos               (2)                                               /*!< RTC_T::TAMSK: MMIN Position               */
N#define RTC_TAMSK_MMIN_Msk               (0x1ul << RTC_TAMSK_MMIN_Pos)                     /*!< RTC_T::TAMSK: MMIN Mask                   */
N
N#define RTC_TAMSK_MTENMIN_Pos            (3)                                               /*!< RTC_T::TAMSK: MTENMIN Position            */
N#define RTC_TAMSK_MTENMIN_Msk            (0x1ul << RTC_TAMSK_MTENMIN_Pos)                  /*!< RTC_T::TAMSK: MTENMIN Mask                */
N
N#define RTC_TAMSK_MHR_Pos                (4)                                               /*!< RTC_T::TAMSK: MHR Position                */
N#define RTC_TAMSK_MHR_Msk                (0x1ul << RTC_TAMSK_MHR_Pos)                      /*!< RTC_T::TAMSK: MHR Mask                    */
N
N#define RTC_TAMSK_MTENHR_Pos             (5)                                               /*!< RTC_T::TAMSK: MTENHR Position             */
N#define RTC_TAMSK_MTENHR_Msk             (0x1ul << RTC_TAMSK_MTENHR_Pos)                   /*!< RTC_T::TAMSK: MTENHR Mask                 */
N
N#define RTC_CAMSK_MDAY_Pos               (0)                                               /*!< RTC_T::CAMSK: MDAY Position               */
N#define RTC_CAMSK_MDAY_Msk               (0x1ul << RTC_CAMSK_MDAY_Pos)                     /*!< RTC_T::CAMSK: MDAY Mask                   */
N
N#define RTC_CAMSK_MTENDAY_Pos            (1)                                               /*!< RTC_T::CAMSK: MTENDAY Position            */
N#define RTC_CAMSK_MTENDAY_Msk            (0x1ul << RTC_CAMSK_MTENDAY_Pos)                  /*!< RTC_T::CAMSK: MTENDAY Mask                */
N
N#define RTC_CAMSK_MMON_Pos               (2)                                               /*!< RTC_T::CAMSK: MMON Position               */
N#define RTC_CAMSK_MMON_Msk               (0x1ul << RTC_CAMSK_MMON_Pos)                     /*!< RTC_T::CAMSK: MMON Mask                   */
N
N#define RTC_CAMSK_MTENMON_Pos            (3)                                               /*!< RTC_T::CAMSK: MTENMON Position            */
N#define RTC_CAMSK_MTENMON_Msk            (0x1ul << RTC_CAMSK_MTENMON_Pos)                  /*!< RTC_T::CAMSK: MTENMON Mask                */
N
N#define RTC_CAMSK_MYEAR_Pos              (4)                                               /*!< RTC_T::CAMSK: MYEAR Position              */
N#define RTC_CAMSK_MYEAR_Msk              (0x1ul << RTC_CAMSK_MYEAR_Pos)                    /*!< RTC_T::CAMSK: MYEAR Mask                  */
N
N#define RTC_CAMSK_MTENYEAR_Pos           (5)                                               /*!< RTC_T::CAMSK: MTENYEAR Position           */
N#define RTC_CAMSK_MTENYEAR_Msk           (0x1ul << RTC_CAMSK_MTENYEAR_Pos)                 /*!< RTC_T::CAMSK: MTENYEAR Mask               */
N
N#define RTC_SPRCTL_SNPDEN_Pos            (0)                                               /*!< RTC_T::SPRCTL: SNPDEN Position            */
N#define RTC_SPRCTL_SNPDEN_Msk            (0x1ul << RTC_SPRCTL_SNPDEN_Pos)                  /*!< RTC_T::SPRCTL: SNPDEN Mask                */
N
N#define RTC_SPRCTL_SNPTYPE0_Pos          (1)                                               /*!< RTC_T::SPRCTL: SNPTYPE0 Position          */
N#define RTC_SPRCTL_SNPTYPE0_Msk          (0x1ul << RTC_SPRCTL_SNPTYPE0_Pos)                /*!< RTC_T::SPRCTL: SNPTYPE0 Mask              */
N
N#define RTC_SPRCTL_SPRRWEN_Pos           (2)                                               /*!< RTC_T::SPRCTL: SPRRWEN Position           */
N#define RTC_SPRCTL_SPRRWEN_Msk           (0x1ul << RTC_SPRCTL_SPRRWEN_Pos)                 /*!< RTC_T::SPRCTL: SPRRWEN Mask               */
N
N#define RTC_SPRCTL_SNPTYPE1_Pos          (3)                                               /*!< RTC_T::SPRCTL: SNPTYPE1 Position          */
N#define RTC_SPRCTL_SNPTYPE1_Msk          (0x1ul << RTC_SPRCTL_SNPTYPE1_Pos)                /*!< RTC_T::SPRCTL: SNPTYPE1 Mask              */
N
N#define RTC_SPRCTL_SPRCSTS_Pos           (5)                                               /*!< RTC_T::SPRCTL: SPRCSTS Position           */
N#define RTC_SPRCTL_SPRCSTS_Msk           (0x1ul << RTC_SPRCTL_SPRCSTS_Pos)                 /*!< RTC_T::SPRCTL: SPRCSTS Mask               */
N
N#define RTC_SPRCTL_SPRRWRDY_Pos          (7)                                               /*!< RTC_T::SPRCTL: SPRRWRDY Position          */
N#define RTC_SPRCTL_SPRRWRDY_Msk          (0x1ul << RTC_SPRCTL_SPRRWRDY_Pos)                /*!< RTC_T::SPRCTL: SPRRWRDY Mask              */
N
N#define RTC_SPR_SPARE_Pos                (0)                                               /*!< RTC_T::SPR: SPARE Position                */
N#define RTC_SPR_SPARE_Msk                (0xfffffffful << RTC_SPR_SPARE_Pos)               /*!< RTC_T::SPR: SPARE Mask                    */
N
N#define RTC_LXTCTL_LXTEN_Pos             (0)                                               /*!< RTC_T::LXTCTL: LXTEN Position             */
N#define RTC_LXTCTL_LXTEN_Msk             (0x1ul << RTC_LXTCTL_LXTEN_Pos)                   /*!< RTC_T::LXTCTL: LXTEN Mask                 */
N
N#define RTC_LXTCTL_GAIN_Pos              (1)                                               /*!< RTC_T::LXTCTL: GAIN Position              */
N#define RTC_LXTCTL_GAIN_Msk              (0x7ul << RTC_LXTCTL_GAIN_Pos)                    /*!< RTC_T::LXTCTL: GAIN Mask                  */
N
N#define RTC_LXTOCTL_OPMODE_Pos           (0)                                               /*!< RTC_T::LXTOCTL: OPMODE Position           */
N#define RTC_LXTOCTL_OPMODE_Msk           (0x3ul << RTC_LXTOCTL_OPMODE_Pos)                 /*!< RTC_T::LXTOCTL: OPMODE Mask               */
N
N#define RTC_LXTOCTL_DOUT_Pos             (2)                                               /*!< RTC_T::LXTOCTL: DOUT Position             */
N#define RTC_LXTOCTL_DOUT_Msk             (0x1ul << RTC_LXTOCTL_DOUT_Pos)                   /*!< RTC_T::LXTOCTL: DOUT Mask                 */
N
N#define RTC_LXTOCTL_CTLSEL_Pos           (3)                                               /*!< RTC_T::LXTOCTL: CTLSEL Position           */
N#define RTC_LXTOCTL_CTLSEL_Msk           (0x1ul << RTC_LXTOCTL_CTLSEL_Pos)                 /*!< RTC_T::LXTOCTL: CTLSEL Mask               */
N
N#define RTC_LXTICTL_OPMODE_Pos           (0)                                               /*!< RTC_T::LXTICTL: OPMODE Position           */
N#define RTC_LXTICTL_OPMODE_Msk           (0x3ul << RTC_LXTICTL_OPMODE_Pos)                 /*!< RTC_T::LXTICTL: OPMODE Mask               */
N
N#define RTC_LXTICTL_DOUT_Pos             (2)                                               /*!< RTC_T::LXTICTL: DOUT Position             */
N#define RTC_LXTICTL_DOUT_Msk             (0x1ul << RTC_LXTICTL_DOUT_Pos)                   /*!< RTC_T::LXTICTL: DOUT Mask                 */
N
N#define RTC_LXTICTL_CTLSEL_Pos           (3)                                               /*!< RTC_T::LXTICTL: CTLSEL Position           */
N#define RTC_LXTICTL_CTLSEL_Msk           (0x1ul << RTC_LXTICTL_CTLSEL_Pos)                 /*!< RTC_T::LXTICTL: CTLSEL Mask               */
N
N#define RTC_TAMPCTL_OPMODE_Pos           (0)                                               /*!< RTC_T::TAMPCTL: OPMODE Position           */
N#define RTC_TAMPCTL_OPMODE_Msk           (0x3ul << RTC_TAMPCTL_OPMODE_Pos)                 /*!< RTC_T::TAMPCTL: OPMODE Mask               */
N
N#define RTC_TAMPCTL_DOUT_Pos             (2)                                               /*!< RTC_T::TAMPCTL: DOUT Position             */
N#define RTC_TAMPCTL_DOUT_Msk             (0x1ul << RTC_TAMPCTL_DOUT_Pos)                   /*!< RTC_T::TAMPCTL: DOUT Mask                 */
N
N#define RTC_TAMPCTL_CTLSEL_Pos           (3)                                               /*!< RTC_T::TAMPCTL: CTLSEL Position           */
N#define RTC_TAMPCTL_CTLSEL_Msk           (0x1ul << RTC_TAMPCTL_CTLSEL_Pos)                 /*!< RTC_T::TAMPCTL: CTLSEL Mask               */
N
N/**@}*/ /* RTC_CONST */
N/**@}*/ /* end of RTC register group */
N
N
N/*---------------------- Smart Card Host Interface Controller -------------------------*/
N/**
N    @addtogroup SC Smart Card Host Interface Controller(SC)
N    Memory Mapped Structure for SC Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var SC_T::DAT
N * Offset: 0x00  SC Receiving/Transmit Holding Buffer Register.
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |DAT       |Receiving/ Transmit Holding Buffer
N * |        |          |Write Operation:
N * |        |          |By writing data to DAT, the SC will send out an 8-bit data.
N * |        |          |Note: If SCEN(SC_CTL[0]) is not enabled, DAT cannot be programmed.
N * |        |          |Read Operation:
N * |        |          |By reading DAT, the SC will return an 8-bit received data.
N * @var SC_T::CTL
N * Offset: 0x04  SC Control Register.
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |SCEN      |SC Engine Enable Bit
N * |        |          |Set this bit to 1 to enable SC operation.
N * |        |          |If this bit is cleared, SC will force all transition to IDLE state.
N * |[1]     |RXOFF     |RX Transition Disable Control
N * |        |          |0 = The receiver Enabled.
N * |        |          |1 = The receiver Disabled.
N * |        |          |Note:
N * |        |          |If AUTOCEN (SC_CTL[3])is enabled, these fields must be ignored.
N * |[2]     |TXOFF     |TX Transition Disable Control
N * |        |          |0 = The transceiver Enabled.
N * |        |          |1 = The transceiver Disabled.
N * |[3]     |AUTOCEN   |Auto Convention Enable Bit
N * |        |          |0 = Auto-convention Disabled.
N * |        |          |1 = Auto-convention Enabled.
N * |        |          |When hardware receives TS in answer to reset state and the TS is direct convention, CONSEL(SC_CTL[5:4]) will be set to 00 automatically, otherwise if the TS is inverse convention, and CONSEL (SC_CTL[5:4]) will be set to 11.
N * |        |          |If software enables auto convention function, the setting step must be done before Answer to Reset state and the first data must be 0x3B or 0x3F.
N * |        |          |After hardware received first data and stored it at buffer, 
N * |        |          |hardware will decided the convention and change the CONSEL (SC_CTL[5:4]) bits automatically.
N * |        |          |If the first data is not 0x3B or 0x3F, hardware will generate an interrupt if ACERRIEN (SC_INTEN[10]) = 1 to CPU.
N * |[5:4]   |CONSEL    |Convention Selection
N * |        |          |00 = Direct convention.
N * |        |          |01 = Reserved.
N * |        |          |10 = Reserved.
N * |        |          |11 = Inverse convention.
N * |        |          |Note:
N * |        |          |If AUTOCEN(SC_CTL[3]) enabled, this fields are ignored.
N * |[7:6]   |RXTRGLV   |Rx Buffer Trigger Level
N * |        |          |When the number of bytes in the receiving buffer equals the RXTRGLV, the RDAIF will be set (if SC_INTEN [RDAIEN] is enabled, an interrupt will be generated).
N * |        |          |00 = INTR_RDA Trigger Level with 01 Bytes.
N * |        |          |01 = INTR_RDA Trigger Level with 02 Bytes.
N * |        |          |10 = INTR_RDA Trigger Level with 03 Bytes.
N * |        |          |11 = Reserved.
N * |[12:8]  |BGT       |Block Guard Time (BGT)
N * |        |          |Block guard time means the minimum bit length between the leading edges of two consecutive characters between different transfer directions.
N * |        |          |This field indicates the counter for the bit length of block guard time.
N * |        |          |According to ISO7816-3, in T = 0 mode, software must fill 15 (real block guard time = 16.5) to this field; in T = 1 mode, software must fill 21 (real block guard time = 22.5) to it.
N * |        |          |Note:
N * |        |          |The real block guard time is BGT + 1.
N * |[14:13] |TMRSEL    |Timer Selection
N * |        |          |00 = All internal timer function Disabled.
N * |        |          |01 = Internal 24 bit timer Enabled.
N * |        |          |Software can configure it by setting SC_TMRCTL0 [23:0].
N * |        |          |SC_TMRCTL1 and SC_TMRCTL2 will be ignored in this mode.
N * |        |          |10 = internal 24 bit timer and 8 bit internal timer Enabled.
N * |        |          |Software can configure the 24 bit timer by setting SC_TMRCTL0 [23:0] and configure the 8 bit timer by setting SC_TMRCTL1[7:0].
N * |        |          |SC_TMRCTL2 will be ignored in this mode.
N * |        |          |11 = Internal 24 bit timer and two 8 bit timers Enabled.
N * |        |          |Software can configure them by setting SC_TMRCTL0 [23:0], SC_TMRCTL1 [7:0] and SC_TMRCTL2 [7:0].
N * |[15]    |NSB       |Stop Bit Length
N * |        |          |This field indicates the length of stop bit.
N * |        |          |0 = The stop bit length is 2 ETU.
N * |        |          |1= The stop bit length is 1 ETU.
N * |        |          |Note:
N * |        |          |The default stop bit length is 2. SMC and UART adopts NSB to program the stop bit length
N * |[18:16] |RXRTY     |RX Error Retry Count Number
N * |        |          |This field indicates the maximum number of receiver retries that are allowed when parity error has occurred
N * |        |          |Note1: The real retry number is RXRTY + 1, so 8 is the maximum retry number.
N * |        |          |Note2: This field cannot be changed when RXRTYEN enabled.
N * |        |          |The change flow is to disable RXRTYEN first and then fill in new retry value.
N * |[19]    |RXRTYEN   |RX Error Retry Enable Bit
N * |        |          |This bit enables receiver retry function when parity error has occurred.
N * |        |          |0 = RX error retry function Disabled.
N * |        |          |1 = RX error retry function Enabled.
N * |        |          |Note:
N * |        |          |Software must fill in the RXRTY value before enabling this bit.
N * |[22:20] |TXRTY     |TX Error Retry Count Number
N * |        |          |This field indicates the maximum number of transmitter retries that are allowed when parity error has occurred.
N * |        |          |Note1: The real retry number is TXRTY + 1, so 8 is the maximum retry number.
N * |        |          |Note2: This field cannot be changed when TXRTYEN enabled.
N * |        |          |The change flow is to disable TXRTYEN first and then fill in new retry value.
N * |[23]    |TXRTYEN   |TX Error Retry Enable Bit
N * |        |          |This bit enables transmitter retry function when parity error has occurred.
N * |        |          |0 = TX error retry function Disabled.
N * |        |          |1 = TX error retry function Enabled.
N * |[25:24] |CDDBSEL   |Card Detect De-Bounce Selection
N * |        |          |This field indicates the card detect de-bounce selection.
N * |        |          |00 = De-bounce sample card insert once per 384 (128 * 3) peripheral clocks and de-bounce sample card removal once per 128 peripheral clocks.
N * |        |          |01 = De-bounce sample card insert once per 192 (64 * 3) peripheral clocks and de-bounce sample card removal once per 64 peripheral clocks.
N * |        |          |10 = De-bounce sample card insert once per 96 (32 * 3) peripheral clocks and de-bounce sample card removal once per 32 peripheral clocks.
N * |        |          |11 = De-bounce sample card insert once per 48 (16 * 3) peripheral clocks and de-bounce sample card removal once per 16 peripheral clocks.
N * |[26]    |CDLV      |Card Detect Level
N * |        |          |0 = When hardware detects the card detect pin (SC_CD) from high to low, it indicates a card is detected.
N * |        |          |1 = When hardware detects the card detect pin from low to high, it indicates a card is detected.
N * |        |          |Note: Software must select card detect level before Smart Card engine enabled.
N * |[30]    |SYNC      |SYNC Flag Indicator
N * |        |          |Due to synchronization, software should check this bit before writing a new value to RXRTY and TXRTY.
N * |        |          |0 = Synchronizing is completion, user can write new data to RXRTY and TXRTY.
N * |        |          |1 = Last value is synchronizing.
N * |        |          |Note: This bit is read only.
N * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable Control
N * |        |          |0 = ICE debug mode acknowledgement affects SC counting.
N * |        |          |SC internal counter will be held while CPU is held by ICE.
N * |        |          |1 = ICE debug mode acknowledgement Disabled.
N * |        |          |SC internal counter will keep going no matter CPU is held by ICE or not.
N * @var SC_T::ALTCTL
N * Offset: 0x08  SC Alternate Control Register.
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TXRST     |TX Software Reset
N * |        |          |When TXRST is set, all the bytes in the transmit buffer and TX internal state machine will be cleared.
N * |        |          |0 = No effect.
N * |        |          |1 = Reset the TX internal state machine and pointers.
N * |        |          |Note:
N * |        |          |This bit will be auto cleared after reset is complete.
N * |[1]     |RXRST     |Rx Software Reset
N * |        |          |When RXRST is set, all the bytes in the receiver buffer and Rx internal state machine will be cleared.
N * |        |          |0 = No effect.
N * |        |          |1 = Reset the Rx internal state machine and pointers.
N * |        |          |Note:
N * |        |          |This bit will be auto cleared after reset is complete.
N * |[2]     |DACTEN    |Deactivation Sequence Generator Enable Bit
N * |        |          |This bit enables SC controller to initiate the card by deactivation sequence
N * |        |          |0 = No effect.
N * |        |          |1 = Deactivation sequence generator Enabled.
N * |        |          |Note1:
N * |        |          |When the deactivation sequence completed, this bit will be cleared automatically and the INITIF(SC_INTSTS[8]) will be set to 1.
N * |        |          |Note2:
N * |        |          |This field will be cleared by TXRST (SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]).
N * |        |          |So don't fill this bit, TXRST, and RXRST at the same time.
N * |        |          |Note3:
N * |        |          |If SCEN (SC_CTL[0]) is not enabled, this filed cannot be programmed.
N * |[3]     |ACTEN     |Activation Sequence Generator Enable Bit
N * |        |          |This bit enables SC controller to initiate the card by activation sequence
N * |        |          |0 = No effect.
N * |        |          |1 = Activation sequence generator Enabled.
N * |        |          |Note1:
N * |        |          |When the activation sequence completed, this bit will be cleared automatically and the INITIF(SC_INTSTS[8]) will be set to 1.
N * |        |          |Note2:
N * |        |          |This field will be cleared by TXRST(SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]), so don't fill this bit, TXRST(SC_ALTCTL[0]), and RXRST(SC_ALTCTL[1]) at the same time.
N * |        |          |Note3:
N * |        |          |If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
N * |[4]     |WARSTEN   |Warm Reset Sequence Generator Enable Bit
N * |        |          |This bit enables SC controller to initiate the card by warm reset sequence
N * |        |          |0 = No effect.
N * |        |          |1 = Warm reset sequence generator Enabled.
N * |        |          |Note1:
N * |        |          |When the warm reset sequence completed, this bit will be cleared automatically and the INITIF(SC_INTSTS[8]) will be set to 1.
N * |        |          |Note2:
N * |        |          |This field will be cleared by TXRST(SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]), so don't fill this bit, TXRST, and RXRST at the same time.
N * |        |          |Note3:
N * |        |          |If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
N * |[5]     |CNTEN0    |Internal Timer0 Start Enable Bit
N * |        |          |This bit enables Timer 0 to start counting.
N * |        |          |Software can fill 0 to stop it and set 1 to reload and count.
N * |        |          |0 = Stops counting.
N * |        |          |1 = Start counting.
N * |        |          |Note1:
N * |        |          |This field is used for internal 24 bit timer when TMRSEL (SC_CTL[14:13]) = 01.
N * |        |          |Note2:
N * |        |          |If the operation mode is not in auto-reload mode (SC_TMRCTL0[26] = 0), this bit will be auto-cleared by hardware.
N * |        |          |Note3:
N * |        |          |This field will be cleared by TXRST(SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]).
N * |        |          |So don't fill this bit, TXRST and RXRST at the same time.
N * |        |          |Note4: If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
N * |[6]     |CNTEN1    |Internal Timer1 Start Enable Bit
N * |        |          |This bit enables Timer 1 to start counting.
N * |        |          |Software can fill 0 to stop it and set 1 to reload and count.
N * |        |          |0 = Stops counting.
N * |        |          |1 = Start counting.
N * |        |          |Note1:
N * |        |          |This field is used for internal 8 bit timer when TMRSEL(SC_CTL[14:13]) = 10 or TMRSEL(SC_CTL[14:13]) = 11.
N * |        |          |Don't filled CNTEN1 when TMRSEL(SC_CTL[14:13]) = 00 or TMRSEL(SC_CTL[14:13]) = 01.
N * |        |          |Note2:
N * |        |          |If the operation mode is not in auto-reload mode (SC_TMRCTL1[26] = 0), this bit will be auto-cleared by hardware.
N * |        |          |Note3:
N * |        |          |This field will be cleared by TXRST(SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]), so don't fill this bit, TXRST(SC_ALTCTL[0]), and RXRST(SC_ALTCTL[1]) at the same time.
N * |        |          |Note4:
N * |        |          |If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
N * |[7]     |CNTEN2    |Internal Timer2 Start Enable Bit
N * |        |          |This bit enables Timer 2 to start counting.
N * |        |          |Software can fill 0 to stop it and set 1 to reload and count.
N * |        |          |0 = Stops counting.
N * |        |          |1 = Start counting.
N * |        |          |Note1:
N * |        |          |This field is used for internal 8 bit timer when TMRSEL(SC_CTL[14:13]) = 11.
N * |        |          |Don't filled CNTEN2 when TMRSEL(SC_CTL[14:13]) = 00 or TMRSEL(SC_CTL[14:13]) = 01 or TMRSEL(SC_CTL[14:13]) = 10.
N * |        |          |Note2:
N * |        |          |If the operation mode is not in auto-reload mode (SC_TMRCTL2[26] = 0), this bit will be auto-cleared by hardware.
N * |        |          |Note3:
N * |        |          |This field will be cleared by TXRST(SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]).
N * |        |          |So don't fill this bit, TXRST(SC_ALTCTL[0]), and RXRST(SC_ALTCTL[1]) at the same time.
N * |        |          |Note4:
N * |        |          |If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
N * |[9:8]   |INITSEL   |Initial Timing Selection
N * |        |          |This fields indicates the timing of hardware initial state (activation or warm-reset or deactivation).
N * |        |          |Unit: SC clock
N * |        |          |Activation: refer to SC Activation Sequence in Figure 6.17-4
N * |        |          |Warm-reset: refer to Warm-Reset Sequence in Figure 6.17-5
N * |        |          |Deactivation: refer to Deactivation Sequence in Figure 6.17-6
N * |[12]    |RXBGTEN   |Receiver Block Guard Time Function Enable Bit
N * |        |          |0 = Receiver block guard time function Disabled.
N * |        |          |1 = Receiver block guard time function Enabled.
N * |[13]    |ACTSTS0   |Internal Timer0 Active State (Read Only)
N * |        |          |This bit indicates the timer counter status of timer0.
N * |        |          |0 = Timer0 is not active.
N * |        |          |1 = Timer0 is active.
N * |[14]    |ACTSTS1   |Internal Timer1 Active State (Read Only)
N * |        |          |This bit indicates the timer counter status of timer1.
N * |        |          |0 = Timer1 is not active.
N * |        |          |1 = Timer1 is active.
N * |[15]    |ACTSTS2   |Internal Timer2 Active State (Read Only)
N * |        |          |This bit indicates the timer counter status of timer2.
N * |        |          |0 = Timer2 is not active.
N * |        |          |1 = Timer2 is active.
N * @var SC_T::EGT
N * Offset: 0x0C  SC Extend Guard Time Register.
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |EGT       |Extended Guard Time
N * |        |          |This field indicates the extended guard timer value.
N * |        |          |Note:
N * |        |          |The counter is ETU base and the real extended guard time is EGT.
N * @var SC_T::RXTOUT
N * Offset: 0x10  SC Receive buffer Time-out Register.
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[8:0]   |RFTM      |SC Receiver FIFO Time-out (ETU Base)
N * |        |          |The time-out counter resets and starts counting whenever the RX buffer received a new data word.
N * |        |          |Once the counter decrease to 1 and no new data is received or CPU does not read data by reading SC_DAT buffer, a receiver time-out interrupt INT_RTMR will be generated(if RXTOIF(SC_INTEN[9]) = 1 ).
N * |        |          |Note1: The counter unit is ETU based and the interval of time-out is RFTM + 0.5.
N * |        |          |Note2:
N * |        |          |Filling all 0 to this field indicates to disable this function.
N * @var SC_T::ETUCTL
N * Offset: 0x14  SC ETU Control Register.
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |ETURDIV   |ETU Rate Divider
N * |        |          |The field indicates the clock rate divider.
N * |        |          |The real ETU is ETURDIV + 1.
N * |        |          |Note:
N * |        |          |Software can configure this field, but this field must be greater than 0x004.
N * |[15]    |CMPEN     |Compensation Mode Enable Bit
N * |        |          |This bit enables clock compensation function.
N * |        |          |When this bit enabled, hardware will alternate between n clock cycles and n-1 clock cycles, where n is the value to be written into the ETURDIV .
N * |        |          |0 = Compensation function Disabled.
N * |        |          |1 = Compensation function Enabled.
N * @var SC_T::INTEN
N * Offset: 0x18  SC Interrupt Enable Control Register.
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RDAIEN    |Receive Data Reach Interrupt Enable Bit
N * |        |          |This field is used for received data reaching trigger level RXTRGLV (SC_CTL[7:6]) interrupt enable.
N * |        |          |0 = Receive data reach trigger level interrupt Disabled.
N * |        |          |1 = Receive data reach trigger level interrupt Enabled.
N * |[1]     |TBEIEN    |Transmit Buffer Empty Interrupt Enable Bit
N * |        |          |This field is used for transmit buffer empty interrupt enable.
N * |        |          |0 = Transmit buffer empty interrupt Disabled.
N * |        |          |1 = Transmit buffer empty interrupt Enabled.
N * |[2]     |TERRIEN   |Transfer Error Interrupt Enable Bit
N * |        |          |This field is used for transfer error interrupt enable.
N * |        |          |The transfer error states is at SC_STATUS register which includes receiver break error BEF(SC_STATUS[6]), frame error FEF(SC_STATUS[5]), parity error PEF(SC_STATUS[4]), receiver buffer overflow error RXOV(SC_STATUS[0]), transmit buffer overflow error TXOV(SC_STATUS[8]), receiver retry over limit error RXOVERR(SC_STATUS[22]) and transmitter retry over limit error TXOVERR (SC_STATUS[30]).
N * |        |          |0 = Transfer error interrupt Disabled.
N * |        |          |1 = Transfer error interrupt Enabled.
N * |[3]     |TMR0IEN   |Timer0 Interrupt Enable Bit
N * |        |          |This field is used to enable TMR0 interrupt enable.
N * |        |          |0 = Timer0 interrupt Disabled.
N * |        |          |1 = Timer0 interrupt Enabled.
N * |[4]     |TMR1IEN   |Timer1 Interrupt Enable Bit
N * |        |          |This field is used to enable the TMR1 interrupt.
N * |        |          |0 = Timer1 interrupt Disabled.
N * |        |          |1 = Timer1 interrupt Enabled.
N * |[5]     |TMR2IEN   |Timer2 Interrupt Enable Bit
N * |        |          |This field is used for TMR2 interrupt enable.
N * |        |          |0 = Timer2 interrupt Disabled.
N * |        |          |1 = Timer2 interrupt Enabled.
N * |[6]     |BGTIEN    |Block Guard Time Interrupt Enable Bit
N * |        |          |This field is used for block guard time interrupt enable.
N * |        |          |0 = Block guard time Disabled.
N * |        |          |1 = Block guard time Enabled.
N * |[7]     |CDIEN     |Card Detect Interrupt Enable Bit
N * |        |          |This field is used for card detect interrupt enable. The card detect status is CINSERT(SC_STATUS[12])
N * |        |          |0 = Card detect interrupt Disabled.
N * |        |          |1 = Card detect interrupt Enabled.
N * |[8]     |INITIEN   |Initial End Interrupt Enable Bit
N * |        |          |This field is used for activation (ACTEN(SC_ALTCTL[3] = 1)), deactivation ((DACTEN SC_ALTCTL[2]) = 1) and warm reset (WARSTEN (SC_ALTCTL [4])) sequence interrupt enable.
N * |        |          |0 = Initial end interrupt Disabled.
N * |        |          |1 = Initial end interrupt Enabled.
N * |[9]     |RXTOIF    |Receiver Buffer Time-Out Interrupt Enable Bit
N * |        |          |This field is used for receiver buffer time-out interrupt enable.
N * |        |          |0 = Receiver buffer time-out interrupt Disabled.
N * |        |          |1 = Receiver buffer time-out interrupt Enabled.
N * |[10]    |ACERRIEN  |Auto Convention Error Interrupt Enable Bit
N * |        |          |This field is used for auto-convention error interrupt enable.
N * |        |          |0 = Auto-convention error interrupt Disabled.
N * |        |          |1 = Auto-convention error interrupt Enabled.
N * @var SC_T::INTSTS
N * Offset: 0x1C  SC Interrupt Status Register.
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RDAIF     |Receive Data Reach Interrupt Status Flag (Read Only)
N * |        |          |This field is used for received data reaching trigger level RXTRGLV (SC_CTL[7:6]) interrupt status flag.
N * |        |          |Note: This field is the status flag of received data reaching RXTRGLV (SC_CTL[7:6]).
N * |        |          |If software reads data from SC_DAT and receiver buffer data byte number is less than RXTRGLV (SC_CTL[7:6]), this bit will be cleared automatically.
N * |[1]     |TBEIF     |Transmit Buffer Empty Interrupt Status Flag (Read Only)
N * |        |          |This field is used for transmit buffer empty interrupt status flag.
N * |        |          |Note: This field is the status flag of transmit buffer empty state.
N * |        |          |If software wants to clear this bit, software must write data to DAT(SC_DAT[7:0]) buffer and then this bit will be cleared automatically.
N * |[2]     |TERRIF    |Transfer Error Interrupt Status Flag (Read Only)
N * |        |          |This field is used for transfer error interrupt status flag.
N * |        |          |The transfer error states is at SC_STATUS register which includes receiver break error BEF(SC_STATUS[6]), frame error FEF(SC_STATUS[5]), parity error PEF(SC_STATUS[4]) and receiver buffer overflow error RXOV(SC_STATUS[0]), transmit buffer overflow error TXOV(SC_STATUS[8]), receiver retry over limit error RXOVERR(SC_STATUS[22]) and transmitter retry over limit error TXOVERR(SC_STATUS[30]).
N * |        |          |Note: This field is the status flag of
N * |        |          |BEF(SC_STATUS[6]), FEF(SC_STATUS[5]), PEF(SC_STATUS[4]), RXOV(SC_STATUS[0]), TXOV(SC_STATUS[8]), RXOVERR(SC_STATUS[22]) or TXOVERR(SC_STATUS[30]).
N * |        |          |So, if software wants to clear this bit, software must write 1 to each field.
N * |[3]     |TMR0IF    |Timer0 Interrupt Status Flag (Read Only)
N * |        |          |This field is used for TMR0 interrupt status flag.
N * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
N * |[4]     |TMR1IF    |Timer1 Interrupt Status Flag (Read Only)
N * |        |          |This field is used for TMR1 interrupt status flag.
N * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
N * |[5]     |TMR2IF    |Timer2 Interrupt Status Flag (Read Only)
N * |        |          |This field is used for TMR2 interrupt status flag.
N * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
N * |[6]     |BGTIF     |Block   Guard Time Interrupt Status Flag (Read Only)
N * |        |          |This field   is used for block guard time interrupt status flag.
N * |        |          |Note1: This bit is valid when RXBGTEN   (SC_ALTCTL[12]) is enabled.
N * |        |          |Note2: This bit is read only, but it can be cleared by   writing "1" to it.
N * |[7]     |CDIF      |Card Detect Interrupt Status Flag (Read Only)
N * |        |          |This field is used for card detect interrupt status flag.
N * |        |          |The card detect status is CINSERT (SC_STATUS[12]) and CREMOVE(SC_STATUS[11]).
N * |        |          |Note:
N * |        |          |This field is the status flag of CINSERT(SC_STATUS[12]) or CREMOVE(SC_STATUS[11])].
N * |        |          |So if software wants to clear this bit, software must write 1 to this field.
N * |[8]     |INITIF    |Initial End Interrupt Status Flag (Read Only)
N * |        |          |This field is used for activation (ACTEN(SC_ALTCTL[3])), deactivation (DACTEN (SC_ALTCTL[2])) and warm reset (WARSTEN (SC_ALTCTL[4])) sequence interrupt status flag.
N * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
N * |[9]     |RBTOIF    |Receiver Buffer Time-Out Interrupt Status Flag (Read Only)
N * |        |          |This field is used for receiver buffer time-out interrupt status flag.
N * |        |          |Note: This field is the status flag of receiver buffer time-out state.
N * |        |          |If software wants to clear this bit, software must read all receiver buffer remaining data by reading SC_DAT buffer,.
N * |[10]    |ACERRIF   |Auto Convention Error Interrupt Status Flag (Read Only)
N * |        |          |This field indicates auto convention sequence error.
N * |        |          |If the received TS at ATR state is neither 0x3B nor 0x3F, this bit will be set.
N * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
N * @var SC_T::STATUS
N * Offset: 0x20  SC Status Register.
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RXOV      |RX Overflow Error Status Flag (Read Only)
N * |        |          |This bit is set when RX buffer overflow.
N * |        |          |If the number of received bytes is greater than Rx Buffer size (4 bytes), this bit will be set.
N * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
N * |[1]     |RXEMPTY   |Receiver Buffer Empty Status Flag(Read Only)
N * |        |          |This bit indicates RX buffer empty or not.
N * |        |          |When the last byte of Rx buffer has been read by CPU, hardware sets this bit high.
N * |        |          |It will be cleared when SC receives any new data.
N * |[2]     |RXFULL    |Receiver Buffer Full Status Flag (Read Only)
N * |        |          |This bit indicates RX buffer full or not.
N * |        |          |This bit is set when RX pointer is equal to 4, otherwise it is cleared by hardware.
N * |[4]     |PEF       |Receiver Parity Error Status Flag (Read Only)
N * |        |          |This bit is set to logic 1 whenever the received character does not have a valid
N * |        |          |"parity bit".
N * |        |          |Note1:
N * |        |          |This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2:
N * |        |          |If CPU sets receiver retries function by setting RXRTYEN(SC_CTL[19]) , hardware will not set this flag.
N * |[5]     |FEF       |Receiver Frame Error Status Flag (Read Only)
N * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as logic 0).
N * |        |          |Note1:
N * |        |          |This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2:
N * |        |          |If CPU sets receiver retries function by setting RXRTYEN(SC_CTL[19]) , hardware will not set this flag.
N * |[6]     |BEF       |Receiver Break Error Status Flag (Read Only)
N * |        |          |This bit is set to logic 1 whenever the received data input (RX) held in the "spacing state" (logic 0) is longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits).
N * |        |          |.
N * |        |          |Note1:
N * |        |          |This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2:
N * |        |          |If CPU sets receiver retries function by setting RXRTYEN(SC_CTL[19]) , hardware will not set this flag.
N * |[8]     |TXOV      |TX Overflow Error Interrupt Status Flag (Read Only)
N * |        |          |If TX buffer is full, an additional write to DAT(SC_DAT[7:0]) will cause this bit be set to "1" by hardware.
N * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
N * |[9]     |TXEMPTY   |Transmit Buffer Empty Status Flag (Read Only)
N * |        |          |This bit indicates TX buffer empty or not.
N * |        |          |When the last byte of TX buffer has been transferred to Transmitter Shift Register, hardware sets this bit high.
N * |        |          |It will be cleared when writing data into DAT(SC_DAT[7:0]) (TX buffer not empty).
N * |[10]    |TXFULL    |Transmit Buffer Full Status Flag (Read Only)
N * |        |          |This bit indicates TX buffer full or not.This bit is set when TX pointer is equal to 4, otherwise is cleared by hardware.
N * |[11]    |CREMOVE   |Card Detect Removal Status Of SC_CD Pin (Read Only)
N * |        |          |This bit is set whenever card has been removal.
N * |        |          |0 = No effect.
N * |        |          |1 = Card removed.
N * |        |          |Note1: This bit is read only, but it can be cleared by writing "1" to it.
N * |        |          |Note2: Card detect engine will start after SCEN (SC_CTL[0])set.
N * |[12]    |CINSERT   |Card Detect Insert Status Of SC_CD Pin (Read Only)
N * |        |          |This bit is set whenever card has been inserted.
N * |        |          |0 = No effect.
N * |        |          |1 = Card insert.
N * |        |          |Note1: This bit is read only, but it can be cleared by writing "1" to it.
N * |        |          |Note2: The
N * |        |          |card detect engine will start after SCEN (SC_CTL[0]) set.
N * |[13]    |CDPINSTS  |Card Detect Status Of SC_CD Pin Status (Read Only)
N * |        |          |This bit is the pin status flag of SC_CD
N * |        |          |0 = The SC_CD pin state at low.
N * |        |          |1 = The SC_CD pin state at high.
N * |[17:16] |RXPOINT   |Receiver Buffer Pointer Status Flag (Read Only)
N * |        |          |This field indicates the RX buffer pointer status flag.
N * |        |          |When SC receives one byte from external device, RXPOINT(SC_STATUS[17:16]) increases one.
N * |        |          |When one byte of RX buffer is read by CPU, RXPOINT(SC_STATUS[17:16]) decreases one.
N * |[21]    |RXRERR    |Receiver Retry Error (Read Only)
N * |        |          |This bit is set by hardware when RX has any error and retries transfer.
N * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2 This bit is a flag and cannot generate any interrupt to CPU.
N * |        |          |Note3: If CPU enables receiver retry function by setting RXRTYEN (SC_CTL[19]) , the PEF(SC_STATUS[4]) flag will be ignored (hardware will not set PEF(SC_STATUS[4])).
N * |[22]    |RXOVERR   |Receiver Over Retry Error (Read Only)
N * |        |          |This bit is set by hardware when RX transfer error retry over retry number limit.
N * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2: If CPU enables receiver retries function by setting RXRTYEN (SC_CTL[19]), the PEF(SC_STATUS[4]) flag will be ignored (hardware will not set PEF(SC_STATUS[4])).
N * |[23]    |RXACT     |Receiver In Active Status Flag (Read Only)
N * |        |          |This bit is set by hardware when RX transfer is in active.
N * |        |          |This bit is cleared automatically when RX transfer is finished.
N * |[25:24] |TXPOINT   |Transmit Buffer Pointer Status Flag (Read Only)
N * |        |          |This field indicates the TX buffer pointer status flag.
N * |        |          |When CPU writes data into SC_DAT, TXPOINT increases one.
N * |        |          |When one byte of TX Buffer is transferred to transmitter shift register, TXPOINT decreases one.
N * |[29]    |TXRERR    |Transmitter Retry Error (Read Only)
N * |        |          |This bit is set by hardware when transmitter re-transmits.
N * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2 This bit is a flag and cannot generate any interrupt to CPU.
N * |[30]    |TXOVERR   |Transmitter Over Retry Error (Read Only)
N * |        |          |This bit is set by hardware when transmitter re-transmits over retry number limitation.
N * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
N * |[31]    |TXACT     |Transmit In Active Status Flag (Read Only)
N * |        |          |0 = This bit is cleared automatically when TX transfer is finished or the last byte transmission has completed.
N * |        |          |1 = This bit is set by hardware when TX transfer is in active and the STOP bit of the last byte has been transmitted.
N * @var SC_T::PINCTL
N * Offset: 0x24  SC Pin Control State Register.
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PWREN     |SC_PWREN Pin Signal
N * |        |          |Software can set PWREN (SC_PINCTL[0]) and PWRINV (SC_PINCTL[11])to decide SC_PWR pin is in high or low level.
N * |        |          |Write this field to drive SC_PWR pin
N * |        |          |Refer PWRINV (SC_PINCTL[11]) description for programming SC_PWR pin voltage level.
N * |        |          |Read this field to get SC_PWR pin status.
N * |        |          |0 = SC_PWR pin status is low.
N * |        |          |1 = SC_PWR pin status is high.
N * |        |          |Note: When operating at activation, warm reset or deactivation mode, this bit will be changed automatically.
N * |        |          |So don't fill this field when operating in these modes.
N * |[1]     |SCRST     |SC_RST Pin Signal
N * |        |          |This bit is the pin status of SC_RST but user can drive SC_RST pin to high or low by setting this bit.
N * |        |          |Write this field to drive SC_RST pin.
N * |        |          |0 = Drive SC_RST pin to low.
N * |        |          |1 = Drive SC_RST pin to high.
N * |        |          |Read this field to get SC_RST pin status.
N * |        |          |0 = SC_RST pin status is low.
N * |        |          |1 = SC_RST pin status is high.
N * |        |          |Note: When operating at activation, warm reset or deactivation mode, this bit will be changed automatically.
N * |        |          |So don't fill this field when operating in these modes.
N * |[5]     |CSTOPLV   |SC Clock Stop Level
N * |        |          |This field indicates the clock polarity control in clock stop mode.
N * |        |          |0 = SC_CLK stopped in low level.
N * |        |          |1 = SC_CLK stopped in high level.
N * |[6]     |CLKKEEP   |SC Clock Enable Bit
N * |        |          |0 = SC clock generation Disabled.
N * |        |          |1 = SC clock always keeps free running.
N * |        |          |Note: When operating in activation, warm reset or deactivation mode, this bit will be changed automatically.
N * |        |          |So don't fill this field when operating in these modes.
N * |[9]     |SCDOUT    |SC Data Output Pin
N * |        |          |This bit is the pin status of SCDATOUT but user can drive SCDATOUT pin to high or low by setting this bit.
N * |        |          |0 = Drive SCDATOUT pin to low.
N * |        |          |1 = Drive SCDATOUT pin to high.
N * |        |          |Note: When SC is at activation, warm reset or deactivation mode, this bit will be changed automatically.
N * |        |          |So don't fill this field when SC is in these modes.
N * |[11]    |PWRINV    |SC_POW Pin Inverse
N * |        |          |This bit is used for inverse the SC_POW pin.
N * |        |          |There are four kinds of combination for SC_POW pin setting by PWRINV(SC_PINCTL[11]) and PWREN(SC_PINCTL[0]).
N * |        |          |PWRINV (SC_PINCTL[11]) is bit 1 and PWREN(SC_PINCTL[0]) is bit 0 for SC_POW_Pin as high or low voltage selection.
N * |        |          |00 = SC_POW_ Pin is 0.
N * |        |          |01 = SC_POW _Pin is 1.
N * |        |          |10 = SC_POW _Pin is 1.
N * |        |          |11 = SC_POW_ Pin is 0.
N * |        |          |Note: Software must select PWRINV (SC_PINCTL[11]) before Smart Card is enabled by SCEN (SC_CTL[0]).
N * |[12]    |SCDOSTS   |SC Data Pin Output Status
N * |        |          |This bit is the pin status of SCDATOUT
N * |        |          |0 = SCDATOUT pin to low.
N * |        |          |1 = SCDATOUT pin to high.
N * |        |          |Note: When SC is operated at activation, warm reset or deactivation mode, this bit will be changed automatically.
N * |        |          |This bit is not allowed to program when SC is operated at these modes.
N * |[16]    |DATSTS    |This bit   is the pin status of SC_DAT
N * |        |          |0 = The   SC_DAT pin is low.
N * |        |          |1 = The   SC_DAT pin is high.
N * |[17]    |PWRSTS    |SC_PWR   Pin Signal
N * |        |          |This bit   is the pin status of SC_PWR
N * |        |          |0 = SC_PWR   pin to low.
N * |        |          |1 = SC_PWR   pin to high.
N * |        |          |Note: When SC is operated at activation, warm reset or deactivation mode, this bit will be changed automatically.
N * |        |          |This bit is not allowed to program when SC is operated at these modes.
N * |[18]    |RSTSTS    |SCRST Pin Signals
N * |        |          |This bit is the pin status of SC_RST
N * |        |          |0 = SC_RST pin is low.
N * |        |          |1 = SC_RST pin is high.
N * |        |          |Note: When SC is operated at activation, warm reset or deactivation mode, this bit will be changed automatically.
N * |        |          |This bit is not allowed to program when SC is operated at these modes.
N * |[30]    |SYNC      |SYNC Flag Indicator
N * |        |          |Due to synchronization, software should check this bit when writing a new value to SC_PINCTL register.
N * |        |          |0 = Synchronizing is completion, user can write new data to SC_PINCTL register.
N * |        |          |1 = Last value is synchronizing.
N * |        |          |Note: This bit is read only.
N * |[31]    |LOOPBK    |Loop Back Test
N * |        |          |0 = loop back test Disabled.
N * |        |          |1 = Enabling loop back test and the internal SCDATOUT will connect to internal SC_DATA_I.
N * @var SC_T::TMRCTL0
N * Offset: 0x28  SC Internal Timer Control Register 0.
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[23:0]  |CNT       |Timer 0 Counter Value (ETU Base)
N * |        |          |This field indicates the internal timer operation values.
N * |[27:24] |OPMODE    |Timer 0 Operation Mode Selection
N * |        |          |This field indicates the internal 24-bit timer operation selection.
N * |        |          |Refer to 6.17.5.4 for programming Timer0
N * @var SC_T::TMRCTL1
N * Offset: 0x2C  SC Internal Timer Control Register 1.
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |CNT       |Timer 1 Counter Value (ETU Base)
N * |        |          |This field indicates the internal timer operation values.
N * |[27:24] |OPMODE    |Timer 1 Operation Mode Selection
N * |        |          |This field indicates the internal 8-bit timer operation selection.
N * |        |          |Refer to 6.17.5.4 for programming Timer1
N * @var SC_T::TMRCTL2
N * Offset: 0x30  SC Internal Timer Control Register 2.
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |CNT       |Timer 2 Counter Value (ETU Base)
N * |        |          |This field indicates the internal timer operation values.
N * |[27:24] |OPMODE    |Timer 2 Operation Mode Selection
N * |        |          |This field indicates the internal 8-bit timer operation selection
N * |        |          |Refer to 6.17.5.4 for programming Timer2
N * @var SC_T::UARTCTL
N * Offset: 0x34  SC UART Mode Control Register.
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |UARTEN    |UART Mode Enable Bit
N * |        |          |0 = Smart Card mode.
N * |        |          |1 = UART mode.
N * |        |          |Note1: When operating in UART mode, user must set CONSEL (SC_CTL[5:4]) = 00 and AUTOCEN(SC_CTL[3]) = 0.
N * |        |          |Note2: When operating in Smart Card mode, user must set UARTEN(SC_UARTCTL [0]) = 00.
N * |        |          |Note3: When UART is enabled, hardware will generate a reset to reset FIFO and internal state machine.
N * |[5:4]   |WLS10     |Word Length Selection
N * |        |          |00 = Word length is 8 bits.
N * |        |          |01 = Word length is 7 bits.
N * |        |          |10 = Word length is 6 bits.
N * |        |          |11 = Word length is 5 bits.
N * |        |          |Note: In smart card mode, this WLS must be '00'
N * |[6]     |PBOFF     |Parity Bit Disable Control
N * |        |          |0 = Parity bit is generated or checked between the "last data word bit" and "stop bit" of the serial data.
N * |        |          |1 = Parity bit is not generated (transmitting data) or checked (receiving data) during transfer.
N * |        |          |Note: In smart card mode, this field must be '0' (default setting is with parity bit)
N * |[7]     |OPE       |Odd Parity Enable Bit
N * |        |          |0 = Even number of logic 1's are transmitted or check the data word and parity bits in receiving mode.
N * |        |          |1 = Odd number of logic 1's are transmitted or check the data word and parity bits in receiving mode.
N * |        |          |Note: This bit has effect only when PBOFF bit is '0'.
N * @var SC_T::TMRDAT0
N * Offset: 0x38  SC Timer Current Data Register A.
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[23:0]  |CNT0      |Timer0 Current Data Value (Read Only)
N * |        |          |This field indicates the current count values of timer0.
N * @var SC_T::TMRDAT1_2
N * Offset: 0x3C  SC Timer Current Data Register B.
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |CNT1      |Timer1 Current Data Value (Read Only)
N * |        |          |This field indicates the current count values of timer1.
N * |[15:8]  |CNT2      |Timer2 Current Data Value (Read Only)
N * |        |          |This field indicates the current count values of timer2.
N */
N
N    __IO uint32_t DAT;           /* Offset: 0x00  SC Receiving/Transmit Holding Buffer Register.                     */
X    volatile uint32_t DAT;            
N    __IO uint32_t CTL;           /* Offset: 0x04  SC Control Register.                                               */
X    volatile uint32_t CTL;            
N    __IO uint32_t ALTCTL;        /* Offset: 0x08  SC Alternate Control Register.                                     */
X    volatile uint32_t ALTCTL;         
N    __IO uint32_t EGT;           /* Offset: 0x0C  SC Extend Guard Time Register.                                     */
X    volatile uint32_t EGT;            
N    __IO uint32_t RXTOUT;        /* Offset: 0x10  SC Receive buffer Time-out Register.                               */
X    volatile uint32_t RXTOUT;         
N    __IO uint32_t ETUCTL;        /* Offset: 0x14  SC ETU Control Register.                                           */
X    volatile uint32_t ETUCTL;         
N    __IO uint32_t INTEN;         /* Offset: 0x18  SC Interrupt Enable Control Register.                              */
X    volatile uint32_t INTEN;          
N    __IO uint32_t INTSTS;        /* Offset: 0x1C  SC Interrupt Status Register.                                      */
X    volatile uint32_t INTSTS;         
N    __IO uint32_t STATUS;        /* Offset: 0x20  SC Status Register.                                                */
X    volatile uint32_t STATUS;         
N    __IO uint32_t PINCTL;        /* Offset: 0x24  SC Pin Control State Register.                                     */
X    volatile uint32_t PINCTL;         
N    __IO uint32_t TMRCTL0;       /* Offset: 0x28  SC Internal Timer Control Register 0.                              */
X    volatile uint32_t TMRCTL0;        
N    __IO uint32_t TMRCTL1;       /* Offset: 0x2C  SC Internal Timer Control Register 1.                              */
X    volatile uint32_t TMRCTL1;        
N    __IO uint32_t TMRCTL2;       /* Offset: 0x30  SC Internal Timer Control Register 2.                              */
X    volatile uint32_t TMRCTL2;        
N    __IO uint32_t UARTCTL;       /* Offset: 0x34  SC UART Mode Control Register.                                     */
X    volatile uint32_t UARTCTL;        
N    __I  uint32_t TMRDAT0;       /* Offset: 0x38  SC Timer Current Data Register A.                                  */
X    volatile const  uint32_t TMRDAT0;        
N    __I  uint32_t TMRDAT1_2;     /* Offset: 0x3C  SC Timer Current Data Register B.                                  */
X    volatile const  uint32_t TMRDAT1_2;      
N
N} SC_T;
N
N
N
N/**
N    @addtogroup SC_CONST SC Bit Field Definition
N    Constant Definitions for SC Controller
N@{ */
N
N#define SC_DAT_DAT_Pos                   (0)                                        /*!< SC_T::DAT: DAT Position   */
N#define SC_DAT_DAT_Msk                   (0xfful << SC_DAT_DAT_Pos)                 /*!< SC_T::DAT: DAT Mask       */
N
N#define SC_CTL_SCEN_Pos                  (0)                                        /*!< SC_T::CTL: SCEN Position  */
N#define SC_CTL_SCEN_Msk                  (0x1ul << SC_CTL_SCEN_Pos)                 /*!< SC_T::CTL: SCEN Mask      */
N
N#define SC_CTL_RXOFF_Pos                 (1)                                        /*!< SC_T::CTL: RXOFF Position */
N#define SC_CTL_RXOFF_Msk                 (0x1ul << SC_CTL_RXOFF_Pos)                /*!< SC_T::CTL: RXOFF Mask     */
N
N#define SC_CTL_TXOFF_Pos                 (2)                                        /*!< SC_T::CTL: TXOFF Position */
N#define SC_CTL_TXOFF_Msk                 (0x1ul << SC_CTL_TXOFF_Pos)                /*!< SC_T::CTL: TXOFF Mask     */
N
N#define SC_CTL_AUTOCEN_Pos               (3)                                        /*!< SC_T::CTL: AUTOCEN Position   */
N#define SC_CTL_AUTOCEN_Msk               (0x1ul << SC_CTL_AUTOCEN_Pos)              /*!< SC_T::CTL: AUTOCEN Mask       */
N
N#define SC_CTL_CONSEL_Pos                (4)                                        /*!< SC_T::CTL: CONSEL Position    */
N#define SC_CTL_CONSEL_Msk                (0x3ul << SC_CTL_CONSEL_Pos)               /*!< SC_T::CTL: CONSEL Mask        */
N
N#define SC_CTL_RXTRGLV_Pos               (6)                                        /*!< SC_T::CTL: RXTRGLV Position   */
N#define SC_CTL_RXTRGLV_Msk               (0x3ul << SC_CTL_RXTRGLV_Pos)              /*!< SC_T::CTL: RXTRGLV Mask       */
N
N#define SC_CTL_BGT_Pos                   (8)                                        /*!< SC_T::CTL: BGT Position   */
N#define SC_CTL_BGT_Msk                   (0x1ful << SC_CTL_BGT_Pos)                 /*!< SC_T::CTL: BGT Mask       */
N
N#define SC_CTL_TMRSEL_Pos                (13)                                       /*!< SC_T::CTL: TMRSEL Position    */
N#define SC_CTL_TMRSEL_Msk                (0x3ul << SC_CTL_TMRSEL_Pos)               /*!< SC_T::CTL: TMRSEL Mask        */
N
N#define SC_CTL_NSB_Pos                   (15)                                       /*!< SC_T::CTL: NSB Position   */
N#define SC_CTL_NSB_Msk                   (0x1ul << SC_CTL_NSB_Pos)                  /*!< SC_T::CTL: NSB Mask       */
N
N#define SC_CTL_RXRTY_Pos                 (16)                                       /*!< SC_T::CTL: RXRTY Position */
N#define SC_CTL_RXRTY_Msk                 (0x7ul << SC_CTL_RXRTY_Pos)                /*!< SC_T::CTL: RXRTY Mask     */
N
N#define SC_CTL_RXRTYEN_Pos               (19)                                       /*!< SC_T::CTL: RXRTYEN Position   */
N#define SC_CTL_RXRTYEN_Msk               (0x1ul << SC_CTL_RXRTYEN_Pos)              /*!< SC_T::CTL: RXRTYEN Mask       */
N
N#define SC_CTL_TXRTY_Pos                 (20)                                       /*!< SC_T::CTL: TXRTY Position */
N#define SC_CTL_TXRTY_Msk                 (0x7ul << SC_CTL_TXRTY_Pos)                /*!< SC_T::CTL: TXRTY Mask     */
N
N#define SC_CTL_TXRTYEN_Pos               (23)                                       /*!< SC_T::CTL: TXRTYEN Position   */
N#define SC_CTL_TXRTYEN_Msk               (0x1ul << SC_CTL_TXRTYEN_Pos)              /*!< SC_T::CTL: TXRTYEN Mask       */
N
N#define SC_CTL_CDDBSEL_Pos               (24)                                       /*!< SC_T::CTL: CDDBSEL Position   */
N#define SC_CTL_CDDBSEL_Msk               (0x3ul << SC_CTL_CDDBSEL_Pos)              /*!< SC_T::CTL: CDDBSEL Mask       */
N
N#define SC_CTL_CDLV_Pos                  (26)                                       /*!< SC_T::CTL: CDLV Position  */
N#define SC_CTL_CDLV_Msk                  (0x1ul << SC_CTL_CDLV_Pos)                 /*!< SC_T::CTL: CDLV Mask      */
N
N#define SC_CTL_SYNC_Pos                  (30)                                       /*!< SC_T::CTL: SYNC Position  */
N#define SC_CTL_SYNC_Msk                  (0x1ul << SC_CTL_SYNC_Pos)                 /*!< SC_T::CTL: SYNC Mask      */
N
N#define SC_CTL_ICEDEBUG_Pos              (31)                                       /*!< SC_T::CTL: ICEDEBUG Position  */
N#define SC_CTL_ICEDEBUG_Msk              (0x1ul << SC_CTL_ICEDEBUG_Pos)             /*!< SC_T::CTL: ICEDEBUG Mask      */
N
N#define SC_ALTCTL_TXRST_Pos              (0)                                        /*!< SC_T::ALTCTL: TXRST Position  */
N#define SC_ALTCTL_TXRST_Msk              (0x1ul << SC_ALTCTL_TXRST_Pos)             /*!< SC_T::ALTCTL: TXRST Mask      */
N
N#define SC_ALTCTL_RXRST_Pos              (1)                                        /*!< SC_T::ALTCTL: RXRST Position  */
N#define SC_ALTCTL_RXRST_Msk              (0x1ul << SC_ALTCTL_RXRST_Pos)             /*!< SC_T::ALTCTL: RXRST Mask      */
N
N#define SC_ALTCTL_DACTEN_Pos             (2)                                        /*!< SC_T::ALTCTL: DACTEN Position */
N#define SC_ALTCTL_DACTEN_Msk             (0x1ul << SC_ALTCTL_DACTEN_Pos)            /*!< SC_T::ALTCTL: DACTEN Mask     */
N
N#define SC_ALTCTL_ACTEN_Pos              (3)                                        /*!< SC_T::ALTCTL: ACTEN Position  */
N#define SC_ALTCTL_ACTEN_Msk              (0x1ul << SC_ALTCTL_ACTEN_Pos)             /*!< SC_T::ALTCTL: ACTEN Mask      */
N
N#define SC_ALTCTL_WARSTEN_Pos            (4)                                        /*!< SC_T::ALTCTL: WARSTEN Position    */
N#define SC_ALTCTL_WARSTEN_Msk            (0x1ul << SC_ALTCTL_WARSTEN_Pos)           /*!< SC_T::ALTCTL: WARSTEN Mask        */
N
N#define SC_ALTCTL_CNTEN0_Pos             (5)                                        /*!< SC_T::ALTCTL: CNTEN0 Position */
N#define SC_ALTCTL_CNTEN0_Msk             (0x1ul << SC_ALTCTL_CNTEN0_Pos)            /*!< SC_T::ALTCTL: CNTEN0 Mask     */
N
N#define SC_ALTCTL_CNTEN1_Pos             (6)                                        /*!< SC_T::ALTCTL: CNTEN1 Position */
N#define SC_ALTCTL_CNTEN1_Msk             (0x1ul << SC_ALTCTL_CNTEN1_Pos)            /*!< SC_T::ALTCTL: CNTEN1 Mask     */
N
N#define SC_ALTCTL_CNTEN2_Pos             (7)                                        /*!< SC_T::ALTCTL: CNTEN2 Position */
N#define SC_ALTCTL_CNTEN2_Msk             (0x1ul << SC_ALTCTL_CNTEN2_Pos)            /*!< SC_T::ALTCTL: CNTEN2 Mask     */
N
N#define SC_ALTCTL_INITSEL_Pos            (8)                                        /*!< SC_T::ALTCTL: INITSEL Position    */
N#define SC_ALTCTL_INITSEL_Msk            (0x3ul << SC_ALTCTL_INITSEL_Pos)           /*!< SC_T::ALTCTL: INITSEL Mask        */
N
N#define SC_ALTCTL_ADACEN_Pos             (11)                                       /*!< SC_T::ALTCTL: ADACEN Position    */
N#define SC_ALTCTL_ADACEN_Msk             (0x1ul << SC_ALTCTL_ADACEN_Pos)            /*!< SC_T::ALTCTL: ADACEN Mask        */
N
N#define SC_ALTCTL_RXBGTEN_Pos            (12)                                       /*!< SC_T::ALTCTL: RXBGTEN Position    */
N#define SC_ALTCTL_RXBGTEN_Msk            (0x1ul << SC_ALTCTL_RXBGTEN_Pos)           /*!< SC_T::ALTCTL: RXBGTEN Mask        */
N
N#define SC_ALTCTL_ACTSTS0_Pos            (13)                                       /*!< SC_T::ALTCTL: ACTSTS0 Position    */
N#define SC_ALTCTL_ACTSTS0_Msk            (0x1ul << SC_ALTCTL_ACTSTS0_Pos)           /*!< SC_T::ALTCTL: ACTSTS0 Mask        */
N
N#define SC_ALTCTL_ACTSTS1_Pos            (14)                                       /*!< SC_T::ALTCTL: ACTSTS1 Position    */
N#define SC_ALTCTL_ACTSTS1_Msk            (0x1ul << SC_ALTCTL_ACTSTS1_Pos)           /*!< SC_T::ALTCTL: ACTSTS1 Mask        */
N
N#define SC_ALTCTL_ACTSTS2_Pos            (15)                                       /*!< SC_T::ALTCTL: ACTSTS2 Position    */
N#define SC_ALTCTL_ACTSTS2_Msk            (0x1ul << SC_ALTCTL_ACTSTS2_Pos)           /*!< SC_T::ALTCTL: ACTSTS2 Mask        */
N
N#define SC_ALTCTL_OUTSEL_Pos             (16)                                       /*!< SC_T::ALTCTL: OUTSEL Position */
N#define SC_ALTCTL_OUTSEL_Msk             (0x1ul << SC_ALTCTL_OUTSEL_Pos)            /*!< SC_T::ALTCTL: OUTSEL Mask     */
N
N#define SC_EGT_EGT_Pos                   (0)                                        /*!< SC_T::EGT: EGT Position   */
N#define SC_EGT_EGT_Msk                   (0xfful << SC_EGT_EGT_Pos)                 /*!< SC_T::EGT: EGT Mask       */
N
N#define SC_RXTOUT_RFTM_Pos               (0)                                        /*!< SC_T::RXTOUT: RFTM Position   */
N#define SC_RXTOUT_RFTM_Msk               (0x1fful << SC_RXTOUT_RFTM_Pos)            /*!< SC_T::RXTOUT: RFTM Mask       */
N
N#define SC_ETUCTL_ETURDIV_Pos            (0)                                        /*!< SC_T::ETUCTL: ETURDIV_ Position   */
N#define SC_ETUCTL_ETURDIV_Msk            (0xffful << SC_ETUCTL_ETURDIV_Pos)         /*!< SC_T::ETUCTL: ETURDIV_ Mask       */
N
N#define SC_ETUCTL_CMPEN_Pos              (15)                                       /*!< SC_T::ETUCTL: CMPEN_ Position */
N#define SC_ETUCTL_CMPEN_Msk              (0x1ul << SC_ETUCTL_CMPEN_Pos)             /*!< SC_T::ETUCTL: CMPEN_ Mask     */
N
N#define SC_INTEN_RDAIEN_Pos              (0)                                        /*!< SC_T::INTEN: RDAIEN Position  */
N#define SC_INTEN_RDAIEN_Msk              (0x1ul << SC_INTEN_RDAIEN_Pos)             /*!< SC_T::INTEN: RDAIEN Mask      */
N
N#define SC_INTEN_TBEIEN_Pos              (1)                                        /*!< SC_T::INTEN: TBEIEN Position  */
N#define SC_INTEN_TBEIEN_Msk              (0x1ul << SC_INTEN_TBEIEN_Pos)             /*!< SC_T::INTEN: TBEIEN Mask      */
N
N#define SC_INTEN_TERRIEN_Pos             (2)                                        /*!< SC_T::INTEN: TERRIEN Position */
N#define SC_INTEN_TERRIEN_Msk             (0x1ul << SC_INTEN_TERRIEN_Pos)            /*!< SC_T::INTEN: TERRIEN Mask     */
N
N#define SC_INTEN_TMR0IEN_Pos             (3)                                        /*!< SC_T::INTEN: TMR0IEN_Position */
N#define SC_INTEN_TMR0IEN_Msk             (0x1ul << SC_INTEN_TMR0IEN_Pos)            /*!< SC_T::INTEN: TMR0IEN Mask     */
N
N#define SC_INTEN_TMR1IEN_Pos             (4)                                        /*!< SC_T::INTEN: TMR1IEN Position */
N#define SC_INTEN_TMR1IEN_Msk             (0x1ul << SC_INTEN_TMR1IEN_Pos)            /*!< SC_T::INTEN: TMR1IEN Mask     */
N
N#define SC_INTEN_TMR2IEN_Pos             (5)                                        /*!< SC_T::INTEN: TMR2IEN Position */
N#define SC_INTEN_TMR2IEN_Msk             (0x1ul << SC_INTEN_TMR2IEN_Pos)            /*!< SC_T::INTEN: TMR2IEN Mask     */
N
N#define SC_INTEN_BGTIEN_Pos              (6)                                        /*!< SC_T::INTEN: BGTIEN Position  */
N#define SC_INTEN_BGTIEN_Msk              (0x1ul << SC_INTEN_BGTIEN_Pos)             /*!< SC_T::INTEN: BGTIEN Mask      */
N
N#define SC_INTEN_CDIEN_Pos               (7)                                        /*!< SC_T::INTEN: CDIEN Position   */
N#define SC_INTEN_CDIEN_Msk               (0x1ul << SC_INTEN_CDIEN_Pos)              /*!< SC_T::INTEN: CDIEN Mask       */
N
N#define SC_INTEN_INITIEN_Pos             (8)                                        /*!< SC_T::INTEN: INITIEN Position */
N#define SC_INTEN_INITIEN_Msk             (0x1ul << SC_INTEN_INITIEN_Pos)            /*!< SC_T::INTEN: INITIEN Mask     */
N
N#define SC_INTEN_RXTOIF_Pos              (9)                                        /*!< SC_T::INTEN: RXTOIF Position  */
N#define SC_INTEN_RXTOIF_Msk              (0x1ul << SC_INTEN_RXTOIF_Pos)             /*!< SC_T::INTEN: RXTOIF Mask      */
N
N#define SC_INTEN_ACERRIEN_Pos            (10)                                       /*!< SC_T::INTEN: ACERRIEN Position    */
N#define SC_INTEN_ACERRIEN_Msk            (0x1ul << SC_INTEN_ACERRIEN_Pos)           /*!< SC_T::INTEN: ACERRIEN Mask        */
N
N#define SC_INTSTS_RDAIF_Pos              (0)                                        /*!< SC_T::INTSTS: RDAIF Position  */
N#define SC_INTSTS_RDAIF_Msk              (0x1ul << SC_INTSTS_RDAIF_Pos)             /*!< SC_T::INTSTS: RDAIF Mask      */
N
N#define SC_INTSTS_TBEIF_Pos              (1)                                        /*!< SC_T::INTSTS: TBEIF Position  */
N#define SC_INTSTS_TBEIF_Msk              (0x1ul << SC_INTSTS_TBEIF_Pos)             /*!< SC_T::INTSTS: TBEIF Mask      */
N
N#define SC_INTSTS_TERRIF_Pos             (2)                                        /*!< SC_T::INTSTS: TERRIF Position */
N#define SC_INTSTS_TERRIF_Msk             (0x1ul << SC_INTSTS_TERRIF_Pos)            /*!< SC_T::INTSTS: TERRIF Mask     */
N
N#define SC_INTSTS_TMR0IF_Pos             (3)                                        /*!< SC_T::INTSTS: TMR0IF Position */
N#define SC_INTSTS_TMR0IF_Msk             (0x1ul << SC_INTSTS_TMR0IF_Pos)            /*!< SC_T::INTSTS: TMR0IF Mask     */
N
N#define SC_INTSTS_TMR1IF_Pos             (4)                                        /*!< SC_T::INTSTS: TMR1IF Position */
N#define SC_INTSTS_TMR1IF_Msk             (0x1ul << SC_INTSTS_TMR1IF_Pos)            /*!< SC_T::INTSTS: TMR1IF Mask     */
N
N#define SC_INTSTS_TMR2IF_Pos             (5)                                        /*!< SC_T::INTSTS: TMR2IF Position */
N#define SC_INTSTS_TMR2IF_Msk             (0x1ul << SC_INTSTS_TMR2IF_Pos)            /*!< SC_T::INTSTS: TMR2IF Mask     */
N
N#define SC_INTSTS_BGTIF_Pos              (6)                                        /*!< SC_T::INTSTS: BGTIF Position  */
N#define SC_INTSTS_BGTIF_Msk              (0x1ul << SC_INTSTS_BGTIF_Pos)             /*!< SC_T::INTSTS: BGTIF Mask      */
N
N#define SC_INTSTS_CDIF_Pos               (7)                                        /*!< SC_T::INTSTS: CDIF Position   */
N#define SC_INTSTS_CDIF_Msk               (0x1ul << SC_INTSTS_CDIF_Pos)              /*!< SC_T::INTSTS: CDIF Mask       */
N
N#define SC_INTSTS_INITIF_Pos             (8)                                        /*!< SC_T::INTSTS: INITIF Position */
N#define SC_INTSTS_INITIF_Msk             (0x1ul << SC_INTSTS_INITIF_Pos)            /*!< SC_T::INTSTS: INITIF Mask     */
N
N#define SC_INTSTS_RBTOIF_Pos             (9)                                        /*!< SC_T::INTSTS: RBTOIF Position */
N#define SC_INTSTS_RBTOIF_Msk             (0x1ul << SC_INTSTS_RBTOIF_Pos)            /*!< SC_T::INTSTS: RBTOIF Mask     */
N
N#define SC_INTSTS_ACERRIF_Pos            (10)                                       /*!< SC_T::INTSTS: ACERRIF Position    */
N#define SC_INTSTS_ACERRIF_Msk            (0x1ul << SC_INTSTS_ACERRIF_Pos)           /*!< SC_T::INTSTS: ACERRIF Mask        */
N
N#define SC_STATUS_RXOV_Pos               (0)                                        /*!< SC_T::STATUS: RXO Position    */
N#define SC_STATUS_RXOV_Msk               (0x1ul << SC_STATUS_RXOV_Pos)              /*!< SC_T::STATUS: RXO Mask        */
N
N#define SC_STATUS_RXEMPTY_Pos            (1)                                        /*!< SC_T::STATUS: RXEMPTY Position    */
N#define SC_STATUS_RXEMPTY_Msk            (0x1ul << SC_STATUS_RXEMPTY_Pos)           /*!< SC_T::STATUS: RXEMPTY Mask        */
N
N#define SC_STATUS_RXFULL_Pos             (2)                                        /*!< SC_T::STATUS: RXFULL Position */
N#define SC_STATUS_RXFULL_Msk             (0x1ul << SC_STATUS_RXFULL_Pos)            /*!< SC_T::STATUS: RXFULL Mask     */
N
N#define SC_STATUS_PEF_Pos                (4)                                        /*!< SC_T::STATUS: PEF Position    */
N#define SC_STATUS_PEF_Msk                (0x1ul << SC_STATUS_PEF_Pos)               /*!< SC_T::STATUS: PEF Mask        */
N
N#define SC_STATUS_FEF_Pos                (5)                                        /*!< SC_T::STATUS: FEF Position    */
N#define SC_STATUS_FEF_Msk                (0x1ul << SC_STATUS_FEF_Pos)               /*!< SC_T::STATUS: FEF Mask        */
N
N#define SC_STATUS_BEF_Pos                (6)                                        /*!< SC_T::STATUS: BEF Position    */
N#define SC_STATUS_BEF_Msk                (0x1ul << SC_STATUS_BEF_Pos)               /*!< SC_T::STATUS: BEF Mask        */
N
N#define SC_STATUS_TXOV_Pos               (8)                                        /*!< SC_T::STATUS: TXOV Position   */
N#define SC_STATUS_TXOV_Msk               (0x1ul << SC_STATUS_TXOV_Pos)              /*!< SC_T::STATUS: TXOV Mask       */
N
N#define SC_STATUS_TXEMPTY_Pos            (9)                                        /*!< SC_T::STATUS: TXEMPTY Position    */
N#define SC_STATUS_TXEMPTY_Msk            (0x1ul << SC_STATUS_TXEMPTY_Pos)           /*!< SC_T::STATUS: TXEMPTY Mask        */
N
N#define SC_STATUS_TXFULL_Pos             (10)                                       /*!< SC_T::STATUS: TXFULL Position */
N#define SC_STATUS_TXFULL_Msk             (0x1ul << SC_STATUS_TXFULL_Pos)            /*!< SC_T::STATUS: TXFULL Mask     */
N
N#define SC_STATUS_CREMOVE_Pos            (11)                                       /*!< SC_T::STATUS: CREMOVE Position    */
N#define SC_STATUS_CREMOVE_Msk            (0x1ul << SC_STATUS_CREMOVE_Pos)           /*!< SC_T::STATUS: CREMOVE Mask        */
N
N#define SC_STATUS_CINSERT_Pos            (12)                                       /*!< SC_T::STATUS: CINSERT Position    */
N#define SC_STATUS_CINSERT_Msk            (0x1ul << SC_STATUS_CINSERT_Pos)           /*!< SC_T::STATUS: CINSERT Mask        */
N
N#define SC_STATUS_CDPINSTS_Pos           (13)                                       /*!< SC_T::STATUS: CDPINSTS Position   */
N#define SC_STATUS_CDPINSTS_Msk           (0x1ul << SC_STATUS_CDPINSTS_Pos)          /*!< SC_T::STATUS: CDPINSTS Mask       */
N
N#define SC_STATUS_RXPOINT_Pos            (16)                                       /*!< SC_T::STATUS: RXPOINT Position    */
N#define SC_STATUS_RXPOINT_Msk            (0x3ul << SC_STATUS_RXPOINT_Pos)           /*!< SC_T::STATUS: RXPOINT Mask        */
N
N#define SC_STATUS_RXRERR_Pos             (21)                                       /*!< SC_T::STATUS: RXRERR Position     */
N#define SC_STATUS_RXRERR_Msk             (0x1ul << SC_STATUS_RXRERR_Pos)            /*!< SC_T::STATUS: RXRERR Mask         */
N
N#define SC_STATUS_RXOVERR_Pos            (22)                                       /*!< SC_T::STATUS: RXOVERR Position    */
N#define SC_STATUS_RXOVERR_Msk            (0x1ul << SC_STATUS_RXOVERR_Pos)           /*!< SC_T::STATUS: RXOVERR Mask        */
N
N#define SC_STATUS_RXACT_Pos              (23)                                       /*!< SC_T::STATUS: RXACT Position      */
N#define SC_STATUS_RXACT_Msk              (0x1ul << SC_STATUS_RXACT_Pos)             /*!< SC_T::STATUS: RXACT Msk           */
N
N#define SC_STATUS_TXPOINT_Pos            (24)                                       /*!< SC_T::STATUS: TXPOINT Position    */
N#define SC_STATUS_TXPOINT_Msk            (0x3ul << SC_STATUS_TXPOINT_Pos)           /*!< SC_T::STATUS: TXPOINT Msk         */
N
N#define SC_STATUS_TXRERR_Pos             (29)                                       /*!< SC_T::STATUS: TXRERR Position     */
N#define SC_STATUS_TXRERR_Msk             (0x1ul << SC_STATUS_TXRERR_Pos)            /*!< SC_T::STATUS: TXRERR Msk          */
N
N#define SC_STATUS_TXOVERR_Pos            (30)                                       /*!< SC_T::STATUS: TXOVERR_ Position   */
N#define SC_STATUS_TXOVERR_Msk            (0x1ul << SC_STATUS_TXOVERR_Pos)           /*!< SC_T::STATUS: TXOVERR_ Msk        */
N
N#define SC_STATUS_TXACT_Pos              (31)                                       /*!< SC_T::STATUS: TXACT Position      */
N#define SC_STATUS_TXACT_Msk              (0x1ul << SC_STATUS_TXACT_Pos)             /*!< SC_T::STATUS: TXACT Msk           */
N
N#define SC_PINCTL_PWREN_Pos              (0)                                        /*!< SC_T::PINCTL: PWREN Position  */
N#define SC_PINCTL_PWREN_Msk              (0x1ul << SC_PINCTL_PWREN_Pos)             /*!< SC_T::PINCTL: PWREN Msk       */
N
N#define SC_PINCTL_SCRST_Pos              (1)                                        /*!< SC_T::PINCTL: SCRST Position  */
N#define SC_PINCTL_SCRST_Msk              (0x1ul << SC_PINCTL_SCRST_Pos)             /*!< SC_T::PINCTL: SCRST Msk       */
N
N#define SC_PINCTL_CSTOPLV_Pos            (5)                                        /*!< SC_T::PINCTL: CSTOPLV Position    */
N#define SC_PINCTL_CSTOPLV_Msk            (0x1ul << SC_PINCTL_CSTOPLV_Pos)           /*!< SC_T::PINCTL: CSTOPLV Msk         */
N
N#define SC_PINCTL_CLKKEEP_Pos            (6)                                        /*!< SC_T::PINCTL: CLKKEEP Position    */
N#define SC_PINCTL_CLKKEEP_Msk            (0x1ul << SC_PINCTL_CLKKEEP_Pos)           /*!< SC_T::PINCTL: CLKKEEP Msk         */
N
N#define SC_PINCTL_SCDOUT_Pos             (9)                                        /*!< SC_T::PINCTL: SCDOUT Position */
N#define SC_PINCTL_SCDOUT_Msk             (0x1ul << SC_PINCTL_SCDOUT_Pos)            /*!< SC_T::PINCTL: SCDOUT Msk      */
N
N#define SC_PINCTL_PWRINV_Pos             (11)                                       /*!< SC_T::PINCTL: PWRINV Position */
N#define SC_PINCTL_PWRINV_Msk             (0x1ul << SC_PINCTL_PWRINV_Pos)            /*!< SC_T::PINCTL: PWRINV Msk      */
N
N#define SC_PINCTL_SCDOSTS_Pos            (12)                                       /*!< SC_T::PINCTL: SCDOSTS Position    */
N#define SC_PINCTL_SCDOSTS_Msk            (0x1ul << SC_PINCTL_SCDOSTS_Pos)           /*!< SC_T::PINCTL: SCDOSTS Msk         */
N
N#define SC_PINCTL_DATSTS_Pos             (16)                                       /*!< SC_T::PINCTL: DATSTS Position */
N#define SC_PINCTL_DATSTS_Msk             (0x1ul << SC_PINCTL_DATSTS_Pos)            /*!< SC_T::PINCTL: DATSTS Msk      */
N
N#define SC_PINCTL_PWRSTS_Pos             (17)                                       /*!< SC_T::PINCTL: PWRSTS Position */
N#define SC_PINCTL_PWRSTS_Msk             (0x1ul << SC_PINCTL_PWRSTS_Pos)            /*!< SC_T::PINCTL: PWRSTS Msk      */
N
N#define SC_PINCTL_RSTSTS_Pos             (18)                                       /*!< SC_T::PINCTL: RSTSTS Position */
N#define SC_PINCTL_RSTSTS_Msk             (0x1ul << SC_PINCTL_RSTSTS_Pos)            /*!< SC_T::PINCTL: RSTSTS Msk      */
N
N#define SC_PINCTL_SYNC_Pos               (30)                                       /*!< SC_T::PINCTL: SYNC Position   */
N#define SC_PINCTL_SYNC_Msk               (0x1ul << SC_PINCTL_SYNC_Pos)              /*!< SC_T::PINCTL: SYNC Msk        */
N
N#define SC_PINCTL_LOOPBK_Pos             (31)                                       /*!< SC_T::PINCTL: LOOPBK Position */
N#define SC_PINCTL_LOOPBK_Msk             (0x1ul << SC_PINCTL_LOOPBK_Pos)            /*!< SC_T::PINCTL: LOOPBK Msk      */
N
N#define SC_TMRCTL0_CNT_Pos               (0)                                        /*!< SC_T::TMRCTL0: CNT Position   */
N#define SC_TMRCTL0_CNT_Msk               (0xfffffful << SC_TMRCTL0_CNT_Pos)         /*!< SC_T::TMRCTL0: CNT Msk        */
N
N#define SC_TMRCTL0_OPMODE_Pos            (24)                                       /*!< SC_T::TMRCTL0: OPMODE Position    */
N#define SC_TMRCTL0_OPMODE_Msk            (0xful << SC_TMRCTL0_OPMODE_Pos)           /*!< SC_T::TMRCTL0: OPMODE Msk         */
N
N#define SC_TMRCTL1_CNT_Pos               (0)                                        /*!< SC_T::TMRCTL1: CNT Position   */
N#define SC_TMRCTL1_CNT_Msk               (0xfful << SC_TMRCTL1_CNT_Pos)             /*!< SC_T::TMRCTL1: CNT Msk        */
N
N#define SC_TMRCTL1_OPMODE_Pos            (24)                                       /*!< SC_T::TMRCTL1: OPMODE Position    */
N#define SC_TMRCTL1_OPMODE_Msk            (0xful << SC_TMRCTL1_OPMODE_Pos)           /*!< SC_T::TMRCTL1: OPMODE Msk         */
N
N#define SC_TMRCTL2_CNT_Pos               (0)                                        /*!< SC_T::TMRCTL2: CNT Position   */
N#define SC_TMRCTL2_CNT_Msk               (0xfful << SC_TMRCTL2_CNT_Pos)             /*!< SC_T::TMRCTL2: CNT Msk        */
N
N#define SC_TMRCTL2_OPMODE_Pos            (24)                                       /*!< SC_T::TMRCTL2: OPMODE Position    */
N#define SC_TMRCTL2_OPMODE_Msk            (0xful << SC_TMRCTL2_OPMODE_Pos)           /*!< SC_T::TMRCTL2: OPMODE Msk         */
N
N#define SC_UARTCTL_UARTEN_Pos            (0)                                        /*!< SC_T::UARTCTL: UARTEN Position    */
N#define SC_UARTCTL_UARTEN_Msk            (0x1ul << SC_UARTCTL_UARTEN_Pos)           /*!< SC_T::UARTCTL: UARTEN Msk         */
N
N#define SC_UARTCTL_WLS_Pos               (4)                                        /*!< SC_T::UARTCTL: WLS Position   */
N#define SC_UARTCTL_WLS_Msk               (0x3ul << SC_UARTCTL_WLS10_Pos)            /*!< SC_T::UARTCTL: WLS Msk        */
N
N#define SC_UARTCTL_PBOFF_Pos             (6)                                        /*!< SC_T::UARTCTL: PBOFF Position */
N#define SC_UARTCTL_PBOFF_Msk             (0x1ul << SC_UARTCTL_PBOFF_Pos)            /*!< SC_T::UARTCTL: PBOFF Msk      */
N
N#define SC_UARTCTL_OPE_Pos               (7)                                        /*!< SC_T::UARTCTL: OPE Position   */
N#define SC_UARTCTL_OPE_Msk               (0x1ul << SC_UARTCTL_OPE_Pos)              /*!< SC_T::UARTCTL: OPE Msk        */
N
N#define SC_TMRDAT0_CNT0_Pos              (0)                                        /*!< SC_T::TMRDAT0: CNT0 Position  */
N#define SC_TMRDAT0_CNT0_Msk              (0xfffffful << SC_TMRDAT0_CNT0_Pos)        /*!< SC_T::TMRDAT0: CNT0 Msk       */
N
N#define SC_TMRDAT1_2_CNT1_Pos            (0)                                        /*!< SC_T::TMRDAT1_2: CNT1 Position    */
N#define SC_TMRDAT1_2_CNT1_Msk            (0xfful << SC_TMRDAT1_2_CNT1_Pos)          /*!< SC_T::TMRDAT1_2: CNT1 Msk         */
N
N#define SC_TMRDAT1_2_CNT2_Pos            (8)                                        /*!< SC_T::TMRDAT1_2: CNT2 Position    */
N#define SC_TMRDAT1_2_CNT2_Msk            (0xfful << SC_TMRDAT1_2_CNT2_Pos)          /*!< SC_T::TMRDAT1_2: CNT2 Msk         */
N
N/**@}*/ /* SC_CONST */
N/**@}*/ /* end of SC register group */
N
N
N/*---------------------- Serial Peripheral Interface Controller -------------------------*/
N/**
N    @addtogroup SPI Serial Peripheral Interface Controller(SPI)
N    Memory Mapped Structure for SPI Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var SPI_T::CTL
N * Offset: 0x00  Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |SPIEN     |SPI Transfer Control Enable Bit
N * |        |          |In Master mode, the transfer will start when there is data in the FIFO buffer after this is set to 1.
N * |        |          |In Slave mode, this device is ready to receive data when this bit is set to 1.
N * |        |          |0 = Transfer control Disabled.
N * |        |          |1 = Transfer control Enabled.
N * |        |          |Note: Before changing the configurations of SPI_CTL, SPI_CLKDIV, SPI_SSCTL and SPI_FIFOCTL registers, user shall clear the SPIEN (SPI_CTL[0]) and confirm the SPIENSTS (SPI_STATUS[15]) is 0.
N * |[1]     |RXNEG     |Receive On Negative Edge
N * |        |          |0 = Received data input signal is latched on the rising edge of SPI bus clock.
N * |        |          |1 = Received data input signal is latched on the falling edge of SPI bus clock.
N * |[2]     |TXNEG     |Transmit On Negative Edge
N * |        |          |0 = Transmitted data output signal is changed on the rising edge of SPI bus clock.
N * |        |          |1 = Transmitted data output signal is changed on the falling edge of SP bus clock.
N * |[3]     |CLKPOL    |Clock Polarity
N * |        |          |0 = SPI bus clock is idle low.
N * |        |          |1 = SPI bus clock is idle high.
N * |[7:4]   |SUSPITV   |Suspend Interval (Master Only)
N * |        |          |The four bits provide configurable suspend interval between two successive transmit/receive transaction in a transfer.
N * |        |          |The definition of the suspend interval is the interval between the last clock edge of the preceding transaction word and the first clock edge of the following transaction word.
N * |        |          |The default value is 0x3.
N * |        |          |The period of the suspend interval is obtained according to the following equation.
N * |        |          |(SUSPITV[3:0] + 0.5) * period of SPICLK clock cycle
N * |        |          |Example:
N * |        |          |SUSPITV = 0x0 ... 0.5 SPICLK clock cycle.
N * |        |          |SUSPITV = 0x1 ... 1.5 SPICLK clock cycle.
N * |        |          |...
N * |        |          |SUSPITV = 0xE ... 14.5 SPICLK clock cycle.
N * |        |          |SUSPITV = 0xF ... 15.5 SPICLK clock cycle.
N * |[12:8]  |DWIDTH    |Data Width
N * |        |          |This field specifies how many bits can be transmitted / received in one transaction.
N * |        |          |The minimum bit length is 8 bits and can up to 32 bits.
N * |        |          |DWIDTH = 0x08 ... 8 bits.
N * |        |          |DWIDTH = 0x09 ... 9 bits.
N * |        |          |...
N * |        |          |DWIDTH = 0x1F ... 31 bits.
N * |        |          |DWIDTH = 0x00 ... 32 bits.
N * |[13]    |LSB       |Send LSB First
N * |        |          |0 = The MSB, which bit of transmit/receive register depends on the setting of DWIDTH, is transmitted/received first.
N * |        |          |1 = The LSB, bit 0 of the SPI TX register, is sent first to the SPI data output pin, and the first bit received from the SPI data input pin will be put in the LSB position of the RX register (bit 0 of SPI_RX).
N * |[16]    |TWOBIT    |2-Bit Transfer Mode Enable Bit (Only Supported in SPI0)
N * |        |          |0 = 2-Bit Transfer mode Disabled.
N * |        |          |1 = 2-Bit Transfer mode Enabled.
N * |        |          |Note: When 2-Bit Transfer mode is enabled, the first serial transmitted bit data is from the first FIFO buffer data, and the 2nd
N * |        |          |serial transmitted bit data is from the second FIFO buffer data.
N * |        |          |As the same as transmitted function, the first received bit data is stored into the first FIFO buffer and the 2nd received bit data is stored into the second FIFO buffer at the same time.
N * |[17]    |UNITIEN   |Unit Transfer Interrupt Enable Bit
N * |        |          |0 = SPI unit transfer interrupt Disabled.
N * |        |          |1 = SPI unit transfer interrupt Enabled.
N * |[18]    |SLAVE     |Slave Mode Control
N * |        |          |0 = Master mode.
N * |        |          |1 = Slave mode.
N * |[19]    |REORDER   |Byte Reorder Function Enable Bit
N * |        |          |0 = Byte Reorder function Disabled.
N * |        |          |1 = Byte Reorder function Enabled. A byte suspend interval will be inserted among each byte.
N * |        |          |The period of the byte suspend interval depends on the setting of SUSPITV.
N * |        |          |Note:
N * |        |          |1. Byte Reorder function is only available if DWIDTH is defined as 16, 24, and 32 bits.
N * |        |          |2. Byte Reorder function is not supported when the Quad or Dual I/O mode is enabled.
N * |[20]    |QDIODIR   |Quad Or Dual I/O Mode Direction Control (Only Supported in SPI0)
N * |        |          |0 = Quad or Dual Input mode.
N * |        |          |1 = Quad or Dual Output mode.
N * |[21]    |DUALIOEN  |Dual I/O Mode Enable Bit (Only Supported in SPI0)
N * |        |          |0 = Dual I/O mode Disabled.
N * |        |          |1 = Dual I/O mode Enabled.
N * |[22]    |QUADIOEN  |Quad I/O Mode Enable Bit (Only Supported in SPI0)
N * |        |          |0 = Quad I/O mode Disabled.
N * |        |          |1 = Quad I/O mode Enabled.
N * @var SPI_T::CLKDIV
N * Offset: 0x04  Clock Divider Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |DIVIDER   |Clock Divider
N * |        |          |The value in this field is the frequency divider for generating the peripheral clock, fspi_eclk, and the SPI bus clock of SPI master.
N * |        |          |The frequency is obtained according to the following equation.
N * |        |          | fspi_eclk = fspi_clock_src / (DIVIDER + 1)
N * |        |          |where fspi_clock_src is the peripheral clock source, which is defined in the clock control register CLK_CLKSEL2.
N * @var SPI_T::SSCTL
N * Offset: 0x08  Slave Select Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |SS        |Slave Selection Control (Master Only)
N * |        |          |If AUTOSS bit is cleared to 0,
N * |        |          |0 = set the SPIn_SS line to inactive state.
N * |        |          |1 = set the SPIn_SS line to active state
N * |        |          |If the AUTOSS bit is set to 1,
N * |        |          |0 = Keep the SPIn_SS line at inactive state.
N * |        |          |1 = SPIn_SS line will be automatically driven to active state for the duration of data transfer, and will be driven to inactive state for the rest of the time.
N * |        |          |The active state of SPIn_SS is specified in SSACTPOL (SPI_SSCTL[2]).
N * |[2]     |SSACTPOL  |Slave Selection Active Polarity
N * |        |          |This bit defines the active polarity of slave selection signal (SPIn_SS).
N * |        |          |0 = The slave selection signal SPIn_SS is active low.
N * |        |          |1 = The slave selection signal SPIn_SS is active high.
N * |[3]     |AUTOSS    |Automatic Slave Selection Function Enable Bit (Master Only)
N * |        |          |0 = Automatic slave selection function Disabled.
N * |        |          |Slave selection signal will be asserted/de-asserted according to SS (SPI_SSCTL[0]).
N * |        |          |1 = Automatic slave selection function Enabled.
N * |[4]     |SLV3WIRE  |Slave 3-Wire Mode Enable Bit
N * |        |          |Slave 3-wire mode is only available in SPI0.
N * |        |          |In Slave 3-wire mode, the SPI controller can work with 3-wire interface including SPI0_CLK, SPI0_MISO, and SPI0_MOSI.
N * |        |          |0 = 4-wire bi-direction interface.
N * |        |          |1 = 3-wire bi-direction interface.
N * |[5]     |SLVTOIEN  |Slave Mode Time-Out Interrupt Enable Bit (Only Supported in SPI0)
N * |        |          |0 = Slave mode time-out interrupt Disabled.
N * |        |          |1 = Slave mode time-out interrupt Enabled.
N * |[6]     |SLVTORST  |Slave Mode Time-Out Reset Control (Only Supported in SPI0)
N * |        |          |0 = When Slave mode time-out event occurs, the TX and RX control circuit will not be reset.
N * |        |          |1 = When Slave mode time-out event occurs, the TX and RX control circuit will be reset by hardware.
N * |[8]     |SLVBEIEN  |Slave Mode Bit Count Error Interrupt Enable Bit
N * |        |          |0 = Slave mode bit count error interrupt Disabled.
N * |        |          |1 = Slave mode bit count error interrupt Enabled.
N * |[9]     |SLVURIEN  |Slave Mode TX Under Run Interrupt Enable Bit
N * |        |          |0 = Slave mode TX under run interrupt Disabled.
N * |        |          |1 = Slave mode TX under run interrupt Enabled.
N * |[12]    |SSACTIEN  |Slave Select Active Interrupt Enable Bit
N * |        |          |0 = Slave select active interrupt Disabled.
N * |        |          |1 = Slave select active interrupt Enabled.
N * |[13]    |SSINAIEN  |Slave Select Inactive Interrupt Enable Bit
N * |        |          |0 = Slave select inactive interrupt Disabled.
N * |        |          |1 = Slave select inactive interrupt Enabled.
N * |[31:16] |SLVTOCNT  |Slave Mode Time-Out Period (Only Supported in SPI0)
N * |        |          |In Slave mode, these bits indicate the time-out period when there is bus clock input during slave select active.
N * |        |          |The clock source of the time-out counter is Slave peripheral clock.
N * |        |          |If the value is 0, it indicates the slave mode time-out function is disabled.
N * @var SPI_T::PDMACTL
N * Offset: 0x0C  SPI PDMA Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TXPDMAEN  |Transmit PDMA Enable Bit
N * |        |          |0 = Transmit PDMA function Disabled.
N * |        |          |1 = Transmit PDMA function Enabled.
N * |        |          |Note: In SPI master mode with full duplex transfer, if both TX and RX PDMA functions are enabled, RX PDMA function cannot be enabled prior to TX PDMA function.
N * |        |          |User can enable TX PDMA function firstly or enable both functions simultaneously.
N * |[1]     |RXPDMAEN  |Receive PDMA Enable Bit
N * |        |          |0 = Receiver PDMA function Disabled.
N * |        |          |1 = Receiver PDMA function Enabled.
N * |[2]     |PDMARST   |PDMA Reset
N * |        |          |0 = No effect.
N * |        |          |1 = Reset the PDMA control logic of the SPI controller. This bit will be automatically cleared to 0.
N * @var SPI_T::FIFOCTL
N * Offset: 0x10  SPI FIFO Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RXRST     |Receive Reset
N * |        |          |0 = No effect.
N * |        |          |1 = Reset receive FIFO pointer and receive circuit. The RXFULL bit will be cleared to 0 and the RXEMPTY bit will be set to 1.
N * |        |          |This bit will be cleared to 0 by hardware about 3 system clock cycles + 3 peripheral clock cycles after it is set to 1.
N * |        |          |User can read TXRXRST (SPI_STATUS[23]) to check if reset is accomplished or not.
N * |        |          |Note: If there is slave receive time-out event, the RXRST will be set 1 when the SLVTORST (SPI_SSCTL[6]) is enabled.
N * |[1]     |TXRST     |Transmit Reset
N * |        |          |0 = No effect.
N * |        |          |1 = Reset transmit FIFO pointer and transmit circuit. The TXFULL bit will be cleared to 0 and the TXEMPTY bit will be set to 1.
N * |        |          |This bit will be cleared to 0 by hardware about 3 system clock cycles + 3 peripheral clock cycles after it is set to 1.
N * |        |          |User can read TXRXRST (SPI_STATUS[23]) to check if reset is accomplished or not.
N * |        |          |Note: If there is slave receive time-out event, the TXRST will be set to 1 when the SLVTORST (SPI_SSCTL[6]) is enabled.
N * |[2]     |RXTHIEN   |Receive FIFO Threshold Interrupt Enable Bit
N * |        |          |0 = RX FIFO threshold interrupt Disabled.
N * |        |          |1 = RX FIFO threshold interrupt Enabled.
N * |[3]     |TXTHIEN   |Transmit FIFO Threshold Interrupt Enable Bit
N * |        |          |0 = TX FIFO threshold interrupt Disabled.
N * |        |          |1 = TX FIFO threshold interrupt Enabled.
N * |[4]     |RXTOIEN   |Slave Receive Time-Out Interrupt Enable Bit
N * |        |          |0 = Receive time-out interrupt Disabled.
N * |        |          |1 = Receive time-out interrupt Enabled.
N * |[5]     |RXOVIEN   |Receive FIFO Overrun Interrupt Enable Bit
N * |        |          |0 = Receive FIFO overrun interrupt Disabled.
N * |        |          |1 = Receive FIFO overrun interrupt Enabled.
N * |[6]     |TXUFPOL   |TX Underflow Data Polarity
N * |        |          |0 = The SPI data out is keep 0 if there is TX underflow event in Slave mode.
N * |        |          |1 = The SPI data out is keep 1 if there is TX underflow event in Slave mode.
N * |        |          |Note: The TX underflow event occurs if there is not any data in TX FIFO when the slave selection signal is active.
N * |[7]     |TXUFIEN   |TX Underflow Interrupt Enable Bit
N * |        |          |In Slave mode, when TX underflow event occurs, this interrupt flag will be set to 1.
N * |        |          |0 = Slave TX underflow interrupt Disabled.
N * |        |          |1 = Slave TX underflow interrupt Enabled.
N * |[8]     |RXFBCLR   |Receive FIFO Buffer Clear
N * |        |          |0 = No effect.
N * |        |          |1 = Clear receive FIFO pointer. The RXFULL bit will be cleared to 0 and the RXEMPTY bit will be set to 1.
N * |        |          |This bit will be cleared to 0 by hardware about 1 system clock after it is set to 1.
N * |        |          |Note: The RX shift register will not be cleared.
N * |[9]     |TXFBCLR   |Transmit FIFO Buffer Clear
N * |        |          |0 = No effect.
N * |        |          |1 = Clear transmit FIFO pointer. The TXFULL bit will be cleared to 0 and the TXEMPTY bit will be set to 1.
N * |        |          |This bit will be cleared to 0 by hardware about 1 system clock after it is set to 1.
N * |        |          |Note: The TX shift register will not be cleared.
N * |[26:24] |RXTH      |Receive FIFO Threshold
N * |        |          |If the valid data count of the receive FIFO buffer is larger than the RXTH setting, the RXTHIF bit will be set to 1, else the RXTHIF bit will be cleared to 0.
N * |        |          |In SPI0, RXTH is a 3-bit wide configuration; in SPI1 and SPI2, 2-bit wide only (SPI_FIFOCTL[25:24]).
N * |[30:28] |TXTH      |Transmit FIFO Threshold
N * |        |          |If the valid data count of the transmit FIFO buffer is less than or equal to the TXTH setting, the TXTHIF bit will be set to 1, else the TXTHIF bit will be cleared to 0.
N * |        |          |In SPI0, TXTH is a 3-bit wide configuration; in SPI1 and SPI2, 2-bit wide only (SPI_FIFOCTL[29:28]).
N * @var SPI_T::STATUS
N * Offset: 0x14  SPI Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |BUSY      |Busy Status (Read Only)
N * |        |          |0 = SPI controller is in idle state.
N * |        |          |1 = SPI controller is in busy state.
N * |        |          |The following listing are the bus busy conditions:
N * |        |          |a. SPI_CTL[0] = 1 and the TXEMPTY = 0.
N * |        |          |b. For SPI Master mode, the TXEMPTY = 1 but the current transaction is not finished yet.
N * |        |          |c. For SPI Slave mode, the SPI_CTL[0] = 1 and there is serial clock input into the SPI core logic when slave select is active.
N * |        |          |d. For SPI Slave mode, the SPI_CTL[0] = 1 and the transmit buffer or transmit shift register is not empty even if the slave select is inactive.
N * |[1]     |UNITIF    |Unit Transfer Interrupt Flag
N * |        |          |0 = No transaction has been finished since this bit was cleared to 0.
N * |        |          |1 = SPI controller has finished one unit transfer.
N * |        |          |Note: This bit will be cleared by writing 1 to it.
N * |[2]     |SSACTIF   |Slave Select Active Interrupt Flag
N * |        |          |0 = Slave select active interrupt was cleared or not occurred.
N * |        |          |1 = Slave select active interrupt event occurred.
N * |        |          |Note: Only available in Slave mode. This bit will be cleared by writing 1 to it.
N * |[3]     |SSINAIF   |Slave Select Inactive Interrupt Flag
N * |        |          |0 = Slave select inactive interrupt was cleared or not occurred.
N * |        |          |1 = Slave select inactive interrupt event occurred.
N * |        |          |Note: Only available in Slave mode. This bit will be cleared by writing 1 to it.
N * |[4]     |SSLINE    |Slave Select Line Bus Status (Read Only)
N * |        |          |0 = The slave select line status is 0.
N * |        |          |1 = The slave select line status is 1.
N * |        |          |Note: This bit is only available in Slave mode.
N * |        |          |If SSACTPOL (SPI_SSCTL[2]) is set 0, and the SSLINE is 1, the SPI slave select is in inactive status.
N * |[5]     |SLVTOIF   |Slave Time-Out Interrupt Flag (Only Supported in SPI0)
N * |        |          |When the Slave Select is active and the value of SLVTOCNT is not 0, as the bus clock is detected, the slave time-out counter in SPI controller logic will be started.
N * |        |          |When the value of time-out counter is greater than or equal to the value of SLVTOCNT (SPI_SSCTL[31:16]) before one transaction is done, the slave time-out interrupt event will be asserted.
N * |        |          |0 = Slave time-out is not active.
N * |        |          |1 = Slave time-out is active.
N * |        |          |Note: This bit will be cleared by writing 1 to it.
N * |[6]     |SLVBEIF   |Slave Mode Bit Count Error Interrupt Flag
N * |        |          |In Slave mode, when the slave select line goes to inactive state, if bit counter is mismatch with DWIDTH, this interrupt flag will be set to 1.
N * |        |          |0 = No Slave mode bit count error event.
N * |        |          |1 = Slave mode bit count error event occurs.
N * |        |          |Note: If the slave select active but there is no any bus clock input, the SLVBCEIF also active when the slave select goes to inactive state.
N * |        |          |This bit will be cleared by writing 1 to it.
N * |[7]     |SLVURIF   |Slave Mode TX Under Run Interrupt Flag
N * |        |          |In Slave mode, if TX underflow event occurs and the slave select line goes to inactive state, this interrupt flag will be set to 1.
N * |        |          |0 = No Slave TX under run event.
N * |        |          |1 = Slave TX under run occurs.
N * |        |          |Note: This bit will be cleared by writing 1 to it.
N * |[8]     |RXEMPTY   |Receive FIFO Buffer Empty Indicator (Read Only)
N * |        |          |0 = Receive FIFO buffer is not empty.
N * |        |          |1 = Receive FIFO buffer is empty.
N * |[9]     |RXFULL    |Receive FIFO Buffer Full Indicator (Read Only)
N * |        |          |0 = Receive FIFO buffer is not full.
N * |        |          |1 = Receive FIFO buffer is full.
N * |[10]    |RXTHIF    |Receive FIFO Threshold Interrupt Flag (Read Only)
N * |        |          |0 = The valid data count within the RX FIFO buffer is smaller than or equal to the setting value of RXTH.
N * |        |          |1 = The valid data count within the receive FIFO buffer is larger than the setting value of RXTH.
N * |[11]    |RXOVIF    |Receive FIFO Overrun Interrupt Flag
N * |        |          |When the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.
N * |        |          |0 = No FIFO is over run.
N * |        |          |1 = Receive FIFO over run.
N * |        |          |Note: This bit will be cleared by writing 1 to it.
N * |[12]    |RXTOIF    |Receive Time-Out Interrupt Flag
N * |        |          |0 = No receive FIFO time-out event.
N * |        |          |1 = Receive FIFO buffer is not empty and no read operation on receive FIFO buffer over 64 SPI clock period in Master mode or over 576 peripheral clock period in Slave mode.
N * |        |          |When the received FIFO buffer is read by software, the time-out status will be cleared automatically.
N * |        |          |Note: This bit will be cleared by writing 1 to it.
N * |[15]    |SPIENSTS  |SPI Enable Status (Read Only)
N * |        |          |0 = The SPI controller is disabled.
N * |        |          |1 = The SPI controller is enabled.
N * |        |          |Note: The SPI peripheral clock is asynchronous with the system clock.
N * |        |          |In order to make sure the SPI control logic is disabled, this bit indicates the real status of SPI controller.
N * |[16]    |TXEMPTY   |Transmit FIFO Buffer Empty Indicator (Read Only)
N * |        |          |0 = Transmit FIFO buffer is not empty.
N * |        |          |1 = Transmit FIFO buffer is empty.
N * |[17]    |TXFULL    |Transmit FIFO Buffer Full Indicator (Read Only)
N * |        |          |0 = Transmit FIFO buffer is not full.
N * |        |          |1 = Transmit FIFO buffer is full.
N * |[18]    |TXTHIF    |Transmit FIFO Threshold Interrupt Flag (Read Only)
N * |        |          |0 = The valid data count within the transmit FIFO buffer is larger than the setting value of TXTH.
N * |        |          |1 = The valid data count within the transmit FIFO buffer is less than or equal to the setting value of TXTH.
N * |[19]    |TXUFIF    |TX Underflow Interrupt Flag
N * |        |          |When the TX underflow event occurs, this bit will be set to 1, the state of data output pin depends on the setting of TXUFPOL.
N * |        |          |0 = No effect.
N * |        |          |1 = No data in Transmit FIFO and TX shift register when the slave selection signal is active.
N * |        |          |Note 1: This bit will be cleared by writing 1 to it.
N * |        |          |Note 2: If reset slave's transmission circuit when slave selection signal is active, this flag will be set to 1 after 2 peripheral clock cycles + 3 system clock cycles since the reset operation is done.
N * |[23]    |TXRXRST   |TX or RX Reset Status (Read Only)
N * |        |          |0 = The reset function of TXRST or RXRST is done.
N * |        |          |1 = Doing the reset function of TXRST or RXRST.
N * |        |          |Note: Both the reset operations of TXRST and RXRST need 3 system clock cycles + 2 peripheral clock cycles.
N * |        |          |User can check the status of this bit to monitor the reset function is doing or done.
N * |[27:24] |RXCNT     |Receive FIFO Data Count (Read Only)
N * |        |          |This bit field indicates the valid data count of receive FIFO buffer.
N * |[31:28] |TXCNT     |Transmit FIFO Data Count (Read Only)
N * |        |          |This bit field indicates the valid data count of transmit FIFO buffer.
N * @var SPI_T::TX
N * Offset: 0x20  Data Transmit Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |TX        |Data Transmit Register
N * |        |          |The data transmit registers pass through the transmitted data into the 8-/4-level transmit FIFO buffer.
N * |        |          |The number of valid bits depends on the setting of DWIDTH (SPI_CTL[12:8]).
N * |        |          |For example, if DWIDTH is set to 0x08, the bits TX[7:0] will be transmitted.
N * |        |          |If DWIDTH is set to 0x00, the SPI controller will perform a 32-bit transfer.
N * |        |          |Note: In Master mode, SPI controller will start to transfer after 5 peripheral clock cycles after user writes to this register.
N * @var SPI_T::RX
N * Offset: 0x30  Data Receive Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |RX        |Data Receive Register
N * |        |          |There are 8-/4-level FIFO buffers in this controller.
N * |        |          |The data receive register holds the data received from SPI data input pin.
N * |        |          |If the RXEMPTY (SPI_STATUS[8]) is not set to 1, the receive FIFO buffers can be accessed through software by reading this register.
N * |        |          |This is a read only register.
N * @var SPI_T::I2SCTL
N * Offset: 0x60  I2S Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |I2SEN     |I2S Controller Enable Bit
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |        |          |Note: If enable this bit, I2Sn_BCLK will start to output in master mode.
N * |[1]     |TXEN      |Transmit Enable Bit
N * |        |          |0 = Data transmit Disabled.
N * |        |          |1 = Data transmit Enabled.
N * |[2]     |RXEN      |Receive Enable Bit
N * |        |          |0 = Data receiving Disabled.
N * |        |          |1 = Data receiving Enabled.
N * |[3]     |MUTE      |Transmit Mute Enable Bit
N * |        |          |0 = Transmit data is shifted from buffer.
N * |        |          |1= Transmit channel zero.
N * |[5:4]   |WDWIDTH   |Word Width
N * |        |          |00 = data is 8-bit.
N * |        |          |01 = data is 16-bit.
N * |        |          |10 = data is 24-bit.
N * |        |          |11 = data is 32-bit.
N * |[6]     |MONO      |Monaural Data
N * |        |          |0 = Data is stereo format.
N * |        |          |1 = Data is monaural format.
N * |[7]     |ORDER     |Stereo Data Order In FIFO
N * |        |          |0 = Left channel data at high byte.
N * |        |          |1 = Left channel data at low byte.
N * |[8]     |SLAVE     |Slave Mode
N * |        |          |I2S can operate as master or slave.
N * |        |          |For Master mode, I2Sn_BCLK and I2Sn_LRCLK pins are output mode and send bit clock from NuMicro M451 series to Audio CODEC chip.
N * |        |          |In Slave mode, I2Sn_BCLK and I2Sn_LRCLK pins are input mode and I2Sn_BCLK and I2Sn_LRCLK signals are received from outer Audio CODEC chip.
N * |        |          |0 = Master mode.
N * |        |          |1 = Slave mode.
N * |[15]    |MCLKEN    |Master Clock Enable Bit
N * |        |          |If MCLKEN is set to 1, I2S controller will generate master clock on I2Sn_MCLK pin for external audio devices.
N * |        |          |0 = Master clock Disabled.
N * |        |          |1 = Master clock Enabled.
N * |[16]    |RZCEN     |Right Channel Zero Cross Detection Enable Bit
N * |        |          |If this bit is set to 1, when right channel data sign bit change or next shift data bits are all 0 then RZCIF flag in SPI_I2SSTS register is set to 1.
N * |        |          |This function is only available in transmit operation.
N * |        |          |0 = Right channel zero cross detection Disabled.
N * |        |          |1 = Right channel zero cross detection Enabled.
N * |[17]    |LZCEN     |Left Channel Zero Cross Detection Enable Bit
N * |        |          |If this bit is set to 1, when left channel data sign bit changes or next shift data bits are all 0 then LZCIF flag in SPI_I2SSTS register is set to 1.
N * |        |          |This function is only available in transmit operation.
N * |        |          |0 = Left channel zero cross detection Disabled.
N * |        |          |1 = Left channel zero cross detection Enabled.
N * |[23]    |RXLCH     |Receive Left Channel Enable Bit
N * |        |          |When monaural format is selected (MONO = 1), I2S controller will receive right channel data if RXLCH is set to 0, and receive left channel data if RXLCH is set to 1.
N * |        |          |0 = Receive right channel data in Mono mode.
N * |        |          |1 = Receive left channel data in Mono mode.
N * |[24]    |RZCIEN    |Right Channel Zero-Cross Interrupt Enable Bit
N * |        |          |Interrupt occurs if this bit is set to 1 and right channel zero-cross event occurs.
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |[25]    |LZCIEN    |Left Channel Zero-Cross Interrupt Enable Bit
N * |        |          |Interrupt occurs if this bit is set to 1 and left channel zero-cross event occurs.
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |[29:28] |FORMAT    |Data Format Selection
N * |        |          |00 = I2S data format.
N * |        |          |01 = MSB justified data format.
N * |        |          |10 = PCM mode A.
N * |        |          |11 = PCM mode B.
N * @var SPI_T::I2SCLK
N * Offset: 0x64  I2S Clock Divider Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |MCLKDIV   |Master Clock Divider
N * |        |          |If MCLKEN is set to 1, I2S controller will generate master clock for external audio devices.
N * |        |          |The master clock rate, F_MCLK, is determined by the following expressions.
N * |        |          |If MCLKDIV >= 1, F_MCLK = F_I2SCLK/(2x(MCLKDIV)).
N * |        |          |If MCLKDIV = 0, F_MCLK = F_I2SCLK.
N * |        |          |F_I2SCLK is the frequency of I2S peripheral clock.
N * |        |          |In general, the master clock rate is 256 times sampling clock rate.
N * |[16:8]  |BCLKDIV   |Bit Clock Divider
N * |        |          |The I2S controller will generate bit clock in Master mode.
N * |        |          |The bit clock rate, F_BCLK, is determined by the following expression.
N * |        |          |F_BCLK = F_I2SCLK /(2x(BCLKDIV + 1)) , where F_I2SCLK is the frequency of I2S peripheral clock.
N * @var SPI_T::I2SSTS
N * Offset: 0x68  I2S Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[4]     |RIGHT     |Right Channel (Read Only)
N * |        |          |This bit indicates the current transmit data is belong to which channel.
N * |        |          |0 = Left channel.
N * |        |          |1 = Right channel.
N * |[8]     |RXEMPTY   |Receive FIFO Buffer Empty Indicator (Read Only)
N * |        |          |0 = Receive FIFO buffer is not empty.
N * |        |          |1 = Receive FIFO buffer is empty.
N * |[9]     |RXFULL    |Receive FIFO Buffer Full Indicator (Read Only)
N * |        |          |0 = Receive FIFO buffer is not full.
N * |        |          |1 = Receive FIFO buffer is full.
N * |[10]    |RXTHIF    |Receive FIFO Threshold Interrupt Flag (Read Only)
N * |        |          |0 = The valid data count within the Rx FIFO buffer is smaller than or equal to the setting value of RXTH.
N * |        |          |1 = The valid data count within the receive FIFO buffer is larger than the setting value of RXTH.
N * |        |          |Note: If RXTHIEN = 1 and RXTHIF = 1, the SPI/I2S controller will generate a SPI interrupt request.
N * |[11]    |RXOVIF    |Receive FIFO Overrun Interrupt Flag
N * |        |          |When the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.
N * |        |          |Note: This bit will be cleared by writing 1 to it.
N * |[12]    |RXTOIF    |Receive Time-Out Interrupt Flag
N * |        |          |0 = No receive FIFO time-out event.
N * |        |          |1 = Receive FIFO buffer is not empty and no read operation on receive FIFO buffer over 64 SPI clock period in Master mode or over 576 peripheral clock period in Slave mode.
N * |        |          |When the received FIFO buffer is read by software, the time-out status will be cleared automatically.
N * |        |          |Note: This bit will be cleared by writing 1 to it.
N * |[15]    |I2SENSTS  |I2S Enable Status (Read Only)
N * |        |          |0 = The SPI/I2S control logic is disabled.
N * |        |          |1 = The SPI/I2S control logic is enabled.
N * |        |          |Note: The SPI peripheral clock is asynchronous with the system clock.
N * |        |          |In order to make sure the SPI/I2S controller logic is disabled, this bit indicates the real status of SPI/I2S controller logic for user.
N * |[16]    |TXEMPTY   |Transmit FIFO Buffer Empty Indicator (Read Only)
N * |        |          |0 = Transmit FIFO buffer is not empty.
N * |        |          |1 = Transmit FIFO buffer is empty.
N * |[17]    |TXFULL    |Transmit FIFO Buffer Full Indicator (Read Only)
N * |        |          |0 = Transmit FIFO buffer is not full.
N * |        |          |1 = Transmit FIFO buffer is full.
N * |[18]    |TXTHIF    |Transmit FIFO Threshold Interrupt Flag (Read Only)
N * |        |          |0 = The valid data count within the transmit FIFO buffer is larger than the setting value of TXTH.
N * |        |          |1 = The valid data count within the transmit FIFO buffer is less than or equal to the setting value of TXTH.
N * |        |          |Note: If TXTHIEN = 1 and TXTHIF = 1, the SPI controller will generate a SPI interrupt request.
N * |[19]    |TXUFIF    |Transmit FIFO Underflow Interrupt Flag
N * |        |          |When the transmit FIFO buffer is empty and there is no datum written into the FIFO buffer, if there is more bus clock input,
N * |        |          | the output data depends on the setting of TXUFPOL and this bit will be set to 1.
N * |        |          |Note: This bit will be cleared by writing 1 to it.
N * |[20]    |RZCIF     |Right Channel Zero Cross Interrupt Flag
N * |        |          |0 = No zero cross event occurred on right channel.
N * |        |          |1 = Zero cross event occurred on right channel.
N * |[21]    |LZCIF     |Left Channel Zero Cross Interrupt Flag
N * |        |          |0 = No zero cross event occurred on left channel.
N * |        |          |1 = Zero cross event occurred on left channel.
N * |[23]    |TXRXRST   |TX or RX Reset Status (Read Only)
N * |        |          |0 = The reset function of TXRST or RXRST is done.
N * |        |          |1 = Doing the reset function of TXRST or RXRST.
N * |        |          |Note: Both the reset operations of TXRST and RXRST need 3 system clock cycles + 3 peripheral clock cycles.
N * |        |          |User can check the status of this bit to monitor the reset function is doing or done.
N * |[26:24] |RXCNT     |Receive FIFO Data Count (Read Only)
N * |        |          |This bit field indicates the valid data count of receive FIFO buffer.
N * |[30:28] |TXCNT     |Transmit FIFO Data Count (Read Only)
N * |        |          |This bit field indicates the valid data count of transmit FIFO buffer.
N */
N
N    __IO uint32_t CTL;           /* Offset: 0x00  Control Register                                                   */
X    volatile uint32_t CTL;            
N    __IO uint32_t CLKDIV;        /* Offset: 0x04  Clock Divider Register                                             */
X    volatile uint32_t CLKDIV;         
N    __IO uint32_t SSCTL;         /* Offset: 0x08  Slave Select Control Register                                      */
X    volatile uint32_t SSCTL;          
N    __IO uint32_t PDMACTL;       /* Offset: 0x0C  SPI PDMA Control Register                                          */
X    volatile uint32_t PDMACTL;        
N    __IO uint32_t FIFOCTL;       /* Offset: 0x10  SPI FIFO Control Register                                          */
X    volatile uint32_t FIFOCTL;        
N    __IO uint32_t STATUS;        /* Offset: 0x14  SPI Status Register                                                */
X    volatile uint32_t STATUS;         
N    __I  uint32_t RESERVE0[2];  
X    volatile const  uint32_t RESERVE0[2];  
N    __O  uint32_t TX;            /* Offset: 0x20  Data Transmit Register                                             */
X    volatile  uint32_t TX;             
N    __I  uint32_t RESERVE1[3];  
X    volatile const  uint32_t RESERVE1[3];  
N    __I  uint32_t RX;            /* Offset: 0x30  Data Receive Register                                              */
X    volatile const  uint32_t RX;             
N    __I  uint32_t RESERVE2[11]; 
X    volatile const  uint32_t RESERVE2[11]; 
N    __IO uint32_t I2SCTL;        /* Offset: 0x60  I2S Control Register                                               */
X    volatile uint32_t I2SCTL;         
N    __IO uint32_t I2SCLK;        /* Offset: 0x64  I2S Clock Divider Control Register                                 */
X    volatile uint32_t I2SCLK;         
N    __IO uint32_t I2SSTS;        /* Offset: 0x68  I2S Status Register                                                */
X    volatile uint32_t I2SSTS;         
N
N} SPI_T;
N
N
N
N/**
N    @addtogroup SPI_CONST SPI Bit Field Definition
N    Constant Definitions for SPI Controller
N@{ */
N
N#define SPI_CTL_SPIEN_Pos                (0)                                               /*!< SPI_T::CTL: SPIEN Position                */
N#define SPI_CTL_SPIEN_Msk                (0x1ul << SPI_CTL_SPIEN_Pos)                      /*!< SPI_T::CTL: SPIEN Mask                    */
N
N#define SPI_CTL_RXNEG_Pos                (1)                                               /*!< SPI_T::CTL: RXNEG Position                */
N#define SPI_CTL_RXNEG_Msk                (0x1ul << SPI_CTL_RXNEG_Pos)                      /*!< SPI_T::CTL: RXNEG Mask                    */
N
N#define SPI_CTL_TXNEG_Pos                (2)                                               /*!< SPI_T::CTL: TXNEG Position                */
N#define SPI_CTL_TXNEG_Msk                (0x1ul << SPI_CTL_TXNEG_Pos)                      /*!< SPI_T::CTL: TXNEG Mask                    */
N
N#define SPI_CTL_CLKPOL_Pos               (3)                                               /*!< SPI_T::CTL: CLKPOL Position               */
N#define SPI_CTL_CLKPOL_Msk               (0x1ul << SPI_CTL_CLKPOL_Pos)                     /*!< SPI_T::CTL: CLKPOL Mask                   */
N
N#define SPI_CTL_SUSPITV_Pos              (4)                                               /*!< SPI_T::CTL: SUSPITV Position              */
N#define SPI_CTL_SUSPITV_Msk              (0xful << SPI_CTL_SUSPITV_Pos)                    /*!< SPI_T::CTL: SUSPITV Mask                  */
N
N#define SPI_CTL_DWIDTH_Pos               (8)                                               /*!< SPI_T::CTL: DWIDTH Position               */
N#define SPI_CTL_DWIDTH_Msk               (0x1ful << SPI_CTL_DWIDTH_Pos)                    /*!< SPI_T::CTL: DWIDTH Mask                   */
N
N#define SPI_CTL_LSB_Pos                  (13)                                              /*!< SPI_T::CTL: LSB Position                  */
N#define SPI_CTL_LSB_Msk                  (0x1ul << SPI_CTL_LSB_Pos)                        /*!< SPI_T::CTL: LSB Mask                      */
N
N#define SPI_CTL_TWOBIT_Pos               (16)                                              /*!< SPI_T::CTL: TWOBIT Position               */
N#define SPI_CTL_TWOBIT_Msk               (0x1ul << SPI_CTL_TWOBIT_Pos)                     /*!< SPI_T::CTL: TWOBIT Mask                   */
N
N#define SPI_CTL_UNITIEN_Pos              (17)                                              /*!< SPI_T::CTL: UNITIEN Position              */
N#define SPI_CTL_UNITIEN_Msk              (0x1ul << SPI_CTL_UNITIEN_Pos)                    /*!< SPI_T::CTL: UNITIEN Mask                  */
N
N#define SPI_CTL_SLAVE_Pos                (18)                                              /*!< SPI_T::CTL: SLAVE Position                */
N#define SPI_CTL_SLAVE_Msk                (0x1ul << SPI_CTL_SLAVE_Pos)                      /*!< SPI_T::CTL: SLAVE Mask                    */
N
N#define SPI_CTL_REORDER_Pos              (19)                                              /*!< SPI_T::CTL: REORDER Position              */
N#define SPI_CTL_REORDER_Msk              (0x1ul << SPI_CTL_REORDER_Pos)                    /*!< SPI_T::CTL: REORDER Mask                  */
N
N#define SPI_CTL_QDIODIR_Pos              (20)                                              /*!< SPI_T::CTL: QDIODIR Position              */
N#define SPI_CTL_QDIODIR_Msk              (0x1ul << SPI_CTL_QDIODIR_Pos)                    /*!< SPI_T::CTL: QDIODIR Mask                  */
N
N#define SPI_CTL_DUALIOEN_Pos             (21)                                              /*!< SPI_T::CTL: DUALIOEN Position             */
N#define SPI_CTL_DUALIOEN_Msk             (0x1ul << SPI_CTL_DUALIOEN_Pos)                   /*!< SPI_T::CTL: DUALIOEN Mask                 */
N
N#define SPI_CTL_QUADIOEN_Pos             (22)                                              /*!< SPI_T::CTL: QUADIOEN Position             */
N#define SPI_CTL_QUADIOEN_Msk             (0x1ul << SPI_CTL_QUADIOEN_Pos)                   /*!< SPI_T::CTL: QUADIOEN Mask                 */
N
N#define SPI_CLKDIV_DIVIDER_Pos           (0)                                               /*!< SPI_T::CLKDIV: DIVIDER Position           */
N#define SPI_CLKDIV_DIVIDER_Msk           (0xfful << SPI_CLKDIV_DIVIDER_Pos)                /*!< SPI_T::CLKDIV: DIVIDER Mask               */
N
N#define SPI_SSCTL_SS_Pos                 (0)                                               /*!< SPI_T::SSCTL: SS Position                 */
N#define SPI_SSCTL_SS_Msk                 (0x1ul << SPI_SSCTL_SS_Pos)                       /*!< SPI_T::SSCTL: SS Mask                     */
N
N#define SPI_SSCTL_SSACTPOL_Pos           (2)                                               /*!< SPI_T::SSCTL: SSACTPOL Position           */
N#define SPI_SSCTL_SSACTPOL_Msk           (0x1ul << SPI_SSCTL_SSACTPOL_Pos)                 /*!< SPI_T::SSCTL: SSACTPOL Mask               */
N
N#define SPI_SSCTL_AUTOSS_Pos             (3)                                               /*!< SPI_T::SSCTL: AUTOSS Position             */
N#define SPI_SSCTL_AUTOSS_Msk             (0x1ul << SPI_SSCTL_AUTOSS_Pos)                   /*!< SPI_T::SSCTL: AUTOSS Mask                 */
N
N#define SPI_SSCTL_SLV3WIRE_Pos           (4)                                               /*!< SPI_T::SSCTL: SLV3WIRE Position           */
N#define SPI_SSCTL_SLV3WIRE_Msk           (0x1ul << SPI_SSCTL_SLV3WIRE_Pos)                 /*!< SPI_T::SSCTL: SLV3WIRE Mask               */
N
N#define SPI_SSCTL_SLVTOIEN_Pos           (5)                                               /*!< SPI_T::SSCTL: SLVTOIEN Position           */
N#define SPI_SSCTL_SLVTOIEN_Msk           (0x1ul << SPI_SSCTL_SLVTOIEN_Pos)                 /*!< SPI_T::SSCTL: SLVTOIEN Mask               */
N
N#define SPI_SSCTL_SLVTORST_Pos           (6)                                               /*!< SPI_T::SSCTL: SLVTORST Position           */
N#define SPI_SSCTL_SLVTORST_Msk           (0x1ul << SPI_SSCTL_SLVTORST_Pos)                 /*!< SPI_T::SSCTL: SLVTORST Mask               */
N
N#define SPI_SSCTL_SLVBEIEN_Pos           (8)                                               /*!< SPI_T::SSCTL: SLVBEIEN Position           */
N#define SPI_SSCTL_SLVBEIEN_Msk           (0x1ul << SPI_SSCTL_SLVBEIEN_Pos)                 /*!< SPI_T::SSCTL: SLVBEIEN Mask               */
N
N#define SPI_SSCTL_SLVURIEN_Pos           (9)                                               /*!< SPI_T::SSCTL: SLVURIEN Position           */
N#define SPI_SSCTL_SLVURIEN_Msk           (0x1ul << SPI_SSCTL_SLVURIEN_Pos)                 /*!< SPI_T::SSCTL: SLVURIEN Mask               */
N
N#define SPI_SSCTL_SSACTIEN_Pos           (12)                                              /*!< SPI_T::SSCTL: SSACTIEN Position           */
N#define SPI_SSCTL_SSACTIEN_Msk           (0x1ul << SPI_SSCTL_SSACTIEN_Pos)                 /*!< SPI_T::SSCTL: SSACTIEN Mask               */
N
N#define SPI_SSCTL_SSINAIEN_Pos           (13)                                              /*!< SPI_T::SSCTL: SSINAIEN Position           */
N#define SPI_SSCTL_SSINAIEN_Msk           (0x1ul << SPI_SSCTL_SSINAIEN_Pos)                 /*!< SPI_T::SSCTL: SSINAIEN Mask               */
N
N#define SPI_SSCTL_SLVTOCNT_Pos           (16)                                              /*!< SPI_T::SSCTL: SLVTOCNT Position           */
N#define SPI_SSCTL_SLVTOCNT_Msk           (0xfffful << SPI_SSCTL_SLVTOCNT_Pos)              /*!< SPI_T::SSCTL: SLVTOCNT Mask               */
N
N#define SPI_PDMACTL_TXPDMAEN_Pos         (0)                                               /*!< SPI_T::PDMACTL: TXPDMAEN Position         */
N#define SPI_PDMACTL_TXPDMAEN_Msk         (0x1ul << SPI_PDMACTL_TXPDMAEN_Pos)               /*!< SPI_T::PDMACTL: TXPDMAEN Mask             */
N
N#define SPI_PDMACTL_RXPDMAEN_Pos         (1)                                               /*!< SPI_T::PDMACTL: RXPDMAEN Position         */
N#define SPI_PDMACTL_RXPDMAEN_Msk         (0x1ul << SPI_PDMACTL_RXPDMAEN_Pos)               /*!< SPI_T::PDMACTL: RXPDMAEN Mask             */
N
N#define SPI_PDMACTL_PDMARST_Pos          (2)                                               /*!< SPI_T::PDMACTL: PDMARST Position          */
N#define SPI_PDMACTL_PDMARST_Msk          (0x1ul << SPI_PDMACTL_PDMARST_Pos)                /*!< SPI_T::PDMACTL: PDMARST Mask              */
N
N#define SPI_FIFOCTL_RXRST_Pos            (0)                                               /*!< SPI_T::FIFOCTL: RXRST Position            */
N#define SPI_FIFOCTL_RXRST_Msk            (0x1ul << SPI_FIFOCTL_RXRST_Pos)                  /*!< SPI_T::FIFOCTL: RXRST Mask                */
N
N#define SPI_FIFOCTL_TXRST_Pos            (1)                                               /*!< SPI_T::FIFOCTL: TXRST Position            */
N#define SPI_FIFOCTL_TXRST_Msk            (0x1ul << SPI_FIFOCTL_TXRST_Pos)                  /*!< SPI_T::FIFOCTL: TXRST Mask                */
N
N#define SPI_FIFOCTL_RXTHIEN_Pos          (2)                                               /*!< SPI_T::FIFOCTL: RXTHIEN Position          */
N#define SPI_FIFOCTL_RXTHIEN_Msk          (0x1ul << SPI_FIFOCTL_RXTHIEN_Pos)                /*!< SPI_T::FIFOCTL: RXTHIEN Mask              */
N
N#define SPI_FIFOCTL_TXTHIEN_Pos          (3)                                               /*!< SPI_T::FIFOCTL: TXTHIEN Position          */
N#define SPI_FIFOCTL_TXTHIEN_Msk          (0x1ul << SPI_FIFOCTL_TXTHIEN_Pos)                /*!< SPI_T::FIFOCTL: TXTHIEN Mask              */
N
N#define SPI_FIFOCTL_RXTOIEN_Pos          (4)                                               /*!< SPI_T::FIFOCTL: RXTOIEN Position          */
N#define SPI_FIFOCTL_RXTOIEN_Msk          (0x1ul << SPI_FIFOCTL_RXTOIEN_Pos)                /*!< SPI_T::FIFOCTL: RXTOIEN Mask              */
N
N#define SPI_FIFOCTL_RXOVIEN_Pos          (5)                                               /*!< SPI_T::FIFOCTL: RXOVIEN Position          */
N#define SPI_FIFOCTL_RXOVIEN_Msk          (0x1ul << SPI_FIFOCTL_RXOVIEN_Pos)                /*!< SPI_T::FIFOCTL: RXOVIEN Mask              */
N
N#define SPI_FIFOCTL_TXUFPOL_Pos          (6)                                               /*!< SPI_T::FIFOCTL: TXUFPOL Position          */
N#define SPI_FIFOCTL_TXUFPOL_Msk          (0x1ul << SPI_FIFOCTL_TXUFPOL_Pos)                /*!< SPI_T::FIFOCTL: TXUFPOL Mask              */
N
N#define SPI_FIFOCTL_TXUFIEN_Pos          (7)                                               /*!< SPI_T::FIFOCTL: TXUFIEN Position          */
N#define SPI_FIFOCTL_TXUFIEN_Msk          (0x1ul << SPI_FIFOCTL_TXUFIEN_Pos)                /*!< SPI_T::FIFOCTL: TXUFIEN Mask              */
N
N#define SPI_FIFOCTL_RXFBCLR_Pos          (8)                                               /*!< SPI_T::FIFOCTL: RXFBCLR Position          */
N#define SPI_FIFOCTL_RXFBCLR_Msk          (0x1ul << SPI_FIFOCTL_RXFBCLR_Pos)                /*!< SPI_T::FIFOCTL: RXFBCLR Mask              */
N
N#define SPI_FIFOCTL_TXFBCLR_Pos          (9)                                               /*!< SPI_T::FIFOCTL: TXFBCLR Position          */
N#define SPI_FIFOCTL_TXFBCLR_Msk          (0x1ul << SPI_FIFOCTL_TXFBCLR_Pos)                /*!< SPI_T::FIFOCTL: TXFBCLR Mask              */
N
N#define SPI_FIFOCTL_RXTH_Pos             (24)                                              /*!< SPI_T::FIFOCTL: RXTH Position             */
N#define SPI_FIFOCTL_RXTH_Msk             (0x7ul << SPI_FIFOCTL_RXTH_Pos)                   /*!< SPI_T::FIFOCTL: RXTH Mask                 */
N
N#define SPI_FIFOCTL_TXTH_Pos             (28)                                              /*!< SPI_T::FIFOCTL: TXTH Position             */
N#define SPI_FIFOCTL_TXTH_Msk             (0x7ul << SPI_FIFOCTL_TXTH_Pos)                   /*!< SPI_T::FIFOCTL: TXTH Mask                 */
N
N#define SPI_STATUS_BUSY_Pos              (0)                                               /*!< SPI_T::STATUS: BUSY Position              */
N#define SPI_STATUS_BUSY_Msk              (0x1ul << SPI_STATUS_BUSY_Pos)                    /*!< SPI_T::STATUS: BUSY Mask                  */
N
N#define SPI_STATUS_UNITIF_Pos            (1)                                               /*!< SPI_T::STATUS: UNITIF Position            */
N#define SPI_STATUS_UNITIF_Msk            (0x1ul << SPI_STATUS_UNITIF_Pos)                  /*!< SPI_T::STATUS: UNITIF Mask                */
N
N#define SPI_STATUS_SSACTIF_Pos           (2)                                               /*!< SPI_T::STATUS: SSACTIF Position           */
N#define SPI_STATUS_SSACTIF_Msk           (0x1ul << SPI_STATUS_SSACTIF_Pos)                 /*!< SPI_T::STATUS: SSACTIF Mask               */
N
N#define SPI_STATUS_SSINAIF_Pos           (3)                                               /*!< SPI_T::STATUS: SSINAIF Position           */
N#define SPI_STATUS_SSINAIF_Msk           (0x1ul << SPI_STATUS_SSINAIF_Pos)                 /*!< SPI_T::STATUS: SSINAIF Mask               */
N
N#define SPI_STATUS_SSLINE_Pos            (4)                                               /*!< SPI_T::STATUS: SSLINE Position            */
N#define SPI_STATUS_SSLINE_Msk            (0x1ul << SPI_STATUS_SSLINE_Pos)                  /*!< SPI_T::STATUS: SSLINE Mask                */
N
N#define SPI_STATUS_SLVTOIF_Pos           (5)                                               /*!< SPI_T::STATUS: SLVTOIF Position           */
N#define SPI_STATUS_SLVTOIF_Msk           (0x1ul << SPI_STATUS_SLVTOIF_Pos)                 /*!< SPI_T::STATUS: SLVTOIF Mask               */
N
N#define SPI_STATUS_SLVBEIF_Pos           (6)                                               /*!< SPI_T::STATUS: SLVBEIF Position           */
N#define SPI_STATUS_SLVBEIF_Msk           (0x1ul << SPI_STATUS_SLVBEIF_Pos)                 /*!< SPI_T::STATUS: SLVBEIF Mask               */
N
N#define SPI_STATUS_SLVURIF_Pos           (7)                                               /*!< SPI_T::STATUS: SLVURIF Position           */
N#define SPI_STATUS_SLVURIF_Msk           (0x1ul << SPI_STATUS_SLVURIF_Pos)                 /*!< SPI_T::STATUS: SLVURIF Mask               */
N
N#define SPI_STATUS_RXEMPTY_Pos           (8)                                               /*!< SPI_T::STATUS: RXEMPTY Position           */
N#define SPI_STATUS_RXEMPTY_Msk           (0x1ul << SPI_STATUS_RXEMPTY_Pos)                 /*!< SPI_T::STATUS: RXEMPTY Mask               */
N
N#define SPI_STATUS_RXFULL_Pos            (9)                                               /*!< SPI_T::STATUS: RXFULL Position            */
N#define SPI_STATUS_RXFULL_Msk            (0x1ul << SPI_STATUS_RXFULL_Pos)                  /*!< SPI_T::STATUS: RXFULL Mask                */
N
N#define SPI_STATUS_RXTHIF_Pos            (10)                                              /*!< SPI_T::STATUS: RXTHIF Position            */
N#define SPI_STATUS_RXTHIF_Msk            (0x1ul << SPI_STATUS_RXTHIF_Pos)                  /*!< SPI_T::STATUS: RXTHIF Mask                */
N
N#define SPI_STATUS_RXOVIF_Pos            (11)                                              /*!< SPI_T::STATUS: RXOVIF Position            */
N#define SPI_STATUS_RXOVIF_Msk            (0x1ul << SPI_STATUS_RXOVIF_Pos)                  /*!< SPI_T::STATUS: RXOVIF Mask                */
N
N#define SPI_STATUS_RXTOIF_Pos            (12)                                              /*!< SPI_T::STATUS: RXTOIF Position            */
N#define SPI_STATUS_RXTOIF_Msk            (0x1ul << SPI_STATUS_RXTOIF_Pos)                  /*!< SPI_T::STATUS: RXTOIF Mask                */
N
N#define SPI_STATUS_SPIENSTS_Pos          (15)                                              /*!< SPI_T::STATUS: SPIENSTS Position          */
N#define SPI_STATUS_SPIENSTS_Msk          (0x1ul << SPI_STATUS_SPIENSTS_Pos)                /*!< SPI_T::STATUS: SPIENSTS Mask              */
N
N#define SPI_STATUS_TXEMPTY_Pos           (16)                                              /*!< SPI_T::STATUS: TXEMPTY Position           */
N#define SPI_STATUS_TXEMPTY_Msk           (0x1ul << SPI_STATUS_TXEMPTY_Pos)                 /*!< SPI_T::STATUS: TXEMPTY Mask               */
N
N#define SPI_STATUS_TXFULL_Pos            (17)                                              /*!< SPI_T::STATUS: TXFULL Position            */
N#define SPI_STATUS_TXFULL_Msk            (0x1ul << SPI_STATUS_TXFULL_Pos)                  /*!< SPI_T::STATUS: TXFULL Mask                */
N
N#define SPI_STATUS_TXTHIF_Pos            (18)                                              /*!< SPI_T::STATUS: TXTHIF Position            */
N#define SPI_STATUS_TXTHIF_Msk            (0x1ul << SPI_STATUS_TXTHIF_Pos)                  /*!< SPI_T::STATUS: TXTHIF Mask                */
N
N#define SPI_STATUS_TXUFIF_Pos            (19)                                              /*!< SPI_T::STATUS: TXUFIF Position            */
N#define SPI_STATUS_TXUFIF_Msk            (0x1ul << SPI_STATUS_TXUFIF_Pos)                  /*!< SPI_T::STATUS: TXUFIF Mask                */
N
N#define SPI_STATUS_TXRXRST_Pos           (23)                                              /*!< SPI_T::STATUS: TXRXRST Position           */
N#define SPI_STATUS_TXRXRST_Msk           (0x1ul << SPI_STATUS_TXRXRST_Pos)                 /*!< SPI_T::STATUS: TXRXRST Mask               */
N
N#define SPI_STATUS_RXCNT_Pos             (24)                                              /*!< SPI_T::STATUS: RXCNT Position             */
N#define SPI_STATUS_RXCNT_Msk             (0xful << SPI_STATUS_RXCNT_Pos)                   /*!< SPI_T::STATUS: RXCNT Mask                 */
N
N#define SPI_STATUS_TXCNT_Pos             (28)                                              /*!< SPI_T::STATUS: TXCNT Position             */
N#define SPI_STATUS_TXCNT_Msk             (0xful << SPI_STATUS_TXCNT_Pos)                   /*!< SPI_T::STATUS: TXCNT Mask                 */
N
N#define SPI_TX_TX_Pos                    (0)                                               /*!< SPI_T::TX: TX Position                    */
N#define SPI_TX_TX_Msk                    (0xfffffffful << SPI_TX_TX_Pos)                   /*!< SPI_T::TX: TX Mask                        */
N
N#define SPI_RX_RX_Pos                    (0)                                               /*!< SPI_T::RX: RX Position                    */
N#define SPI_RX_RX_Msk                    (0xfffffffful << SPI_RX_RX_Pos)                   /*!< SPI_T::RX: RX Mask                        */
N
N#define SPI_I2SCTL_I2SEN_Pos             (0)                                               /*!< SPI_T::I2SCTL: I2SEN Position             */
N#define SPI_I2SCTL_I2SEN_Msk             (0x1ul << SPI_I2SCTL_I2SEN_Pos)                   /*!< SPI_T::I2SCTL: I2SEN Mask                 */
N
N#define SPI_I2SCTL_TXEN_Pos              (1)                                               /*!< SPI_T::I2SCTL: TXEN Position              */
N#define SPI_I2SCTL_TXEN_Msk              (0x1ul << SPI_I2SCTL_TXEN_Pos)                    /*!< SPI_T::I2SCTL: TXEN Mask                  */
N
N#define SPI_I2SCTL_RXEN_Pos              (2)                                               /*!< SPI_T::I2SCTL: RXEN Position              */
N#define SPI_I2SCTL_RXEN_Msk              (0x1ul << SPI_I2SCTL_RXEN_Pos)                    /*!< SPI_T::I2SCTL: RXEN Mask                  */
N
N#define SPI_I2SCTL_MUTE_Pos              (3)                                               /*!< SPI_T::I2SCTL: MUTE Position              */
N#define SPI_I2SCTL_MUTE_Msk              (0x1ul << SPI_I2SCTL_MUTE_Pos)                    /*!< SPI_T::I2SCTL: MUTE Mask                  */
N
N#define SPI_I2SCTL_WDWIDTH_Pos           (4)                                               /*!< SPI_T::I2SCTL: WDWIDTH Position           */
N#define SPI_I2SCTL_WDWIDTH_Msk           (0x3ul << SPI_I2SCTL_WDWIDTH_Pos)                 /*!< SPI_T::I2SCTL: WDWIDTH Mask               */
N
N#define SPI_I2SCTL_MONO_Pos              (6)                                               /*!< SPI_T::I2SCTL: MONO Position              */
N#define SPI_I2SCTL_MONO_Msk              (0x1ul << SPI_I2SCTL_MONO_Pos)                    /*!< SPI_T::I2SCTL: MONO Mask                  */
N
N#define SPI_I2SCTL_ORDER_Pos             (7)                                               /*!< SPI_T::I2SCTL: ORDER Position             */
N#define SPI_I2SCTL_ORDER_Msk             (0x1ul << SPI_I2SCTL_ORDER_Pos)                   /*!< SPI_T::I2SCTL: ORDER Mask                 */
N
N#define SPI_I2SCTL_SLAVE_Pos             (8)                                               /*!< SPI_T::I2SCTL: SLAVE Position             */
N#define SPI_I2SCTL_SLAVE_Msk             (0x1ul << SPI_I2SCTL_SLAVE_Pos)                   /*!< SPI_T::I2SCTL: SLAVE Mask                 */
N
N#define SPI_I2SCTL_MCLKEN_Pos            (15)                                              /*!< SPI_T::I2SCTL: MCLKEN Position            */
N#define SPI_I2SCTL_MCLKEN_Msk            (0x1ul << SPI_I2SCTL_MCLKEN_Pos)                  /*!< SPI_T::I2SCTL: MCLKEN Mask                */
N
N#define SPI_I2SCTL_RZCEN_Pos             (16)                                              /*!< SPI_T::I2SCTL: RZCEN Position             */
N#define SPI_I2SCTL_RZCEN_Msk             (0x1ul << SPI_I2SCTL_RZCEN_Pos)                   /*!< SPI_T::I2SCTL: RZCEN Mask                 */
N
N#define SPI_I2SCTL_LZCEN_Pos             (17)                                              /*!< SPI_T::I2SCTL: LZCEN Position             */
N#define SPI_I2SCTL_LZCEN_Msk             (0x1ul << SPI_I2SCTL_LZCEN_Pos)                   /*!< SPI_T::I2SCTL: LZCEN Mask                 */
N
N#define SPI_I2SCTL_RXLCH_Pos             (23)                                              /*!< SPI_T::I2SCTL: RXLCH Position             */
N#define SPI_I2SCTL_RXLCH_Msk             (0x1ul << SPI_I2SCTL_RXLCH_Pos)                   /*!< SPI_T::I2SCTL: RXLCH Mask                 */
N
N#define SPI_I2SCTL_RZCIEN_Pos            (24)                                              /*!< SPI_T::I2SCTL: RZCIEN Position            */
N#define SPI_I2SCTL_RZCIEN_Msk            (0x1ul << SPI_I2SCTL_RZCIEN_Pos)                  /*!< SPI_T::I2SCTL: RZCIEN Mask                */
N
N#define SPI_I2SCTL_LZCIEN_Pos            (25)                                              /*!< SPI_T::I2SCTL: LZCIEN Position            */
N#define SPI_I2SCTL_LZCIEN_Msk            (0x1ul << SPI_I2SCTL_LZCIEN_Pos)                  /*!< SPI_T::I2SCTL: LZCIEN Mask                */
N
N#define SPI_I2SCTL_FORMAT_Pos            (28)                                              /*!< SPI_T::I2SCTL: FORMAT Position            */
N#define SPI_I2SCTL_FORMAT_Msk            (0x3ul << SPI_I2SCTL_FORMAT_Pos)                  /*!< SPI_T::I2SCTL: FORMAT Mask                */
N
N#define SPI_I2SCLK_MCLKDIV_Pos           (0)                                               /*!< SPI_T::I2SCLK: MCLKDIV Position           */
N#define SPI_I2SCLK_MCLKDIV_Msk           (0x3ful << SPI_I2SCLK_MCLKDIV_Pos)                /*!< SPI_T::I2SCLK: MCLKDIV Mask               */
N
N#define SPI_I2SCLK_BCLKDIV_Pos           (8)                                               /*!< SPI_T::I2SCLK: BCLKDIV Position           */
N#define SPI_I2SCLK_BCLKDIV_Msk           (0x1fful << SPI_I2SCLK_BCLKDIV_Pos)               /*!< SPI_T::I2SCLK: BCLKDIV Mask               */
N
N#define SPI_I2SSTS_RIGHT_Pos             (4)                                               /*!< SPI_T::I2SSTS: RIGHT Position             */
N#define SPI_I2SSTS_RIGHT_Msk             (0x1ul << SPI_I2SSTS_RIGHT_Pos)                   /*!< SPI_T::I2SSTS: RIGHT Mask                 */
N
N#define SPI_I2SSTS_RXEMPTY_Pos           (8)                                               /*!< SPI_T::I2SSTS: RXEMPTY Position           */
N#define SPI_I2SSTS_RXEMPTY_Msk           (0x1ul << SPI_I2SSTS_RXEMPTY_Pos)                 /*!< SPI_T::I2SSTS: RXEMPTY Mask               */
N
N#define SPI_I2SSTS_RXFULL_Pos            (9)                                               /*!< SPI_T::I2SSTS: RXFULL Position            */
N#define SPI_I2SSTS_RXFULL_Msk            (0x1ul << SPI_I2SSTS_RXFULL_Pos)                  /*!< SPI_T::I2SSTS: RXFULL Mask                */
N
N#define SPI_I2SSTS_RXTHIF_Pos            (10)                                              /*!< SPI_T::I2SSTS: RXTHIF Position            */
N#define SPI_I2SSTS_RXTHIF_Msk            (0x1ul << SPI_I2SSTS_RXTHIF_Pos)                  /*!< SPI_T::I2SSTS: RXTHIF Mask                */
N
N#define SPI_I2SSTS_RXOVIF_Pos            (11)                                              /*!< SPI_T::I2SSTS: RXOVIF Position            */
N#define SPI_I2SSTS_RXOVIF_Msk            (0x1ul << SPI_I2SSTS_RXOVIF_Pos)                  /*!< SPI_T::I2SSTS: RXOVIF Mask                */
N
N#define SPI_I2SSTS_RXTOIF_Pos            (12)                                              /*!< SPI_T::I2SSTS: RXTOIF Position            */
N#define SPI_I2SSTS_RXTOIF_Msk            (0x1ul << SPI_I2SSTS_RXTOIF_Pos)                  /*!< SPI_T::I2SSTS: RXTOIF Mask                */
N
N#define SPI_I2SSTS_I2SENSTS_Pos          (15)                                              /*!< SPI_T::I2SSTS: I2SENSTS Position          */
N#define SPI_I2SSTS_I2SENSTS_Msk          (0x1ul << SPI_I2SSTS_I2SENSTS_Pos)                /*!< SPI_T::I2SSTS: I2SENSTS Mask              */
N
N#define SPI_I2SSTS_TXEMPTY_Pos           (16)                                              /*!< SPI_T::I2SSTS: TXEMPTY Position           */
N#define SPI_I2SSTS_TXEMPTY_Msk           (0x1ul << SPI_I2SSTS_TXEMPTY_Pos)                 /*!< SPI_T::I2SSTS: TXEMPTY Mask               */
N
N#define SPI_I2SSTS_TXFULL_Pos            (17)                                              /*!< SPI_T::I2SSTS: TXFULL Position            */
N#define SPI_I2SSTS_TXFULL_Msk            (0x1ul << SPI_I2SSTS_TXFULL_Pos)                  /*!< SPI_T::I2SSTS: TXFULL Mask                */
N
N#define SPI_I2SSTS_TXTHIF_Pos            (18)                                              /*!< SPI_T::I2SSTS: TXTHIF Position            */
N#define SPI_I2SSTS_TXTHIF_Msk            (0x1ul << SPI_I2SSTS_TXTHIF_Pos)                  /*!< SPI_T::I2SSTS: TXTHIF Mask                */
N
N#define SPI_I2SSTS_TXUFIF_Pos            (19)                                              /*!< SPI_T::I2SSTS: TXUFIF Position            */
N#define SPI_I2SSTS_TXUFIF_Msk            (0x1ul << SPI_I2SSTS_TXUFIF_Pos)                  /*!< SPI_T::I2SSTS: TXUFIF Mask                */
N
N#define SPI_I2SSTS_RZCIF_Pos             (20)                                              /*!< SPI_T::I2SSTS: RZCIF Position             */
N#define SPI_I2SSTS_RZCIF_Msk             (0x1ul << SPI_I2SSTS_RZCIF_Pos)                   /*!< SPI_T::I2SSTS: RZCIF Mask                 */
N
N#define SPI_I2SSTS_LZCIF_Pos             (21)                                              /*!< SPI_T::I2SSTS: LZCIF Position             */
N#define SPI_I2SSTS_LZCIF_Msk             (0x1ul << SPI_I2SSTS_LZCIF_Pos)                   /*!< SPI_T::I2SSTS: LZCIF Mask                 */
N
N#define SPI_I2SSTS_TXRXRST_Pos           (23)                                              /*!< SPI_T::I2SSTS: TXRXRST Position           */
N#define SPI_I2SSTS_TXRXRST_Msk           (0x1ul << SPI_I2SSTS_TXRXRST_Pos)                 /*!< SPI_T::I2SSTS: TXRXRST Mask               */
N
N#define SPI_I2SSTS_RXCNT_Pos             (24)                                              /*!< SPI_T::I2SSTS: RXCNT Position             */
N#define SPI_I2SSTS_RXCNT_Msk             (0x7ul << SPI_I2SSTS_RXCNT_Pos)                   /*!< SPI_T::I2SSTS: RXCNT Mask                 */
N
N#define SPI_I2SSTS_TXCNT_Pos             (28)                                              /*!< SPI_T::I2SSTS: TXCNT Position             */
N#define SPI_I2SSTS_TXCNT_Msk             (0x7ul << SPI_I2SSTS_TXCNT_Pos)                   /*!< SPI_T::I2SSTS: TXCNT Mask                 */
N
N/**@}*/ /* SPI_CONST */
N/**@}*/ /* end of SPI register group */
N
N
N/*---------------------- System Manger Controller -------------------------*/
N/**
N    @addtogroup SYS System Manger Controller(SYS)
N    Memory Mapped Structure for SYS Controller
N@{ */
N
N
Ntypedef struct
N{
N
N/**
N * @var SYS_T::PDID
N * Offset: 0x00  Part Device Identification Number Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |PDID      |Part Device Identification Number (Read Only)
N * |        |          |This register reflects device part number code.
N * |        |          |Software can read this register to identify which device is used.
N * @var SYS_T::RSTSTS
N * Offset: 0x04  System Reset Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PORF      |POR Reset Flag
N * |        |          |The POR reset flag is set by the "Reset Signal" from the Power-On Reset (POR) Controller or bit CHIPRST (SYS_IPRST0[0]) to indicate the previous reset source.
N * |        |          |0 = No reset from POR or CHIPRST.
N * |        |          |1 = Power-On Reset (POR) or CHIPRST had issued the reset signal to reset the system.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[1]     |PINRF     |nRESET Pin Reset Flag
N * |        |          |The nRESET pin reset flag is set by the "Reset Signal" from the nRESET Pin to indicate the previous reset source.
N * |        |          |0 = No reset from nRESET pin.
N * |        |          |1 = Pin nRESET had issued the reset signal to reset the system.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[2]     |WDTRF     |WDT Reset Flag
N * |        |          |The WDT reset flag is set by the "Reset Signal" from the Watchdog Timer or Window Watchdog Timer to indicate the previous reset source.
N * |        |          |0 = No reset from watchdog timer or window watchdog timer.
N * |        |          |1 = The watchdog timer or window watchdog timer had issued the reset signal to reset the system.
N * |        |          |Note1:
N * |        |          |Write 1 to clear this bit to 0.
N * |        |          |Note2: Watchdog Timer register RSTF(WDT_CTL[2]) bit is set if the system has been reset by WDT time-out reset.
N * |        |          |Window Watchdog Timer register WWDTRF(WWDT_STATUS[1]) bit is set if the system has been reset by WWDT time-out reset.
N * |[3]     |LVRF      |LVR Reset Flag
N * |        |          |The LVR reset flag is set by the "Reset Signal" from the Low-Voltage-Reset Controller to indicate the previous reset source.
N * |        |          |0 = No reset from LVR.
N * |        |          |1 = LVR controller had issued the reset signal to reset the system.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[4]     |BODRF     |BOD Reset Flag
N * |        |          |The BOD reset flag is set by the "Reset Signal" from the Brown-Out-Detector to indicate the previous reset source.
N * |        |          |0 = No reset from BOD.
N * |        |          |1 = The BOD had issued the reset signal to reset the system.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[5]     |SYSRF     |System Reset Flag
N * |        |          |The system reset flag is set by the "Reset Signal" from the Cortex-M4 Core to indicate the previous reset source.
N * |        |          |0 = No reset from Cortex-M4.
N * |        |          |1 = The Cortex-M4 had issued the reset signal to reset the system by writing 1 to the bit SYSRESETREQ(AIRCR[2], Application Interrupt and Reset Control Register, address = 0xE000ED0C) in system control registers of Cortex-M4 core.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[7]     |CPURF     |CPU Reset Flag
N * |        |          |The CPU reset flag is set by hardware if software writes CPURST (SYS_IPRST0[1]) 1 to reset Cortex-M4 Core and Flash Memory Controller (FMC).
N * |        |          |0 = No reset from CPU.
N * |        |          |1 = The Cortex-M4 Core and FMC are reset by software setting CPURST to 1.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[8]     |CPULKRF   |CPU Lockup Reset Flag
N * |        |          |The CPU reset flag is set by hardware if Cortex-M4 lockup happened.
N * |        |          |0 = No reset from CPU lockup happened.
N * |        |          |1 = The Cortex-M4 lockup happened and chip is reset.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * @var SYS_T::IPRST0
N * Offset: 0x08  Peripheral  Reset Control Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CHIPRST   |Chip One-Shot Reset (Write Protect)
N * |        |          |Setting this bit will reset the whole chip, including Processor core and all peripherals, and this bit will automatically return to 0 after the 2 clock cycles.
N * |        |          |The CHIPRST is same as the POR reset, all the chip controllers is reset and the chip setting from flash are also reload.
N * |        |          |About the difference between CHIPRST and SYSRESETREQ, please refer to section 5.2.2
N * |        |          |0 = Chip normal operation.
N * |        |          |1 = Chip one shot reset.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[1]     |CPURST    |Processor Core One-Shot Reset (Write Protect)
N * |        |          |Setting this bit will only reset the processor core and Flash Memory Controller(FMC), and this bit will automatically return to 0 after the 2 clock cycles.
N * |        |          |0 = Processor core normal operation.
N * |        |          |1 = Processor core one-shot reset.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[2]     |PDMARST   |PDMA Controller Reset (Write Protect)
N * |        |          |Setting this bit to 1 will generate a reset signal to the PDMA.
N * |        |          |User needs to set this bit to 0 to release from reset state.
N * |        |          |0 = PDMA controller normal operation.
N * |        |          |1 = PDMA controller reset.
N * |[3]     |EBIRST    |EBI Controller Reset (Write Protect)
N * |        |          |Set this bit to 1 will generate a reset signal to the EBI.
N * |        |          |User needs to set this bit to 0 to release from the reset state.
N * |        |          |0 = EBI controller normal operation.
N * |        |          |1 = EBI controller reset.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[4]     |USBHRST   |USBH Controller Reset (Write Protect)
N * |        |          |Set this bit to 1 will generate a reset signal to the USB host controller.
N * |        |          |User needs to set this bit to 0 to release from the reset state.
N * |        |          |0 = USBH controller normal operation.
N * |        |          |1 = USBH controller reset.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[7]     |CRCRST    |CRC Calculation Unit Reset (Write Protect)
N * |        |          |Set this bit to 1 will generate a reset signal to the CRC calculation module.
N * |        |          |User needs to set this bit to 0 to release from the reset state.
N * |        |          |0 = CRC Calculation unit normal operation.
N * |        |          |1 = CRC Calculation unit reset.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * @var SYS_T::IPRST1
N * Offset: 0x0C  Peripheral Reset Control Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1]     |GPIORST   |GPIO Controller Reset
N * |        |          |0 = GPIO controller normal operation.
N * |        |          |1 = GPIO controller reset.
N * |[2]     |TMR0RST   |Timer0 Controller Reset
N * |        |          |0 = Timer0 controller normal operation.
N * |        |          |1 = Timer0 controller reset.
N * |[3]     |TMR1RST   |Timer1 Controller Reset
N * |        |          |0 = Timer1 controller normal operation.
N * |        |          |1 = Timer1 controller reset.
N * |[4]     |TMR2RST   |Timer2 Controller Reset
N * |        |          |0 = Timer2 controller normal operation.
N * |        |          |1 = Timer2 controller reset.
N * |[5]     |TMR3RST   |Timer3 Controller Reset
N * |        |          |0 = Timer3 controller normal operation.
N * |        |          |1 = Timer3 controller reset.
N * |[7]     |ACMP01RST |Analog Comparator 0/1 Controller Reset
N * |        |          |0 = Analog Comparator 0/1 controller normal operation.
N * |        |          |1 = Analog Comparator 0/1 controller reset.
N * |[8]     |I2C0RST   |I2C0 Controller Reset
N * |        |          |0 = I2C0 controller normal operation.
N * |        |          |1 = I2C0 controller reset.
N * |[9]     |I2C1RST   |I2C1 Controller Reset
N * |        |          |0 = I2C1 controller normal operation.
N * |        |          |1 = I2C1 controller reset.
N * |[12]    |SPI0RST   |SPI0 Controller Reset
N * |        |          |0 = SPI0 controller normal operation.
N * |        |          |1 = SPI0 controller reset.
N * |[13]    |SPI1RST   |SPI1 Controller Reset
N * |        |          |0 = SPI1 controller normal operation.
N * |        |          |1 = SPI1 controller reset.
N * |[14]    |SPI2RST   |SPI2 Controller Reset
N * |        |          |0 = SPI2 controller normal operation.
N * |        |          |1 = SPI2 controller reset.
N * |[16]    |UART0RST  |UART0 Controller Reset
N * |        |          |0 = UART0 controller normal operation.
N * |        |          |1 = UART0 controller reset.
N * |[17]    |UART1RST  |UART1 Controller Reset
N * |        |          |0 = UART1 controller normal operation.
N * |        |          |1 = UART1 controller reset.
N * |[18]    |UART2RST  |UART2 Controller Reset
N * |        |          |0 = UART2 controller normal operation.
N * |        |          |1 = UART2 controller reset.
N * |[19]    |UART3RST  |UART3 Controller Reset
N * |        |          |0 = UART3 controller normal operation.
N * |        |          |1 = UART3 controller reset.
N * |[24]    |CAN0RST   |CAN0 Controller Reset
N * |        |          |0 = CAN0 controller normal operation.
N * |        |          |1 = CAN0 controller reset.
N * |[26]    |OTGRST    |OTG Controller Reset
N * |        |          |0 = OTG controller normal operation.
N * |        |          |1 = OTG controller reset.
N * |[27]    |USBDRST   |USB Device Controller Reset
N * |        |          |0 = USB device controller normal operation.
N * |        |          |1 = USB device controller reset.
N * |[28]    |EADCRST   |EADC Controller Reset
N * |        |          |0 = EADC controller normal operation.
N * |        |          |1 = EADC controller reset.
N * @var SYS_T::IPRST2
N * Offset: 0x10  Peripheral Reset Control Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |SC0RST    |SC0 Controller Reset
N * |        |          |0 = SC0 controller normal operation.
N * |        |          |1 = SC0 controller reset.
N * |[12]    |DACRST    |DAC Controller Reset
N * |        |          |0 = DAC controller normal operation.
N * |        |          |1 = DAC controller reset.
N * |[16]    |PWM0RST   |PWM0 Controller Reset
N * |        |          |0 = PWM0 controller normal operation.
N * |        |          |1 = PWM0 controller reset.
N * |[17]    |PWM1RST   |PWM1 Controller Reset
N * |        |          |0 = PWM1 controller normal operation.
N * |        |          |1 = PWM1 controller reset.
N * |[25]    |TKRST     |Touch Key Controller Reset
N * |        |          |0 = Touch Key controller normal operation.
N * |        |          |1 = Touch Key controller reset.
N * @var SYS_T::BODCTL
N * Offset: 0x18  Brown-Out Detector Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |BODEN     |Brown-Out Detector Enable Bit (Write Protect)
N * |        |          |The default value is set by flash controller user configuration register CBODEN (CONFIG0 [23]).
N * |        |          |0 = Brown-out Detector function Disabled.
N * |        |          |1 = Brown-out Detector function Enabled.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[2:1]   |BODVL     |Brown-Out Detector Threshold Voltage Selection (Write Protect)
N * |        |          |The default value is set by flash controller user configuration register CBOV (CONFIG0 [22:21]).
N * |        |          |00 = Brown-Out Detector Threshold Voltage is 2.2V
N * |        |          |01 = Brown-Out Detector Threshold Voltage is 2.7V
N * |        |          |10 = Brown-Out Detector Threshold Voltage is 3.7V
N * |        |          |11 = Brown-Out Detector Threshold Voltage is 4.5V
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[3]     |BODRSTEN  |Brown-Out Reset Enable Bit (Write Protect)
N * |        |          |The default value is set by flash controller user configuration register CBORST(CONFIG0[20]) bit .
N * |        |          |0 = Brown-out "INTERRUPT" function Enabled.
N * |        |          |1 = Brown-out "RESET" function Enabled.
N * |        |          |Note1:
N * |        |          |While the Brown-out Detector function is enabled (BODEN high) and BOD reset function is enabled (BODRSTEN high), BOD will assert a signal to reset chip when the detected voltage is lower than the threshold (BODOUT high).
N * |        |          |While the BOD function is enabled (BODEN high) and BOD interrupt function is enabled (BODRSTEN low), BOD will assert an interrupt if BODOUT is high.
N * |        |          |BOD interrupt will keep till to the BODEN set to 0.
N * |        |          |BOD interrupt can be blocked by disabling the NVIC BOD interrupt or disabling BOD function (set BODEN low).
N * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[4]     |BODIF     |Brown-Out Detector Interrupt Flag
N * |        |          |0 = Brown-out Detector does not detect any voltage draft at VDD down through or up through the voltage of BODVL setting.
N * |        |          |1 = When Brown-out Detector detects the VDD is dropped down through the voltage of BODVL setting or the VDD is raised up through the voltage of BODVL setting, this bit is set to 1 and the brown-out interrupt is requested if brown-out interrupt is enabled.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[5]     |BODLPM    |Brown-Out Detector Low Power Mode (Write Protect)
N * |        |          |0 = BOD operate in normal mode (default).
N * |        |          |1 = BOD Low Power mode Enabled.
N * |        |          |Note1: The BOD consumes about 100uA in normal mode, the low power mode can reduce the current to about 1/10 but slow the BOD response.
N * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[6]     |BODOUT    |Brown-Out Detector Output Status
N * |        |          |0 = Brown-out Detector output status is 0.
N * |        |          |It means the detected voltage is higher than BODVL setting or BODEN is 0.
N * |        |          |1 = Brown-out Detector output status is 1.
N * |        |          |It means the detected voltage is lower than BODVL setting.
N * |        |          |If the BODEN is 0, BOD function disabled , this bit always responds 0000.
N * |[7]     |LVREN     |Low Voltage Reset Enable Bit (Write Protect)
N * |        |          |The LVR function resets the chip when the input power voltage is lower than LVR circuit setting.
N * |        |          |LVR function is enabled by default.
N * |        |          |0 = Low Voltage Reset function Disabled.
N * |        |          |1 = Low Voltage Reset function Enabled
N * |        |          |Note1: After enabling the bit, the LVR function will be active with 100us delay for LVR output stable (default).
N * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[10:8]  |BODDGSEL  |Brown-Out Detector Output De-Glitch Time Select (Write Protect)
N * |        |          |000 = BOD output is sampled by RC10K clock.
N * |        |          |001 = 4 system clock (HCLK).
N * |        |          |010 = 8 system clock (HCLK).
N * |        |          |011 = 16 system clock (HCLK).
N * |        |          |100 = 32 system clock (HCLK).
N * |        |          |101 = 64 system clock (HCLK).
N * |        |          |110 = 128 system clock (HCLK).
N * |        |          |111 = 256 system clock (HCLK).
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[14:12] |LVRDGSEL  |LVR Output De-Glitch Time Select (Write Protect)
N * |        |          |000 = Without de-glitch function.
N * |        |          |001 = 4 system clock (HCLK).
N * |        |          |010 = 8 system clock (HCLK).
N * |        |          |011 = 16 system clock (HCLK).
N * |        |          |100 = 32 system clock (HCLK).
N * |        |          |101 = 64 system clock (HCLK).
N * |        |          |110 = 128 system clock (HCLK).
N * |        |          |111 = 256 system clock (HCLK).
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * @var SYS_T::IVSCTL
N * Offset: 0x1C  Internal Voltage Source Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |VTEMPEN   |Temperature Sensor Enable Bit
N * |        |          |This bit is used to enable/disable temperature sensor function.
N * |        |          |0 = Temperature sensor function Disabled (default).
N * |        |          |1 = Temperature sensor function Enabled.
N * |        |          |Note: After this bit is set to 1, the value of temperature sensor output can be obtained from ADC conversion result.
N * |        |          |Please refer to ADC function chapter for details.
N * |[1]     |VBATUGEN  |VBAT Unity Gain Buffer Enable Bit
N * |        |          |This bit is used to enable/disable VBAT unity gain buffer function.
N * |        |          |0 = VBAT unity gain buffer function Disabled (default).
N * |        |          |1 = VBAT unity gain buffer function Enabled.
N * |        |          |Note: After this bit is set to 1, the value of VBAT unity gain buffer output voltage can be obtained from ADC conversion result
N * @var SYS_T::PORCTL
N * Offset: 0x24  Power-On-Reset Controller Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |POROFF    |Power-On-Reset Enable Bit (Write Protect)
N * |        |          |When powered on, the POR circuit generates a reset signal to reset the whole chip function, but noise on the power may cause the POR active again.
N * |        |          |User can disable internal POR circuit to avoid unpredictable noise to cause chip reset by writing 0x5AA5 to this field.
N * |        |          |The POR function will be active again when this field is set to another value or chip is reset by other reset source, including:
N * |        |          |nRESET, Watchdog, LVR reset, BOD reset, ICE reset command and the software-chip reset function
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * @var SYS_T::VREFCTL
N * Offset: 0x28  VREF Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[4:0]   |VREFCTL   |VREF Control Bits (Write Protect)
N * |        |          |00011 = VREF is internal 2.65V.
N * |        |          |00111 = VREF is internal 2.048V.
N * |        |          |01011 = VREF is internal 3.072V.
N * |        |          |01111 = VREF is internal 4.096V.
N * |        |          |Others = Reserved.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * @var SYS_T::USBPHY
N * Offset: 0x2C  USB PHY Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |USBROLE   |USB Role Option (Write Protect)
N * |        |          |These two bits are used to select the role of USB.
N * |        |          |00 = Standard USB Device mode.
N * |        |          |01 = Standard USB Host mode.
N * |        |          |10 = ID dependent mode.
N * |        |          |11 = On-The-Go device mode.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[8]     |LDO33EN   |USB LDO33 Enable Bit (Write Protect)
N * |        |          |0 = USB LDO33 Disabled.
N * |        |          |1 = USB LDO33 Enabled.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * @var SYS_T::GPA_MFPL
N * Offset: 0x30  GPIOA Low Byte Multiple Function Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |PA0MFP    |PA.0 Multi-function Pin Selection
N * |[7:4]   |PA1MFP    |PA.1 Multi-function Pin Selection
N * |[11:8]  |PA2MFP    |PA.2 Multi-function Pin Selection
N * |[15:12] |PA3MFP    |PA.3 Multi-function Pin Selection
N * |[19:16] |PA4MFP    |PA.4 Multi-function Pin Selection
N * |[23:20] |PA5MFP    |PA.5 Multi-function Pin Selection
N * |[27:24] |PA6MFP    |PA.6 Multi-function Pin Selection
N * |[31:28] |PA7MFP    |PA.7 Multi-function Pin Selection
N * @var SYS_T::GPA_MFPH
N * Offset: 0x34  GPIOA High Byte Multiple Function Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |PA8MFP    |PA.8 Multi-function Pin Selection
N * |[7:4]   |PA9MFP    |PA.9 Multi-function Pin Selection
N * |[11:8]  |PA10MFP   |PA.10 Multi-function Pin Selection
N * |[15:12] |PA11MFP   |PA.11 Multi-function Pin Selection
N * |[19:16] |PA12MFP   |PA.12 Multi-function Pin Selection
N * |[23:20] |PA13MFP   |PA.13 Multi-function Pin Selection
N * |[27:24] |PA14MFP   |PA.14 Multi-function Pin Selection
N * |[31:28] |PA15MFP   |PA.15 Multi-function Pin Selection
N * @var SYS_T::GPB_MFPL
N * Offset: 0x38  GPIOB Low Byte Multiple Function Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |PB0MFP    |PB.0 Multi-function Pin Selection
N * |[7:4]   |PB1MFP    |PB.1 Multi-function Pin Selection
N * |[11:8]  |PB2MFP    |PB.2 Multi-function Pin Selection
N * |[15:12] |PB3MFP    |PB.3 Multi-function Pin Selection
N * |[19:16] |PB4MFP    |PB.4 Multi-function Pin Selection
N * |[23:20] |PB5MFP    |PB.5 Multi-function Pin Selection
N * |[27:24] |PB6MFP    |PB.6 Multi-function Pin Selection
N * |[31:28] |PB7MFP    |PB.7 Multi-function Pin Selection
N * @var SYS_T::GPB_MFPH
N * Offset: 0x3C  GPIOB High Byte Multiple Function Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |PB8MFP    |PB.8 Multi-function Pin Selection
N * |[7:4]   |PB9MFP    |PB.9 Multi-function Pin Selection
N * |[11:8]  |PB10MFP   |PB.10 Multi-function Pin Selection
N * |[15:12] |PB11MFP   |PB.11 Multi-function Pin Selection
N * |[19:16] |PB12MFP   |PB.12 Multi-function Pin Selection
N * |[23:20] |PB13MFP   |PB.13 Multi-function Pin Selection
N * |[27:24] |PB14MFP   |PB.14 Multi-function Pin Selection
N * |[31:28] |PB15MFP   |PB.15 Multi-function Pin Selection
N * @var SYS_T::GPC_MFPL
N * Offset: 0x40  GPIOC Low Byte Multiple Function Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |PC0MFP    |PC.0 Multi-function Pin Selection
N * |[7:4]   |PC1MFP    |PC.1 Multi-function Pin Selection
N * |[11:8]  |PC2MFP    |PC.2 Multi-function Pin Selection
N * |[15:12] |PC3MFP    |PC.3 Multi-function Pin Selection
N * |[19:16] |PC4MFP    |PC.4 Multi-function Pin Selection
N * |[23:20] |PC5MFP    |PC.5 Multi-function Pin Selection
N * |[27:24] |PC6MFP    |PC.6 Multi-function Pin Selection
N * |[31:28] |PC7MFP    |PC.7 Multi-function Pin Selection
N * @var SYS_T::GPC_MFPH
N * Offset: 0x44  GPIOC High Byte Multiple Function Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |PC8MFP    |PC.8 Multi-function Pin Selection
N * |[7:4]   |PC9MFP    |PC.9 Multi-function Pin Selection
N * |[11:8]  |PC10MFP   |PC.10 Multi-function Pin Selection
N * |[15:12] |PC11MFP   |PC.11 Multi-function Pin Selection
N * |[19:16] |PC12MFP   |PC.12 Multi-function Pin Selection
N * |[23:20] |PC13MFP   |PC.13 Multi-function Pin Selection
N * |[27:24] |PC14MFP   |PC.14 Multi-function Pin Selection
N * |[31:28] |PC15MFP   |PC.15 Multi-function Pin Selection
N * @var SYS_T::GPD_MFPL
N * Offset: 0x48  GPIOD Low Byte Multiple Function Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |PD0MFP    |PD.0 Multi-function Pin Selection
N * |[7:4]   |PD1MFP    |PD.1 Multi-function Pin Selection
N * |[11:8]  |PD2MFP    |PD.2 Multi-function Pin Selection
N * |[15:12] |PD3MFP    |PD.3 Multi-function Pin Selection
N * |[19:16] |PD4MFP    |PD.4 Multi-function Pin Selection
N * |[23:20] |PD5MFP    |PD.5 Multi-function Pin Selection
N * |[27:24] |PD6MFP    |PD.6 Multi-function Pin Selection
N * |[31:28] |PD7MFP    |PD.7 Multi-function Pin Selection
N * @var SYS_T::GPD_MFPH
N * Offset: 0x4C  GPIOD High Byte Multiple Function Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |PD8MFP    |PD.8 Multi-function Pin Selection
N * |[7:4]   |PD9MFP    |PD.9 Multi-function Pin Selection
N * |[11:8]  |PD10MFP   |PD.10 Multi-function Pin Selection
N * |[15:12] |PD11MFP   |PD.11 Multi-function Pin Selection
N * |[19:16] |PD12MFP   |PD.12 Multi-function Pin Selection
N * |[23:20] |PD13MFP   |PD.13 Multi-function Pin Selection
N * |[27:24] |PD14MFP   |PD.14 Multi-function Pin Selection
N * |[31:28] |PD15MFP   |PD.15 Multi-function Pin Selection
N * @var SYS_T::GPE_MFPL
N * Offset: 0x50  GPIOE Low Byte Multiple Function Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |PE0MFP    |PE.0 Multi-function Pin Selection
N * |[7:4]   |PE1MFP    |PE.1 Multi-function Pin Selection
N * |[11:8]  |PE2MFP    |PE.2 Multi-function Pin Selection
N * |[15:12] |PE3MFP    |PE.3 Multi-function Pin Selection
N * |[19:16] |PE4MFP    |PE.4 Multi-function Pin Selection
N * |[23:20] |PE5MFP    |PE.5 Multi-function Pin Selection
N * |[27:24] |PE6MFP    |PE.6 Multi-function Pin Selection
N * |[31:28] |PE7MFP    |PE.7 Multi-function Pin Selection
N * @var SYS_T::GPE_MFPH
N * Offset: 0x54  GPIOE High Byte Multiple Function Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |PE8MFP    |PE.8 Multi-function Pin Selection
N * |[7:4]   |PE9MFP    |PE.9 Multi-function Pin Selection
N * |[11:8]  |PE10MFP   |PE.10 Multi-function Pin Selection
N * |[15:12] |PE11MFP   |PE.11 Multi-function Pin Selection
N * |[19:16] |PE12MFP   |PE.12 Multi-function Pin Selection
N * |[23:20] |PE13MFP   |PE.13 Multi-function Pin Selection
N * |[27:24] |PE14_MFP  |PE.14 Multi-function Pin Selection
N * @var SYS_T::GPF_MFPL
N * Offset: 0x58  GPIOF Low Byte Multiple Function Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |PF0MFP    |PF.0 Multi-function Pin Selection
N * |[7:4]   |PF1MFP    |PF.1 Multi-function Pin Selection
N * |[11:8]  |PF2MFP    |PF.2 Multi-function Pin Selection
N * |[15:12] |PF3MFP    |PF.3 Multi-function Pin Selection
N * |[19:16] |PF4MFP    |PF.4 Multi-function Pin Selection
N * |[23:20] |PF5MFP    |PF.5 Multi-function Pin Selection
N * |[27:24] |PF6MFP    |PF.6 Multi-function Pin Selection
N * |[31:28] |PF7MFP    |PF.7 Multi-function Pin Selection
N * @var SYS_T::SRAM_INTCTL
N * Offset: 0xC0  System SRAM Interrupt Enable Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PERRIEN   |SRAM Parity Check Error Interrupt Enable Bit
N * |        |          |0 = SRAM parity check error interrupt Disabled.
N * |        |          |1 = SRAM parity check error interrupt Enabled.
N * @var SYS_T::SRAM_STATUS
N * Offset: 0xC4  System SRAM Parity Error Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PERRIF    |SRAM Parity Check Error Flag
N * |        |          |0 = No System SRAM parity error.
N * |        |          |1 = System SRAM parity error occur.
N * @var SYS_T::SRAM_ERRADDR
N * Offset: 0xC8  System SRAM Parity Check Error Address Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |ERRADDR   |System SRAM Parity Error Address
N * |        |          |This register shows system SRAM parity error byte address.
N * @var SYS_T::SRAM_BISTCTL
N * Offset: 0xD0  System SRAM BIST Test Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |SRBIST0   |1st
N * |        |          |SRAM BIST Enable Bit
N * |        |          |This bit enables BIST test for SRAM located in address 0x2000_0000 ~0x2000_3FFF
N * |        |          |0 = system SRAM BIST Disabled.
N * |        |          |1 = system SRAM BIST Enabled.
N * |[1]     |SRBIST1   |2nd
N * |        |          |SRAM BIST Enable Bit
N * |        |          |This bit enables BIST test for SRAM located in address 0x2000_4000 ~0x2000_7FFF
N * |        |          |0 = system SRAM BIST Disabled.
N * |        |          |1 = system SRAM BIST Enabled.
N * |[2]     |CRBIST    |CACHE BIST Enable Bit
N * |        |          |This bit enables BIST test for CACHE RAM
N * |        |          |0 = system CACHE BIST Disabled.
N * |        |          |1 = system CACHE BIST Enabled.
N * |[3]     |CANBIST   |CAN BIST Enable Bit
N * |        |          |This bit enables BIST test for CAN RAM
N * |        |          |0 = system CAN BIST Disabled.
N * |        |          |1 = system CAN BIST Enabled.
N * |[4]     |USBBIST   |USB BIST Enable Bit
N * |        |          |This bit enables BIST test for USB RAM
N * |        |          |0 = system USB BIST Disabled.
N * |        |          |1 = system USB BIST Enabled.
N * @var SYS_T::SRAM_BISTSTS
N * Offset: 0xD4  System SRAM BIST Test Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |SRBISTEF0 |1st System SRAM BIST Fail Flag
N * |        |          |0 = 1st system SRAM BIST test pass.
N * |        |          |1 = 1st system SRAM BIST test fail.
N * |[1]     |SRBISTEF1 |2nd System SRAM BIST Fail Flag
N * |        |          |0 = 2nd system SRAM BIST test pass.
N * |        |          |1 = 2nd system SRAM BIST test fail.
N * |[2]     |CRBISTEF  |CACHE SRAM BIST Fail Flag
N * |        |          |0 = System CACHE RAM BIST test pass.
N * |        |          |1 = System CACHE RAM BIST test fail.
N * |[3]     |CANBEF    |CAN SRAM BIST Fail Flag
N * |        |          |0 = CAN SRAM BIST test pass.
N * |        |          |1 = CAN SRAM BIST test fail.
N * |[4]     |USBBEF    |USB SRAM BIST Fail Flag
N * |        |          |0 = USB SRAM BIST test pass.
N * |        |          |1 = USB SRAM BIST test fail.
N * |[16]    |SRBEND0   |1st SRAM BIST Test Finish
N * |        |          |0 = 1st system SRAM BIST active.
N * |        |          |1 = 1st system SRAM BIST finish.
N * |[17]    |SRBEND1   |2nd SRAM BIST Test Finish
N * |        |          |0 = 2nd system SRAM BIST is active.
N * |        |          |1 = 2nd system SRAM BIST finish.
N * |[18]    |CRBEND    |CACHE SRAM BIST Test Finish
N * |        |          |0 = System CACHE RAM BIST is active.
N * |        |          |1 = System CACHE RAM BIST test finish.
N * |[19]    |CANBEND   |CAN SRAM BIST Test Finish
N * |        |          |0 = CAN SRAM BIST is active.
N * |        |          |1 = CAN SRAM BIST test finish.
N * |[20]    |USBBEND   |USB SRAM BIST Test Finish
N * |        |          |0 = USB SRAM BIST is active.
N * |        |          |1 = USB SRAM BIST test finish.
N * @var SYS_T::IRCTCTL
N * Offset: 0xF0  IRC Trim Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |FREQSEL   |Trim Frequency Selection
N * |        |          |This field indicates the target frequency of internal 22.1184 MHz high-speed oscillator auto trim.
N * |        |          |During auto trim operation, if clock error detected with CESTOPEN is set to 1 or trim retry limitation count reached, this field will be cleared to 00 automatically.
N * |        |          |00 = Disable HIRC auto trim function.
N * |        |          |01 = Enable HIRC auto trim function and trim HIRC to 22.1184 MHz.
N * |        |          |10 = Enable HIRC auto trim function and trim HIRC to 24 MHz.
N * |        |          |11 = Reserved.
N * |[5:4]   |LOOPSEL   |Trim Calculation Loop Selection
N * |        |          |This field defines that trim value calculation is based on how many 32.768 kHz clock.
N * |        |          |00 = Trim value calculation is based on average difference in 4 32.768 kHz clock.
N * |        |          |01 = Trim value calculation is based on average difference in 8 32.768 kHz clock.
N * |        |          |10 = Trim value calculation is based on average difference in 16 32.768 kHz clock.
N * |        |          |11 = Trim value calculation is based on average difference in 32 32.768 kHz clock.
N * |        |          |Note: For example, if LOOPSEL is set as 00, auto trim circuit will calculate trim value based on the average frequency difference in 4 32.768 kHz clock.
N * |[7:6]   |RETRYCNT  |Trim Value Update Limitation Count
N * |        |          |This field defines that how many times the auto trim circuit will try to update the HIRC trim value before the frequency of HIRC locked.
N * |        |          |Once the HIRC locked, the internal trim value update counter will be reset.
N * |        |          |If the trim value update counter reached this limitation value and frequency of HIRC still doesn't lock, the auto trim operation will be disabled and FREQSEL will be cleared to 00.
N * |        |          |00 = Trim retry count limitation is 64 loops.
N * |        |          |01 = Trim retry count limitation is 128 loops.
N * |        |          |10 = Trim retry count limitation is 256 loops.
N * |        |          |11 = Trim retry count limitation is 512 loops.
N * |[8]     |CESTOPEN  |Clock Error Stop Enable Bit
N * |        |          |0 = The trim operation is keep going if clock is inaccuracy.
N * |        |          |1 = The trim operation is stopped if clock is inaccuracy.
N * @var SYS_T::IRCTIEN
N * Offset: 0xF4  IRC Trim Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1]     |TFAILIEN  |Trim Failure Interrupt Enable Bit
N * |        |          |This bit controls if an interrupt will be triggered while HIRC trim value update limitation count reached and HIRC frequency still not locked on target frequency set by FREQSEL(SYS_IRCTCTL[1:0]).
N * |        |          |If this bit is high and TFAILIF(SYS_IRCTSTS[1]) is set during auto trim operation, an interrupt will be triggered to notify that HIRC trim value update limitation count was reached.
N * |        |          |0 = Disable TFAILIF(SYS_IRCTSTS[1]) status to trigger an interrupt to CPU.
N * |        |          |1 = Enable TFAILIF(SYS_IRCTSTS[1]) status to trigger an interrupt to CPU.
N * |[2]     |CLKEIEN   |Clock Error Interrupt Enable Bit
N * |        |          |This bit controls if CPU would get an interrupt while clock is inaccuracy during auto trim operation.
N * |        |          |If this bit is set to1, and CLKERRIF(SYS_IRCTSTS[2]) is set during auto trim operation, an interrupt will be triggered to notify the clock frequency is inaccuracy.
N * |        |          |0 = Disable CLKERRIF(SYS_IRCTSTS[2]) status to trigger an interrupt to CPU.
N * |        |          |1 = Enable CLKERRIF(SYS_IRCTSTS[2]) status to trigger an interrupt to CPU.
N * @var SYS_T::IRCTISTS
N * Offset: 0xF8  IRC Trim Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |FREQLOCK  |HIRC Frequency Lock Status
N * |        |          |This bit indicates the internal 22.1184 MHz high-speed oscillator frequency is locked.
N * |        |          |This is a status bit and doesn't trigger any interrupt.
N * |[1]     |TFAILIF   |Trim Failure Interrupt Status
N * |        |          |This bit indicates that internal 22.1184 MHz high-speed oscillator trim value update limitation count reached and the internal 22.1184 MHz high-speed oscillator clock frequency still doesn't be locked.
N * |        |          |Once this bit is set, the auto trim operation stopped and FREQSEL(SYS_iRCTCTL[1:0]) will be cleared to 00 by hardware automatically.
N * |        |          |If this bit is set and TFAILIEN(SYS_IRCTIEN[1]) is high, an interrupt will be triggered to notify that HIRC trim value update limitation count was reached.
N * |        |          |Write 1 to clear this to 0.
N * |        |          |0 = Trim value update limitation count does not reach.
N * |        |          |1 = Trim value update limitation count reached and internal 22.1184 MHz high-speed oscillator frequency still not locked.
N * |[2]     |CLKERRIF  |Clock Error Interrupt Status
N * |        |          |When the frequency of external 32.768 kHz low-speed crystal or internal 22.1184 MHz high-speed oscillator is shift larger to unreasonable value, this bit will be set and to be an indicate that clock frequency is inaccuracy
N * |        |          |Once this bit is set to 1, the auto trim operation stopped and FREQSEL(SYS_IRCTCL[1:0]) will be cleared to 00 by hardware automatically if CESTOPEN(SYS_IRCTCTL[8]) is set to 1.
N * |        |          |If this bit is set and CLKEIEN(SYS_IRCTIEN[2]) is high, an interrupt will be triggered to notify the clock frequency is inaccuracy.
N * |        |          |Write 1 to clear this to 0.
N * |        |          |0 = Clock frequency is accuracy.
N * |        |          |1 = Clock frequency is inaccuracy.
N * @var SYS_T::REGLCTL
N * Offset: 0x100  Register Lock Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |REGLCTL   |Register Lock Control Code
N * |        |          |Write operation:
N * |        |          |Some registers have write-protection function.
N * |        |          |Writing these registers have to disable the protected function by writing the sequence value "59h", "16h", "88h" to this field.
N * |        |          |After this sequence is completed, the REGLCTL bit will be set to 1 and write-protection registers can be normal write.
N * |        |          |Read operation:
N * |        |          |0 = Write-protection Enabled for writing protected registers.
N * |        |          |Any write to the protected register is ignored.
N * |        |          |1 = Write-protection Disabled for writing protected registers.
N * |        |          |The Protected registers are:
N * |        |          |SYS_IPRST0: address 0x4000_0008
N * |        |          |SYS_BODCTL: address 0x4000_0018
N * |        |          |SYS_PORCTL: address 0x4000_0024
N * |        |          |SYS_VREFCTL: address 0x4000_0028
N * |        |          |SYS_USBPHY: address 0x4000_002C
N * |        |          |CLK_PWRCTL: address 0x4000_0200 (bit[6] is not protected for power wake-up interrupt clear)
N * |        |          |SYS_SRAM_BISTCTL: address 0x4000_00D0
N * |        |          |CLK_APBCLK0 [0]: address 0x4000_0208 (bit[0] is watchdog clock enable)
N * |        |          |CLK_CLKSEL0: address 0x4000_0210 (for HCLK and CPU STCLK clock source select)
N * |        |          |CLK_CLKSEL1 [1:0]: address 0x4000_0214 (for watchdog clock source select)
N * |        |          |CLK_CLKSEL1 [31:30]: address 0x4000_0214 (for window watchdog clock source select)
N * |        |          |CLK_CLKDSTS: address 0x4000_0274
N * |        |          |NMIEN: address 0x4000_0300
N * |        |          |FMC_ISPCTL: address 0x4000_C000 (Flash ISP Control register)
N * |        |          |FMC_ISPTRG: address 0x4000_C010 (ISP Trigger Control register)
N * |        |          |FMC_ISPSTS: address 0x4000_C040
N * |        |          |WDT_CTL: address 0x4004_0000
N * |        |          |FMC_FTCTL: address 0x4000_5018
N * |        |          |FMC_ICPCMD: address 0x4000_501C
N * |        |          |CLK_PLLCTL: address 0x40000240
N * |        |          |PWM_CTL0: address 0x4005_8000
N * |        |          |PWM_CTL0: address 0x4005_9000
N * |        |          |PWM_DTCTL0_1: address 0x4005_8070
N * |        |          |PWM_DTCTL0_1: address 0x4005_9070
N * |        |          |PWM_DTCTL2_3: address 0x4005_8074
N * |        |          |PWM_DTCTL2_3: address 0x4005_9074
N * |        |          |PWM_DTCTL4_5: address 0x4005_8078
N * |        |          |PWM_DTCTL4_5: address 0x4005_9078
N * |        |          |PWM_BRKCTL0_1: address 0x4005_80C8
N * |        |          |PWM_BRKCTL0_1: address 0x4005_90C8
N * |        |          |PWM_BRKCTL2_3: address0x4005_80CC
N * |        |          |PWM_BRKCTL2_3: address0x4005_90CC
N * |        |          |PWM_BRKCTL4_5: address0x4005_80D0
N * |        |          |PWM_BRKCTL4_5: address0x4005_90D0
N * |        |          |PWM_INTEN1: address0x4005_80E4
N * |        |          |PWM_INTEN1: address0x4005_90E4
N * |        |          |PWM_INTSTS1: address0x4005_80EC
N * |        |          |PWM_INTSTS1: address0x4005_90EC
N */
N
N    __I  uint32_t PDID;          /* Offset: 0x00  Part Device Identification Number Register                         */
X    volatile const  uint32_t PDID;           
N    __IO uint32_t RSTSTS;        /* Offset: 0x04  System Reset Status Register                                       */
X    volatile uint32_t RSTSTS;         
N    __IO uint32_t IPRST0;        /* Offset: 0x08  Peripheral  Reset Control Register 0                               */
X    volatile uint32_t IPRST0;         
N    __IO uint32_t IPRST1;        /* Offset: 0x0C  Peripheral Reset Control Register 1                                */
X    volatile uint32_t IPRST1;         
N    __IO uint32_t IPRST2;        /* Offset: 0x10  Peripheral Reset Control Register 2                                */
X    volatile uint32_t IPRST2;         
N    __I  uint32_t RESERVE0[1];  
X    volatile const  uint32_t RESERVE0[1];  
N    __IO uint32_t BODCTL;        /* Offset: 0x18  Brown-Out Detector Control Register                                */
X    volatile uint32_t BODCTL;         
N    __IO uint32_t IVSCTL;        /* Offset: 0x1C  Internal Voltage Source Control Register                           */
X    volatile uint32_t IVSCTL;         
N    __I  uint32_t RESERVE1[1];  
X    volatile const  uint32_t RESERVE1[1];  
N    __IO uint32_t PORCTL;        /* Offset: 0x24  Power-On-Reset Controller Register                                 */
X    volatile uint32_t PORCTL;         
N    __IO uint32_t VREFCTL;       /* Offset: 0x28  VREF Control Register                                              */
X    volatile uint32_t VREFCTL;        
N    __IO uint32_t USBPHY;        /* Offset: 0x2C  USB PHY Control Register                                           */
X    volatile uint32_t USBPHY;         
N    __IO uint32_t GPA_MFPL;      /* Offset: 0x30  GPIOA Low Byte Multiple Function Control Register                  */
X    volatile uint32_t GPA_MFPL;       
N    __IO uint32_t GPA_MFPH;      /* Offset: 0x34  GPIOA High Byte Multiple Function Control Register                 */
X    volatile uint32_t GPA_MFPH;       
N    __IO uint32_t GPB_MFPL;      /* Offset: 0x38  GPIOB Low Byte Multiple Function Control Register                  */
X    volatile uint32_t GPB_MFPL;       
N    __IO uint32_t GPB_MFPH;      /* Offset: 0x3C  GPIOB High Byte Multiple Function Control Register                 */
X    volatile uint32_t GPB_MFPH;       
N    __IO uint32_t GPC_MFPL;      /* Offset: 0x40  GPIOC Low Byte Multiple Function Control Register                  */
X    volatile uint32_t GPC_MFPL;       
N    __IO uint32_t GPC_MFPH;      /* Offset: 0x44  GPIOC High Byte Multiple Function Control Register                 */
X    volatile uint32_t GPC_MFPH;       
N    __IO uint32_t GPD_MFPL;      /* Offset: 0x48  GPIOD Low Byte Multiple Function Control Register                  */
X    volatile uint32_t GPD_MFPL;       
N    __IO uint32_t GPD_MFPH;      /* Offset: 0x4C  GPIOD High Byte Multiple Function Control Register                 */
X    volatile uint32_t GPD_MFPH;       
N    __IO uint32_t GPE_MFPL;      /* Offset: 0x50  GPIOE Low Byte Multiple Function Control Register                  */
X    volatile uint32_t GPE_MFPL;       
N    __IO uint32_t GPE_MFPH;      /* Offset: 0x54  GPIOE High Byte Multiple Function Control Register                 */
X    volatile uint32_t GPE_MFPH;       
N    __IO uint32_t GPF_MFPL;      /* Offset: 0x58  GPIOF Low Byte Multiple Function Control Register                  */
X    volatile uint32_t GPF_MFPL;       
N    __I  uint32_t RESERVE2[25]; 
X    volatile const  uint32_t RESERVE2[25]; 
N    __IO uint32_t SRAM_INTCTL;   /* Offset: 0xC0  System SRAM Interrupt Enable Control Register                      */
X    volatile uint32_t SRAM_INTCTL;    
N    __I  uint32_t SRAM_STATUS;   /* Offset: 0xC4  System SRAM Parity Error Status Register                           */
X    volatile const  uint32_t SRAM_STATUS;    
N    __I  uint32_t SRAM_ERRADDR;  /* Offset: 0xC8  System SRAM Parity Check Error Address Register                    */
X    volatile const  uint32_t SRAM_ERRADDR;   
N    __I  uint32_t RESERVE3[1];  
X    volatile const  uint32_t RESERVE3[1];  
N    __IO uint32_t SRAM_BISTCTL;  /* Offset: 0xD0  System SRAM BIST Test Control Register                             */
X    volatile uint32_t SRAM_BISTCTL;   
N    __I  uint32_t SRAM_BISTSTS;  /* Offset: 0xD4  System SRAM BIST Test Status Register                              */
X    volatile const  uint32_t SRAM_BISTSTS;   
N    __I  uint32_t RESERVE4[6];  
X    volatile const  uint32_t RESERVE4[6];  
N    __IO uint32_t IRCTCTL;       /* Offset: 0xF0  IRC Trim Control Register                                          */
X    volatile uint32_t IRCTCTL;        
N    __IO uint32_t IRCTIEN;       /* Offset: 0xF4  IRC Trim Interrupt Enable Register                                 */
X    volatile uint32_t IRCTIEN;        
N    __IO uint32_t IRCTISTS;      /* Offset: 0xF8  IRC Trim Interrupt Status Register                                 */
X    volatile uint32_t IRCTISTS;       
N    __I  uint32_t RESERVE5[1];  
X    volatile const  uint32_t RESERVE5[1];  
N    __IO uint32_t REGLCTL;       /* Offset: 0x100  Register Lock Control Register                                    */
X    volatile uint32_t REGLCTL;        
N
N} SYS_T;
N
N
N
N/**
N    @addtogroup SYS_CONST SYS Bit Field Definition
N    Constant Definitions for SYS Controller
N@{ */
N
N#define SYS_PDID_PDID_Pos                (0)                                               /*!< SYS_T::PDID: PDID Position                */
N#define SYS_PDID_PDID_Msk                (0xfffffffful << SYS_PDID_PDID_Pos)               /*!< SYS_T::PDID: PDID Mask                    */
N
N#define SYS_RSTSTS_PORF_Pos              (0)                                               /*!< SYS_T::RSTSTS: PORF Position              */
N#define SYS_RSTSTS_PORF_Msk              (0x1ul << SYS_RSTSTS_PORF_Pos)                    /*!< SYS_T::RSTSTS: PORF Mask                  */
N
N#define SYS_RSTSTS_PINRF_Pos             (1)                                               /*!< SYS_T::RSTSTS: PINRF Position             */
N#define SYS_RSTSTS_PINRF_Msk             (0x1ul << SYS_RSTSTS_PINRF_Pos)                   /*!< SYS_T::RSTSTS: PINRF Mask                 */
N
N#define SYS_RSTSTS_WDTRF_Pos             (2)                                               /*!< SYS_T::RSTSTS: WDTRF Position             */
N#define SYS_RSTSTS_WDTRF_Msk             (0x1ul << SYS_RSTSTS_WDTRF_Pos)                   /*!< SYS_T::RSTSTS: WDTRF Mask                 */
N
N#define SYS_RSTSTS_LVRF_Pos              (3)                                               /*!< SYS_T::RSTSTS: LVRF Position              */
N#define SYS_RSTSTS_LVRF_Msk              (0x1ul << SYS_RSTSTS_LVRF_Pos)                    /*!< SYS_T::RSTSTS: LVRF Mask                  */
N
N#define SYS_RSTSTS_BODRF_Pos             (4)                                               /*!< SYS_T::RSTSTS: BODRF Position             */
N#define SYS_RSTSTS_BODRF_Msk             (0x1ul << SYS_RSTSTS_BODRF_Pos)                   /*!< SYS_T::RSTSTS: BODRF Mask                 */
N
N#define SYS_RSTSTS_SYSRF_Pos             (5)                                               /*!< SYS_T::RSTSTS: SYSRF Position             */
N#define SYS_RSTSTS_SYSRF_Msk             (0x1ul << SYS_RSTSTS_SYSRF_Pos)                   /*!< SYS_T::RSTSTS: SYSRF Mask                 */
N
N#define SYS_RSTSTS_CPURF_Pos             (7)                                               /*!< SYS_T::RSTSTS: CPURF Position             */
N#define SYS_RSTSTS_CPURF_Msk             (0x1ul << SYS_RSTSTS_CPURF_Pos)                   /*!< SYS_T::RSTSTS: CPURF Mask                 */
N
N#define SYS_RSTSTS_CPULKRF_Pos           (8)                                               /*!< SYS_T::RSTSTS: CPULKRF Position           */
N#define SYS_RSTSTS_CPULKRF_Msk           (0x1ul << SYS_RSTSTS_CPULKRF_Pos)                 /*!< SYS_T::RSTSTS: CPULKRF Mask               */
N
N#define SYS_IPRST0_CHIPRST_Pos           (0)                                               /*!< SYS_T::IPRST0: CHIPRST Position           */
N#define SYS_IPRST0_CHIPRST_Msk           (0x1ul << SYS_IPRST0_CHIPRST_Pos)                 /*!< SYS_T::IPRST0: CHIPRST Mask               */
N
N#define SYS_IPRST0_CPURST_Pos            (1)                                               /*!< SYS_T::IPRST0: CPURST Position            */
N#define SYS_IPRST0_CPURST_Msk            (0x1ul << SYS_IPRST0_CPURST_Pos)                  /*!< SYS_T::IPRST0: CPURST Mask                */
N
N#define SYS_IPRST0_PDMARST_Pos           (2)                                               /*!< SYS_T::IPRST0: PDMARST Position           */
N#define SYS_IPRST0_PDMARST_Msk           (0x1ul << SYS_IPRST0_PDMARST_Pos)                 /*!< SYS_T::IPRST0: PDMARST Mask               */
N
N#define SYS_IPRST0_EBIRST_Pos            (3)                                               /*!< SYS_T::IPRST0: EBIRST Position            */
N#define SYS_IPRST0_EBIRST_Msk            (0x1ul << SYS_IPRST0_EBIRST_Pos)                  /*!< SYS_T::IPRST0: EBIRST Mask                */
N
N#define SYS_IPRST0_USBHRST_Pos           (4)                                               /*!< SYS_T::IPRST0: USBHRST Position           */
N#define SYS_IPRST0_USBHRST_Msk           (0x1ul << SYS_IPRST0_USBHRST_Pos)                 /*!< SYS_T::IPRST0: USBHRST Mask               */
N
N#define SYS_IPRST0_CRCRST_Pos            (7)                                               /*!< SYS_T::IPRST0: CRCRST Position            */
N#define SYS_IPRST0_CRCRST_Msk            (0x1ul << SYS_IPRST0_CRCRST_Pos)                  /*!< SYS_T::IPRST0: CRCRST Mask                */
N
N#define SYS_IPRST1_GPIORST_Pos           (1)                                               /*!< SYS_T::IPRST1: GPIORST Position           */
N#define SYS_IPRST1_GPIORST_Msk           (0x1ul << SYS_IPRST1_GPIORST_Pos)                 /*!< SYS_T::IPRST1: GPIORST Mask               */
N
N#define SYS_IPRST1_TMR0RST_Pos           (2)                                               /*!< SYS_T::IPRST1: TMR0RST Position           */
N#define SYS_IPRST1_TMR0RST_Msk           (0x1ul << SYS_IPRST1_TMR0RST_Pos)                 /*!< SYS_T::IPRST1: TMR0RST Mask               */
N
N#define SYS_IPRST1_TMR1RST_Pos           (3)                                               /*!< SYS_T::IPRST1: TMR1RST Position           */
N#define SYS_IPRST1_TMR1RST_Msk           (0x1ul << SYS_IPRST1_TMR1RST_Pos)                 /*!< SYS_T::IPRST1: TMR1RST Mask               */
N
N#define SYS_IPRST1_TMR2RST_Pos           (4)                                               /*!< SYS_T::IPRST1: TMR2RST Position           */
N#define SYS_IPRST1_TMR2RST_Msk           (0x1ul << SYS_IPRST1_TMR2RST_Pos)                 /*!< SYS_T::IPRST1: TMR2RST Mask               */
N
N#define SYS_IPRST1_TMR3RST_Pos           (5)                                               /*!< SYS_T::IPRST1: TMR3RST Position           */
N#define SYS_IPRST1_TMR3RST_Msk           (0x1ul << SYS_IPRST1_TMR3RST_Pos)                 /*!< SYS_T::IPRST1: TMR3RST Mask               */
N
N#define SYS_IPRST1_ACMP01RST_Pos         (7)                                               /*!< SYS_T::IPRST1: ACMP01RST Position         */
N#define SYS_IPRST1_ACMP01RST_Msk         (0x1ul << SYS_IPRST1_ACMP01RST_Pos)               /*!< SYS_T::IPRST1: ACMP01RST Mask             */
N
N#define SYS_IPRST1_I2C0RST_Pos           (8)                                               /*!< SYS_T::IPRST1: I2C0RST Position           */
N#define SYS_IPRST1_I2C0RST_Msk           (0x1ul << SYS_IPRST1_I2C0RST_Pos)                 /*!< SYS_T::IPRST1: I2C0RST Mask               */
N
N#define SYS_IPRST1_I2C1RST_Pos           (9)                                               /*!< SYS_T::IPRST1: I2C1RST Position           */
N#define SYS_IPRST1_I2C1RST_Msk           (0x1ul << SYS_IPRST1_I2C1RST_Pos)                 /*!< SYS_T::IPRST1: I2C1RST Mask               */
N
N#define SYS_IPRST1_SPI0RST_Pos           (12)                                              /*!< SYS_T::IPRST1: SPI0RST Position           */
N#define SYS_IPRST1_SPI0RST_Msk           (0x1ul << SYS_IPRST1_SPI0RST_Pos)                 /*!< SYS_T::IPRST1: SPI0RST Mask               */
N
N#define SYS_IPRST1_SPI1RST_Pos           (13)                                              /*!< SYS_T::IPRST1: SPI1RST Position           */
N#define SYS_IPRST1_SPI1RST_Msk           (0x1ul << SYS_IPRST1_SPI1RST_Pos)                 /*!< SYS_T::IPRST1: SPI1RST Mask               */
N
N#define SYS_IPRST1_SPI2RST_Pos           (14)                                              /*!< SYS_T::IPRST1: SPI2RST Position           */
N#define SYS_IPRST1_SPI2RST_Msk           (0x1ul << SYS_IPRST1_SPI2RST_Pos)                 /*!< SYS_T::IPRST1: SPI2RST Mask               */
N
N#define SYS_IPRST1_UART0RST_Pos          (16)                                              /*!< SYS_T::IPRST1: UART0RST Position          */
N#define SYS_IPRST1_UART0RST_Msk          (0x1ul << SYS_IPRST1_UART0RST_Pos)                /*!< SYS_T::IPRST1: UART0RST Mask              */
N
N#define SYS_IPRST1_UART1RST_Pos          (17)                                              /*!< SYS_T::IPRST1: UART1RST Position          */
N#define SYS_IPRST1_UART1RST_Msk          (0x1ul << SYS_IPRST1_UART1RST_Pos)                /*!< SYS_T::IPRST1: UART1RST Mask              */
N
N#define SYS_IPRST1_UART2RST_Pos          (18)                                              /*!< SYS_T::IPRST1: UART2RST Position          */
N#define SYS_IPRST1_UART2RST_Msk          (0x1ul << SYS_IPRST1_UART2RST_Pos)                /*!< SYS_T::IPRST1: UART2RST Mask              */
N
N#define SYS_IPRST1_UART3RST_Pos          (19)                                              /*!< SYS_T::IPRST1: UART3RST Position          */
N#define SYS_IPRST1_UART3RST_Msk          (0x1ul << SYS_IPRST1_UART3RST_Pos)                /*!< SYS_T::IPRST1: UART3RST Mask              */
N
N#define SYS_IPRST1_CAN0RST_Pos           (24)                                              /*!< SYS_T::IPRST1: CAN0RST Position           */
N#define SYS_IPRST1_CAN0RST_Msk           (0x1ul << SYS_IPRST1_CAN0RST_Pos)                 /*!< SYS_T::IPRST1: CAN0RST Mask               */
N
N#define SYS_IPRST1_OTGRST_Pos            (26)                                              /*!< SYS_T::IPRST1: OTGRST Position            */
N#define SYS_IPRST1_OTGRST_Msk            (0x1ul << SYS_IPRST1_OTGRST_Pos)                  /*!< SYS_T::IPRST1: OTGRST Mask                */
N
N#define SYS_IPRST1_USBDRST_Pos           (27)                                              /*!< SYS_T::IPRST1: USBDRST Position           */
N#define SYS_IPRST1_USBDRST_Msk           (0x1ul << SYS_IPRST1_USBDRST_Pos)                 /*!< SYS_T::IPRST1: USBDRST Mask               */
N
N#define SYS_IPRST1_EADCRST_Pos           (28)                                              /*!< SYS_T::IPRST1: EADCRST Position           */
N#define SYS_IPRST1_EADCRST_Msk           (0x1ul << SYS_IPRST1_EADCRST_Pos)                 /*!< SYS_T::IPRST1: EADCRST Mask               */
N
N#define SYS_IPRST2_SC0RST_Pos            (0)                                               /*!< SYS_T::IPRST2: SC0RST Position            */
N#define SYS_IPRST2_SC0RST_Msk            (0x1ul << SYS_IPRST2_SC0RST_Pos)                  /*!< SYS_T::IPRST2: SC0RST Mask                */
N
N#define SYS_IPRST2_DACRST_Pos            (12)                                              /*!< SYS_T::IPRST2: DACRST Position            */
N#define SYS_IPRST2_DACRST_Msk            (0x1ul << SYS_IPRST2_DACRST_Pos)                  /*!< SYS_T::IPRST2: DACRST Mask                */
N
N#define SYS_IPRST2_PWM0RST_Pos           (16)                                              /*!< SYS_T::IPRST2: PWM0RST Position           */
N#define SYS_IPRST2_PWM0RST_Msk           (0x1ul << SYS_IPRST2_PWM0RST_Pos)                 /*!< SYS_T::IPRST2: PWM0RST Mask               */
N
N#define SYS_IPRST2_PWM1RST_Pos           (17)                                              /*!< SYS_T::IPRST2: PWM1RST Position           */
N#define SYS_IPRST2_PWM1RST_Msk           (0x1ul << SYS_IPRST2_PWM1RST_Pos)                 /*!< SYS_T::IPRST2: PWM1RST Mask               */
N
N#define SYS_IPRST2_TKRST_Pos             (25)                                              /*!< SYS_T::IPRST2: TKRST Position             */
N#define SYS_IPRST2_TKRST_Msk             (0x1ul << SYS_IPRST2_TKRST_Pos)                   /*!< SYS_T::IPRST2: TKRST Mask                 */
N
N#define SYS_BODCTL_BODEN_Pos             (0)                                               /*!< SYS_T::BODCTL: BODEN Position             */
N#define SYS_BODCTL_BODEN_Msk             (0x1ul << SYS_BODCTL_BODEN_Pos)                   /*!< SYS_T::BODCTL: BODEN Mask                 */
N
N#define SYS_BODCTL_BODVL_Pos             (1)                                               /*!< SYS_T::BODCTL: BODVL Position             */
N#define SYS_BODCTL_BODVL_Msk             (0x3ul << SYS_BODCTL_BODVL_Pos)                   /*!< SYS_T::BODCTL: BODVL Mask                 */
N
N#define SYS_BODCTL_BODRSTEN_Pos          (3)                                               /*!< SYS_T::BODCTL: BODRSTEN Position          */
N#define SYS_BODCTL_BODRSTEN_Msk          (0x1ul << SYS_BODCTL_BODRSTEN_Pos)                /*!< SYS_T::BODCTL: BODRSTEN Mask              */
N
N#define SYS_BODCTL_BODIF_Pos             (4)                                               /*!< SYS_T::BODCTL: BODIF Position             */
N#define SYS_BODCTL_BODIF_Msk             (0x1ul << SYS_BODCTL_BODIF_Pos)                   /*!< SYS_T::BODCTL: BODIF Mask                 */
N
N#define SYS_BODCTL_BODLPM_Pos            (5)                                               /*!< SYS_T::BODCTL: BODLPM Position            */
N#define SYS_BODCTL_BODLPM_Msk            (0x1ul << SYS_BODCTL_BODLPM_Pos)                  /*!< SYS_T::BODCTL: BODLPM Mask                */
N
N#define SYS_BODCTL_BODOUT_Pos            (6)                                               /*!< SYS_T::BODCTL: BODOUT Position            */
N#define SYS_BODCTL_BODOUT_Msk            (0x1ul << SYS_BODCTL_BODOUT_Pos)                  /*!< SYS_T::BODCTL: BODOUT Mask                */
N
N#define SYS_BODCTL_LVREN_Pos             (7)                                               /*!< SYS_T::BODCTL: LVREN Position             */
N#define SYS_BODCTL_LVREN_Msk             (0x1ul << SYS_BODCTL_LVREN_Pos)                   /*!< SYS_T::BODCTL: LVREN Mask                 */
N
N#define SYS_BODCTL_BODDGSEL_Pos          (8)                                               /*!< SYS_T::BODCTL: BODDGSEL Position          */
N#define SYS_BODCTL_BODDGSEL_Msk          (0x7ul << SYS_BODCTL_BODDGSEL_Pos)                /*!< SYS_T::BODCTL: BODDGSEL Mask              */
N
N#define SYS_BODCTL_LVRDGSEL_Pos          (12)                                              /*!< SYS_T::BODCTL: LVRDGSEL Position          */
N#define SYS_BODCTL_LVRDGSEL_Msk          (0x7ul << SYS_BODCTL_LVRDGSEL_Pos)                /*!< SYS_T::BODCTL: LVRDGSEL Mask              */
N
N#define SYS_IVSCTL_VTEMPEN_Pos           (0)                                               /*!< SYS_T::IVSCTL: VTEMPEN Position           */
N#define SYS_IVSCTL_VTEMPEN_Msk           (0x1ul << SYS_IVSCTL_VTEMPEN_Pos)                 /*!< SYS_T::IVSCTL: VTEMPEN Mask               */
N
N#define SYS_IVSCTL_VBATUGEN_Pos          (1)                                               /*!< SYS_T::IVSCTL: VBATUGEN Position          */
N#define SYS_IVSCTL_VBATUGEN_Msk          (0x1ul << SYS_IVSCTL_VBATUGEN_Pos)                /*!< SYS_T::IVSCTL: VBATUGEN Mask              */
N
N#define SYS_PORCTL_POROFF_Pos            (0)                                               /*!< SYS_T::PORCTL: POROFF Position            */
N#define SYS_PORCTL_POROFF_Msk            (0xfffful << SYS_PORCTL_POROFF_Pos)               /*!< SYS_T::PORCTL: POROFF Mask                */
N
N#define SYS_VREFCTL_VREFCTL_Pos          (0)                                               /*!< SYS_T::VREFCTL: VREFCTL Position          */
N#define SYS_VREFCTL_VREFCTL_Msk          (0x1ful << SYS_VREFCTL_VREFCTL_Pos)               /*!< SYS_T::VREFCTL: VREFCTL Mask              */
N
N#define SYS_USBPHY_USBROLE_Pos           (0)                                               /*!< SYS_T::USBPHY: USBROLE Position           */
N#define SYS_USBPHY_USBROLE_Msk           (0x3ul << SYS_USBPHY_USBROLE_Pos)                 /*!< SYS_T::USBPHY: USBROLE Mask               */
N
N#define SYS_USBPHY_LDO33EN_Pos           (8)                                               /*!< SYS_T::USBPHY: LDO33EN Position           */
N#define SYS_USBPHY_LDO33EN_Msk           (0x1ul << SYS_USBPHY_LDO33EN_Pos)                 /*!< SYS_T::USBPHY: LDO33EN Mask               */
N
N#define SYS_GPA_MFPL_PA0MFP_Pos          (0)                                               /*!< SYS_T::GPA_MFPL: PA0MFP Position          */
N#define SYS_GPA_MFPL_PA0MFP_Msk          (0xful << SYS_GPA_MFPL_PA0MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA0MFP Mask              */
N
N#define SYS_GPA_MFPL_PA1MFP_Pos          (4)                                               /*!< SYS_T::GPA_MFPL: PA1MFP Position          */
N#define SYS_GPA_MFPL_PA1MFP_Msk          (0xful << SYS_GPA_MFPL_PA1MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA1MFP Mask              */
N
N#define SYS_GPA_MFPL_PA2MFP_Pos          (8)                                               /*!< SYS_T::GPA_MFPL: PA2MFP Position          */
N#define SYS_GPA_MFPL_PA2MFP_Msk          (0xful << SYS_GPA_MFPL_PA2MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA2MFP Mask              */
N
N#define SYS_GPA_MFPL_PA3MFP_Pos          (12)                                              /*!< SYS_T::GPA_MFPL: PA3MFP Position          */
N#define SYS_GPA_MFPL_PA3MFP_Msk          (0xful << SYS_GPA_MFPL_PA3MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA3MFP Mask              */
N
N#define SYS_GPA_MFPL_PA4MFP_Pos          (16)                                              /*!< SYS_T::GPA_MFPL: PA4MFP Position          */
N#define SYS_GPA_MFPL_PA4MFP_Msk          (0xful << SYS_GPA_MFPL_PA4MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA4MFP Mask              */
N
N#define SYS_GPA_MFPL_PA5MFP_Pos          (20)                                              /*!< SYS_T::GPA_MFPL: PA5MFP Position          */
N#define SYS_GPA_MFPL_PA5MFP_Msk          (0xful << SYS_GPA_MFPL_PA5MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA5MFP Mask              */
N
N#define SYS_GPA_MFPL_PA6MFP_Pos          (24)                                              /*!< SYS_T::GPA_MFPL: PA6MFP Position          */
N#define SYS_GPA_MFPL_PA6MFP_Msk          (0xful << SYS_GPA_MFPL_PA6MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA6MFP Mask              */
N
N#define SYS_GPA_MFPL_PA7MFP_Pos          (28)                                              /*!< SYS_T::GPA_MFPL: PA7MFP Position          */
N#define SYS_GPA_MFPL_PA7MFP_Msk          (0xful << SYS_GPA_MFPL_PA7MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA7MFP Mask              */
N
N#define SYS_GPA_MFPH_PA8MFP_Pos          (0)                                               /*!< SYS_T::GPA_MFPH: PA8MFP Position          */
N#define SYS_GPA_MFPH_PA8MFP_Msk          (0xful << SYS_GPA_MFPH_PA8MFP_Pos)                /*!< SYS_T::GPA_MFPH: PA8MFP Mask              */
N
N#define SYS_GPA_MFPH_PA9MFP_Pos          (4)                                               /*!< SYS_T::GPA_MFPH: PA9MFP Position          */
N#define SYS_GPA_MFPH_PA9MFP_Msk          (0xful << SYS_GPA_MFPH_PA9MFP_Pos)                /*!< SYS_T::GPA_MFPH: PA9MFP Mask              */
N
N#define SYS_GPA_MFPH_PA10MFP_Pos         (8)                                               /*!< SYS_T::GPA_MFPH: PA10MFP Position         */
N#define SYS_GPA_MFPH_PA10MFP_Msk         (0xful << SYS_GPA_MFPH_PA10MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA10MFP Mask             */
N
N#define SYS_GPA_MFPH_PA11MFP_Pos         (12)                                              /*!< SYS_T::GPA_MFPH: PA11MFP Position         */
N#define SYS_GPA_MFPH_PA11MFP_Msk         (0xful << SYS_GPA_MFPH_PA11MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA11MFP Mask             */
N
N#define SYS_GPA_MFPH_PA12MFP_Pos         (16)                                              /*!< SYS_T::GPA_MFPH: PA12MFP Position         */
N#define SYS_GPA_MFPH_PA12MFP_Msk         (0xful << SYS_GPA_MFPH_PA12MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA12MFP Mask             */
N
N#define SYS_GPA_MFPH_PA13MFP_Pos         (20)                                              /*!< SYS_T::GPA_MFPH: PA13MFP Position         */
N#define SYS_GPA_MFPH_PA13MFP_Msk         (0xful << SYS_GPA_MFPH_PA13MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA13MFP Mask             */
N
N#define SYS_GPA_MFPH_PA14MFP_Pos         (24)                                              /*!< SYS_T::GPA_MFPH: PA14MFP Position         */
N#define SYS_GPA_MFPH_PA14MFP_Msk         (0xful << SYS_GPA_MFPH_PA14MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA14MFP Mask             */
N
N#define SYS_GPA_MFPH_PA15MFP_Pos         (28)                                              /*!< SYS_T::GPA_MFPH: PA15MFP Position         */
N#define SYS_GPA_MFPH_PA15MFP_Msk         (0xful << SYS_GPA_MFPH_PA15MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA15MFP Mask             */
N
N#define SYS_GPB_MFPL_PB0MFP_Pos          (0)                                               /*!< SYS_T::GPB_MFPL: PB0MFP Position          */
N#define SYS_GPB_MFPL_PB0MFP_Msk          (0xful << SYS_GPB_MFPL_PB0MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB0MFP Mask              */
N
N#define SYS_GPB_MFPL_PB1MFP_Pos          (4)                                               /*!< SYS_T::GPB_MFPL: PB1MFP Position          */
N#define SYS_GPB_MFPL_PB1MFP_Msk          (0xful << SYS_GPB_MFPL_PB1MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB1MFP Mask              */
N
N#define SYS_GPB_MFPL_PB2MFP_Pos          (8)                                               /*!< SYS_T::GPB_MFPL: PB2MFP Position          */
N#define SYS_GPB_MFPL_PB2MFP_Msk          (0xful << SYS_GPB_MFPL_PB2MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB2MFP Mask              */
N
N#define SYS_GPB_MFPL_PB3MFP_Pos          (12)                                              /*!< SYS_T::GPB_MFPL: PB3MFP Position          */
N#define SYS_GPB_MFPL_PB3MFP_Msk          (0xful << SYS_GPB_MFPL_PB3MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB3MFP Mask              */
N
N#define SYS_GPB_MFPL_PB4MFP_Pos          (16)                                              /*!< SYS_T::GPB_MFPL: PB4MFP Position          */
N#define SYS_GPB_MFPL_PB4MFP_Msk          (0xful << SYS_GPB_MFPL_PB4MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB4MFP Mask              */
N
N#define SYS_GPB_MFPL_PB5MFP_Pos          (20)                                              /*!< SYS_T::GPB_MFPL: PB5MFP Position          */
N#define SYS_GPB_MFPL_PB5MFP_Msk          (0xful << SYS_GPB_MFPL_PB5MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB5MFP Mask              */
N
N#define SYS_GPB_MFPL_PB6MFP_Pos          (24)                                              /*!< SYS_T::GPB_MFPL: PB6MFP Position          */
N#define SYS_GPB_MFPL_PB6MFP_Msk          (0xful << SYS_GPB_MFPL_PB6MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB6MFP Mask              */
N
N#define SYS_GPB_MFPL_PB7MFP_Pos          (28)                                              /*!< SYS_T::GPB_MFPL: PB7MFP Position          */
N#define SYS_GPB_MFPL_PB7MFP_Msk          (0xful << SYS_GPB_MFPL_PB7MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB7MFP Mask              */
N
N#define SYS_GPB_MFPH_PB8MFP_Pos          (0)                                               /*!< SYS_T::GPB_MFPH: PB8MFP Position          */
N#define SYS_GPB_MFPH_PB8MFP_Msk          (0xful << SYS_GPB_MFPH_PB8MFP_Pos)                /*!< SYS_T::GPB_MFPH: PB8MFP Mask              */
N
N#define SYS_GPB_MFPH_PB9MFP_Pos          (4)                                               /*!< SYS_T::GPB_MFPH: PB9MFP Position          */
N#define SYS_GPB_MFPH_PB9MFP_Msk          (0xful << SYS_GPB_MFPH_PB9MFP_Pos)                /*!< SYS_T::GPB_MFPH: PB9MFP Mask              */
N
N#define SYS_GPB_MFPH_PB10MFP_Pos         (8)                                               /*!< SYS_T::GPB_MFPH: PB10MFP Position         */
N#define SYS_GPB_MFPH_PB10MFP_Msk         (0xful << SYS_GPB_MFPH_PB10MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB10MFP Mask             */
N
N#define SYS_GPB_MFPH_PB11MFP_Pos         (12)                                              /*!< SYS_T::GPB_MFPH: PB11MFP Position         */
N#define SYS_GPB_MFPH_PB11MFP_Msk         (0xful << SYS_GPB_MFPH_PB11MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB11MFP Mask             */
N
N#define SYS_GPB_MFPH_PB12MFP_Pos         (16)                                              /*!< SYS_T::GPB_MFPH: PB12MFP Position         */
N#define SYS_GPB_MFPH_PB12MFP_Msk         (0xful << SYS_GPB_MFPH_PB12MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB12MFP Mask             */
N
N#define SYS_GPB_MFPH_PB13MFP_Pos         (20)                                              /*!< SYS_T::GPB_MFPH: PB13MFP Position         */
N#define SYS_GPB_MFPH_PB13MFP_Msk         (0xful << SYS_GPB_MFPH_PB13MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB13MFP Mask             */
N
N#define SYS_GPB_MFPH_PB14MFP_Pos         (24)                                              /*!< SYS_T::GPB_MFPH: PB14MFP Position         */
N#define SYS_GPB_MFPH_PB14MFP_Msk         (0xful << SYS_GPB_MFPH_PB14MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB14MFP Mask             */
N
N#define SYS_GPB_MFPH_PB15MFP_Pos         (28)                                              /*!< SYS_T::GPB_MFPH: PB15MFP Position         */
N#define SYS_GPB_MFPH_PB15MFP_Msk         (0xful << SYS_GPB_MFPH_PB15MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB15MFP Mask             */
N
N#define SYS_GPC_MFPL_PC0MFP_Pos          (0)                                               /*!< SYS_T::GPC_MFPL: PC0MFP Position          */
N#define SYS_GPC_MFPL_PC0MFP_Msk          (0xful << SYS_GPC_MFPL_PC0MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC0MFP Mask              */
N
N#define SYS_GPC_MFPL_PC1MFP_Pos          (4)                                               /*!< SYS_T::GPC_MFPL: PC1MFP Position          */
N#define SYS_GPC_MFPL_PC1MFP_Msk          (0xful << SYS_GPC_MFPL_PC1MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC1MFP Mask              */
N
N#define SYS_GPC_MFPL_PC2MFP_Pos          (8)                                               /*!< SYS_T::GPC_MFPL: PC2MFP Position          */
N#define SYS_GPC_MFPL_PC2MFP_Msk          (0xful << SYS_GPC_MFPL_PC2MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC2MFP Mask              */
N
N#define SYS_GPC_MFPL_PC3MFP_Pos          (12)                                              /*!< SYS_T::GPC_MFPL: PC3MFP Position          */
N#define SYS_GPC_MFPL_PC3MFP_Msk          (0xful << SYS_GPC_MFPL_PC3MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC3MFP Mask              */
N
N#define SYS_GPC_MFPL_PC4MFP_Pos          (16)                                              /*!< SYS_T::GPC_MFPL: PC4MFP Position          */
N#define SYS_GPC_MFPL_PC4MFP_Msk          (0xful << SYS_GPC_MFPL_PC4MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC4MFP Mask              */
N
N#define SYS_GPC_MFPL_PC5MFP_Pos          (20)                                              /*!< SYS_T::GPC_MFPL: PC5MFP Position          */
N#define SYS_GPC_MFPL_PC5MFP_Msk          (0xful << SYS_GPC_MFPL_PC5MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC5MFP Mask              */
N
N#define SYS_GPC_MFPL_PC6MFP_Pos          (24)                                              /*!< SYS_T::GPC_MFPL: PC6MFP Position          */
N#define SYS_GPC_MFPL_PC6MFP_Msk          (0xful << SYS_GPC_MFPL_PC6MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC6MFP Mask              */
N
N#define SYS_GPC_MFPL_PC7MFP_Pos          (28)                                              /*!< SYS_T::GPC_MFPL: PC7MFP Position          */
N#define SYS_GPC_MFPL_PC7MFP_Msk          (0xful << SYS_GPC_MFPL_PC7MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC7MFP Mask              */
N
N#define SYS_GPC_MFPH_PC8MFP_Pos          (0)                                               /*!< SYS_T::GPC_MFPH: PC8MFP Position          */
N#define SYS_GPC_MFPH_PC8MFP_Msk          (0xful << SYS_GPC_MFPH_PC8MFP_Pos)                /*!< SYS_T::GPC_MFPH: PC8MFP Mask              */
N
N#define SYS_GPC_MFPH_PC9MFP_Pos          (4)                                               /*!< SYS_T::GPC_MFPH: PC9MFP Position          */
N#define SYS_GPC_MFPH_PC9MFP_Msk          (0xful << SYS_GPC_MFPH_PC9MFP_Pos)                /*!< SYS_T::GPC_MFPH: PC9MFP Mask              */
N
N#define SYS_GPC_MFPH_PC10MFP_Pos         (8)                                               /*!< SYS_T::GPC_MFPH: PC10MFP Position         */
N#define SYS_GPC_MFPH_PC10MFP_Msk         (0xful << SYS_GPC_MFPH_PC10MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC10MFP Mask             */
N
N#define SYS_GPC_MFPH_PC11MFP_Pos         (12)                                              /*!< SYS_T::GPC_MFPH: PC11MFP Position         */
N#define SYS_GPC_MFPH_PC11MFP_Msk         (0xful << SYS_GPC_MFPH_PC11MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC11MFP Mask             */
N
N#define SYS_GPC_MFPH_PC12MFP_Pos         (16)                                              /*!< SYS_T::GPC_MFPH: PC12MFP Position         */
N#define SYS_GPC_MFPH_PC12MFP_Msk         (0xful << SYS_GPC_MFPH_PC12MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC12MFP Mask             */
N
N#define SYS_GPC_MFPH_PC13MFP_Pos         (20)                                              /*!< SYS_T::GPC_MFPH: PC13MFP Position         */
N#define SYS_GPC_MFPH_PC13MFP_Msk         (0xful << SYS_GPC_MFPH_PC13MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC13MFP Mask             */
N
N#define SYS_GPC_MFPH_PC14MFP_Pos         (24)                                              /*!< SYS_T::GPC_MFPH: PC14MFP Position         */
N#define SYS_GPC_MFPH_PC14MFP_Msk         (0xful << SYS_GPC_MFPH_PC14MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC14MFP Mask             */
N
N#define SYS_GPC_MFPH_PC15MFP_Pos         (28)                                              /*!< SYS_T::GPC_MFPH: PC15MFP Position         */
N#define SYS_GPC_MFPH_PC15MFP_Msk         (0xful << SYS_GPC_MFPH_PC15MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC15MFP Mask             */
N
N#define SYS_GPD_MFPL_PD0MFP_Pos          (0)                                               /*!< SYS_T::GPD_MFPL: PD0MFP Position          */
N#define SYS_GPD_MFPL_PD0MFP_Msk          (0xful << SYS_GPD_MFPL_PD0MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD0MFP Mask              */
N
N#define SYS_GPD_MFPL_PD1MFP_Pos          (4)                                               /*!< SYS_T::GPD_MFPL: PD1MFP Position          */
N#define SYS_GPD_MFPL_PD1MFP_Msk          (0xful << SYS_GPD_MFPL_PD1MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD1MFP Mask              */
N
N#define SYS_GPD_MFPL_PD2MFP_Pos          (8)                                               /*!< SYS_T::GPD_MFPL: PD2MFP Position          */
N#define SYS_GPD_MFPL_PD2MFP_Msk          (0xful << SYS_GPD_MFPL_PD2MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD2MFP Mask              */
N
N#define SYS_GPD_MFPL_PD3MFP_Pos          (12)                                              /*!< SYS_T::GPD_MFPL: PD3MFP Position          */
N#define SYS_GPD_MFPL_PD3MFP_Msk          (0xful << SYS_GPD_MFPL_PD3MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD3MFP Mask              */
N
N#define SYS_GPD_MFPL_PD4MFP_Pos          (16)                                              /*!< SYS_T::GPD_MFPL: PD4MFP Position          */
N#define SYS_GPD_MFPL_PD4MFP_Msk          (0xful << SYS_GPD_MFPL_PD4MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD4MFP Mask              */
N
N#define SYS_GPD_MFPL_PD5MFP_Pos          (20)                                              /*!< SYS_T::GPD_MFPL: PD5MFP Position          */
N#define SYS_GPD_MFPL_PD5MFP_Msk          (0xful << SYS_GPD_MFPL_PD5MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD5MFP Mask              */
N
N#define SYS_GPD_MFPL_PD6MFP_Pos          (24)                                              /*!< SYS_T::GPD_MFPL: PD6MFP Position          */
N#define SYS_GPD_MFPL_PD6MFP_Msk          (0xful << SYS_GPD_MFPL_PD6MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD6MFP Mask              */
N
N#define SYS_GPD_MFPL_PD7MFP_Pos          (28)                                              /*!< SYS_T::GPD_MFPL: PD7MFP Position          */
N#define SYS_GPD_MFPL_PD7MFP_Msk          (0xful << SYS_GPD_MFPL_PD7MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD7MFP Mask              */
N
N#define SYS_GPD_MFPH_PD8MFP_Pos          (0)                                               /*!< SYS_T::GPD_MFPH: PD8MFP Position          */
N#define SYS_GPD_MFPH_PD8MFP_Msk          (0xful << SYS_GPD_MFPH_PD8MFP_Pos)                /*!< SYS_T::GPD_MFPH: PD8MFP Mask              */
N
N#define SYS_GPD_MFPH_PD9MFP_Pos          (4)                                               /*!< SYS_T::GPD_MFPH: PD9MFP Position          */
N#define SYS_GPD_MFPH_PD9MFP_Msk          (0xful << SYS_GPD_MFPH_PD9MFP_Pos)                /*!< SYS_T::GPD_MFPH: PD9MFP Mask              */
N
N#define SYS_GPD_MFPH_PD10MFP_Pos         (8)                                               /*!< SYS_T::GPD_MFPH: PD10MFP Position         */
N#define SYS_GPD_MFPH_PD10MFP_Msk         (0xful << SYS_GPD_MFPH_PD10MFP_Pos)              /*!< SYS_T::GPD_MFPH: PD10MFP Mask              */
N
N#define SYS_GPD_MFPH_PD11MFP_Pos         (12)                                              /*!< SYS_T::GPD_MFPH: PD11MFP Position         */
N#define SYS_GPD_MFPH_PD11MFP_Msk         (0xful << SYS_GPD_MFPH_PD11MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD11MFP Mask             */
N
N#define SYS_GPD_MFPH_PD12MFP_Pos         (16)                                              /*!< SYS_T::GPD_MFPH: PD12MFP Position         */
N#define SYS_GPD_MFPH_PD12MFP_Msk         (0xful << SYS_GPD_MFPH_PD12MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD12MFP Mask             */
N
N#define SYS_GPD_MFPH_PD13MFP_Pos         (20)                                              /*!< SYS_T::GPD_MFPH: PD13MFP Position         */
N#define SYS_GPD_MFPH_PD13MFP_Msk         (0xful << SYS_GPD_MFPH_PD13MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD13MFP Mask             */
N
N#define SYS_GPD_MFPH_PD14MFP_Pos         (24)                                              /*!< SYS_T::GPD_MFPH: PD14MFP Position         */
N#define SYS_GPD_MFPH_PD14MFP_Msk         (0xful << SYS_GPD_MFPH_PD14MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD14MFP Mask             */
N
N#define SYS_GPD_MFPH_PD15MFP_Pos         (28)                                              /*!< SYS_T::GPD_MFPH: PD15MFP Position         */
N#define SYS_GPD_MFPH_PD15MFP_Msk         (0xful << SYS_GPD_MFPH_PD15MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD15MFP Mask             */
N
N#define SYS_GPE_MFPL_PE0MFP_Pos          (0)                                               /*!< SYS_T::GPE_MFPL: PE0MFP Position          */
N#define SYS_GPE_MFPL_PE0MFP_Msk          (0xful << SYS_GPE_MFPL_PE0MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE0MFP Mask              */
N
N#define SYS_GPE_MFPL_PE1MFP_Pos          (4)                                               /*!< SYS_T::GPE_MFPL: PE1MFP Position          */
N#define SYS_GPE_MFPL_PE1MFP_Msk          (0xful << SYS_GPE_MFPL_PE1MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE1MFP Mask              */
N
N#define SYS_GPE_MFPL_PE2MFP_Pos          (8)                                               /*!< SYS_T::GPE_MFPL: PE2MFP Position          */
N#define SYS_GPE_MFPL_PE2MFP_Msk          (0xful << SYS_GPE_MFPL_PE2MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE2MFP Mask              */
N
N#define SYS_GPE_MFPL_PE3MFP_Pos          (12)                                              /*!< SYS_T::GPE_MFPL: PE3MFP Position          */
N#define SYS_GPE_MFPL_PE3MFP_Msk          (0xful << SYS_GPE_MFPL_PE3MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE3MFP Mask              */
N
N#define SYS_GPE_MFPL_PE4MFP_Pos          (16)                                              /*!< SYS_T::GPE_MFPL: PE4MFP Position          */
N#define SYS_GPE_MFPL_PE4MFP_Msk          (0xful << SYS_GPE_MFPL_PE4MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE4MFP Mask              */
N
N#define SYS_GPE_MFPL_PE5MFP_Pos          (20)                                              /*!< SYS_T::GPE_MFPL: PE5MFP Position          */
N#define SYS_GPE_MFPL_PE5MFP_Msk          (0xful << SYS_GPE_MFPL_PE5MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE5MFP Mask              */
N
N#define SYS_GPE_MFPL_PE6MFP_Pos          (24)                                              /*!< SYS_T::GPE_MFPL: PE6MFP Position          */
N#define SYS_GPE_MFPL_PE6MFP_Msk          (0xful << SYS_GPE_MFPL_PE6MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE6MFP Mask              */
N
N#define SYS_GPE_MFPL_PE7MFP_Pos          (28)                                              /*!< SYS_T::GPE_MFPL: PE7MFP Position          */
N#define SYS_GPE_MFPL_PE7MFP_Msk          (0xful << SYS_GPE_MFPL_PE7MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE7MFP Mask              */
N
N#define SYS_GPE_MFPH_PE8MFP_Pos          (0)                                               /*!< SYS_T::GPE_MFPH: PE8MFP Position          */
N#define SYS_GPE_MFPH_PE8MFP_Msk          (0xful << SYS_GPE_MFPH_PE8MFP_Pos)                /*!< SYS_T::GPE_MFPH: PE8MFP Mask              */
N
N#define SYS_GPE_MFPH_PE9MFP_Pos          (4)                                               /*!< SYS_T::GPE_MFPH: PE9MFP Position          */
N#define SYS_GPE_MFPH_PE9MFP_Msk          (0xful << SYS_GPE_MFPH_PE9MFP_Pos)                /*!< SYS_T::GPE_MFPH: PE9MFP Mask              */
N
N#define SYS_GPE_MFPH_PE10MFP_Pos         (8)                                               /*!< SYS_T::GPE_MFPH: PE10MFP Position         */
N#define SYS_GPE_MFPH_PE10MFP_Msk         (0xful << SYS_GPE_MFPH_PE10MFP_Pos)               /*!< SYS_T::GPE_MFPH: PE10MFP Mask             */
N
N#define SYS_GPE_MFPH_PE11MFP_Pos         (12)                                              /*!< SYS_T::GPE_MFPH: PE11MFP Position         */
N#define SYS_GPE_MFPH_PE11MFP_Msk         (0xful << SYS_GPE_MFPH_PE11MFP_Pos)               /*!< SYS_T::GPE_MFPH: PE11MFP Mask             */
N
N#define SYS_GPE_MFPH_PE12MFP_Pos         (16)                                              /*!< SYS_T::GPE_MFPH: PE12MFP Position         */
N#define SYS_GPE_MFPH_PE12MFP_Msk         (0xful << SYS_GPE_MFPH_PE12MFP_Pos)               /*!< SYS_T::GPE_MFPH: PE12MFP Mask             */
N
N#define SYS_GPE_MFPH_PE13MFP_Pos         (20)                                              /*!< SYS_T::GPE_MFPH: PE13MFP Position         */
N#define SYS_GPE_MFPH_PE13MFP_Msk         (0xful << SYS_GPE_MFPH_PE13MFP_Pos)               /*!< SYS_T::GPE_MFPH: PE13MFP Mask             */
N
N#define SYS_GPE_MFPH_PE14MFP_Pos         (24)                                              /*!< SYS_T::GPE_MFPH: PE14MFP Position         */
N#define SYS_GPE_MFPH_PE14MFP_Msk         (0xful << SYS_GPE_MFPH_PE14MFP_Pos)               /*!< SYS_T::GPE_MFPH: PE14MFP Mask             */
N
N#define SYS_GPF_MFPL_PF0MFP_Pos          (0)                                               /*!< SYS_T::GPF_MFPL: PF0MFP Position          */
N#define SYS_GPF_MFPL_PF0MFP_Msk          (0xful << SYS_GPF_MFPL_PF0MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF0MFP Mask              */
N
N#define SYS_GPF_MFPL_PF1MFP_Pos          (4)                                               /*!< SYS_T::GPF_MFPL: PF1MFP Position          */
N#define SYS_GPF_MFPL_PF1MFP_Msk          (0xful << SYS_GPF_MFPL_PF1MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF1MFP Mask              */
N
N#define SYS_GPF_MFPL_PF2MFP_Pos          (8)                                               /*!< SYS_T::GPF_MFPL: PF2MFP Position          */
N#define SYS_GPF_MFPL_PF2MFP_Msk          (0xful << SYS_GPF_MFPL_PF2MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF2MFP Mask              */
N
N#define SYS_GPF_MFPL_PF3MFP_Pos          (12)                                              /*!< SYS_T::GPF_MFPL: PF3MFP Position          */
N#define SYS_GPF_MFPL_PF3MFP_Msk          (0xful << SYS_GPF_MFPL_PF3MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF3MFP Mask              */
N
N#define SYS_GPF_MFPL_PF4MFP_Pos          (16)                                              /*!< SYS_T::GPF_MFPL: PF4MFP Position          */
N#define SYS_GPF_MFPL_PF4MFP_Msk          (0xful << SYS_GPF_MFPL_PF4MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF4MFP Mask              */
N
N#define SYS_GPF_MFPL_PF5MFP_Pos          (20)                                              /*!< SYS_T::GPF_MFPL: PF5MFP Position          */
N#define SYS_GPF_MFPL_PF5MFP_Msk          (0xful << SYS_GPF_MFPL_PF5MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF5MFP Mask              */
N
N#define SYS_GPF_MFPL_PF6MFP_Pos          (24)                                              /*!< SYS_T::GPF_MFPL: PF6MFP Position          */
N#define SYS_GPF_MFPL_PF6MFP_Msk          (0xful << SYS_GPF_MFPL_PF6MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF6MFP Mask              */
N
N#define SYS_GPF_MFPL_PF7MFP_Pos          (28)                                              /*!< SYS_T::GPF_MFPL: PF7MFP Position          */
N#define SYS_GPF_MFPL_PF7MFP_Msk          (0xful << SYS_GPF_MFPL_PF7MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF7MFP Mask              */
N
N#define SYS_SRAM_INTCTL_PERRIEN_Pos      (0)                                               /*!< SYS_T::SRAM_INTCTL: PERRIEN Position      */
N#define SYS_SRAM_INTCTL_PERRIEN_Msk      (0x1ul << SYS_SRAM_INTCTL_PERRIEN_Pos)            /*!< SYS_T::SRAM_INTCTL: PERRIEN Mask          */
N
N#define SYS_SRAM_STATUS_PERRIF_Pos       (0)                                               /*!< SYS_T::SRAM_STATUS: PERRIF Position       */
N#define SYS_SRAM_STATUS_PERRIF_Msk       (0x1ul << SYS_SRAM_STATUS_PERRIF_Pos)             /*!< SYS_T::SRAM_STATUS: PERRIF Mask           */
N
N#define SYS_SRAM_ERRADDR_ERRADDR_Pos     (0)                                               /*!< SYS_T::SRAM_ERRADDR: ERRADDR Position     */
N#define SYS_SRAM_ERRADDR_ERRADDR_Msk     (0xfffffffful << SYS_SRAM_ERRADDR_ERRADDR_Pos)    /*!< SYS_T::SRAM_ERRADDR: ERRADDR Mask         */
N
N#define SYS_SRAM_BISTCTL_SRBIST0_Pos     (0)                                               /*!< SYS_T::SRAM_BISTCTL: SRBIST0 Position     */
N#define SYS_SRAM_BISTCTL_SRBIST0_Msk     (0x1ul << SYS_SRAM_BISTCTL_SRBIST0_Pos)           /*!< SYS_T::SRAM_BISTCTL: SRBIST0 Mask         */
N
N#define SYS_SRAM_BISTCTL_SRBIST1_Pos     (1)                                               /*!< SYS_T::SRAM_BISTCTL: SRBIST1 Position     */
N#define SYS_SRAM_BISTCTL_SRBIST1_Msk     (0x1ul << SYS_SRAM_BISTCTL_SRBIST1_Pos)           /*!< SYS_T::SRAM_BISTCTL: SRBIST1 Mask         */
N
N#define SYS_SRAM_BISTCTL_CRBIST_Pos      (2)                                               /*!< SYS_T::SRAM_BISTCTL: CRBIST Position      */
N#define SYS_SRAM_BISTCTL_CRBIST_Msk      (0x1ul << SYS_SRAM_BISTCTL_CRBIST_Pos)            /*!< SYS_T::SRAM_BISTCTL: CRBIST Mask          */
N
N#define SYS_SRAM_BISTCTL_CANBIST_Pos     (3)                                               /*!< SYS_T::SRAM_BISTCTL: CANBIST Position     */
N#define SYS_SRAM_BISTCTL_CANBIST_Msk     (0x1ul << SYS_SRAM_BISTCTL_CANBIST_Pos)           /*!< SYS_T::SRAM_BISTCTL: CANBIST Mask         */
N
N#define SYS_SRAM_BISTCTL_USBBIST_Pos     (4)                                               /*!< SYS_T::SRAM_BISTCTL: USBBIST Position     */
N#define SYS_SRAM_BISTCTL_USBBIST_Msk     (0x1ul << SYS_SRAM_BISTCTL_USBBIST_Pos)           /*!< SYS_T::SRAM_BISTCTL: USBBIST Mask         */
N
N#define SYS_SRAM_BISTSTS_SRBISTEF0_Pos   (0)                                               /*!< SYS_T::SRAM_BISTSTS: SRBISTEF0 Position   */
N#define SYS_SRAM_BISTSTS_SRBISTEF0_Msk   (0x1ul << SYS_SRAM_BISTSTS_SRBISTEF0_Pos)         /*!< SYS_T::SRAM_BISTSTS: SRBISTEF0 Mask       */
N
N#define SYS_SRAM_BISTSTS_SRBISTEF1_Pos   (1)                                               /*!< SYS_T::SRAM_BISTSTS: SRBISTEF1 Position   */
N#define SYS_SRAM_BISTSTS_SRBISTEF1_Msk   (0x1ul << SYS_SRAM_BISTSTS_SRBISTEF1_Pos)         /*!< SYS_T::SRAM_BISTSTS: SRBISTEF1 Mask       */
N
N#define SYS_SRAM_BISTSTS_CRBISTEF_Pos    (2)                                               /*!< SYS_T::SRAM_BISTSTS: CRBISTEF Position    */
N#define SYS_SRAM_BISTSTS_CRBISTEF_Msk    (0x1ul << SYS_SRAM_BISTSTS_CRBISTEF_Pos)          /*!< SYS_T::SRAM_BISTSTS: CRBISTEF Mask        */
N
N#define SYS_SRAM_BISTSTS_CANBEF_Pos      (3)                                               /*!< SYS_T::SRAM_BISTSTS: CANBEF Position      */
N#define SYS_SRAM_BISTSTS_CANBEF_Msk      (0x1ul << SYS_SRAM_BISTSTS_CANBEF_Pos)            /*!< SYS_T::SRAM_BISTSTS: CANBEF Mask          */
N
N#define SYS_SRAM_BISTSTS_USBBEF_Pos      (4)                                               /*!< SYS_T::SRAM_BISTSTS: USBBEF Position      */
N#define SYS_SRAM_BISTSTS_USBBEF_Msk      (0x1ul << SYS_SRAM_BISTSTS_USBBEF_Pos)            /*!< SYS_T::SRAM_BISTSTS: USBBEF Mask          */
N
N#define SYS_SRAM_BISTSTS_SRBEND0_Pos     (16)                                              /*!< SYS_T::SRAM_BISTSTS: SRBEND0 Position     */
N#define SYS_SRAM_BISTSTS_SRBEND0_Msk     (0x1ul << SYS_SRAM_BISTSTS_SRBEND0_Pos)           /*!< SYS_T::SRAM_BISTSTS: SRBEND0 Mask         */
N
N#define SYS_SRAM_BISTSTS_SRBEND1_Pos     (17)                                              /*!< SYS_T::SRAM_BISTSTS: SRBEND1 Position     */
N#define SYS_SRAM_BISTSTS_SRBEND1_Msk     (0x1ul << SYS_SRAM_BISTSTS_SRBEND1_Pos)           /*!< SYS_T::SRAM_BISTSTS: SRBEND1 Mask         */
N
N#define SYS_SRAM_BISTSTS_CRBEND_Pos      (18)                                              /*!< SYS_T::SRAM_BISTSTS: CRBEND Position      */
N#define SYS_SRAM_BISTSTS_CRBEND_Msk      (0x1ul << SYS_SRAM_BISTSTS_CRBEND_Pos)            /*!< SYS_T::SRAM_BISTSTS: CRBEND Mask          */
N
N#define SYS_SRAM_BISTSTS_CANBEND_Pos     (19)                                              /*!< SYS_T::SRAM_BISTSTS: CANBEND Position     */
N#define SYS_SRAM_BISTSTS_CANBEND_Msk     (0x1ul << SYS_SRAM_BISTSTS_CANBEND_Pos)           /*!< SYS_T::SRAM_BISTSTS: CANBEND Mask         */
N
N#define SYS_SRAM_BISTSTS_USBBEND_Pos     (20)                                              /*!< SYS_T::SRAM_BISTSTS: USBBEND Position     */
N#define SYS_SRAM_BISTSTS_USBBEND_Msk     (0x1ul << SYS_SRAM_BISTSTS_USBBEND_Pos)           /*!< SYS_T::SRAM_BISTSTS: USBBEND Mask         */
N
N#define SYS_IRCTCTL_FREQSEL_Pos          (0)                                               /*!< SYS_T::IRCTCTL: FREQSEL Position          */
N#define SYS_IRCTCTL_FREQSEL_Msk          (0x3ul << SYS_IRCTCTL_FREQSEL_Pos)                /*!< SYS_T::IRCTCTL: FREQSEL Mask              */
N
N#define SYS_IRCTCTL_LOOPSEL_Pos          (4)                                               /*!< SYS_T::IRCTCTL: LOOPSEL Position          */
N#define SYS_IRCTCTL_LOOPSEL_Msk          (0x3ul << SYS_IRCTCTL_LOOPSEL_Pos)                /*!< SYS_T::IRCTCTL: LOOPSEL Mask              */
N
N#define SYS_IRCTCTL_RETRYCNT_Pos         (6)                                               /*!< SYS_T::IRCTCTL: RETRYCNT Position         */
N#define SYS_IRCTCTL_RETRYCNT_Msk         (0x3ul << SYS_IRCTCTL_RETRYCNT_Pos)               /*!< SYS_T::IRCTCTL: RETRYCNT Mask             */
N
N#define SYS_IRCTCTL_CESTOPEN_Pos         (8)                                               /*!< SYS_T::IRCTCTL: CESTOPEN Position         */
N#define SYS_IRCTCTL_CESTOPEN_Msk         (0x1ul << SYS_IRCTCTL_CESTOPEN_Pos)               /*!< SYS_T::IRCTCTL: CESTOPEN Mask             */
N
N#define SYS_IRCTIEN_TFAILIEN_Pos         (1)                                               /*!< SYS_T::IRCTIEN: TFAILIEN Position         */
N#define SYS_IRCTIEN_TFAILIEN_Msk         (0x1ul << SYS_IRCTIEN_TFAILIEN_Pos)               /*!< SYS_T::IRCTIEN: TFAILIEN Mask             */
N
N#define SYS_IRCTIEN_CLKEIEN_Pos          (2)                                               /*!< SYS_T::IRCTIEN: CLKEIEN Position          */
N#define SYS_IRCTIEN_CLKEIEN_Msk          (0x1ul << SYS_IRCTIEN_CLKEIEN_Pos)                /*!< SYS_T::IRCTIEN: CLKEIEN Mask              */
N
N#define SYS_IRCTISTS_FREQLOCK_Pos        (0)                                               /*!< SYS_T::IRCTISTS: FREQLOCK Position        */
N#define SYS_IRCTISTS_FREQLOCK_Msk        (0x1ul << SYS_IRCTISTS_FREQLOCK_Pos)              /*!< SYS_T::IRCTISTS: FREQLOCK Mask            */
N
N#define SYS_IRCTISTS_TFAILIF_Pos         (1)                                               /*!< SYS_T::IRCTISTS: TFAILIF Position         */
N#define SYS_IRCTISTS_TFAILIF_Msk         (0x1ul << SYS_IRCTISTS_TFAILIF_Pos)               /*!< SYS_T::IRCTISTS: TFAILIF Mask             */
N
N#define SYS_IRCTISTS_CLKERRIF_Pos        (2)                                               /*!< SYS_T::IRCTISTS: CLKERRIF Position        */
N#define SYS_IRCTISTS_CLKERRIF_Msk        (0x1ul << SYS_IRCTISTS_CLKERRIF_Pos)              /*!< SYS_T::IRCTISTS: CLKERRIF Mask            */
N
N#define SYS_REGLCTL_REGLCTL_Pos          (0)                                               /*!< SYS_T::REGLCTL: REGLCTL Position          */
N#define SYS_REGLCTL_REGLCTL_Msk          (0xfful << SYS_REGLCTL_REGLCTL_Pos)               /*!< SYS_T::REGLCTL: REGLCTL Mask              */
N
N/**@}*/ /* SYS_CONST */
N
N
Ntypedef struct
N{
N
N/**
N * @var SYS_INT_T::NMIEN
N * Offset: 0x00  NMI Source Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |BODOUT    |BOD NMI Source Enable (Write Protect)
N * |        |          |0 = BOD NMI source Disabled.
N * |        |          |1 = BOD NMI source Enabled.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.    
N * |[1]     |IRC_INT   |IRC TRIM NMI Source Enable (Write Protect)
N * |        |          |0 = IRC TRIM NMI source Disabled.
N * |        |          |1 = IRC TRIM NMI source Enabled.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.   
N * |[2]     |PWRWU_INT |Power-Down Mode Wake-Up NMI Source Enable (Write Protect)
N * |        |          |0 = Power-down mode wake-up NMI source Disabled.
N * |        |          |1 = Power-down mode wake-up NMI source Enabled.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.    
N * |[3]     |SRAM_PERR   |SRAM ParityCheck Error NMI Source Enable (Write Protect)
N * |        |          |0 = SRAM parity check error NMI source Disabled.
N * |        |          |1 = SRAM parity check error NMI source Enabled.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.    
N * |[4]     |CLKFAIL   |Clock Fail Detected NMI Source Enable (Write Protect)
N * |        |          |0 = Clock fail detected interrupt NMI source Disabled.
N * |        |          |1 = Clock fail detected interrupt NMI source Enabled.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.    
N * |[6]     |RTC_INT   |RTC NMI Source Enable (Write Protect)
N * |        |          |0 = RTC NMI source Disabled.
N * |        |          |1 = RTC NMI source Enabled.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.    
N * |[7]     |TAMPER_INT|TAMPER_INT NMI Source Enable (Write Protect)
N * |        |          |0 = Backup register tamper detected interrupt.NMI source Disabled.
N * |        |          |1 = Backup register tamper detected interrupt.NMI source Enabled.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.     
N * |[8]     |EINT0     |External Interrupt From PA.0, PD.2 Or PE.4 Pin NMI Source Enable (Write Protect)
N * |        |          |0 = External interrupt from PA.0, PD.2 or PE.4 pin NMI source Disabled.
N * |        |          |1 = External interrupt from PA.0, PD.2 or PE.4 pin NMI source Enabled.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.        
N * |[9]     |EINT1     |External Interrupt From PB.0, PD.3 Or PE.5 Pin NMI Source Enable (Write Protect)
N * |        |          |0 = External interrupt from PB.0, PD.3 or PE.5 pin NMI source Disabled.
N * |        |          |1 = External interrupt from PB.0, PD.3 or PE.5 pin NMI source Enabled.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[10]    |EINT2     |External Interrupt From PC.0 Pin NMI Source Enable (Write Protect)
N * |        |          |0 = External interrupt from PC.0 pin NMI source Disabled.
N * |        |          |1 = External interrupt from PC.0 pin NMI source Enabled.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.       
N * |[11]    |EINT3     |External Interrupt From PD.0 Pin NMI Source Enable (Write Protect)
N * |        |          |0 = External interrupt from PD.0 pin NMI source Disabled.
N * |        |          |1 = External interrupt from PD.0 pin NMI source Enabled.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.     
N * |[12]    |EINT4     |External Interrupt From PE.0 Pin NMI Source Enable (Write Protect)
N * |        |          |0 = External interrupt from PE.0 pin NMI source Disabled.
N * |        |          |1 = External interrupt from PE.0 pin NMI source Enabled.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.      
N * |[13]    |EINT5     |External Interrupt From PF.0 Pin NMI Source Enable (Write Protect)
N * |        |          |0 = External interrupt from PF.0 pin NMI source Disabled.
N * |        |          |1 = External interrupt from PF.0 pin NMI source Enabled.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.     
N * |[14]    |UART0_INT |UART0 NMI Source Enable (Write Protect)
N * |        |          |0 = UART0 NMI source Disabled.
N * |        |          |1 = UART0 NMI source Enabled.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.    
N * |[15]    |UART1_INT |UART1 NMI Source Enable (Write Protect)
N * |        |          |0 = UART1 NMI source Disabled.
N * |        |          |1 = UART1 NMI source Enabled.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * @var SYS_INT_T::NMISTS
N * Offset: 0x04  NMI source interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |BODOUT    |BOD Interrupt Flag (Read Only)
N * |        |          |0 = BOD interrupt is deasserted.
N * |        |          |1 = BOD interrupt is asserted. 
N * |[1]     |IRC_INT   |IRC TRIM Interrupt Flag (Read Only)
N * |        |          |0 = HIRC TRIM interrupt is deasserted.
N * |        |          |1 = HIRC TRIM interrupt is asserted. 
N * |[2]     |PWRWU_INT |Power-Down Mode Wake-Up Interrupt Flag (Read Only)
N * |        |          |0 = Power-down mode wake-up interrupt is deasserted.
N * |        |          |1 = Power-down mode wake-up interrupt is asserted. 
N * |[3]     |SRAM_PERR |SRAM ParityCheck Error Interrupt Flag (Read Only)
N * |        |          |0 = SRAM parity check error interrupt is deasserted.
N * |        |          |1 = SRAM parity check error interrupt is asserted. 
N * |[4]     |CLKFAIL   |Clock Fail Detected Interrupt Flag (Read Only)
N * |        |          |0 = Clock fail detected interrupt is deasserted.
N * |        |          |1 = Clock fail detected interrupt is asserted.
N * |[6]     |RTC_INT   |RTC Interrupt Flag (Read Only)
N * |        |          |0 = RTC interrupt is deasserted.
N * |        |          |1 = RTC interrupt is asserted.
N * |[7]     |TAMPER_INT|TAMPER_INT Interrupt Flag (Read Only)
N * |        |          |0 = Backup register tamper detected interrupt is deasserted.
N * |        |          |1 = Backup register tamper detected interrupt is asserted.
N * |[8]     |EINT0     |External Interrupt From PA.0, PD.2 Or PE.4 Pin Interrupt Flag (Read Only)
N * |        |          |0 = External Interrupt from PA.0, PD.2 or PE.4 interrupt is deasserted.
N * |        |          |1 = External Interrupt from PA.0, PD.2 or PE.4 interrupt is asserted. 
N * |[9]     |EINT1     |External Interrupt From PB.0, PD.3 Or PE.5 Pin Interrupt Flag (Read Only)
N * |        |          |0 = External Interrupt from PB.0, PD.3 or PE.5 interrupt is deasserted.
N * |        |          |1 = External Interrupt from PB.0, PD.3 or PE.5 interrupt is asserted. 
N * |[10]    |EINT2     |External Interrupt From PC.0 Pin Interrupt Flag (Read Only)
N * |        |          |0 = External Interrupt from PC.0 interrupt is deasserted.
N * |        |          |1 = External Interrupt from PC.0 interrupt is asserted. 
N * |[11]    |EINT3     |External Interrupt From PD.0 Pin Interrupt Flag (Read Only)
N * |        |          |0 = External Interrupt from PD.0 interrupt is deasserted.
N * |        |          |1 = External Interrupt from PD.0 interrupt is asserted. 
N * |[12]    |EINT4     |External Interrupt From PE.0 Pin Interrupt Flag (Read Only)
N * |        |          |0 = External Interrupt from PE.0 interrupt is deasserted.
N * |        |          |1 = External Interrupt from PE.0 interrupt is asserted. 
N * |[13]    |EINT5     |External Interrupt From PF.0 Pin Interrupt Flag (Read Only)
N * |        |          |0 = External Interrupt from PF.0 interrupt is deasserted.
N * |        |          |1 = External Interrupt from PF.0 interrupt is asserted. 
N * |[14]    |UART0_INT |UART0 Interrupt Flag (Read Only)
N * |        |          |0 = UART1 interrupt is deasserted.
N * |        |          |1 = UART1 interrupt is asserted.
N * |[15]    |UART1_INT |UART1 Interrupt Flag (Read Only)
N * |        |          |0 = UART1 interrupt is deasserted.
N * |        |          |1 = UART1 interrupt is asserted.
N */
N
N    __IO  uint32_t NMIEN;          /* Offset: 0x00  NMI Source Interrupt Enable Register                               */
X    volatile  uint32_t NMIEN;           
N    __I   uint32_t NMISTS;         /* Offset: 0x04  NMI source interrupt Status Register                               */
X    volatile const   uint32_t NMISTS;          
N
N} SYS_INT_T;
N
N
N
N/**
N    @addtogroup INT_CONST INT Bit Field Definition
N    Constant Definitions for SYS Controller
N@{ */
N
N#define SYS_NMIEN_BODOUT_Pos             (0)                                               /*!< SYS_INT_T::NMIEN: BODOUT Position         */
N#define SYS_NMIEN_BODOUT_Msk             (0x1ul << SYS_NMIEN_BODOUT_Pos )                  /*!< SYS_INT_T::NMIEN: BODOUT Mask             */
N
N#define SYS_NMIEN_IRC_INT_Pos            (1)                                               /*!< SYS_INT_T::NMIEN: IRC_INT Position        */
N#define SYS_NMIEN_IRC_INT_Msk            (0x1ul << SYS_NMIEN_IRC_INT_Pos )                 /*!< SYS_INT_T::NMIEN: IRC_INT Mask            */
N
N#define SYS_NMIEN_PWRWU_INT_Pos          (2)                                               /*!< SYS_INT_T::NMIEN: PWRWU_INT Position      */
N#define SYS_NMIEN_PWRWU_INT_Msk          (0x1ul << SYS_NMIEN_PWRWU_INT_Pos )               /*!< SYS_INT_T::NMIEN: PWRWU_INT Mask          */
N
N#define SYS_NMIEN_SRAM_PERR_Pos          (3)                                               /*!< SYS_INT_T::NMIEN: SRAM_PERR Position      */
N#define SYS_NMIEN_SRAM_PERR_Msk          (0x1ul << SYS_NMIEN_SRAM_PERR_Pos )               /*!< SYS_INT_T::NMIEN: SRAM_PERR Mask          */
N
N#define SYS_NMIEN_CLKFAIL_Pos            (4)                                               /*!< SYS_INT_T::NMIEN: CLKFAIL Position        */
N#define SYS_NMIEN_CLKFAIL_Msk            (0x1ul << SYS_NMIEN_CLKFAIL_Pos )                 /*!< SYS_INT_T::NMIEN: CLKFAIL Mask            */
N
N#define SYS_NMIEN_RTC_INT_Pos            (6)                                               /*!< SYS_INT_T::NMIEN: RTC_INT Position        */
N#define SYS_NMIEN_RTC_INT_Msk            (0x1ul << SYS_NMIEN_RTC_INT_Pos )                 /*!< SYS_INT_T::NMIEN: RTC_INT Mask            */
N
N#define SYS_NMIEN_TAMPER_INT_Pos         (7)                                               /*!< SYS_INT_T::NMIEN: TAMPER_INT Position     */
N#define SYS_NMIEN_TAMPER_INT_Msk         (0x1ul << SYS_NMIEN_TAMPER_INT_Pos )              /*!< SYS_INT_T::NMIEN: TAMPER_INT Mask         */
N
N#define SYS_NMIEN_EINT0_Pos              (8)                                               /*!< SYS_INT_T::NMIEN: EINT0 Position          */
N#define SYS_NMIEN_EINT0_Msk              (0x1ul << SYS_NMIEN_EINT0_Pos )                   /*!< SYS_INT_T::NMIEN: EINT0 Mask              */
N
N#define SYS_NMIEN_EINT1_Pos              (9)                                               /*!< SYS_INT_T::NMIEN: EINT1 Position          */
N#define SYS_NMIEN_EINT1_Msk              (0x1ul << SYS_NMIEN_EINT1_Pos )                   /*!< SYS_INT_T::NMIEN: EINT1 Mask              */
N
N#define SYS_NMIEN_EINT2_Pos              (10)                                              /*!< SYS_INT_T::NMIEN: EINT2 Position          */
N#define SYS_NMIEN_EINT2_Msk              (0x1ul << SYS_NMIEN_EINT2_Pos )                   /*!< SYS_INT_T::NMIEN: EINT2 Mask              */
N
N#define SYS_NMIEN_EINT3_Pos              (11)                                              /*!< SYS_INT_T::NMIEN: EINT3 Position          */
N#define SYS_NMIEN_EINT3_Msk              (0x1ul << SYS_NMIEN_EINT3_Pos )                   /*!< SYS_INT_T::NMIEN: EINT3 Mask              */
N
N#define SYS_NMIEN_EINT4_Pos              (12)                                              /*!< SYS_INT_T::NMIEN: EINT4 Position          */
N#define SYS_NMIEN_EINT4_Msk              (0x1ul << SYS_NMIEN_EINT4_Pos )                   /*!< SYS_INT_T::NMIEN: EINT4 Mask              */
N
N#define SYS_NMIEN_EINT5_Pos              (13)                                              /*!< SYS_INT_T::NMIEN: EINT5 Position          */
N#define SYS_NMIEN_EINT5_Msk              (0x1ul << SYS_NMIEN_EINT5_Pos )                   /*!< SYS_INT_T::NMIEN: EINT5 Mask              */
N
N#define SYS_NMIEN_UART0_INT_Pos          (14)                                              /*!< SYS_INT_T::NMIEN: UART0_INT Position      */
N#define SYS_NMIEN_UART0_INT_Msk          (0x1ul << SYS_NMIEN_UART0_INT_Pos )               /*!< SYS_INT_T::NMIEN: UART0_INT Mask          */
N
N#define SYS_NMIEN_UART1_INT_Pos          (15)                                              /*!< SYS_INT_T::NMIEN: UART1_INT Position      */
N#define SYS_NMIEN_UART1_INT_Msk          (0x1ul << SYS_NMIEN_UART1_INT_Pos )               /*!< SYS_INT_T::NMIEN: UART1_INT Mask          */
N
N#define SYS_NMISTS_BODOUT_Pos            (0)                                               /*!< SYS_INT_T::NMISTS: BODOUT Position        */
N#define SYS_NMISTS_BODOUT_Msk            (0x1ul << SYS_NMISTS_BODOUT_Pos )                 /*!< SYS_INT_T::NMISTS: BODOUT Mask            */
N
N#define SYS_NMISTS_IRC_INT_Pos           (1)                                               /*!< SYS_INT_T::NMISTS: IRC_INT Position       */
N#define SYS_NMISTS_IRC_INT_Msk           (0x1ul << SYS_NMISTS_IRC_INT_Pos )                /*!< SYS_INT_T::NMISTS: IRC_INT Mask           */
N
N#define SYS_NMISTS_PWRWU_INT_Pos         (2)                                               /*!< SYS_INT_T::NMISTS: PWRWU_INT Position     */
N#define SYS_NMISTS_PWRWU_INT_Msk         (0x1ul << SYS_NMISTS_PWRWU_INT_Pos )              /*!< SYS_INT_T::NMISTS: PWRWU_INT Mask         */
N
N#define SYS_NMISTS_SRAM_PERR_Pos         (3)                                               /*!< SYS_INT_T::NMISTS: SRAM_PERR Position     */
N#define SYS_NMISTS_SRAM_PERR_Msk         (0x1ul << SYS_NMISTS_SRAM_PERR_Pos )              /*!< SYS_INT_T::NMISTS: SRAM_PERR Mask         */
N
N#define SYS_NMISTS_CLKFAIL_Pos           (4)                                               /*!< SYS_INT_T::NMISTS: CLKFAIL Position       */
N#define SYS_NMISTS_CLKFAIL_Msk           (0x1ul << SYS_NMISTS_CLKFAIL_Pos )                /*!< SYS_INT_T::NMISTS: CLKFAIL Mask           */
N
N#define SYS_NMISTS_RTC_INT_Pos           (6)                                               /*!< SYS_INT_T::NMISTS: RTC_INT Position       */
N#define SYS_NMISTS_RTC_INT_Msk           (0x1ul << SYS_NMISTS_RTC_INT_Pos )                /*!< SYS_INT_T::NMISTS: RTC_INT Mask           */
N
N#define SYS_NMISTS_TAMPER_INT_Pos        (7)                                               /*!< SYS_INT_T::NMISTS: TAMPER_INT Position    */
N#define SYS_NMISTS_TAMPER_INT_Msk        (0x1ul << SYS_NMISTS_TAMPER_INT_Pos )             /*!< SYS_INT_T::NMISTS: TAMPER_INT Mask        */
N
N#define SYS_NMISTS_EINT0_Pos             (8)                                               /*!< SYS_INT_T::NMISTS: EINT0 Position         */
N#define SYS_NMISTS_EINT0_Msk             (0x1ul << SYS_NMISTS_EINT0_Pos )                  /*!< SYS_INT_T::NMISTS: EINT0 Mask             */
N
N#define SYS_NMISTS_EINT1_Pos             (9)                                               /*!< SYS_INT_T::NMISTS: EINT1 Position         */
N#define SYS_NMISTS_EINT1_Msk             (0x1ul << SYS_NMISTS_EINT1_Pos )                  /*!< SYS_INT_T::NMISTS: EINT1 Mask             */
N
N#define SYS_NMISTS_EINT2_Pos             (10)                                              /*!< SYS_INT_T::NMISTS: EINT2 Position         */
N#define SYS_NMISTS_EINT2_Msk             (0x1ul << SYS_NMISTS_EINT2_Pos )                  /*!< SYS_INT_T::NMISTS: EINT2 Mask             */
N
N#define SYS_NMISTS_EINT3_Pos             (11)                                              /*!< SYS_INT_T::NMISTS: EINT3 Position         */
N#define SYS_NMISTS_EINT3_Msk             (0x1ul << SYS_NMISTS_EINT3_Pos )                  /*!< SYS_INT_T::NMISTS: EINT3 Mask             */
N
N#define SYS_NMISTS_EINT4_Pos             (12)                                              /*!< SYS_INT_T::NMISTS: EINT4 Position         */
N#define SYS_NMISTS_EINT4_Msk             (0x1ul << SYS_NMISTS_EINT4_Pos )                  /*!< SYS_INT_T::NMISTS: EINT4 Mask             */
N
N#define SYS_NMISTS_EINT5_Pos             (13)                                              /*!< SYS_INT_T::NMISTS: EINT5 Position         */
N#define SYS_NMISTS_EINT5_Msk             (0x1ul << SYS_NMISTS_EINT5_Pos )                  /*!< SYS_INT_T::NMISTS: EINT5 Mask             */
N
N#define SYS_NMISTS_UART0_INT_Pos         (14)                                              /*!< SYS_INT_T::NMISTS: UART0_INT Position     */
N#define SYS_NMISTS_UART0_INT_Msk         (0x1ul << SYS_NMISTS_UART0_INT_Pos )              /*!< SYS_INT_T::NMISTS: UART0_INT Mask         */
N
N#define SYS_NMISTS_UART1_INT_Pos         (15)                                              /*!< SYS_INT_T::NMISTS: UART1_INT Position     */
N#define SYS_NMISTS_UART1_INT_Msk         (0x1ul << SYS_NMISTS_UART1_INT_Pos )              /*!< SYS_INT_T::NMISTS: UART1_INT Mask         */
N
N/**@}*/ /* INT_CONST */
N/**@}*/ /* end of SYS register group */
N
N
N/*---------------------- Touch Key Controller -------------------------*/
N/**
N    @addtogroup TK Touch Key Controller(TK)
N    Memory Mapped Structure for TK Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var TK_T::CTL
N * Offset: 0x00  Touch Key Scan Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TKSEN0    |TK0 Scan Enable Bit
N * |        |          |This bit is ignored if TKREN0 (TK_REFCTL[0]) is "1" except SCANALL (TK_REFCTL[23]) is "1".
N * |        |          |0 = TKDAT0 (TK_DAT0[7:0]) is invalid.
N * |        |          |1 = TK0 is always enable for Touch Key scan. TKDAT0 (TK_DAT0[7:0]) is valid.
N * |[1]     |TKSEN1    |TK1 Scan Enable Bit
N * |        |          |This bit is ignored if TKREN1 (TK_REFCTL[1]) is "1".
N * |        |          |0 = TKDAT1 (TK_DAT0[15:8]) is invalid.
N * |        |          |1 = TK1 is always enable for Touch Key scan. TKDAT1 (TK_DAT0[15:8]) is valid.
N * |[2]     |TKSEN2    |TK2 Scan Enable Bit
N * |        |          |This bit is ignored if TKREN2 (TK_REFCTL[2]) is "1".
N * |        |          |0 = TKDAT2 (TK_DAT0[23:16]) is invalid.
N * |        |          |1 = TK2 is always enable for Touch Key scan. TKDAT2 (TK_DAT0[23:16]) is valid.
N * |[3]     |TKSEN3    |TK3 Scan Enable Bit
N * |        |          |0 = TKDAT3 (TK_DAT0[31:24]) is invalid.
N * |        |          |1 = TK3 is always enable for Touch Key scan. TKDAT3 (TK_DAT0[31:24]) is valid.
N * |        |          |This bit is ignored if TKREN3 (TK_REFCTL[3]) is "1".
N * |[4]     |TKSEN4    |TK4 Scan Enable Bit
N * |        |          |This bit is ignored if TKREN4 (TK_REFCTL[4]) is "1".
N * |        |          |0 = TKDAT4 (TK_DAT1[7:0]) is invalid.
N * |        |          |1 = TK4 is always enable for Touch Key scan. TKDAT4 (TK_DAT1[7:0]) is valid.
N * |[5]     |TKSEN5    |TK5 Scan Enable Bit
N * |        |          |This bit is ignored if TKREN5 (TK_REFCTL[5]) is "1".
N * |        |          |0 = TKDAT5 (TK_DAT1[15:8]) is invalid.
N * |        |          |1 = TK5 is always enable for Touch Key scan. TKDAT5 (TK_DAT1[15:8]) is valid.
N * |[6]     |TKSEN6    |TK6 Scan Enable Bit
N * |        |          |This bit is ignored if TKREN6 (TK_REFCTL[6]) is "1".
N * |        |          |0 = TKDAT6 (TK_DAT1[23:16]) is invalid.
N * |        |          |1 = TK6 is always enable for Touch Key scan. TKDAT6 (TK_DAT1[23:16]) is valid.
N * |[7]     |TKSEN7    |TK7 Scan Enable
N * |        |          |This bit is ignored if TKREN7 (TK_REFCTL[7]) is "1".
N * |        |          |0 = TKDAT7 (TK_DAT1[31:24]) is invalid.
N * |        |          |1 = TK7 is always enable for Touch Key scan. TKDAT7 (TK_DAT1[31:24]) is valid.
N * |[8]     |TKSEN8    |TK8 Scan Enable Bit
N * |        |          |This bit is ignored if TKREN8 (TK_REFCTL[8]) is "1".
N * |        |          |0 = TKDAT8 (TK_DAT2[7:0]) is invalid.
N * |        |          |1 = TK8 is always enable for Touch Key scan. TKDAT8 (TK_DAT2[7:0]) is valid.
N * |[9]     |TKSEN9    |TK9 Scan Enable Bit
N * |        |          |This bit is ignored if TKREN9 (TK_REFCTL[9]) is "1".
N * |        |          |0 = TKDAT9 (TK_DAT2[15:8]) is invalid.
N * |        |          |1 = TK9 is always enable for Touch Key scan. TKDAT9 (TK_DAT2[15:8]) is valid.
N * |[10]    |TKSEN10   |TK10 Scan Enable Bit
N * |        |          |This bit is ignored if TKREN10 (TK_REFCTL[10]) is "1".
N * |        |          |0 = TKDAT10 (TK_DAT2[23:16]) is invalid.
N * |        |          |1 = TK10 is always enable for Touch Key scan. TKDAT10 (TK_DAT2[23:16]) is valid.
N * |[11]    |TKSEN11   |TK11 Scan Enable
N * |        |          |This bit is ignored if TKREN11 (TK_REFCTL[11]) is "1".
N * |        |          |0 = TKDAT11 (TK_DAT2[31:24]) is invalid.
N * |        |          |1 = TK11 is always enable for Touch Key scan. TKDAT11 (TK_DAT2[31:24]) is valid.
N * |[12]    |TKSEN12   |TK12 Scan Enable Bit
N * |        |          |This bit is ignored if TKREN12 (TK_REFCTL[12]) is "1".
N * |        |          |0 = TKDAT12 (TK_DAT3[7:0]) is invalid.
N * |        |          |1 = TK12 is always enable for Touch Key scan. TKDAT12 (TK_DAT3[7:0]) is valid.
N * |[13]    |TKSEN13   |TK13 Scan Enable Bit
N * |        |          |This bit is ignored if TKREN13 (TK_REFCTL[13]) is "1".
N * |        |          |0 = TKDAT13 (TK_DAT3[15:8]) is invalid.
N * |        |          |1 = TK13 is always enable for key scan. TKDAT13 (TK_DAT3[15:8]) is valid.
N * |[14]    |TKSEN14   |TK14 Scan Enable Bit
N * |        |          |This bit is ignored if TKREN14 (TK_REFCTL[14]) is "1".
N * |        |          |0 = TKDAT14 (TK_DAT3[23:16]) is invalid.
N * |        |          |1 = TK14 is always enabled for key scan. TKDAT14 (TK_DAT3[23:16]) is valid.
N * |[15]    |TKSEN15   |TK15 Scan Enable Bit
N * |        |          |This bit is ignored if TKREN15 (TK_REFCTL[15]) is "1".
N * |        |          |0 = TKDAT15 (TK_DAT3[31:24]) is invalid.
N * |        |          |1 = TK15 is always enabled for key scan. TKDAT15 (TK_DAT3[31:24]) is valid.
N * |[16]    |TKSEN16   |TK16 Scan Enable Bit
N * |        |          |This bit is ignored if TKREN16 (TK_REFCTL[16]) is "1".
N * |        |          |0 = TKDAT16 (TK_DAT4[7:0]) is invalid.
N * |        |          |1 = TK16 is always enabled for key scan. TKDAT16 (TK_DAT4[7:0]) is valid.
N * |[22:20] |AVCCHSEL  |AVCCH Voltage Select
N * |        |          |000 = 1/16 VDD.
N * |        |          |001 = 1/8 VDD.
N * |        |          |010 = 3/16 VDD.
N * |        |          |011 = 1/4 VDD.
N * |        |          |100 = 5/16 VDD.
N * |        |          |101 = 3/8 VDD.
N * |        |          |110 = 7/16 VDD.
N * |        |          |111 = 1/2 VDD.
N * |[24]    |SCAN      |Scan
N * |        |          |Write an '1' to this bit will immediately initiate key scan on all channels which are enabled.
N * |        |          |This bit will be self-cleared after key scan started.
N * |[25]    |TMRTRGEN  |Timer Trigger Enable Bit
N * |        |          |0 = Disable timer to trigger key scan.
N * |        |          |1 = Enable timer triggers key scan periodically. Key scan will be initiated by Timer0 periodically.
N * |[31]    |TKEN      |Touch Key Scan Enable Bit
N * |        |          |0 = Disable Touch Key Function.
N * |        |          |1 = Enable Touch Key Function.
N * @var TK_T::REFCTL
N * Offset: 0x04  Touch Key Reference Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TKREN0    |TK0 Reference Enable Bit
N * |        |          |0 = TK0 is not reference.
N * |        |          |1 = TK0 is set as reference, and TKDAT0 (TK_DAT0[7:0]) is invalid except SCANALL (TK_REFCTL[23]) is "1".
N * |[1]     |TKREN1    |TK1 Reference Enable Bit
N * |        |          |0 = TK1 is not reference.
N * |        |          |1 = TK1 is set as reference, and TKDAT1 (TK_DAT0[15:8]) is invalid.
N * |[2]     |TKREN2    |TK2 Reference Enable Bit
N * |        |          |0 = TK2 is not reference.
N * |        |          |1 = TK2 is set as reference, and TKDAT2 (TK_DAT0[23:16]) is invalid.
N * |[3]     |TKREN3    |TK3 Reference Enable Bit
N * |        |          |0 = TK3 is not reference.
N * |        |          |1 = TK3 is set as reference, and TKDAT3 (TK_DAT0[31:24]) is invalid.
N * |[4]     |TKREN4    |TK4 Reference Enable Bit
N * |        |          |0 = TK4 is not reference.
N * |        |          |1 = TK4 is set as reference, and TKDAT4 (TK_DAT1[7:0]) is invalid.
N * |[5]     |TKREN5    |TK5 Reference Enable Bit
N * |        |          |0 = TK5 is not reference.
N * |        |          |1 = TK5 is set as reference, and TKDAT5 (TK_DAT1[15:8]) is invalid.
N * |[6]     |TKREN6    |TK6 Reference Enable Bit
N * |        |          |0 = TK6 is not reference.
N * |        |          |1 = TK6 is set as reference, and TKDAT6 (TK_DAT1[23:16]) is invalid.
N * |[7]     |TKREN7    |TK7 Reference Enable Bit
N * |        |          |0 = TK7 is not reference.
N * |        |          |1 = TK7 is set as reference, and TKDAT7 (TK_DAT1[31:24]) is invalid.
N * |[8]     |TKREN8    |TK8 Reference Enable Bit
N * |        |          |0 = TK8 is not reference.
N * |        |          |1 = TK8 is set as reference, and TKDAT8 (TK_DAT2[7:0]) is invalid.
N * |[9]     |TKREN9    |TK9 Reference Enable Bit
N * |        |          |0 = TK9 is not reference.
N * |        |          |1 = TK9 is set as reference, and TKDAT9 (TK_DAT2[15:8]) is invalid.
N * |[10]    |TKREN10   |TK10 Reference Enable Bit
N * |        |          |0 = TK10 is not reference.
N * |        |          |1 = TK10 is set as reference, and TKDAT10 (TK_DAT2[23:16]) is invalid.
N * |[11]    |TKREN11   |TK11 Reference Enable Bit
N * |        |          |0 = TK11 is not reference.
N * |        |          |1 = TK11 is set as reference, and TKDAT11 (TK_DAT2[31:24]) is invalid.
N * |[12]    |TKREN12   |TK12 Reference Enable Bit
N * |        |          |0 = TK12 is not reference.
N * |        |          |1 = TK12 is set as reference, and TKDAT12 (TK_DAT3[7:0]) is invalid.
N * |[13]    |TKREN13   |TK13 Reference Enable Bit
N * |        |          |0 = TK13 is not reference.
N * |        |          |1 = TK13 is set as reference, and TKDAT13 (TK_DAT3[15:8]) is invalid.
N * |[14]    |TKREN14   |TK14 Reference Enable Bit
N * |        |          |0 = TK14 is not reference.
N * |        |          |1 = TK14 is set as reference, and TKDAT14 (TK_DAT3[23:16]) is invalid.
N * |[15]    |TKREN15   |TK15 Reference Enable Bit
N * |        |          |0 = TK15 is not reference.
N * |        |          |1 = TK15 is set as reference, and TKDAT15 (TK_DAT3[31:24]) is invalid.
N * |[16]    |TKREN16   |TK16 Reference Enable Bit
N * |        |          |0 = TK16 is not reference.
N * |        |          |1 = TK16 is set as reference, and TKDAT16 (TK_DAT4[7:0]) is invalid.
N * |        |          |Note: This bit is forced to "1" automatically if none is set as reference.
N * |[23]    |SCANALL   |All Key Scan Enable Bit
N * |        |          |This function is used for low power key scanning operation.
N * |        |          |TKDAT0 (TK_DAT0[7:0]) is the only one valid data when key scan is complete.
N * |        |          |0 = Disable All Keys Scan function.
N * |        |          |1 = Enable All Keys Scan function.
N * |[25:24] |SENTCTL   |Touch Key Sensing Time Control
N * |        |          |00 = 128 x SENPTCTL.
N * |        |          |01 = 255 x SENPTCTL.
N * |        |          |10 = 511 x SENPTCTL.
N * |        |          |11 = 1023 x SENPTCTL.
N * |[29:28] |SENPTCTL  |Touch Key Sensing Pulse Width Time Control
N * |        |          |00 = 1us.
N * |        |          |01 = 2us.
N * |        |          |10 = 4us.
N * |        |          |11 = 8us.
N * @var TK_T::CCBDAT0
N * Offset: 0x08  Touch Key Complement Capacitor Bank Data Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |CCBDAT0   |TK0 Complement CB Data
N * |        |          |This is register is used for TK0 sensitivity adjustment.
N * |[15:8]  |CCBDAT1   |TK1 Complement CB Data
N * |        |          |This is register is used for TK1 sensitivity adjustment.
N * |[23:16] |CCBDAT2   |TK2 Complement CB Data
N * |        |          |This is register is used for TK2 sensitivity adjustment.
N * |[31:24] |CCBDAT3   |TK3 Complement CB Data
N * |        |          |This is register is used for TK3 sensitivity adjustment.
N * @var TK_T::CCBDAT1
N * Offset: 0x0C  Touch Key Complement Capacitor Bank Data Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |CCBDAT4   |TK4 Complement CB Data
N * |        |          |This is register is used for TK4 sensitivity adjustment.
N * |[15:8]  |CCBDAT5   |TK5 Complement CB Data
N * |        |          |This is register is used for TK5 sensitivity adjustment.
N * |[23:16] |CCBDAT6   |TK6 Complement CB Data
N * |        |          |This is register is used for TK6 sensitivity adjustment.
N * |[31:24] |CCBDAT7   |TK7 Complement CB Data
N * |        |          |This is register is used for TK7 sensitivity adjustment.
N * @var TK_T::CCBDAT2
N * Offset: 0x10  Touch Key Complement Capacitor Bank Data Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |CCBDAT8   |TK8 Complement CB Data
N * |        |          |This is register is used for TK8 sensitivity adjustment.
N * |[15:8]  |CCBDAT9   |TK9 Complement CB Data
N * |        |          |This is register is used for TK9 sensitivity adjustment.
N * |[23:16] |CCBDAT10  |TK10 Complement CB Data
N * |        |          |This is register is used for TK10 sensitivity adjustment.
N * |[31:24] |CCBDAT11  |TK11 Complement CB Data
N * |        |          |This is register is used for TK11 sensitivity adjustment.
N * @var TK_T::CCBDAT3
N * Offset: 0x14  Touch Key Complement Capacitor Bank Data Register 3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |CCBDAT12  |TK12 Complement CB Data
N * |        |          |This is register is used for TK12 sensitivity adjustment.
N * |[15:8]  |CCBDAT13  |TK13 Complement CB Data
N * |        |          |This is register is used for TK13 sensitivity adjustment.
N * |[23:16] |CCBDAT14  |TK14 Complement CB Data
N * |        |          |This is register is used for TK14 sensitivity adjustment.
N * |[31:24] |CCBDAT15  |TK15 Complement CB Data
N * |        |          |This is register is used for TK15 sensitivity adjustment.
N * @var TK_T::CCBDAT4
N * Offset: 0x18  Touch Key Complement Capacitor Bank Data Register 4
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |CCBDAT16  |TK16 Complement CB Data
N * |        |          |This is register is used for TK16 sensitivity adjustment.
N * |[31:24] |REFCBDAT  |Reference CB Data
N * @var TK_T::IDLESEL
N * Offset: 0x1C  Touch Key Idle State Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |IDLSn     |TKn Idle State Control
N * |        |          |This register is ignored if both TKSENn (TK_CTL[n]) and POLENn (TK_POLCTL[n+8]) are "0" or TKRENn (TK_REFCTL[n]) is "1".
N * |        |          |00 = TKn connected to GND.
N * |        |          |01 = TKn connected to AVCCH.
N * |        |          |10 = TKn connected to VDD.
N * |        |          |11 = TKn connected to VDD.
N * |        |          |n = 0 to 15.
N * @var TK_T::POLSEL
N * Offset: 0x20  Touch Key Polarity Select Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |POLSELn   |TKn Polarity Select
N * |        |          |This register is ignored if POLENn (TK_POLCTL[n+8]) is "0", or either TKSENn (TK_CTL[n]) or TKRENn (TK_REFCTL[n]) is "1".
N * |        |          |00 = TKn connected to Gnd.
N * |        |          |01 = TKn connected to AVCCH.
N * |        |          |10 = TKn connected to VDD.
N * |        |          |11 = TKn connected to VDD.
N * @var TK_T::POLCTL
N * Offset: 0x24  Touch Key Polarity Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |IDLS16    |TK16 Idle State Control
N * |        |          |This register is ignored if both TKSEN16 (TK_CTL[16]) and POLEN16 (TK_POLCTL[24]) are "0" or TKREN16 (TK_REFCTL[16]) is "1".
N * |        |          |00 = TK16 connected to Gnd.
N * |        |          |01 = TK16 connected to AVCCH.
N * |        |          |10 = TK16 connected to VDD.
N * |        |          |11 = TK16 connected to VDD.
N * |[3:2]   |POLSEL16  |TK16 Polarity Control
N * |        |          |This register is ignored if POLEN16 (TK_POLCTL[24]) is "0", or either TKSEN16 (TK_CTL[16]) or TKREN16 (TK_REFCTL[16]) is "1".
N * |        |          |00 = TK16 connected to Gnd.
N * |        |          |01 = TK16 connected to AVCCH.
N * |        |          |10 = TK16 connected to VDD.
N * |        |          |11 = TK16 connected to VDD.
N * |[5:4]   |CBPOLSEL  |Capacitor Bank Polarity Select
N * |        |          |00 = Gnd.
N * |        |          |01 = AVCCH.
N * |        |          |10 = VDD.
N * |        |          |11 = VDD.
N * |[8]     |POLEN0    |TK0 Polarity Function Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[9]     |POLEN1    |TK1 Polarity Function Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[10]    |POLEN2    |TK2 Polarity Function Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[11]    |POLEN3    |TK3 Polarity Function Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[12]    |POLEN4    |TK4 Polarity Function Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[13]    |POLEN5    |TK5 Polarity Function Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[14]    |POLEN6    |TK6 Polarity Function Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[15]    |POLEN7    |TK7 Polarity Function Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[16]    |POLEN8    |TK8 Polarity Function Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[17]    |POLEN9    |TK9 Polarity Function Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[18]    |POLEN10   |TK10 Polarity Function Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[19]    |POLEN11   |TK11 Polarity Function Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[20]    |POLEN12   |TK12 Polarity Function Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[21]    |POLEN13   |TK13 Polarity Function Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[22]    |POLEN14   |TK14 Polarity Function Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[23]    |POLEN15   |TK15 Polarity Function Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[24]    |POLEN16   |TK16 Polarity Function Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[31]    |SPOTINIT  |Touch Key Sensing Initial Potential Control
N * |        |          |0 = Key pad is connected to Gnd before sensing.
N * |        |          |1 = Key pad is connected to AVCCH before sensing.
N * @var TK_T::STATUS
N * Offset: 0x28  Touch Key Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |BUSY      |Touch Key Busy (Read Only)
N * |        |          |0 = Key scan is complete or stopped.
N * |        |          |1 = Key scan is proceeding.
N * |[1]     |SCIF      |Touch Key Scan Complete Interrupt Flag
N * |        |          |This bit will be cleared by writing a "1" to this bit.
N * |        |          |0 = Key scan is proceeding and data is not ready for read.
N * |        |          |1 = Key scan is complete and data is ready for read in TKDATx registers.
N * |        |          |Note1: The Touch Key interrupt asserts if SCINTEN bit of TK_INTEN register is set.
N * |        |          |Note2: The Touch Key interrupt also asserts if SCTHIEN bit of TK_INTEN register is set and any channel data value is greater/less than its threshold setting
N * |[8]     |TKIF0     |TK0 Interrupt Flag
N * |        |          |This bit will be cleared by writing a "1" to this bit.
N * |        |          |0 = No threshold control event with TK0.
N * |        |          |1 = Threshold control event occurs with TK0.
N * |[9]     |TKIF1     |TK1 Interrupt Flag
N * |        |          |This bit will be cleared by writing a "1" to this bit.
N * |        |          |0 = No threshold control event with TK1.
N * |        |          |1 = Threshold control event occurs with TK1.
N * |[10]    |TKIF2     |TK2 Interrupt Flag
N * |        |          |This bit will be cleared by writing a "1" to this bit.
N * |        |          |0 = No threshold control event with TK2.
N * |        |          |1 = Threshold control event occurs with TK2.
N * |[11]    |TKIF3     |TK3 Interrupt Flag
N * |        |          |This bit will be cleared by writing a "1" to this bit.
N * |        |          |0 = No threshold control event with TK3.
N * |        |          |1 = Threshold control event occurs with TK3.
N * |[12]    |TKIF4     |TK4 Interrupt Flag
N * |        |          |This bit will be cleared by writing a "1" to this bit.
N * |        |          |0 = No threshold control event with TK4.
N * |        |          |1 = Threshold control event occurs with TK4.
N * |[13]    |TKIF5     |TK5 Interrupt Flag
N * |        |          |This bit will be cleared by writing a "1" to this bit.
N * |        |          |0 = No threshold control event with TK5.
N * |        |          |1 = Threshold control event occurs with TK5.
N * |[14]    |TKIF6     |TK6 Interrupt Flag
N * |        |          |This bit will be cleared by writing a "1" to this bit.
N * |        |          |0 = No threshold control event with TK6.
N * |        |          |1 = Threshold control event occurs with TK6.
N * |[15]    |TKIF7     |TK7 Interrupt Flag
N * |        |          |This bit will be cleared by writing a "1" to this bit.
N * |        |          |0 = No threshold control event with TK7.
N * |        |          |1 = Threshold control event occurs with TK7.
N * |[16]    |TKIF8     |TK8 Interrupt Flag
N * |        |          |This bit will be cleared by writing a "1" to this bit.
N * |        |          |0 = No threshold control event with TK8.
N * |        |          |1 = Threshold control event occurs with TK8.
N * |[17]    |TKIF9     |TK9 Interrupt Flag
N * |        |          |This bit will be cleared by writing a "1" to this bit.
N * |        |          |0 = No threshold control event with TK9.
N * |        |          |1 = Threshold control event occurs with TK9.
N * |[18]    |TKIF10    |TK10 Interrupt Flag
N * |        |          |This bit will be cleared by writing a "1" to this bit.
N * |        |          |0 = No threshold control event with TK10.
N * |        |          |1 = Threshold control event occurs with TK10.
N * |[19]    |TKIF11    |TK11 Interrupt Flag
N * |        |          |This bit will be cleared by writing a "1" to this bit.
N * |        |          |0 = No threshold control event with TK11.
N * |        |          |1 = Threshold control event occurs with TK11.
N * |[20]    |TKIF12    |TK12 Interrupt Flag
N * |        |          |This bit will be cleared by writing a "1" to this bit.
N * |        |          |0 = No threshold control event with TK12.
N * |        |          |1 = Threshold control event occurs with TK12.
N * |[21]    |TKIF13    |TK13 Interrupt Flag
N * |        |          |This bit will be cleared by writing a "1" to this bit.
N * |        |          |0 = No threshold control event with TK13.
N * |        |          |1 = Threshold control event occurs with TK13.
N * |[22]    |TKIF14    |TK14 Interrupt Flag
N * |        |          |This bit will be cleared by writing a "1" to this bit.
N * |        |          |0 = No threshold control event with TK14.
N * |        |          |1 = Threshold control event occurs with TK14.
N * |[23]    |TKIF15    |TK15 Interrupt Flag
N * |        |          |This bit will be cleared by writing a "1" to this bit.
N * |        |          |0 = No threshold control event with TK15.
N * |        |          |1 = Threshold control event occurs with TK15.
N * |[24]    |TKIF16    |TK16 Interrupt Flag
N * |        |          |This bit will be cleared by writing a "1" to this bit.
N * |        |          |0 = No threshold control event with TK16.
N * |        |          |1 = Threshold control event occurs with TK16.
N * @var TK_T::DAT0
N * Offset: 0x2C  Touch Key Data Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |TKDAT0    |TK0 Sensing Result Data (Read Only)
N * |        |          |This data is invalid if TKSEN0 (TK_CTL[0]) is "0" or TKREN0 (TK_REFCTL[0]) is "1" except SCANALL (TK_REFCTL[23]) is "1".
N * |[15:8]  |TKDAT1    |TK1 Sensing Result Data (Read Only)
N * |        |          |This data is invalid if TKSEN1 (TK_CTL[1]) is "0" or TKREN1 (TK_REFCTL[1]) is "1".
N * |[23:16] |TKDAT2    |TK2 Sensing Result Data (Read Only)
N * |        |          |This data is invalid if TKSEN2 (TK_CTL[2]) is "0" or TKREN2 (TK_REFCTL[2]) is "1".
N * |[31:24] |TKDAT3    |TK3 Sensing Result Data (Read Only)
N * |        |          |This data is invalid if TKSEN3 (TK_CTL[3]) is "0" or TKREN3 (TK_REFCTL[3]) is "1".
N * @var TK_T::DAT1
N * Offset: 0x30  Touch Key Data Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |TKDAT4    |TK0 Sensing Result Data (Read Only)
N * |        |          |This data is invalid if TKSEN4 (TK_CTL[4]) is "0" or TKREN4 (TK_REFCTL[4]) is "1".
N * |[15:8]  |TKDAT5    |TK5 Sensing Result Data (Read Only)
N * |        |          |This data is invalid if TKSEN5 (TK_CTL[5]) is "0" or TKREN5 (TK_REFCTL[5]) is "1".
N * |[23:16] |TKDAT6    |TK6 Sensing Result Data (Read Only)
N * |        |          |This data is invalid if TKSEN6 (TK_CTL[6]) is "0" or TKREN6 (TK_REFCTL[6]) is "1".
N * |[31:24] |TKDAT7    |TK7 Sensing Result Data (Read Only)
N * |        |          |This data is invalid if TKSEN7 (TK_CTL[7]) is "0" or TKREN7 (TK_REFCTL[7]) is "1".
N * @var TK_T::DAT2
N * Offset: 0x34  Touch Key Data Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |TKDAT8    |TK8 Sensing Result Data (Read Only)
N * |        |          |This data is invalid if TKSEN8 (TK_CTL[8]) is "0" or TKREN8 (TK_REFCTL[8]) is "1".
N * |[15:8]  |TKDAT9    |TK9 Sensing Result Data (Read Only)
N * |        |          |This data is invalid if TKSEN9 (TK_CTL[9]) is "0" or TKREN9 (TK_REFCTL[9]) is "1".
N * |[23:16] |TKDAT10   |TK10 Sensing Result Data (Read Only)
N * |        |          |This data is invalid if TKSEN10 (TK_CTL[10]) is "0" or TKREN10 (TK_REFCTL[10]) is "1".
N * |[31:24] |TKDAT11   |TK11 Sensing Result Data (Read Only)
N * |        |          |This data is invalid if TKSEN11 (TK_CTL[11]) is "0" or TKREN11 (TK_REFCTL[11]) is "1".
N * @var TK_T::DAT3
N * Offset: 0x38  Touch Key Data Register 3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |TKDAT12   |TK12 Sensing Result Data (Read Only)
N * |        |          |This data is invalid if TKSEN12 (TK_CTL[12]) is "0" or TKREN12 (TK_REFCTL[12]) is "1".
N * |[15:8]  |TKDAT13   |TK13 Sensing Result Data (Read Only)
N * |        |          |This data is invalid if TKSEN13 (TK_CTL[13]) is "0" or TKREN13 (TK_REFCTL[13]) is "1".
N * |[23:16] |TKDAT14   |TK14 Sensing Result Data (Read Only)
N * |        |          |This data is invalid if TKSEN14 (TK_CTL[14]) is "0" or TKREN14 (TK_REFCTL[14]) is "1".
N * |[31:24] |TKDAT15   |TK15 Sensing Result Data (Read Only)
N * |        |          |This data is invalid if TKSEN15 (TK_CTL[15]) is "0" or TKREN15 (TK_REFCTL[15]) is "1".
N * @var TK_T::DAT4
N * Offset: 0x3C  Touch Key Data Register 4
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |TKDAT16   |TK16 Sensing Result Data (Read Only)
N * |        |          |This data is invalid if TKSEN16 (TK_CTL[16]) is "0" or TKREN16 (TK_REFCTL[16]) is "1".
N * @var TK_T::INTEN
N * Offset: 0x40  Touch Key Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |SCTHIEN   |Touch Key Scan Complete With High/Low Threshold Control Interrupt Enable Bit
N * |        |          |0 = Key scan complete with threshold control interrupt is disable.
N * |        |          |1 = Key scan complete with threshold control interrupt is enable.
N * |[1]     |SCINTEN   |Touch Key Scan Complete Interrupt Enable
N * |        |          |Bit
N * |        |          |0 = Key scan complete without threshold control interrupt is disable.
N * |        |          |1 = Key scan complete without threshold control interrupt is enable.
N * |[31]    |THIMOD    |Touch Key Threshold Interrupt Mode Select
N * |        |          |0 = Edge trigger mode.
N * |        |          |1 = Level trigger mode.
N * @var TK_T::TH0_1
N * Offset: 0x44  Touch Key TK0/TK1 Threshold Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |LTH0      |Low Threshold Of TK0
N * |        |          |Low level for TK0 threshold control.
N * |[15:8]  |HTH0      |High Threshold Of TK0
N * |        |          |High level for TK0 threshold control.
N * |[23:16] |LTH1      |Low Threshold Of TK1
N * |        |          |Low level for TK1 threshold control.
N * |[31:24] |HTH1      |High Threshold Of TK1
N * |        |          |High level for TK1 threshold control.
N * @var TK_T::TH2_3
N * Offset: 0x48  Touch Key TK2/TK3 Threshold Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |LTH2      |Low Threshold Of TK2
N * |        |          |Low level for TK2 threshold control.
N * |[15:8]  |HTH2      |High Threshold Of TK2
N * |        |          |High level for TK2 threshold control.
N * |[23:16] |LTH3      |Low Threshold Of TK3
N * |        |          |Low level for TK3 threshold control.
N * |[31:24] |HTH3      |High Threshold Of TK3
N * |        |          |High level for TK3 threshold control.
N * @var TK_T::TH4_5
N * Offset: 0x4C  Touch Key TK4/TK5 Threshold Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |LTH4      |Low Threshold Of TK4
N * |        |          |Low level for TK4 threshold control.
N * |[15:8]  |HTH4      |High Threshold Of TK4
N * |        |          |High level for TK4 threshold control.
N * |[23:16] |LTH5      |Low Threshold Of TK5
N * |        |          |Low level for TK5 threshold control.
N * |[31:24] |HTH5      |High Threshold Of TK5
N * |        |          |High level for TK5 threshold control.
N * @var TK_T::TH6_7
N * Offset: 0x50  Touch Key TK6/TK7 Threshold Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |LTH6      |Low Threshold Of TK6
N * |        |          |Low level for TK6 threshold control.
N * |[15:8]  |HTH6      |High Threshold Of TK6
N * |        |          |High level for TK6 threshold control.
N * |[23:16] |LTH7      |Low Threshold Of TK7
N * |        |          |Low level for TK7 threshold control.
N * |[31:24] |HTH7      |High Threshold Of TK7
N * |        |          |High level for TK7 threshold control.
N * @var TK_T::TH8_9
N * Offset: 0x54  Touch Key TK8/TK9 Threshold Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |LTH8      |Low Threshold Of TK8
N * |        |          |Low level for TK8 threshold control.
N * |[15:8]  |HTH8      |High Threshold Of TK8
N * |        |          |High level for TK8 threshold control.
N * |[23:16] |LTH9      |Low Threshold Of TK9
N * |        |          |Low level for TK9 threshold control.
N * |[31:24] |HTH9      |High Threshold Of TK9
N * |        |          |High level for TK9 threshold control.
N * @var TK_T::TH10_11
N * Offset: 0x58  Touch Key TK10/TK11 Threshold Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |LTH10     |Low Threshold Of TK10
N * |        |          |Low level for TK10 threshold control.
N * |[15:8]  |HTH10     |High Threshold Of TK10
N * |        |          |High level for TK10 threshold control.
N * |[23:16] |LTH11     |Low Threshold Of TK11
N * |        |          |Low level for TK11 threshold control.
N * |[31:24] |HTH11     |High Threshold Of TK11
N * |        |          |High level for TK11 threshold control.
N * @var TK_T::TH12_13
N * Offset: 0x5C  Touch Key TK12/TK13 Threshold Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |LTH12     |Low Threshold Of TK12
N * |        |          |Low level for TK12 threshold control.
N * |[15:8]  |HTH12     |High Threshold Of TK12
N * |        |          |High level for TK12 threshold control.
N * |[23:16] |LTH13     |Low Threshold Of TK13
N * |        |          |Low level for TK13 threshold control.
N * |[31:24] |HTH13     |High Threshold Of TK13
N * |        |          |High level for TK13 threshold control.
N * @var TK_T::TH14_15
N * Offset: 0x60  Touch Key TK14/TK15 Threshold Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |LTH14     |Low Threshold Of TK14
N * |        |          |Low level for TK14 threshold control.
N * |[15:8]  |HTH14     |High Threshold Of TK14
N * |        |          |High level for TK14 threshold control.
N * |[23:16] |LTH15     |Low Threshold Of TK15
N * |        |          |Low level for TK15 threshold control.
N * |[31:24] |HTH15     |High Threshold Of TK15
N * |        |          |High level for TK15 threshold control.
N * @var TK_T::TH16
N * Offset: 0x64  Touch Key TK16 Threshold Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |LTH16     |Low Threshold Of TK16
N * |        |          |Low level for TK16 threshold control.
N * |[15:8]  |HTH16     |High Threshold Of TK16
N * |        |          |High level for TK16 threshold control.
N */
N
N    __IO uint32_t CTL;           /* Offset: 0x00  Touch Key Scan Control Register                                    */
X    volatile uint32_t CTL;            
N    __IO uint32_t REFCTL;        /* Offset: 0x04  Touch Key Reference Control Register                               */
X    volatile uint32_t REFCTL;         
N    __IO uint32_t CCBDAT0;       /* Offset: 0x08  Touch Key Complement Capacitor Bank Data Register 0                */
X    volatile uint32_t CCBDAT0;        
N    __IO uint32_t CCBDAT1;       /* Offset: 0x0C  Touch Key Complement Capacitor Bank Data Register 1                */
X    volatile uint32_t CCBDAT1;        
N    __IO uint32_t CCBDAT2;       /* Offset: 0x10  Touch Key Complement Capacitor Bank Data Register 2                */
X    volatile uint32_t CCBDAT2;        
N    __IO uint32_t CCBDAT3;       /* Offset: 0x14  Touch Key Complement Capacitor Bank Data Register 3                */
X    volatile uint32_t CCBDAT3;        
N    __IO uint32_t CCBDAT4;       /* Offset: 0x18  Touch Key Complement Capacitor Bank Data Register 4                */
X    volatile uint32_t CCBDAT4;        
N    __IO uint32_t IDLESEL;       /* Offset: 0x1C  Touch Key Idle State Control Register                              */
X    volatile uint32_t IDLESEL;        
N    __IO uint32_t POLSEL;        /* Offset: 0x20  Touch Key Polarity Select Register                                 */
X    volatile uint32_t POLSEL;         
N    __IO uint32_t POLCTL;        /* Offset: 0x24  Touch Key Polarity Control Register                                */
X    volatile uint32_t POLCTL;         
N    __IO uint32_t STATUS;        /* Offset: 0x28  Touch Key Status Register                                          */
X    volatile uint32_t STATUS;         
N    __I  uint32_t DAT0;          /* Offset: 0x2C  Touch Key Data Register 0                                          */
X    volatile const  uint32_t DAT0;           
N    __I  uint32_t DAT1;          /* Offset: 0x30  Touch Key Data Register 1                                          */
X    volatile const  uint32_t DAT1;           
N    __I  uint32_t DAT2;          /* Offset: 0x34  Touch Key Data Register 2                                          */
X    volatile const  uint32_t DAT2;           
N    __I  uint32_t DAT3;          /* Offset: 0x38  Touch Key Data Register 3                                          */
X    volatile const  uint32_t DAT3;           
N    __I  uint32_t DAT4;          /* Offset: 0x3C  Touch Key Data Register 4                                          */
X    volatile const  uint32_t DAT4;           
N    __IO uint32_t INTEN;         /* Offset: 0x40  Touch Key Interrupt Enable Register                                */
X    volatile uint32_t INTEN;          
N    __IO uint32_t TH0_1;         /* Offset: 0x44  Touch Key TK0/TK1 Threshold Control Register                       */
X    volatile uint32_t TH0_1;          
N    __IO uint32_t TH2_3;         /* Offset: 0x48  Touch Key TK2/TK3 Threshold Control Register                       */
X    volatile uint32_t TH2_3;          
N    __IO uint32_t TH4_5;         /* Offset: 0x4C  Touch Key TK4/TK5 Threshold Control Register                       */
X    volatile uint32_t TH4_5;          
N    __IO uint32_t TH6_7;         /* Offset: 0x50  Touch Key TK6/TK7 Threshold Control Register                       */
X    volatile uint32_t TH6_7;          
N    __IO uint32_t TH8_9;         /* Offset: 0x54  Touch Key TK8/TK9 Threshold Control Register                       */
X    volatile uint32_t TH8_9;          
N    __IO uint32_t TH10_11;       /* Offset: 0x58  Touch Key TK10/TK11 Threshold Control Register                     */
X    volatile uint32_t TH10_11;        
N    __IO uint32_t TH12_13;       /* Offset: 0x5C  Touch Key TK12/TK13 Threshold Control Register                     */
X    volatile uint32_t TH12_13;        
N    __IO uint32_t TH14_15;       /* Offset: 0x60  Touch Key TK14/TK15 Threshold Control Register                     */
X    volatile uint32_t TH14_15;        
N    __IO uint32_t TH16;          /* Offset: 0x64  Touch Key TK16 Threshold Control Register                          */
X    volatile uint32_t TH16;           
N
N} TK_T;
N
N
N
N/**
N    @addtogroup TK_CONST TK Bit Field Definition
N    Constant Definitions for TK Controller
N@{ */
N
N
N#define TK_CTL_TKSEN0_Pos                (0)                                               /*!< TK_T::CTL: TKSEN0 Position                */
N#define TK_CTL_TKSEN0_Msk                (0x1ul << TK_CTL_TKSEN0_Pos)                      /*!< TK_T::CTL: TKSEN0 Mask                    */
N
N#define TK_CTL_TKSEN1_Pos                (1)                                               /*!< TK_T::CTL: TKSEN1 Position                */
N#define TK_CTL_TKSEN1_Msk                (0x1ul << TK_CTL_TKSEN1_Pos)                      /*!< TK_T::CTL: TKSEN1 Mask                    */
N
N#define TK_CTL_TKSEN2_Pos                (2)                                               /*!< TK_T::CTL: TKSEN2 Position                */
N#define TK_CTL_TKSEN2_Msk                (0x1ul << TK_CTL_TKSEN2_Pos)                      /*!< TK_T::CTL: TKSEN2 Mask                    */
N
N#define TK_CTL_TKSEN3_Pos                (3)                                               /*!< TK_T::CTL: TKSEN3 Position                */
N#define TK_CTL_TKSEN3_Msk                (0x1ul << TK_CTL_TKSEN3_Pos)                      /*!< TK_T::CTL: TKSEN3 Mask                    */
N
N#define TK_CTL_TKSEN4_Pos                (4)                                               /*!< TK_T::CTL: TKSEN4 Position                */
N#define TK_CTL_TKSEN4_Msk                (0x1ul << TK_CTL_TKSEN4_Pos)                      /*!< TK_T::CTL: TKSEN4 Mask                    */
N
N#define TK_CTL_TKSEN5_Pos                (5)                                               /*!< TK_T::CTL: TKSEN5 Position                */
N#define TK_CTL_TKSEN5_Msk                (0x1ul << TK_CTL_TKSEN5_Pos)                      /*!< TK_T::CTL: TKSEN5 Mask                    */
N
N#define TK_CTL_TKSEN6_Pos                (6)                                               /*!< TK_T::CTL: TKSEN6 Position                */
N#define TK_CTL_TKSEN6_Msk                (0x1ul << TK_CTL_TKSEN6_Pos)                      /*!< TK_T::CTL: TKSEN6 Mask                    */
N
N#define TK_CTL_TKSEN7_Pos                (7)                                               /*!< TK_T::CTL: TKSEN7 Position                */
N#define TK_CTL_TKSEN7_Msk                (0x1ul << TK_CTL_TKSEN7_Pos)                      /*!< TK_T::CTL: TKSEN7 Mask                    */
N
N#define TK_CTL_TKSEN8_Pos                (8)                                               /*!< TK_T::CTL: TKSEN8 Position                */
N#define TK_CTL_TKSEN8_Msk                (0x1ul << TK_CTL_TKSEN8_Pos)                      /*!< TK_T::CTL: TKSEN8 Mask                    */
N
N#define TK_CTL_TKSEN9_Pos                (9)                                               /*!< TK_T::CTL: TKSEN9 Position                */
N#define TK_CTL_TKSEN9_Msk                (0x1ul << TK_CTL_TKSEN9_Pos)                      /*!< TK_T::CTL: TKSEN9 Mask                    */
N
N#define TK_CTL_TKSEN10_Pos               (10)                                              /*!< TK_T::CTL: TKSEN10 Position               */
N#define TK_CTL_TKSEN10_Msk               (0x1ul << TK_CTL_TKSEN10_Pos)                     /*!< TK_T::CTL: TKSEN10 Mask                   */
N
N#define TK_CTL_TKSEN11_Pos               (11)                                              /*!< TK_T::CTL: TKSEN11 Position               */
N#define TK_CTL_TKSEN11_Msk               (0x1ul << TK_CTL_TKSEN11_Pos)                     /*!< TK_T::CTL: TKSEN11 Mask                   */
N
N#define TK_CTL_TKSEN12_Pos               (12)                                              /*!< TK_T::CTL: TKSEN12 Position               */
N#define TK_CTL_TKSEN12_Msk               (0x1ul << TK_CTL_TKSEN12_Pos)                     /*!< TK_T::CTL: TKSEN12 Mask                   */
N
N#define TK_CTL_TKSEN13_Pos               (13)                                              /*!< TK_T::CTL: TKSEN13 Position               */
N#define TK_CTL_TKSEN13_Msk               (0x1ul << TK_CTL_TKSEN13_Pos)                     /*!< TK_T::CTL: TKSEN13 Mask                   */
N
N#define TK_CTL_TKSEN14_Pos               (14)                                              /*!< TK_T::CTL: TKSEN14 Position               */
N#define TK_CTL_TKSEN14_Msk               (0x1ul << TK_CTL_TKSEN14_Pos)                     /*!< TK_T::CTL: TKSEN14 Mask                   */
N
N#define TK_CTL_TKSEN15_Pos               (15)                                              /*!< TK_T::CTL: TKSEN15 Position               */
N#define TK_CTL_TKSEN15_Msk               (0x1ul << TK_CTL_TKSEN15_Pos)                     /*!< TK_T::CTL: TKSEN15 Mask                   */
N
N#define TK_CTL_TKSEN16_Pos               (16)                                              /*!< TK_T::CTL: TKSEN16 Position               */
N#define TK_CTL_TKSEN16_Msk               (0x1ul << TK_CTL_TKSEN16_Pos)                     /*!< TK_T::CTL: TKSEN16 Mask                   */
N
N#define TK_CTL_AVCCHSEL_Pos              (20)                                              /*!< TK_T::CTL: AVCCHSEL Position              */
N#define TK_CTL_AVCCHSEL_Msk              (0x7ul << TK_CTL_AVCCHSEL_Pos)                    /*!< TK_T::CTL: AVCCHSEL Mask                  */
N
N#define TK_CTL_SCAN_Pos                  (24)                                              /*!< TK_T::CTL: SCAN Position                  */
N#define TK_CTL_SCAN_Msk                  (0x1ul << TK_CTL_SCAN_Pos)                        /*!< TK_T::CTL: SCAN Mask                      */
N
N#define TK_CTL_TMRTRGEN_Pos              (25)                                              /*!< TK_T::CTL: TMRTRGEN Position              */
N#define TK_CTL_TMRTRGEN_Msk              (0x1ul << TK_CTL_TMRTRGEN_Pos)                    /*!< TK_T::CTL: TMRTRGEN Mask                  */
N
N#define TK_CTL_TKEN_Pos                  (31)                                              /*!< TK_T::CTL: TKEN Position                  */
N#define TK_CTL_TKEN_Msk                  (0x1ul << TK_CTL_TKEN_Pos)                        /*!< TK_T::CTL: TKEN Mask                      */
N
N#define TK_REFCTL_TKREN0_Pos             (0)                                               /*!< TK_T::REFCTL: TKREN0 Position             */
N#define TK_REFCTL_TKREN0_Msk             (0x1ul << TK_REFCTL_TKREN0_Pos)                   /*!< TK_T::REFCTL: TKREN0 Mask                 */
N
N#define TK_REFCTL_TKREN1_Pos             (1)                                               /*!< TK_T::REFCTL: TKREN1 Position             */
N#define TK_REFCTL_TKREN1_Msk             (0x1ul << TK_REFCTL_TKREN1_Pos)                   /*!< TK_T::REFCTL: TKREN1 Mask                 */
N
N#define TK_REFCTL_TKREN2_Pos             (2)                                               /*!< TK_T::REFCTL: TKREN2 Position             */
N#define TK_REFCTL_TKREN2_Msk             (0x1ul << TK_REFCTL_TKREN2_Pos)                   /*!< TK_T::REFCTL: TKREN2 Mask                 */
N
N#define TK_REFCTL_TKREN3_Pos             (3)                                               /*!< TK_T::REFCTL: TKREN3 Position             */
N#define TK_REFCTL_TKREN3_Msk             (0x1ul << TK_REFCTL_TKREN3_Pos)                   /*!< TK_T::REFCTL: TKREN3 Mask                 */
N
N#define TK_REFCTL_TKREN4_Pos             (4)                                               /*!< TK_T::REFCTL: TKREN4 Position             */
N#define TK_REFCTL_TKREN4_Msk             (0x1ul << TK_REFCTL_TKREN4_Pos)                   /*!< TK_T::REFCTL: TKREN4 Mask                 */
N
N#define TK_REFCTL_TKREN5_Pos             (5)                                               /*!< TK_T::REFCTL: TKREN5 Position             */
N#define TK_REFCTL_TKREN5_Msk             (0x1ul << TK_REFCTL_TKREN5_Pos)                   /*!< TK_T::REFCTL: TKREN5 Mask                 */
N
N#define TK_REFCTL_TKREN6_Pos             (6)                                               /*!< TK_T::REFCTL: TKREN6 Position             */
N#define TK_REFCTL_TKREN6_Msk             (0x1ul << TK_REFCTL_TKREN6_Pos)                   /*!< TK_T::REFCTL: TKREN6 Mask                 */
N
N#define TK_REFCTL_TKREN7_Pos             (7)                                               /*!< TK_T::REFCTL: TKREN7 Position             */
N#define TK_REFCTL_TKREN7_Msk             (0x1ul << TK_REFCTL_TKREN7_Pos)                   /*!< TK_T::REFCTL: TKREN7 Mask                 */
N
N#define TK_REFCTL_TKREN8_Pos             (8)                                               /*!< TK_T::REFCTL: TKREN8 Position             */
N#define TK_REFCTL_TKREN8_Msk             (0x1ul << TK_REFCTL_TKREN8_Pos)                   /*!< TK_T::REFCTL: TKREN8 Mask                 */
N
N#define TK_REFCTL_TKREN9_Pos             (9)                                               /*!< TK_T::REFCTL: TKREN9 Position             */
N#define TK_REFCTL_TKREN9_Msk             (0x1ul << TK_REFCTL_TKREN9_Pos)                   /*!< TK_T::REFCTL: TKREN9 Mask                 */
N
N#define TK_REFCTL_TKREN10_Pos            (10)                                              /*!< TK_T::REFCTL: TKREN10 Position            */
N#define TK_REFCTL_TKREN10_Msk            (0x1ul << TK_REFCTL_TKREN10_Pos)                  /*!< TK_T::REFCTL: TKREN10 Mask                */
N
N#define TK_REFCTL_TKREN11_Pos            (11)                                              /*!< TK_T::REFCTL: TKREN11 Position            */
N#define TK_REFCTL_TKREN11_Msk            (0x1ul << TK_REFCTL_TKREN11_Pos)                  /*!< TK_T::REFCTL: TKREN11 Mask                */
N
N#define TK_REFCTL_TKREN12_Pos            (12)                                              /*!< TK_T::REFCTL: TKREN12 Position            */
N#define TK_REFCTL_TKREN12_Msk            (0x1ul << TK_REFCTL_TKREN12_Pos)                  /*!< TK_T::REFCTL: TKREN12 Mask                */
N
N#define TK_REFCTL_TKREN13_Pos            (13)                                              /*!< TK_T::REFCTL: TKREN13 Position            */
N#define TK_REFCTL_TKREN13_Msk            (0x1ul << TK_REFCTL_TKREN13_Pos)                  /*!< TK_T::REFCTL: TKREN13 Mask                */
N
N#define TK_REFCTL_TKREN14_Pos            (14)                                              /*!< TK_T::REFCTL: TKREN14 Position            */
N#define TK_REFCTL_TKREN14_Msk            (0x1ul << TK_REFCTL_TKREN14_Pos)                  /*!< TK_T::REFCTL: TKREN14 Mask                */
N
N#define TK_REFCTL_TKREN15_Pos            (15)                                              /*!< TK_T::REFCTL: TKREN15 Position            */
N#define TK_REFCTL_TKREN15_Msk            (0x1ul << TK_REFCTL_TKREN15_Pos)                  /*!< TK_T::REFCTL: TKREN15 Mask                */
N
N#define TK_REFCTL_TKREN16_Pos            (16)                                              /*!< TK_T::REFCTL: TKREN16 Position            */
N#define TK_REFCTL_TKREN16_Msk            (0x1ul << TK_REFCTL_TKREN16_Pos)                  /*!< TK_T::REFCTL: TKREN16 Mask                */
N
N#define TK_REFCTL_SCANALL_Pos            (23)                                              /*!< TK_T::REFCTL: SCANALL Position            */
N#define TK_REFCTL_SCANALL_Msk            (0x1ul << TK_REFCTL_SCANALL_Pos)                  /*!< TK_T::REFCTL: SCANALL Mask                */
N
N#define TK_REFCTL_SENTCTL_Pos            (24)                                              /*!< TK_T::REFCTL: SENTCTL Position            */
N#define TK_REFCTL_SENTCTL_Msk            (0x3ul << TK_REFCTL_SENTCTL_Pos)                  /*!< TK_T::REFCTL: SENTCTL Mask                */
N
N#define TK_REFCTL_SENPTCTL_Pos           (28)                                              /*!< TK_T::REFCTL: SENPTCTL Position           */
N#define TK_REFCTL_SENPTCTL_Msk           (0x3ul << TK_REFCTL_SENPTCTL_Pos)                 /*!< TK_T::REFCTL: SENPTCTL Mask               */
N
N#define TK_CCBDAT0_CCBDAT0_Pos           (0)                                               /*!< TK_T::CCBDAT0: CCBDAT0 Position           */
N#define TK_CCBDAT0_CCBDAT0_Msk           (0xfful << TK_CCBDAT0_CCBDAT0_Pos)                /*!< TK_T::CCBDAT0: CCBDAT0 Mask               */
N
N#define TK_CCBDAT0_CCBDAT1_Pos           (8)                                               /*!< TK_T::CCBDAT0: CCBDAT1 Position           */
N#define TK_CCBDAT0_CCBDAT1_Msk           (0xfful << TK_CCBDAT0_CCBDAT1_Pos)                /*!< TK_T::CCBDAT0: CCBDAT1 Mask               */
N
N#define TK_CCBDAT0_CCBDAT2_Pos           (16)                                              /*!< TK_T::CCBDAT0: CCBDAT2 Position           */
N#define TK_CCBDAT0_CCBDAT2_Msk           (0xfful << TK_CCBDAT0_CCBDAT2_Pos)                /*!< TK_T::CCBDAT0: CCBDAT2 Mask               */
N
N#define TK_CCBDAT0_CCBDAT3_Pos           (24)                                              /*!< TK_T::CCBDAT0: CCBDAT3 Position           */
N#define TK_CCBDAT0_CCBDAT3_Msk           (0xfful << TK_CCBDAT0_CCBDAT3_Pos)                /*!< TK_T::CCBDAT0: CCBDAT3 Mask               */
N
N#define TK_CCBDAT1_CCBDAT4_Pos           (0)                                               /*!< TK_T::CCBDAT1: CCBDAT4 Position           */
N#define TK_CCBDAT1_CCBDAT4_Msk           (0xfful << TK_CCBDAT1_CCBDAT4_Pos)                /*!< TK_T::CCBDAT1: CCBDAT4 Mask               */
N
N#define TK_CCBDAT1_CCBDAT5_Pos           (8)                                               /*!< TK_T::CCBDAT1: CCBDAT5 Position           */
N#define TK_CCBDAT1_CCBDAT5_Msk           (0xfful << TK_CCBDAT1_CCBDAT5_Pos)                /*!< TK_T::CCBDAT1: CCBDAT5 Mask               */
N
N#define TK_CCBDAT1_CCBDAT6_Pos           (16)                                              /*!< TK_T::CCBDAT1: CCBDAT6 Position           */
N#define TK_CCBDAT1_CCBDAT6_Msk           (0xfful << TK_CCBDAT1_CCBDAT6_Pos)                /*!< TK_T::CCBDAT1: CCBDAT6 Mask               */
N
N#define TK_CCBDAT1_CCBDAT7_Pos           (24)                                              /*!< TK_T::CCBDAT1: CCBDAT7 Position           */
N#define TK_CCBDAT1_CCBDAT7_Msk           (0xfful << TK_CCBDAT1_CCBDAT7_Pos)                /*!< TK_T::CCBDAT1: CCBDAT7 Mask               */
N
N#define TK_CCBDAT2_CCBDAT8_Pos           (0)                                               /*!< TK_T::CCBDAT2: CCBDAT8 Position           */
N#define TK_CCBDAT2_CCBDAT8_Msk           (0xfful << TK_CCBDAT2_CCBDAT8_Pos)                /*!< TK_T::CCBDAT2: CCBDAT8 Mask               */
N
N#define TK_CCBDAT2_CCBDAT9_Pos           (8)                                               /*!< TK_T::CCBDAT2: CCBDAT9 Position           */
N#define TK_CCBDAT2_CCBDAT9_Msk           (0xfful << TK_CCBDAT2_CCBDAT9_Pos)                /*!< TK_T::CCBDAT2: CCBDAT9 Mask               */
N
N#define TK_CCBDAT2_CCBDAT10_Pos          (16)                                              /*!< TK_T::CCBDAT2: CCBDAT10 Position          */
N#define TK_CCBDAT2_CCBDAT10_Msk          (0xfful << TK_CCBDAT2_CCBDAT10_Pos)               /*!< TK_T::CCBDAT2: CCBDAT10 Mask              */
N
N#define TK_CCBDAT2_CCBDAT11_Pos          (24)                                              /*!< TK_T::CCBDAT2: CCBDAT11 Position          */
N#define TK_CCBDAT2_CCBDAT11_Msk          (0xfful << TK_CCBDAT2_CCBDAT11_Pos)               /*!< TK_T::CCBDAT2: CCBDAT11 Mask              */
N
N#define TK_CCBDAT3_CCBDAT12_Pos          (0)                                               /*!< TK_T::CCBDAT3: CCBDAT12 Position          */
N#define TK_CCBDAT3_CCBDAT12_Msk          (0xfful << TK_CCBDAT3_CCBDAT12_Pos)               /*!< TK_T::CCBDAT3: CCBDAT12 Mask              */
N
N#define TK_CCBDAT3_CCBDAT13_Pos          (8)                                               /*!< TK_T::CCBDAT3: CCBDAT13 Position          */
N#define TK_CCBDAT3_CCBDAT13_Msk          (0xfful << TK_CCBDAT3_CCBDAT13_Pos)               /*!< TK_T::CCBDAT3: CCBDAT13 Mask              */
N
N#define TK_CCBDAT3_CCBDAT14_Pos          (16)                                              /*!< TK_T::CCBDAT3: CCBDAT14 Position          */
N#define TK_CCBDAT3_CCBDAT14_Msk          (0xfful << TK_CCBDAT3_CCBDAT14_Pos)               /*!< TK_T::CCBDAT3: CCBDAT14 Mask              */
N
N#define TK_CCBDAT3_CCBDAT15_Pos          (24)                                              /*!< TK_T::CCBDAT3: CCBDAT15 Position          */
N#define TK_CCBDAT3_CCBDAT15_Msk          (0xfful << TK_CCBDAT3_CCBDAT15_Pos)               /*!< TK_T::CCBDAT3: CCBDAT15 Mask              */
N
N#define TK_CCBDAT4_CCBDAT16_Pos          (0)                                               /*!< TK_T::CCBDAT4: CCBDAT16 Position          */
N#define TK_CCBDAT4_CCBDAT16_Msk          (0xfful << TK_CCBDAT4_CCBDAT16_Pos)               /*!< TK_T::CCBDAT4: CCBDAT16 Mask              */
N
N#define TK_CCBDAT4_REFCBDAT_Pos          (24)                                              /*!< TK_T::CCBDAT4: REFCBDAT Position          */
N#define TK_CCBDAT4_REFCBDAT_Msk          (0xfful << TK_CCBDAT4_REFCBDAT_Pos)               /*!< TK_T::CCBDAT4: REFCBDAT Mask              */
N
N#define TK_IDLESEL_IDLS_Pos              (0)                                               /*!< TK_T::IDLESEL: IDLS Position              */
N#define TK_IDLESEL_IDLS_Msk              (0xfffffffful << TK_IDLESEL_IDLS_Pos)             /*!< TK_T::IDLESEL: IDLS Mask                  */
N
N#define TK_IDLESEL_IDLSn_Pos             (0)                                               /*!< TK_T::IDLESEL: IDLSn Position             */
N#define TK_IDLESEL_IDLSn_Msk             (0x3ul << TK_IDLESEL_IDLSn_Pos)                   /*!< TK_T::IDLESEL: IDLSn Mask                 */
N
N#define TK_POLSEL_POLSEL_Pos             (0)                                               /*!< TK_T::POLSEL: POLSEL Position             */
N#define TK_POLSEL_POLSEL_Msk             (0xfffffffful << TK_POLSEL_POLSEL_Pos)            /*!< TK_T::POLSEL: POLSEL Mask                 */
N
N#define TK_POLSEL_POLSELn_Pos            (0)                                               /*!< TK_T::POLSEL: POLSELn Position            */
N#define TK_POLSEL_POLSELn_Msk            (0x3ul << TK_POLSEL_POLSELn_Pos)                  /*!< TK_T::POLSEL: POLSELn Mask                */
N
N#define TK_POLCTL_IDLS16_Pos             (0)                                               /*!< TK_T::POLCTL: IDLS16 Position             */
N#define TK_POLCTL_IDLS16_Msk             (0x3ul << TK_POLCTL_IDLS16_Pos)                   /*!< TK_T::POLCTL: IDLS16 Mask                 */
N
N#define TK_POLCTL_POLSEL16_Pos           (2)                                               /*!< TK_T::POLCTL: POLSEL16 Position           */
N#define TK_POLCTL_POLSEL16_Msk           (0x3ul << TK_POLCTL_POLSEL16_Pos)                 /*!< TK_T::POLCTL: POLSEL16 Mask               */
N
N#define TK_POLCTL_CBPOLSEL_Pos           (4)                                               /*!< TK_T::POLCTL: CBPOLSEL Position           */
N#define TK_POLCTL_CBPOLSEL_Msk           (0x3ul << TK_POLCTL_CBPOLSEL_Pos)                 /*!< TK_T::POLCTL: CBPOLSEL Mask               */
N
N#define TK_POLCTL_POLEN0_Pos             (8)                                               /*!< TK_T::POLCTL: POLEN0 Position             */
N#define TK_POLCTL_POLEN0_Msk             (0x1ul << TK_POLCTL_POLEN0_Pos)                   /*!< TK_T::POLCTL: POLEN0 Mask                 */
N
N#define TK_POLCTL_POLEN1_Pos             (9)                                               /*!< TK_T::POLCTL: POLEN1 Position             */
N#define TK_POLCTL_POLEN1_Msk             (0x1ul << TK_POLCTL_POLEN1_Pos)                   /*!< TK_T::POLCTL: POLEN1 Mask                 */
N
N#define TK_POLCTL_POLEN2_Pos             (10)                                              /*!< TK_T::POLCTL: POLEN2 Position             */
N#define TK_POLCTL_POLEN2_Msk             (0x1ul << TK_POLCTL_POLEN2_Pos)                   /*!< TK_T::POLCTL: POLEN2 Mask                 */
N
N#define TK_POLCTL_POLEN3_Pos             (11)                                              /*!< TK_T::POLCTL: POLEN3 Position             */
N#define TK_POLCTL_POLEN3_Msk             (0x1ul << TK_POLCTL_POLEN3_Pos)                   /*!< TK_T::POLCTL: POLEN3 Mask                 */
N
N#define TK_POLCTL_POLEN4_Pos             (12)                                              /*!< TK_T::POLCTL: POLEN4 Position             */
N#define TK_POLCTL_POLEN4_Msk             (0x1ul << TK_POLCTL_POLEN4_Pos)                   /*!< TK_T::POLCTL: POLEN4 Mask                 */
N
N#define TK_POLCTL_POLEN5_Pos             (13)                                              /*!< TK_T::POLCTL: POLEN5 Position             */
N#define TK_POLCTL_POLEN5_Msk             (0x1ul << TK_POLCTL_POLEN5_Pos)                   /*!< TK_T::POLCTL: POLEN5 Mask                 */
N
N#define TK_POLCTL_POLEN6_Pos             (14)                                              /*!< TK_T::POLCTL: POLEN6 Position             */
N#define TK_POLCTL_POLEN6_Msk             (0x1ul << TK_POLCTL_POLEN6_Pos)                   /*!< TK_T::POLCTL: POLEN6 Mask                 */
N
N#define TK_POLCTL_POLEN7_Pos             (15)                                              /*!< TK_T::POLCTL: POLEN7 Position             */
N#define TK_POLCTL_POLEN7_Msk             (0x1ul << TK_POLCTL_POLEN7_Pos)                   /*!< TK_T::POLCTL: POLEN7 Mask                 */
N
N#define TK_POLCTL_POLEN8_Pos             (16)                                              /*!< TK_T::POLCTL: POLEN8 Position             */
N#define TK_POLCTL_POLEN8_Msk             (0x1ul << TK_POLCTL_POLEN8_Pos)                   /*!< TK_T::POLCTL: POLEN8 Mask                 */
N
N#define TK_POLCTL_POLEN9_Pos             (17)                                              /*!< TK_T::POLCTL: POLEN9 Position             */
N#define TK_POLCTL_POLEN9_Msk             (0x1ul << TK_POLCTL_POLEN9_Pos)                   /*!< TK_T::POLCTL: POLEN9 Mask                 */
N
N#define TK_POLCTL_POLEN10_Pos            (18)                                              /*!< TK_T::POLCTL: POLEN10 Position            */
N#define TK_POLCTL_POLEN10_Msk            (0x1ul << TK_POLCTL_POLEN10_Pos)                  /*!< TK_T::POLCTL: POLEN10 Mask                */
N
N#define TK_POLCTL_POLEN11_Pos            (19)                                              /*!< TK_T::POLCTL: POLEN11 Position            */
N#define TK_POLCTL_POLEN11_Msk            (0x1ul << TK_POLCTL_POLEN11_Pos)                  /*!< TK_T::POLCTL: POLEN11 Mask                */
N
N#define TK_POLCTL_POLEN12_Pos            (20)                                              /*!< TK_T::POLCTL: POLEN12 Position            */
N#define TK_POLCTL_POLEN12_Msk            (0x1ul << TK_POLCTL_POLEN12_Pos)                  /*!< TK_T::POLCTL: POLEN12 Mask                */
N
N#define TK_POLCTL_POLEN13_Pos            (21)                                              /*!< TK_T::POLCTL: POLEN13 Position            */
N#define TK_POLCTL_POLEN13_Msk            (0x1ul << TK_POLCTL_POLEN13_Pos)                  /*!< TK_T::POLCTL: POLEN13 Mask                */
N
N#define TK_POLCTL_POLEN14_Pos            (22)                                              /*!< TK_T::POLCTL: POLEN14 Position            */
N#define TK_POLCTL_POLEN14_Msk            (0x1ul << TK_POLCTL_POLEN14_Pos)                  /*!< TK_T::POLCTL: POLEN14 Mask                */
N
N#define TK_POLCTL_POLEN15_Pos            (23)                                              /*!< TK_T::POLCTL: POLEN15 Position            */
N#define TK_POLCTL_POLEN15_Msk            (0x1ul << TK_POLCTL_POLEN15_Pos)                  /*!< TK_T::POLCTL: POLEN15 Mask                */
N
N#define TK_POLCTL_POLEN16_Pos            (24)                                              /*!< TK_T::POLCTL: POLEN16 Position            */
N#define TK_POLCTL_POLEN16_Msk            (0x1ul << TK_POLCTL_POLEN16_Pos)                  /*!< TK_T::POLCTL: POLEN16 Mask                */
N
N#define TK_POLCTL_SPOTINIT_Pos           (31)                                              /*!< TK_T::POLCTL: SPOTINIT Position           */
N#define TK_POLCTL_SPOTINIT_Msk           (0x1ul << TK_POLCTL_SPOTINIT_Pos)                 /*!< TK_T::POLCTL: SPOTINIT Mask               */
N
N#define TK_STATUS_BUSY_Pos               (0)                                               /*!< TK_T::STATUS: BUSY Position               */
N#define TK_STATUS_BUSY_Msk               (0x1ul << TK_STATUS_BUSY_Pos)                     /*!< TK_T::STATUS: BUSY Mask                   */
N
N#define TK_STATUS_SCIF_Pos               (1)                                               /*!< TK_T::STATUS: SCIF Position               */
N#define TK_STATUS_SCIF_Msk               (0x1ul << TK_STATUS_SCIF_Pos)                     /*!< TK_T::STATUS: SCIF Mask                   */
N
N#define TK_STATUS_TKIF0_Pos              (8)                                               /*!< TK_T::STATUS: TKIF0 Position              */
N#define TK_STATUS_TKIF0_Msk              (0x1ul << TK_STATUS_TKIF0_Pos)                    /*!< TK_T::STATUS: TKIF0 Mask                  */
N
N#define TK_STATUS_TKIF1_Pos              (9)                                               /*!< TK_T::STATUS: TKIF1 Position              */
N#define TK_STATUS_TKIF1_Msk              (0x1ul << TK_STATUS_TKIF1_Pos)                    /*!< TK_T::STATUS: TKIF1 Mask                  */
N
N#define TK_STATUS_TKIF2_Pos              (10)                                              /*!< TK_T::STATUS: TKIF2 Position              */
N#define TK_STATUS_TKIF2_Msk              (0x1ul << TK_STATUS_TKIF2_Pos)                    /*!< TK_T::STATUS: TKIF2 Mask                  */
N
N#define TK_STATUS_TKIF3_Pos              (11)                                              /*!< TK_T::STATUS: TKIF3 Position              */
N#define TK_STATUS_TKIF3_Msk              (0x1ul << TK_STATUS_TKIF3_Pos)                    /*!< TK_T::STATUS: TKIF3 Mask                  */
N
N#define TK_STATUS_TKIF4_Pos              (12)                                              /*!< TK_T::STATUS: TKIF4 Position              */
N#define TK_STATUS_TKIF4_Msk              (0x1ul << TK_STATUS_TKIF4_Pos)                    /*!< TK_T::STATUS: TKIF4 Mask                  */
N
N#define TK_STATUS_TKIF5_Pos              (13)                                              /*!< TK_T::STATUS: TKIF5 Position              */
N#define TK_STATUS_TKIF5_Msk              (0x1ul << TK_STATUS_TKIF5_Pos)                    /*!< TK_T::STATUS: TKIF5 Mask                  */
N
N#define TK_STATUS_TKIF6_Pos              (14)                                              /*!< TK_T::STATUS: TKIF6 Position              */
N#define TK_STATUS_TKIF6_Msk              (0x1ul << TK_STATUS_TKIF6_Pos)                    /*!< TK_T::STATUS: TKIF6 Mask                  */
N
N#define TK_STATUS_TKIF7_Pos              (15)                                              /*!< TK_T::STATUS: TKIF7 Position              */
N#define TK_STATUS_TKIF7_Msk              (0x1ul << TK_STATUS_TKIF7_Pos)                    /*!< TK_T::STATUS: TKIF7 Mask                  */
N
N#define TK_STATUS_TKIF8_Pos              (16)                                              /*!< TK_T::STATUS: TKIF8 Position              */
N#define TK_STATUS_TKIF8_Msk              (0x1ul << TK_STATUS_TKIF8_Pos)                    /*!< TK_T::STATUS: TKIF8 Mask                  */
N
N#define TK_STATUS_TKIF9_Pos              (17)                                              /*!< TK_T::STATUS: TKIF9 Position              */
N#define TK_STATUS_TKIF9_Msk              (0x1ul << TK_STATUS_TKIF9_Pos)                    /*!< TK_T::STATUS: TKIF9 Mask                  */
N
N#define TK_STATUS_TKIF10_Pos             (18)                                              /*!< TK_T::STATUS: TKIF10 Position             */
N#define TK_STATUS_TKIF10_Msk             (0x1ul << TK_STATUS_TKIF10_Pos)                   /*!< TK_T::STATUS: TKIF10 Mask                 */
N
N#define TK_STATUS_TKIF11_Pos             (19)                                              /*!< TK_T::STATUS: TKIF11 Position             */
N#define TK_STATUS_TKIF11_Msk             (0x1ul << TK_STATUS_TKIF11_Pos)                   /*!< TK_T::STATUS: TKIF11 Mask                 */
N
N#define TK_STATUS_TKIF12_Pos             (20)                                              /*!< TK_T::STATUS: TKIF12 Position             */
N#define TK_STATUS_TKIF12_Msk             (0x1ul << TK_STATUS_TKIF12_Pos)                   /*!< TK_T::STATUS: TKIF12 Mask                 */
N
N#define TK_STATUS_TKIF13_Pos             (21)                                              /*!< TK_T::STATUS: TKIF13 Position             */
N#define TK_STATUS_TKIF13_Msk             (0x1ul << TK_STATUS_TKIF13_Pos)                   /*!< TK_T::STATUS: TKIF13 Mask                 */
N
N#define TK_STATUS_TKIF14_Pos             (22)                                              /*!< TK_T::STATUS: TKIF14 Position             */
N#define TK_STATUS_TKIF14_Msk             (0x1ul << TK_STATUS_TKIF14_Pos)                   /*!< TK_T::STATUS: TKIF14 Mask                 */
N
N#define TK_STATUS_TKIF15_Pos             (23)                                              /*!< TK_T::STATUS: TKIF15 Position             */
N#define TK_STATUS_TKIF15_Msk             (0x1ul << TK_STATUS_TKIF15_Pos)                   /*!< TK_T::STATUS: TKIF15 Mask                 */
N
N#define TK_STATUS_TKIF16_Pos             (24)                                              /*!< TK_T::STATUS: TKIF16 Position             */
N#define TK_STATUS_TKIF16_Msk             (0x1ul << TK_STATUS_TKIF16_Pos)                   /*!< TK_T::STATUS: TKIF16 Mask                 */
N
N#define TK_DAT0_TKDAT0_Pos               (0)                                               /*!< TK_T::DAT0: TKDAT0 Position               */
N#define TK_DAT0_TKDAT0_Msk               (0xfful << TK_DAT0_TKDAT0_Pos)                    /*!< TK_T::DAT0: TKDAT0 Mask                   */
N
N#define TK_DAT0_TKDAT1_Pos               (8)                                               /*!< TK_T::DAT0: TKDAT1 Position               */
N#define TK_DAT0_TKDAT1_Msk               (0xfful << TK_DAT0_TKDAT1_Pos)                    /*!< TK_T::DAT0: TKDAT1 Mask                   */
N
N#define TK_DAT0_TKDAT2_Pos               (16)                                              /*!< TK_T::DAT0: TKDAT2 Position               */
N#define TK_DAT0_TKDAT2_Msk               (0xfful << TK_DAT0_TKDAT2_Pos)                    /*!< TK_T::DAT0: TKDAT2 Mask                   */
N
N#define TK_DAT0_TKDAT3_Pos               (24)                                              /*!< TK_T::DAT0: TKDAT3 Position               */
N#define TK_DAT0_TKDAT3_Msk               (0xfful << TK_DAT0_TKDAT3_Pos)                    /*!< TK_T::DAT0: TKDAT3 Mask                   */
N
N#define TK_DAT1_TKDAT4_Pos               (0)                                               /*!< TK_T::DAT1: TKDAT4 Position               */
N#define TK_DAT1_TKDAT4_Msk               (0xfful << TK_DAT1_TKDAT4_Pos)                    /*!< TK_T::DAT1: TKDAT4 Mask                   */
N
N#define TK_DAT1_TKDAT5_Pos               (8)                                               /*!< TK_T::DAT1: TKDAT5 Position               */
N#define TK_DAT1_TKDAT5_Msk               (0xfful << TK_DAT1_TKDAT5_Pos)                    /*!< TK_T::DAT1: TKDAT5 Mask                   */
N
N#define TK_DAT1_TKDAT6_Pos               (16)                                              /*!< TK_T::DAT1: TKDAT6 Position               */
N#define TK_DAT1_TKDAT6_Msk               (0xfful << TK_DAT1_TKDAT6_Pos)                    /*!< TK_T::DAT1: TKDAT6 Mask                   */
N
N#define TK_DAT1_TKDAT7_Pos               (24)                                              /*!< TK_T::DAT1: TKDAT7 Position               */
N#define TK_DAT1_TKDAT7_Msk               (0xfful << TK_DAT1_TKDAT7_Pos)                    /*!< TK_T::DAT1: TKDAT7 Mask                   */
N
N#define TK_DAT2_TKDAT8_Pos               (0)                                               /*!< TK_T::DAT2: TKDAT8 Position               */
N#define TK_DAT2_TKDAT8_Msk               (0xfful << TK_DAT2_TKDAT8_Pos)                    /*!< TK_T::DAT2: TKDAT8 Mask                   */
N
N#define TK_DAT2_TKDAT9_Pos               (8)                                               /*!< TK_T::DAT2: TKDAT9 Position               */
N#define TK_DAT2_TKDAT9_Msk               (0xfful << TK_DAT2_TKDAT9_Pos)                    /*!< TK_T::DAT2: TKDAT9 Mask                   */
N
N#define TK_DAT2_TKDAT10_Pos              (16)                                              /*!< TK_T::DAT2: TKDAT10 Position              */
N#define TK_DAT2_TKDAT10_Msk              (0xfful << TK_DAT2_TKDAT10_Pos)                   /*!< TK_T::DAT2: TKDAT10 Mask                  */
N
N#define TK_DAT2_TKDAT11_Pos              (24)                                              /*!< TK_T::DAT2: TKDAT11 Position              */
N#define TK_DAT2_TKDAT11_Msk              (0xfful << TK_DAT2_TKDAT11_Pos)                   /*!< TK_T::DAT2: TKDAT11 Mask                  */
N
N#define TK_DAT3_TKDAT12_Pos              (0)                                               /*!< TK_T::DAT3: TKDAT12 Position              */
N#define TK_DAT3_TKDAT12_Msk              (0xfful << TK_DAT3_TKDAT12_Pos)                   /*!< TK_T::DAT3: TKDAT12 Mask                  */
N
N#define TK_DAT3_TKDAT13_Pos              (8)                                               /*!< TK_T::DAT3: TKDAT13 Position              */
N#define TK_DAT3_TKDAT13_Msk              (0xfful << TK_DAT3_TKDAT13_Pos)                   /*!< TK_T::DAT3: TKDAT13 Mask                  */
N
N#define TK_DAT3_TKDAT14_Pos              (16)                                              /*!< TK_T::DAT3: TKDAT14 Position              */
N#define TK_DAT3_TKDAT14_Msk              (0xfful << TK_DAT3_TKDAT14_Pos)                   /*!< TK_T::DAT3: TKDAT14 Mask                  */
N
N#define TK_DAT3_TKDAT15_Pos              (24)                                              /*!< TK_T::DAT3: TKDAT15 Position              */
N#define TK_DAT3_TKDAT15_Msk              (0xfful << TK_DAT3_TKDAT15_Pos)                   /*!< TK_T::DAT3: TKDAT15 Mask                  */
N
N#define TK_DAT4_TKDAT16_Pos              (0)                                               /*!< TK_T::DAT4: TKDAT16 Position              */
N#define TK_DAT4_TKDAT16_Msk              (0xfful << TK_DAT4_TKDAT16_Pos)                   /*!< TK_T::DAT4: TKDAT16 Mask                  */
N
N#define TK_INTEN_SCTHIEN_Pos             (0)                                               /*!< TK_T::INTEN: SCTHIEN Position             */
N#define TK_INTEN_SCTHIEN_Msk             (0x1ul << TK_INTEN_SCTHIEN_Pos)                   /*!< TK_T::INTEN: SCTHIEN Mask                 */
N
N#define TK_INTEN_SCINTEN_Pos             (1)                                               /*!< TK_T::INTEN: SCINTEN Position             */
N#define TK_INTEN_SCINTEN_Msk             (0x1ul << TK_INTEN_SCINTEN_Pos)                   /*!< TK_T::INTEN: SCINTEN Mask                 */
N
N#define TK_INTEN_THIMOD_Pos              (31)                                              /*!< TK_T::INTEN: THIMOD Position              */
N#define TK_INTEN_THIMOD_Msk              (0x1ul << TK_INTEN_THIMOD_Pos)                    /*!< TK_T::INTEN: THIMOD Mask                  */
N
N#define TK_TH0_1_LTH0_Pos                (0)                                               /*!< TK_T::TH0_1: LTH0 Position                */
N#define TK_TH0_1_LTH0_Msk                (0xfful << TK_TH0_1_LTH0_Pos)                     /*!< TK_T::TH0_1: LTH0 Mask                    */
N
N#define TK_TH0_1_HTH0_Pos                (8)                                               /*!< TK_T::TH0_1: HTH0 Position                */
N#define TK_TH0_1_HTH0_Msk                (0xfful << TK_TH0_1_HTH0_Pos)                     /*!< TK_T::TH0_1: HTH0 Mask                    */
N
N#define TK_TH0_1_LTH1_Pos                (16)                                              /*!< TK_T::TH0_1: LTH1 Position                */
N#define TK_TH0_1_LTH1_Msk                (0xfful << TK_TH0_1_LTH1_Pos)                     /*!< TK_T::TH0_1: LTH1 Mask                    */
N
N#define TK_TH0_1_HTH1_Pos                (24)                                              /*!< TK_T::TH0_1: HTH1 Position                */
N#define TK_TH0_1_HTH1_Msk                (0xfful << TK_TH0_1_HTH1_Pos)                     /*!< TK_T::TH0_1: HTH1 Mask                    */
N
N#define TK_TH2_3_LTH2_Pos                (0)                                               /*!< TK_T::TH2_3: LTH2 Position                */
N#define TK_TH2_3_LTH2_Msk                (0xfful << TK_TH2_3_LTH2_Pos)                     /*!< TK_T::TH2_3: LTH2 Mask                    */
N
N#define TK_TH2_3_HTH2_Pos                (8)                                               /*!< TK_T::TH2_3: HTH2 Position                */
N#define TK_TH2_3_HTH2_Msk                (0xfful << TK_TH2_3_HTH2_Pos)                     /*!< TK_T::TH2_3: HTH2 Mask                    */
N
N#define TK_TH2_3_LTH3_Pos                (16)                                              /*!< TK_T::TH2_3: LTH3 Position                */
N#define TK_TH2_3_LTH3_Msk                (0xfful << TK_TH2_3_LTH3_Pos)                     /*!< TK_T::TH2_3: LTH3 Mask                    */
N
N#define TK_TH2_3_HTH3_Pos                (24)                                              /*!< TK_T::TH2_3: HTH3 Position                */
N#define TK_TH2_3_HTH3_Msk                (0xfful << TK_TH2_3_HTH3_Pos)                     /*!< TK_T::TH2_3: HTH3 Mask                    */
N
N#define TK_TH4_5_LTH4_Pos                (0)                                               /*!< TK_T::TH4_5: LTH4 Position                */
N#define TK_TH4_5_LTH4_Msk                (0xfful << TK_TH4_5_LTH4_Pos)                     /*!< TK_T::TH4_5: LTH4 Mask                    */
N
N#define TK_TH4_5_HTH4_Pos                (8)                                               /*!< TK_T::TH4_5: HTH4 Position                */
N#define TK_TH4_5_HTH4_Msk                (0xfful << TK_TH4_5_HTH4_Pos)                     /*!< TK_T::TH4_5: HTH4 Mask                    */
N
N#define TK_TH4_5_LTH5_Pos                (16)                                              /*!< TK_T::TH4_5: LTH5 Position                */
N#define TK_TH4_5_LTH5_Msk                (0xfful << TK_TH4_5_LTH5_Pos)                     /*!< TK_T::TH4_5: LTH5 Mask                    */
N
N#define TK_TH4_5_HTH5_Pos                (24)                                              /*!< TK_T::TH4_5: HTH5 Position                */
N#define TK_TH4_5_HTH5_Msk                (0xfful << TK_TH4_5_HTH5_Pos)                     /*!< TK_T::TH4_5: HTH5 Mask                    */
N
N#define TK_TH6_7_LTH6_Pos                (0)                                               /*!< TK_T::TH6_7: LTH6 Position                */
N#define TK_TH6_7_LTH6_Msk                (0xfful << TK_TH6_7_LTH6_Pos)                     /*!< TK_T::TH6_7: LTH6 Mask                    */
N
N#define TK_TH6_7_HTH6_Pos                (8)                                               /*!< TK_T::TH6_7: HTH6 Position                */
N#define TK_TH6_7_HTH6_Msk                (0xfful << TK_TH6_7_HTH6_Pos)                     /*!< TK_T::TH6_7: HTH6 Mask                    */
N
N#define TK_TH6_7_LTH7_Pos                (16)                                              /*!< TK_T::TH6_7: LTH7 Position                */
N#define TK_TH6_7_LTH7_Msk                (0xfful << TK_TH6_7_LTH7_Pos)                     /*!< TK_T::TH6_7: LTH7 Mask                    */
N
N#define TK_TH6_7_HTH7_Pos                (24)                                              /*!< TK_T::TH6_7: HTH7 Position                */
N#define TK_TH6_7_HTH7_Msk                (0xfful << TK_TH6_7_HTH7_Pos)                     /*!< TK_T::TH6_7: HTH7 Mask                    */
N
N#define TK_TH8_9_LTH8_Pos                (0)                                               /*!< TK_T::TH8_9: LTH8 Position                */
N#define TK_TH8_9_LTH8_Msk                (0xfful << TK_TH8_9_LTH8_Pos)                     /*!< TK_T::TH8_9: LTH8 Mask                    */
N
N#define TK_TH8_9_HTH8_Pos                (8)                                               /*!< TK_T::TH8_9: HTH8 Position                */
N#define TK_TH8_9_HTH8_Msk                (0xfful << TK_TH8_9_HTH8_Pos)                     /*!< TK_T::TH8_9: HTH8 Mask                    */
N
N#define TK_TH8_9_LTH9_Pos                (16)                                              /*!< TK_T::TH8_9: LTH9 Position                */
N#define TK_TH8_9_LTH9_Msk                (0xfful << TK_TH8_9_LTH9_Pos)                     /*!< TK_T::TH8_9: LTH9 Mask                    */
N
N#define TK_TH8_9_HTH9_Pos                (24)                                              /*!< TK_T::TH8_9: HTH9 Position                */
N#define TK_TH8_9_HTH9_Msk                (0xfful << TK_TH8_9_HTH9_Pos)                     /*!< TK_T::TH8_9: HTH9 Mask                    */
N
N#define TK_TH10_11_LTH10_Pos             (0)                                               /*!< TK_T::TH10_11: LTH10 Position             */
N#define TK_TH10_11_LTH10_Msk             (0xfful << TK_TH10_11_LTH10_Pos)                  /*!< TK_T::TH10_11: LTH10 Mask                 */
N
N#define TK_TH10_11_HTH10_Pos             (8)                                               /*!< TK_T::TH10_11: HTH10 Position             */
N#define TK_TH10_11_HTH10_Msk             (0xfful << TK_TH10_11_HTH10_Pos)                  /*!< TK_T::TH10_11: HTH10 Mask                 */
N
N#define TK_TH10_11_LTH11_Pos             (16)                                              /*!< TK_T::TH10_11: LTH11 Position             */
N#define TK_TH10_11_LTH11_Msk             (0xfful << TK_TH10_11_LTH11_Pos)                  /*!< TK_T::TH10_11: LTH11 Mask                 */
N
N#define TK_TH10_11_HTH11_Pos             (24)                                              /*!< TK_T::TH10_11: HTH11 Position             */
N#define TK_TH10_11_HTH11_Msk             (0xfful << TK_TH10_11_HTH11_Pos)                  /*!< TK_T::TH10_11: HTH11 Mask                 */
N
N#define TK_TH12_13_LTH12_Pos             (0)                                               /*!< TK_T::TH12_13: LTH12 Position             */
N#define TK_TH12_13_LTH12_Msk             (0xfful << TK_TH12_13_LTH12_Pos)                  /*!< TK_T::TH12_13: LTH12 Mask                 */
N
N#define TK_TH12_13_HTH12_Pos             (8)                                               /*!< TK_T::TH12_13: HTH12 Position             */
N#define TK_TH12_13_HTH12_Msk             (0xfful << TK_TH12_13_HTH12_Pos)                  /*!< TK_T::TH12_13: HTH12 Mask                 */
N
N#define TK_TH12_13_LTH13_Pos             (16)                                              /*!< TK_T::TH12_13: LTH13 Position             */
N#define TK_TH12_13_LTH13_Msk             (0xfful << TK_TH12_13_LTH13_Pos)                  /*!< TK_T::TH12_13: LTH13 Mask                 */
N
N#define TK_TH12_13_HTH13_Pos             (24)                                              /*!< TK_T::TH12_13: HTH13 Position             */
N#define TK_TH12_13_HTH13_Msk             (0xfful << TK_TH12_13_HTH13_Pos)                  /*!< TK_T::TH12_13: HTH13 Mask                 */
N
N#define TK_TH14_15_LTH14_Pos             (0)                                               /*!< TK_T::TH14_15: LTH14 Position             */
N#define TK_TH14_15_LTH14_Msk             (0xfful << TK_TH14_15_LTH14_Pos)                  /*!< TK_T::TH14_15: LTH14 Mask                 */
N
N#define TK_TH14_15_HTH14_Pos             (8)                                               /*!< TK_T::TH14_15: HTH14 Position             */
N#define TK_TH14_15_HTH14_Msk             (0xfful << TK_TH14_15_HTH14_Pos)                  /*!< TK_T::TH14_15: HTH14 Mask                 */
N
N#define TK_TH14_15_LTH15_Pos             (16)                                              /*!< TK_T::TH14_15: LTH15 Position             */
N#define TK_TH14_15_LTH15_Msk             (0xfful << TK_TH14_15_LTH15_Pos)                  /*!< TK_T::TH14_15: LTH15 Mask                 */
N
N#define TK_TH14_15_HTH15_Pos             (24)                                              /*!< TK_T::TH14_15: HTH15 Position             */
N#define TK_TH14_15_HTH15_Msk             (0xfful << TK_TH14_15_HTH15_Pos)                  /*!< TK_T::TH14_15: HTH15 Mask                 */
N
N#define TK_TH16_LTH16_Pos                (0)                                               /*!< TK_T::TH16: LTH16 Position                */
N#define TK_TH16_LTH16_Msk                (0xfful << TK_TH16_LTH16_Pos)                     /*!< TK_T::TH16: LTH16 Mask                    */
N
N#define TK_TH16_HTH16_Pos                (8)                                               /*!< TK_T::TH16: HTH16 Position                */
N#define TK_TH16_HTH16_Msk                (0xfful << TK_TH16_HTH16_Pos)                     /*!< TK_T::TH16: HTH16 Mask                    */
N
N/**@}*/ /* TK_CONST */
N/**@}*/ /* end of TK register group */
N
N
N/*---------------------- Timer Controller -------------------------*/
N/**
N    @addtogroup TMR Timer Controller(TMR)
N    Memory Mapped Structure for TMR Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N
N
N/**
N * @var TIMER_T::CTL
N * Offset: 0x00  Timer Control and Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |PSC       |Prescale Counter
N * |        |          |Timer input clock or event source is divided by (PSC+1) before it is fed to the timer up counter.
N * |        |          |If this field is 0 (PSC = 0), then there is no scaling.
N * |[17]    |WKTKEN    |Wake-Up Touch-Key Scan Enable Bit
N * |        |          |If this bit is set to 1, timer time-out interrupt in Power-down mode can be triggered Touch-Key start scan.
N * |        |          |0 = Timer time-out interrupt signal trigger Touch-Key start scan Disabled.
N * |        |          |1 = Timer time-out interrupt signal trigger Touch-Key start scan Enabled.
N * |        |          |Note: This bit is only available in TIMER0_CTL.
N * |[18]    |TRGSSEL   |Trigger Source Select Bit
N * |        |          |This bit is used to select trigger source is form Timer time-out interrupt signal or capture interrupt signal.
N * |        |          |0 = Timer time-out interrupt signal is used to trigger PWM, EADC and DAC.
N * |        |          |1 = Capture interrupt signal is used to trigger PWM, EADC and DAC.
N * |[19]    |TRGPWM    |Trigger PWM Enable Bit
N * |        |          |If this bit is set to 1, timer time-out interrupt or capture interrupt can be triggered PWM.
N * |        |          |0 = Timer interrupt trigger PWM Disabled.
N * |        |          |1 = Timer interrupt trigger PWM Enabled.
N * |        |          |Note: If TRGSSEL (TIMERx_CTL[18]) = 0, time-out interrupt signal will trigger PWM.
N * |        |          |If TRGSSEL (TIMERx_CTL[18]) = 1, capture interrupt signal will trigger PWM.
N * |[20]    |TRGDAC    |Trigger DAC Enable Bit
N * |        |          |If this bit is set to 1, timer time-out interrupt or capture interrupt can be triggered DAC.
N * |        |          |0 = Timer interrupt trigger DAC Disabled.
N * |        |          |1 = Timer interrupt trigger DAC Enabled.
N * |        |          |Note: If TRGSSEL (TIMERx_CTL[18]) = 0, time-out interrupt signal will trigger DAC.
N * |        |          |If TRGSSEL (TIMERx_CTL[18]) = 1, capture interrupt signal will trigger DAC.
N * |[21]    |TRGEADC   |Trigger EADC Enable Bit
N * |        |          |If this bit is set to 1, timer time-out interrupt or capture interrupt can be triggered EADC.
N * |        |          |0 = Timer interrupt trigger EADC Disabled.
N * |        |          |1 = Timer interrupt trigger EADC Enabled.
N * |        |          |Note: If TRGSSEL (TIMERx_CTL[18]) = 0, time-out interrupt signal will trigger EADC.
N * |        |          |If TRGSSEL (TIMERx_CTL[18]) = 1, capture interrupt signal will trigger EADC.
N * |[22]    |TGLPINSEL |Toggle-Output Pin Select
N * |        |          |0 = Toggle mode output to Tx_OUT (Timer Event Counter Pin).
N * |        |          |1 = Toggle mode output to Tx_EXT(Timer External Capture Pin).
N * |[23]    |WKEN      |Wake-Up Function Enable Bit
N * |        |          |If this bit is set to 1, while timer interrupt flag TIF (TIMERx_INTSTS[0]) is 1 and INTEN (TIMERx_CTL[29]) is enabled, the timer interrupt signal will generate a wake-up trigger event to CPU.
N * |        |          |0 = Wake-up function Disabled if timer interrupt signal generated.
N * |        |          |1 = Wake-up function Enabled if timer interrupt signal generated.
N * |[24]    |EXTCNTEN  |Event Counter Mode Enable Bit
N * |        |          |This bit is for external counting pin function enabled.
N * |        |          |0 = Event counter mode Disabled.
N * |        |          |1 = Event counter mode Enabled.
N * |        |          |Note: When timer is used as an event counter, this bit should be set to 1 and select HCLK as timer clock source.
N * |[25]    |ACTSTS    |Timer Active Status Bit (Read Only)
N * |        |          |This bit indicates the 24-bit up counter status.
N * |        |          |0 = 24-bit up counter is not active.
N * |        |          |1 = 24-bit up counter is active.
N * |[26]    |RSTCNT    |Timer Counter Reset Bit
N * |        |          |Setting this bit will reset the 24-bit up counter value CNT (TIMERx_CNT[23:0]) and also force CNTEN (TIMERx_CTL[30]) to 0 if ACTSTS (TIMERx_CTL[25]) is 1.
N * |        |          |0 = No effect.
N * |        |          |1 = Reset internal 8-bit prescale counter, 24-bit up counter value and CNTEN bit.
N * |[28:27] |OPMODE    |Timer Counting Mode Select
N * |        |          |00 = The Timer controller is operated in One-shot mode.
N * |        |          |01 = The Timer controller is operated in Periodic mode.
N * |        |          |10 = The Timer controller is operated in Toggle-output mode.
N * |        |          |11 = The Timer controller is operated in Continuous Counting mode.
N * |[29]    |INTEN     |Timer Interrupt Enable Bit
N * |        |          |0 = Timer Interrupt Disabled.
N * |        |          |1 = Timer Interrupt Enabled.
N * |        |          |Note: If this bit is enabled, when the timer interrupt flag TIF is set to 1, the timer interrupt signal is generated and inform to CPU.
N * |[30]    |CNTEN     |Timer Counting Enable Bit
N * |        |          |0 = Stops/Suspends counting.
N * |        |          |1 = Starts counting.
N * |        |          |Note1: In stop status, and then set CNTEN to 1 will enable the 24-bit up counter to keep counting from the last stop counting value.
N * |        |          |Note2: This bit is auto-cleared by hardware in one-shot mode (TIMER_CTL[28:27] = 00) when the timer interrupt flag TIF (TIMERx_INTSTS[0]) is generated.
N * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable
N * |        |          |0 = ICE debug mode acknowledgement effects TIMER counting.
N * |        |          |TIMER counter will be held while CPU is held by ICE.
N * |        |          |1 = ICE debug mode acknowledgement Disabled.
N * |        |          |TIMER counter will keep going no matter CPU is held by ICE or not.
N * @var TIMER_T::CMP
N * Offset: 0x04  Timer Compare Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[23:0]  |CMPDAT    |Timer Compared Value
N * |        |          |CMPDAT is a 24-bit compared value register.
N * |        |          |When the internal 24-bit up counter value is equal to CMPDAT value, the TIF (TIMERx_INTSTS[0] Timer Interrupt Flag) will set to 1.
N * |        |          |Time-out period = (Period of timer clock input) * (8-bit PSC + 1) * (24-bit CMPDAT).
N * |        |          |Note1: Never write 0x0 or 0x1 in CMPDAT field, or the core will run into unknown state.
N * |        |          |Note2: When timer is operating at continuous counting mode, the 24-bit up counter will keep counting continuously even if user writes a new value into CMPDAT field.
N * |        |          |But if timer is operating at other modes, the 24-bit up counter will restart counting from 0 and using newest CMPDAT value to be the timer compared value while user writes a new value into CMPDAT field.
N * @var TIMER_T::INTSTS
N * Offset: 0x08  Timer Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TIF       |Timer Interrupt Flag
N * |        |          |This bit indicates the interrupt flag status of Timer while 24-bit timer up counter CNT (TIMERx_CNT[23:0]) value reaches to CMPDAT (TIMERx_CMP[23:0]) value.
N * |        |          |0 = No effect.
N * |        |          |1 = CNT value matches the CMPDAT value.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * |[1]     |TWKF      |Timer Wake-Up Flag
N * |        |          |This bit indicates the interrupt wake-up flag status of timer.
N * |        |          |0 = Timer does not cause CPU wake-up.
N * |        |          |1 = CPU wake-up from Idle or Power-down mode if timer time-out interrupt signal generated.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * @var TIMER_T::CNT
N * Offset: 0x0C  Timer Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[23:0]  |CNT       |Timer Data Register
N * |        |          |This field can be reflected the internal 24-bit timer counter value or external event input counter value from Tx_CNT (x=0~3) pin.
N * |        |          |If EXTCNTEN (TIMERx_CTL[24] ) is 0, user can read CNT value for getting current 24- bit counter value .
N * |        |          |If EXTCNTEN (TIMERx_CTL[24] ) is 1, user can read CNT value for getting current 24- bit event input counter value.
N * @var TIMER_T::CAP
N * Offset: 0x10  Timer Capture Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[23:0]  |CAPDAT    |Timer Capture Data Register
N * |        |          |When CAPEN (TIMERx_EXTCTL[3]) bit is set, CAPFUNCS (TIMERx_EXTCTL[4]) bit is 0, and a transition on Tx_EXT pin matched the CAPEDGE (TIMERx_EXTCTL[2:1]) setting, CAPIF (TIMERx_EINTSTS[0]) will set to 1 and the current timer counter value CNT (TIMERx_CNT[23:0]) will be auto-loaded into this CAPDAT field.
N * @var TIMER_T::EXTCTL
N * Offset: 0x14  Timer External Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CNTPHASE  |Timer External Count Phase
N * |        |          |This bit indicates the detection phase of external counting pin Tx_CNT (x= 0~3).
N * |        |          |0 = A Falling edge of external counting pin will be counted.
N * |        |          |1 = A Rising edge of external counting pin will be counted.
N * |[2:1]   |CAPEDGE   |Timer External Capture Pin Edge Detect
N * |        |          |00 = A Falling edge on Tx_EXT (x= 0~3) pin will be detected.
N * |        |          |01 = A Rising edge on Tx_EXT (x= 0~3) pin will be detected.
N * |        |          |10 = Either Rising or Falling edge on Tx_EXT (x= 0~3) pin will be detected.
N * |        |          |11 = Reserved.
N * |[3]     |CAPEN     |Timer External Capture Pin Enable
N * |        |          |This bit enables the Tx_EXT pin.
N * |        |          |0 =Tx_EXT (x= 0~3) pin Disabled.
N * |        |          |1 =Tx_EXT (x= 0~3) pin Enabled.
N * |[4]     |CAPFUNCS  |Capture Function Selection
N * |        |          |0 = External Capture Mode Enabled.
N * |        |          |1 = External Reset Mode Enabled.
N * |        |          |Note1: When CAPFUNCS is 0, transition on Tx_EXT (x= 0~3) pin is using to save the 24-bit timer counter value.
N * |        |          |Note2: When CAPFUNCS is 1, transition on Tx_EXT (x= 0~3) pin is using to reset the 24-bit timer counter value.
N * |[5]     |CAPIEN    |Timer External Capture Interrupt Enable
N * |        |          |0 = Tx_EXT (x= 0~3) pin detection Interrupt Disabled.
N * |        |          |1 = Tx_EXT (x= 0~3) pin detection Interrupt Enabled.
N * |        |          |Note: CAPIEN is used to enable timer external interrupt.
N * |        |          |If CAPIEN enabled, timer will rise an interrupt when CAPIF (TIMERx_EINTSTS[0]) is 1.
N * |        |          |For example, while CAPIEN = 1, CAPEN = 1, and CAPEDGE = 00, a 1 to 0 transition on the Tx_EXT pin will cause the CAPIF to be set then the interrupt signal is generated and sent to NVIC to inform CPU.
N * |[6]     |CAPDBEN   |Timer External Capture Pin De-Bounce Enable
N * |        |          |0 = Tx_EXT (x= 0~3) pin de-bounce Disabled.
N * |        |          |1 = Tx_EXT (x= 0~3) pin de-bounce Enabled.
N * |        |          |Note: If this bit is enabled, the edge detection of Tx_EXT pin is detected with de-bounce circuit.
N * |[7]     |CNTDBEN   |Timer Counter Pin De-Bounce Enable
N * |        |          |0 = Tx_CNT (x= 0~3) pin de-bounce Disabled.
N * |        |          |1 = Tx_CNT (x= 0~3) pin de-bounce Enabled.
N * |        |          |Note: If this bit is enabled, the edge detection of Tx_CNT pin is detected with de-bounce circuit.
N * @var TIMER_T::EINTSTS
N * Offset: 0x18  Timer External Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CAPIF     |Timer External Capture Interrupt Flag
N * |        |          |This bit indicates the timer external capture interrupt flag status.
N * |        |          |0 = Tx_EXT (x= 0~3) pin interrupt did not occur.
N * |        |          |1 = Tx_EXT (x= 0~3) pin interrupt occurred.
N * |        |          |Note1: This bit is cleared by writing 1 to it.
N * |        |          |Note2: When CAPEN (TIMERx_EXTCTL[3]) bit is set, CAPFUNCS (TIMERx_EXTCTL[4]) bit is 0, and a transition on Tx_EXT (x= 0~3) pin matched the CAPEDGE (TIMERx_EXTCTL[2:1]) setting, this bit will set to 1 by hardware.
N * |        |          |Note3: There is a new incoming capture event detected before CPU clearing the CAPIF status.
N * |        |          |If the above condition occurred, the Timer will keep register TIMERx_CAP unchanged and drop the new capture value.
N */
N
N    __IO uint32_t CTL;           /* Offset: 0x00  Timer Control and Status Register                                  */
X    volatile uint32_t CTL;            
N    __IO uint32_t CMP;           /* Offset: 0x04  Timer Compare Register                                             */
X    volatile uint32_t CMP;            
N    __IO uint32_t INTSTS;        /* Offset: 0x08  Timer Interrupt Status Register                                    */
X    volatile uint32_t INTSTS;         
N    __I  uint32_t CNT;           /* Offset: 0x0C  Timer Data Register                                                */
X    volatile const  uint32_t CNT;            
N    __I  uint32_t CAP;           /* Offset: 0x10  Timer Capture Data Register                                        */
X    volatile const  uint32_t CAP;            
N    __IO uint32_t EXTCTL;        /* Offset: 0x14  Timer External Control Register                                    */
X    volatile uint32_t EXTCTL;         
N    __IO uint32_t EINTSTS;       /* Offset: 0x18  Timer External Interrupt Status Register                           */
X    volatile uint32_t EINTSTS;        
N
N} TIMER_T;
N
N
N
N/**
N    @addtogroup TMR_CONST TMR Bit Field Definition
N    Constant Definitions for TMR Controller
N@{ */
N
N#define TIMER_CTL_PSC_Pos                  (0)                                             /*!< TIMER_T::CTL: PSC Position                  */
N#define TIMER_CTL_PSC_Msk                  (0xfful << TIMER_CTL_PSC_Pos)                   /*!< TIMER_T::CTL: PSC Mask                      */
N
N#define TIMER_CTL_WKTKEN_Pos               (17)                                            /*!< TIMER_T::CTL: WKTKEN Position               */
N#define TIMER_CTL_WKTKEN_Msk               (0x1ul << TIMER_CTL_WKTKEN_Pos)                 /*!< TIMER_T::CTL: WKTKEN Mask                   */
N
N#define TIMER_CTL_TRGSSEL_Pos              (18)                                            /*!< TIMER_T::CTL: TRGSSEL Position              */
N#define TIMER_CTL_TRGSSEL_Msk              (0x1ul << TIMER_CTL_TRGSSEL_Pos)                /*!< TIMER_T::CTL: TRGSSEL Mask                  */
N
N#define TIMER_CTL_TRGPWM_Pos               (19)                                            /*!< TIMER_T::CTL: TRGPWM Position               */
N#define TIMER_CTL_TRGPWM_Msk               (0x1ul << TIMER_CTL_TRGPWM_Pos)                 /*!< TIMER_T::CTL: TRGPWM Mask                   */
N
N#define TIMER_CTL_TRGDAC_Pos               (20)                                            /*!< TIMER_T::CTL: TRGDAC Position               */
N#define TIMER_CTL_TRGDAC_Msk               (0x1ul << TIMER_CTL_TRGDAC_Pos)                 /*!< TIMER_T::CTL: TRGDAC Mask                   */
N
N#define TIMER_CTL_TRGEADC_Pos              (21)                                            /*!< TIMER_T::CTL: TRGEADC Position              */
N#define TIMER_CTL_TRGEADC_Msk              (0x1ul << TIMER_CTL_TRGEADC_Pos)                /*!< TIMER_T::CTL: TRGEADC Mask                  */
N
N#define TIMER_CTL_TGLPINSEL_Pos            (22)                                            /*!< TIMER_T::CTL: TGLPINSEL Position            */
N#define TIMER_CTL_TGLPINSEL_Msk            (0x1ul << TIMER_CTL_TGLPINSEL_Pos)              /*!< TIMER_T::CTL: TGLPINSEL Mask                */
N
N#define TIMER_CTL_WKEN_Pos                 (23)                                            /*!< TIMER_T::CTL: WKEN Position                 */
N#define TIMER_CTL_WKEN_Msk                 (0x1ul << TIMER_CTL_WKEN_Pos)                   /*!< TIMER_T::CTL: WKEN Mask                     */
N
N#define TIMER_CTL_EXTCNTEN_Pos             (24)                                            /*!< TIMER_T::CTL: EXTCNTEN Position             */
N#define TIMER_CTL_EXTCNTEN_Msk             (0x1ul << TIMER_CTL_EXTCNTEN_Pos)               /*!< TIMER_T::CTL: EXTCNTEN Mask                 */
N
N#define TIMER_CTL_ACTSTS_Pos               (25)                                            /*!< TIMER_T::CTL: ACTSTS Position               */
N#define TIMER_CTL_ACTSTS_Msk               (0x1ul << TIMER_CTL_ACTSTS_Pos)                 /*!< TIMER_T::CTL: ACTSTS Mask                   */
N
N#define TIMER_CTL_RSTCNT_Pos               (26)                                            /*!< TIMER_T::CTL: RSTCNT Position               */
N#define TIMER_CTL_RSTCNT_Msk               (0x1ul << TIMER_CTL_RSTCNT_Pos)                 /*!< TIMER_T::CTL: RSTCNT Mask                   */
N
N#define TIMER_CTL_OPMODE_Pos               (27)                                            /*!< TIMER_T::CTL: OPMODE Position               */
N#define TIMER_CTL_OPMODE_Msk               (0x3ul << TIMER_CTL_OPMODE_Pos)                 /*!< TIMER_T::CTL: OPMODE Mask                   */
N
N#define TIMER_CTL_INTEN_Pos                (29)                                            /*!< TIMER_T::CTL: INTEN Position                */
N#define TIMER_CTL_INTEN_Msk                (0x1ul << TIMER_CTL_INTEN_Pos)                  /*!< TIMER_T::CTL: INTEN Mask                    */
N
N#define TIMER_CTL_CNTEN_Pos                (30)                                            /*!< TIMER_T::CTL: CNTEN Position                */
N#define TIMER_CTL_CNTEN_Msk                (0x1ul << TIMER_CTL_CNTEN_Pos)                  /*!< TIMER_T::CTL: CNTEN Mask                    */
N
N#define TIMER_CTL_ICEDEBUG_Pos             (31)                                            /*!< TIMER_T::CTL: ICEDEBUG Position             */
N#define TIMER_CTL_ICEDEBUG_Msk             (0x1ul << TIMER_CTL_ICEDEBUG_Pos)               /*!< TIMER_T::CTL: ICEDEBUG Mask                 */
N
N#define TIMER_CMP_CMPDAT_Pos               (0)                                             /*!< TIMER_T::CMP: CMPDAT Position               */
N#define TIMER_CMP_CMPDAT_Msk               (0xfffffful << TIMER_CMP_CMPDAT_Pos)            /*!< TIMER_T::CMP: CMPDAT Mask                   */
N
N#define TIMER_INTSTS_TIF_Pos               (0)                                             /*!< TIMER_T::INTSTS: TIF Position               */
N#define TIMER_INTSTS_TIF_Msk               (0x1ul << TIMER_INTSTS_TIF_Pos)                 /*!< TIMER_T::INTSTS: TIF Mask                   */
N
N#define TIMER_INTSTS_TWKF_Pos              (1)                                             /*!< TIMER_T::INTSTS: TWKF Position              */
N#define TIMER_INTSTS_TWKF_Msk              (0x1ul << TIMER_INTSTS_TWKF_Pos)                /*!< TIMER_T::INTSTS: TWKF Mask                  */
N
N#define TIMER_CNT_CNT_Pos                  (0)                                             /*!< TIMER_T::CNT: CNT Position                  */
N#define TIMER_CNT_CNT_Msk                  (0xfffffful << TIMER_CNT_CNT_Pos)               /*!< TIMER_T::CNT: CNT Mask                      */
N
N#define TIMER_CAP_CAPDAT_Pos               (0)                                             /*!< TIMER_T::CAP: CAPDAT Position               */
N#define TIMER_CAP_CAPDAT_Msk               (0xfffffful << TIMER_CAP_CAPDAT_Pos)            /*!< TIMER_T::CAP: CAPDAT Mask                   */
N
N#define TIMER_EXTCTL_CNTPHASE_Pos          (0)                                             /*!< TIMER_T::EXTCTL: CNTPHASE Position          */
N#define TIMER_EXTCTL_CNTPHASE_Msk          (0x1ul << TIMER_EXTCTL_CNTPHASE_Pos)            /*!< TIMER_T::EXTCTL: CNTPHASE Mask              */
N
N#define TIMER_EXTCTL_CAPEDGE_Pos           (1)                                             /*!< TIMER_T::EXTCTL: CAPEDGE Position           */
N#define TIMER_EXTCTL_CAPEDGE_Msk           (0x3ul << TIMER_EXTCTL_CAPEDGE_Pos)             /*!< TIMER_T::EXTCTL: CAPEDGE Mask               */
N
N#define TIMER_EXTCTL_CAPEN_Pos             (3)                                             /*!< TIMER_T::EXTCTL: CAPEN Position             */
N#define TIMER_EXTCTL_CAPEN_Msk             (0x1ul << TIMER_EXTCTL_CAPEN_Pos)               /*!< TIMER_T::EXTCTL: CAPEN Mask                 */
N
N#define TIMER_EXTCTL_CAPFUNCS_Pos          (4)                                             /*!< TIMER_T::EXTCTL: CAPFUNCS Position          */
N#define TIMER_EXTCTL_CAPFUNCS_Msk          (0x1ul << TIMER_EXTCTL_CAPFUNCS_Pos)            /*!< TIMER_T::EXTCTL: CAPFUNCS Mask              */
N
N#define TIMER_EXTCTL_CAPIEN_Pos            (5)                                             /*!< TIMER_T::EXTCTL: CAPIEN Position            */
N#define TIMER_EXTCTL_CAPIEN_Msk            (0x1ul << TIMER_EXTCTL_CAPIEN_Pos)              /*!< TIMER_T::EXTCTL: CAPIEN Mask                */
N
N#define TIMER_EXTCTL_CAPDBEN_Pos           (6)                                             /*!< TIMER_T::EXTCTL: CAPDBEN Position           */
N#define TIMER_EXTCTL_CAPDBEN_Msk           (0x1ul << TIMER_EXTCTL_CAPDBEN_Pos)             /*!< TIMER_T::EXTCTL: CAPDBEN Mask               */
N
N#define TIMER_EXTCTL_CNTDBEN_Pos           (7)                                             /*!< TIMER_T::EXTCTL: CNTDBEN Position           */
N#define TIMER_EXTCTL_CNTDBEN_Msk           (0x1ul << TIMER_EXTCTL_CNTDBEN_Pos)             /*!< TIMER_T::EXTCTL: CNTDBEN Mask               */
N
N#define TIMER_EINTSTS_CAPIF_Pos            (0)                                             /*!< TIMER_T::EINTSTS: CAPIF Position            */
N#define TIMER_EINTSTS_CAPIF_Msk            (0x1ul << TIMER_EINTSTS_CAPIF_Pos)              /*!< TIMER_T::EINTSTS: CAPIF Mask                */
N
N/**@}*/ /* TIMER_CONST */
N/**@}*/ /* end of TIMER register group */
N
N
N/*---------------------- Universal Asynchronous Receiver/Transmitter Controller -------------------------*/
N/**
N    @addtogroup UART Universal Asynchronous Receiver/Transmitter Controller(UART)
N    Memory Mapped Structure for UART Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N
N
N/**
N * @var UART_T::DAT
N * Offset: 0x00  UART Receive/Transmit Buffer Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |DAT       |Receiving/Transmit Buffer
N * |        |          |Write Operation:
N * |        |          |By writing one byte to this register, the data byte will be stored in transmitter FIFO.
N * |        |          |The UART Controller will send out the data stored in transmitter FIFO top location through the UART_TXD.
N * |        |          |Read Operation:
N * |        |          |By reading this register, the UART will return an 8-bit data received from receiving FIFO.
N * @var UART_T::INTEN
N * Offset: 0x04  UART Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RDAIEN    |Receive Data Available Interrupt Enable Bit
N * |        |          |0 = Receive data available interrupt Disabled.
N * |        |          |1 = Receive data available interrupt Enabled.
N * |[1]     |THREIEN   |Transmit Holding Register Empty Interrupt Enable Bit
N * |        |          |0 = Transmit holding register empty interrupt Disabled.
N * |        |          |1 = Transmit holding register empty interrupt Enabled.
N * |[2]     |RLSIEN    |Receive Line Status Interrupt Enable Bit
N * |        |          |0 = Receive Line Status interrupt Disabled.
N * |        |          |1 = Receive Line Status interrupt Enabled.
N * |[3]     |MODEMIEN  |Modem Status Interrupt Enable Bit
N * |        |          |0 = Modem status interrupt Disabled.
N * |        |          |1 = Modem status interrupt Enabled.
N * |[4]     |RXTOIEN   |RX Time-Out Interrupt Enable Bit
N * |        |          |0 = RX time-out interrupt Disabled.
N * |        |          |1 = RX time-out interrupt Enabled.
N * |[5]     |BUFERRIEN |Buffer Error Interrupt Enable Bit
N * |        |          |0 = Buffer error interrupt Disabled.
N * |        |          |1 = Buffer error interrupt Enabled.
N * |[8]     |LINIEN    |LIN Bus Interrupt Enable Bit (Not Available In UART2/UART3)
N * |        |          |0 = LIN bus interrupt Disabled.
N * |        |          |1 = LIN bus interrupt Enabled.
N * |        |          |Note: This bit is used for LIN function mode.
N * |[9]     |WKCTSIEN  |nCTS Wake-Up Interrupt Enable Bit
N * |        |          |0 = nCTS wake-up system function Disabled.
N * |        |          |1 = Wake-up system function Enabled, when the system is in Power-down mode, an external nCTS change will wake-up system from Power-down mode.
N * |[10]    |WKDATIEN  |Incoming Data Wake-Up Interrupt Enable Bit
N * |        |          |0 = Incoming data wake-up system function Disabled.
N * |        |          |1 = Incoming data wake-up system function Enabled, when the system is in Power-down mode, incoming data will wake-up system from Power-down mode.
N * |        |          |Note: Hardware will clear this bit when the incoming data wake-up operation finishes and "system clock" work stable
N * |[11]    |TOCNTEN   |Time-Out Counter Enable Bit
N * |        |          |0 = Time-out counter Disabled.
N * |        |          |1 = Time-out counter Enabled.
N * |[12]    |ATORTSEN  |nRTS Auto-Flow Control Enable Bit
N * |        |          |0 = nRTS auto-flow control Disabled.
N * |        |          |1 = nRTS auto-flow control Enabled.
N * |        |          |Note: When nRTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTSTRGLV (UART_FIFO[19:16]), the UART will de-assert nRTS signal.
N * |[13]    |ATOCTSEN  |nCTS Auto-Flow Control Enable Bit
N * |        |          |0 = nCTS auto-flow control Disabled.
N * |        |          |1 = nCTS auto-flow control Enabled.
N * |        |          |Note: When nCTS auto-flow is enabled, the UART will send data to external device if nCTS input assert (UART will not send data to device until nCTS is asserted).
N * |[14]    |TXPDMAEN  |TX DMA Enable Bit
N * |        |          |This bit can enable or disable TX DMA service.
N * |        |          |0 = TX DMA Disabled.
N * |        |          |1 = TX DMA Enabled.
N * |[15]    |RXPDMAEN  |RX DMA Enable Bit
N * |        |          |This bit can enable or disable RX DMA service.
N * |        |          |0 = RX DMA Disabled.
N * |        |          |1 = RX DMA Enabled.
N * |[18]    |ABRIEN    |Auto-Baud Rate Interrupt Enable Bit
N * |        |          |0 = Auto-baud rate interrupt Disabled.
N * |        |          |1 = Auto-baud rate interrupt Enabled.
N * @var UART_T::FIFO
N * Offset: 0x08  UART FIFO Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1]     |RXRST     |RX Field Software Reset
N * |        |          |When RXRST (UART_FIFO[1]) is set, all the byte in the receiver FIFO and RX internal state machine are cleared.
N * |        |          |0 = No effect.
N * |        |          |1 = Reset the RX internal state machine and pointers.
N * |        |          |Note: This bit will automatically clear at least 3 UART peripheral clock cycles.
N * |[2]     |TXRST     |TX Field Software Reset
N * |        |          |When TXRST (UART_FIFO[2]) is set, all the byte in the transmit FIFO and TX internal state machine are cleared.
N * |        |          |0 = No effect.
N * |        |          |1 = Reset the TX internal state machine and pointers.
N * |        |          |Note: This bit will automatically clear at least 3 UART peripheral clock cycles.
N * |[7:4]   |RFITL     |RX FIFO Interrupt Trigger Level
N * |        |          |When the number of bytes in the receive FIFO equals the RFITL, the RDAIF will be set (if RDAIEN (UART_INTEN [0]) enabled, and an interrupt will be generated).
N * |        |          |0000 = RX FIFO Interrupt Trigger Level is 1 byte.
N * |        |          |0001 = RX FIFO Interrupt Trigger Level is 4 bytes.
N * |        |          |0010 = RX FIFO Interrupt Trigger Level is 8 bytes.
N * |        |          |0011 = RX FIFO Interrupt Trigger Level is 14 bytes.
N * |        |          |Others = Reserved.
N * |[8]     |RXOFF     |Receiver Disable
N * |        |          |The receiver is disabled or not (set 1 to disable receiver)
N * |        |          |0 = Receiver Enabled.
N * |        |          |1 = Receiver Disabled.
N * |        |          |Note: This bit is used for RS-485 Normal Multi-drop mode.
N * |        |          |It should be programmed before RS485NMM (UART_ALTCTL [8]) is programmed.
N * |[19:16] |RTSTRGLV  |nRTS Trigger Level For Auto-Flow Control Use
N * |        |          |0000 = nRTS Trigger Level is 1 bytes.
N * |        |          |0001 = nRTS Trigger Level is 4bytes.
N * |        |          |0010 = nRTS Trigger Level is 8 bytes.
N * |        |          |0011 = nRTS Trigger Level is 14 bytes.
N * |        |          |Others = Reserved.
N * |        |          |Note: This field is used for auto nRTS flow control.
N * @var UART_T::LINE
N * Offset: 0x0C  UART Line Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |WLS       |Word Length Selection
N * |        |          |This field sets UART word length.
N * |        |          |00 = 5 bits.
N * |        |          |01 = 6 bits.
N * |        |          |10 = 7 bits.
N * |        |          |11 = 8 bits.
N * |[2]     |NSB       |Number Of "STOP Bit"
N * |        |          |0 = One "STOP bit" is generated in the transmitted data.
N * |        |          |1 = When select 5-bit word length, 1.5 "STOP bit" is generated in the transmitted data.
N * |        |          |When select 6-, 7- and 8-bit word length, 2 "STOP bit" is generated in the transmitted data.
N * |[3]     |PBE       |Parity Bit Enable Bit
N * |        |          |0 = No parity bit generated Disabled.
N * |        |          |1 = Parity bit generated Enabled.
N * |        |          |Note : Parity bit is generated on each outgoing character and is checked on each incoming data.
N * |[4]     |EPE       |Even Parity Enable Bit
N * |        |          |0 = Odd number of logic 1's is transmitted and checked in each word.
N * |        |          |1 = Even number of logic 1's is transmitted and checked in each word.
N * |        |          |Note:This bit has effect only when PBE (UART_LINE[3]) is set.
N * |[5]     |SPE       |Stick Parity Enable Bit
N * |        |          |0 = Stick parity Disabled.
N * |        |          |1 = Stick parity Enabled.
N * |        |          |Note: If PBE (UART_LINE[3]) and EPE (UART_LINE[4]) are logic 1, the parity bit is transmitted and checked as logic 0.
N * |        |          |If PBE (UART_LINE[3]) is 1 and EPE (UART_LINE[4]) is 0 then the parity bit is transmitted and checked as 1.
N * |[6]     |BCB       |Break Control Bit
N * |        |          |0 = Break Control Disabled.
N * |        |          |1 = Break Control Enabled.
N * |        |          |Note: When this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0).
N * |        |          |This bit acts only on TX line and has no effect on the transmitter logic.
N * @var UART_T::MODEM
N * Offset: 0x10  UART Modem Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1]     |RTS       |nRTS (Request-To-Send) Signal Control
N * |        |          |This bit is direct control internal nRTS signal active or not, and then drive the nRTS pin output with RTSACTLV bit configuration.
N * |        |          |0 = nRTS signal is active.
N * |        |          |1 = nRTS signal is inactive.
N * |        |          |Note1: This nRTS signal control bit is not effective when nRTS auto-flow control is enabled in UART function mode.
N * |        |          |Note2: This nRTS signal control bit is not effective when RS-485 auto direction mode (AUD) is enabled in RS-485 function mode.
N * |[9]     |RTSACTLV  |nRTS Pin Active Level
N * |        |          |This bit defines the active level state of nRTS pin output.
N * |        |          |0 =n RTS pin output is high level active.
N * |        |          |1 = nRTS pin output is low level active. (Default)
N * |        |          |Note1: Refer to Figure 6.21-10 and Figure 6.21-11 for UART function mode.
N * |        |          |Note2: Refer to Figure 6.21-21 and Figure 6.21-22 for RS-485 function mode.
N * |[13]    |RTSSTS    |nRTS Pin Status (Read Only)
N * |        |          |This bit mirror from nRTS pin output of voltage logic status.
N * |        |          |0 = nRTS pin output is low level voltage logic state.
N * |        |          |1 = nRTS pin output is high level voltage logic state.
N * @var UART_T::MODEMSTS
N * Offset: 0x14  UART Modem Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CTSDETF   |Detect nCTS State Change Flag (Read Only)
N * |        |          |This bit is set whenever nCTS input has change state, and it will generate Modem interrupt to CPU when MODEMIEN (UART_INTEN [3]) is set to 1.
N * |        |          |0 = nCTS input has not change state.
N * |        |          |1 = nCTS input has change state.
N * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
N * |[4]     |CTSSTS    |nCTS Pin Status (Read Only)
N * |        |          |This bit mirror from nCTS pin input of voltage logic status.
N * |        |          |0 = nCTS pin input is low level voltage logic state.
N * |        |          |1 = nCTS pin input is high level voltage logic state.
N * |        |          |Note: This bit echoes when UART Controller peripheral clock is enabled, and nCTS multi-function port is selected.
N * |[8]     |CTSACTLV  |nCTS Pin Active Level
N * |        |          |This bit defines the active level state of nCTS pin input.
N * |        |          |0 = nCTS pin input is high level active.
N * |        |          |1 = nCTS pin input is low level active. (Default)
N * @var UART_T::FIFOSTS
N * Offset: 0x18  UART FIFO Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RXOVIF    |RX Overflow Error Interrupt Flag (Read Only)
N * |        |          |This bit is set when RX FIFO overflow.
N * |        |          |If the number of bytes of received data is greater than RX_FIFO (UART_DAT) size, 16 bytes this bit will be set.
N * |        |          |0 = RX FIFO is not overflow.
N * |        |          |1 = RX FIFO is overflow.
N * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
N * |[1]     |ABRDIF    |Auto-Baud Rate Detect Interrupt (Read Only)
N * |        |          |0 = Auto-baud rate detect function is not finished.
N * |        |          |1 = Auto-baud rate detect function is finished.
N * |        |          |This bit is set to logic "1" when auto-baud rate detect function is finished.
N * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
N * |[2]     |ABRDTOIF  |Auto-Baud Rate Time-Out Interrupt (Read Only)
N * |        |          |0 = Auto-baud rate counter is underflow.
N * |        |          |1 = Auto-baud rate counter is overflow.
N * |        |          |Note1: This bit is set to logic "1" in Auto-baud Rate Detect mode and the baud rate counter is overflow.
N * |        |          |Note2: This bit is read only, but can be cleared by writing "1" to it.
N * |[3]     |ADDRDETF  |RS-485 Address Byte Detect Flag (Read Only)
N * |        |          |0 = Receiver detects a data that is not an address bit (bit 9 ='0').
N * |        |          |1 = Receiver detects a data that is an address bit (bit 9 ='1').
N * |        |          |Note1: This field is used for RS-485 function mode and ADDRDEN (UART_ALTCTL[15]) is set to 1 to enable Address detection mode .
N * |        |          |Note2: This bit is read only, but can be cleared by writing '1' to it.
N * |[4]     |PEF       |Parity Error Flag (Read Only)
N * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "parity bit".
N * |        |          |0 = No parity error is generated.
N * |        |          |1 = Parity error is generated.
N * |        |          |Note: This bit is read only, but can be cleared by writing '1' to it.
N * |[5]     |FEF       |Framing Error Flag (Read Only)
N * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as logic 0).
N * |        |          |0 = No framing error is generated.
N * |        |          |1 = Framing error is generated.
N * |        |          |Note: This bit is read only, but can be cleared by writing '1' to it.
N * |[6]     |BIF       |Break Interrupt Flag (Read Only)
N * |        |          |This bit is set to logic 1 whenever the received data input (RX) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits).
N * |        |          |0 = No Break interrupt is generated.
N * |        |          |1 = Break interrupt is generated.
N * |        |          |Note: This bit is read only, but can be cleared by writing '1' to it.
N * |[13:8]  |RXPTR     |RX FIFO Pointer (Read Only)
N * |        |          |This field indicates the RX FIFO Buffer Pointer.
N * |        |          |When UART receives one byte from external device, RXPTR increases one.
N * |        |          |When one byte of RX FIFO is read by CPU, RXPTR decreases one.
N * |        |          |The Maximum value shown in RXPTR is 15.
N * |        |          |When the using level of RX FIFO Buffer equal to 16, the RXFULL bit is set to 1 and RXPTR will show 0.
N * |        |          |As one byte of RX FIFO is read by CPU, the RXFULL bit is cleared to 0 and RXPTR will show 15.
N * |[14]    |RXEMPTY   |Receiver FIFO Empty (Read Only)
N * |        |          |This bit initiate RX FIFO empty or not.
N * |        |          |0 = RX FIFO is not empty.
N * |        |          |1 = RX FIFO is empty.
N * |        |          |Note: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high.
N * |        |          |It will be cleared when UART receives any new data.
N * |[15]    |RXFULL    |Receiver FIFO Full (Read Only)
N * |        |          |This bit initiates RX FIFO full or not.
N * |        |          |0 = RX FIFO is not full.
N * |        |          |1 = RX FIFO is full.
N * |        |          |Note: This bit is set when the number of usage in RX FIFO Buffer is equal to 16, otherwise is cleared by hardware.
N * |[21:16] |TXPTR     |TX FIFO Pointer (Read Only)
N * |        |          |This field indicates the TX FIFO Buffer Pointer.
N * |        |          |When CPU writes one byte into UART_DAT, TXPTR increases one.
N * |        |          |When one byte of TX FIFO is transferred to Transmitter Shift Register, TXPTR decreases one.
N * |        |          |The Maximum value shown in TXPTR is 15.
N * |        |          |When the using level of TX FIFO Buffer equal to 16, the TXFULL bit is set to 1 and TXPTR will show 0.
N * |        |          |As one byte of TX FIFO is transferred to Transmitter Shift Register, the TXFULL bit is cleared to 0 and TXPTR will show 15.
N * |[22]    |TXEMPTY   |Transmitter FIFO Empty (Read Only)
N * |        |          |This bit indicates TX FIFO empty or not.
N * |        |          |0 = TX FIFO is not empty.
N * |        |          |1 = TX FIFO is empty.
N * |        |          |Note: When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high.
N * |        |          |It will be cleared when writing data into DAT (TX FIFO not empty).
N * |[23]    |TXFULL    |Transmitter FIFO Full (Read Only)
N * |        |          |This bit indicates TX FIFO full or not.
N * |        |          |0 = TX FIFO is not full.
N * |        |          |1 = TX FIFO is full.
N * |        |          |Note: This bit is set when the number of usage in TX FIFO Buffer is equal to 16, otherwise is cleared by hardware.
N * |[24]    |TXOVIF    |TX Overflow Error Interrupt Flag (Read Only)
N * |        |          |If TX FIFO (UART_DAT) is full, an additional write to UART_DAT will cause this bit to logic 1.
N * |        |          |0 = TX FIFO is not overflow.
N * |        |          |1 = TX FIFO is overflow.
N * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
N * |[28]    |TXEMPTYF  |Transmitter Empty Flag (Read Only)
N * |        |          |This bit is set by hardware when TX FIFO (UART_DAT) is empty and the STOP bit of the last byte has been transmitted.
N * |        |          |0 = TX FIFO is not empty.
N * |        |          |1 = TX FIFO is empty.
N * |        |          |Note: This bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.
N * @var UART_T::INTSTS
N * Offset: 0x1C  UART Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RDAIF     |Receive Data Available Interrupt Flag (Read Only)
N * |        |          |When the number of bytes in the RX FIFO equals the RFITL then the RDAIF(UART_INTSTS[0]) will be set.
N * |        |          |If RDAIEN (UART_INTEN [0]) is enabled, the RDA interrupt will be generated.
N * |        |          |0 = No RDA interrupt flag is generated.
N * |        |          |1 = RDA interrupt flag is generated.
N * |        |          |Note: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL(UART_FIFO[7:4])).
N * |[1]     |THREIF    |Transmit Holding Register Empty Interrupt Flag (Read Only)
N * |        |          |This bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register.
N * |        |          |If THREIEN (UART_INTEN[1]) is enabled, the THRE interrupt will be generated.
N * |        |          |0 = No THRE interrupt flag is generated.
N * |        |          |1 = THRE interrupt flag is generated.
N * |        |          |Note: This bit is read only and it will be cleared when writing data into UART_DAT (TX FIFO not empty).
N * |[2]     |RLSIF     |Receive Line Interrupt Flag (Read Only)
N * |        |          |This bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF(UART_FIFOSTS[6]), FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]), is set).
N * |        |          |If RLSIEN (UART_INTEN [2]) is enabled, the RLS interrupt will be generated.
N * |        |          |0 = No RLS interrupt flag is generated.
N * |        |          |1 = RLS interrupt flag is generated.
N * |        |          |Note1: In RS-485 function mode, this field is set include receiver detect and received address byte character (bit9 = '1') bit.
N * |        |          |At the same time, the bit of ADDRDETF (UART_FIFOSTS[3]) is also set.
N * |        |          |Note2: This bit is read only and reset to 0 when all bits of BIF (UART_FIFOSTS[6]), FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]) are cleared.
N * |        |          |Note3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF (UART_FIFOSTS[6]) , FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]) and ADDRDETF (UART_FIFOSTS[3]) are cleared.
N * |[3]     |MODEMIF   |MODEM Interrupt Flag (Read Only) Channel This bit is set when the nCTS pin has state change (CTSDETF (UART_MODEMSTS[0]) = 1). If MODEMIEN (UART_INTEN [3]) is enabled, the Modem interrupt will be generated.
N * |        |          |0 = No Modem interrupt flag is generated.
N * |        |          |1 = Modem interrupt flag is generated.
N * |        |          |Note: This bit is read only and reset to 0 when bit CTSDETF is cleared by a write 1 on CTSDETF(UART_MODEMSTS[0]).
N * |[4]     |RXTOIF    |Time-Out Interrupt Flag (Read Only)
N * |        |          |This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC.
N * |        |          |If TOUTIEN (UART_INTEN [4]) is enabled, the Tout interrupt will be generated.
N * |        |          |0 = No Time-out interrupt flag is generated.
N * |        |          |1 = Time-out interrupt flag is generated.
N * |        |          |Note: This bit is read only and user can read UART_DAT (RX is in active) to clear it.
N * |[5]     |BUFERRIF  |Buffer Error Interrupt Flag (Read Only)
N * |        |          |This bit is set when the TX FIFO or RX FIFO overflows (TXOVIF (UART_FIFOSTS[24]) or RXOVIF (UART_FIFOSTS[0]) is set).
N * |        |          |When BERRIF (UART_INTSTS[5])is set, the transfer is not correct.
N * |        |          |If BFERRIEN (UART_INTEN [8]) is enabled, the buffer error interrupt will be generated.
N * |        |          |0 = No buffer error interrupt flag is generated.
N * |        |          |1 = Buffer error interrupt flag is generated.
N * |        |          |Note: This bit is read only.
N * |        |          |This bit is cleared if both of RXOVIF(UART_FIFOSTS[0]) and TXOVIF(UART_FIFOSTS[24]) are cleared to 0 by writing 1 to RXOVIF(UART_FIFOSTS[0]) and TXOVIF(UART_FIFOSTS[24]).
N * |[6]     |WKIF      |UART Wake-up Interrupt Flag (Read Only)
N * |        |          |This bit is set when DATWKIF (UART_INTSTS[17]) or CTSWKIF(UART_INTSTS[16]) is set to 1.
N * |        |          |0 = No DATWKIF and CTSWKIF are generated.
N * |        |          |1 = DATWKIF or CTSWKIF.
N * |        |          |Note: This bit is read only.
N * |        |          |This bit is cleared if both of DATWKIF (UART_INTSTS[17]) and CTSWKIF(UART_INTSTS[16]) are cleared to 0 by writing 1 to DATWKIF (UART_INTSTS[17]) and CTSWKIF (UART_INTSTS[17]).
N * |[7]     |LINIF     |LIN Bus Interrupt Flag (Read Only) (Not Available in UART2/UART3 Channel)
N * |        |          |This bit is set when LIN slave header detect (SLVHDETF (UART_LINSTS[0] =1)), LIN break detect (BRKDETF(UART_LINSTS[9])=1), bit error detect (BITEF(UART_LINSTS[9])=1), LIN slave ID parity error (SLVIDPEF(UART_LINSTS[2]) = 1) or LIN slave header error detect (SLVHEF (UART_LINSTS[1])).
N * |        |          |If LIN_ IEN (UART_INTEN [8]) is enabled the LIN interrupt will be generated.
N * |        |          |0 = None of SLVHDETF, BRKDETF, BITEF, SLVIDPEF and SLVHEF is generated.
N * |        |          |1 = At least one of SLVHDETF, BRKDETF, BITEF, SLVIDPEF and SLVHEF is generated.
N * |        |          |Note: This bit is read only.
N * |        |          |This bit is cleared when SLVHDETF(UART_LINSTS[0]), BRKDETF(UART_LINSTS[8]), BITEF(UART_LINSTS[9]), SLVIDPEF (UART_LINSTS[2]), SLVHEF(UART_LINSTS[1]) and SLVSYNCF(UART_LINSTS[3]) all are cleared.
N * |[8]     |RDAINT    |Receive Data Available Interrupt Indicator (Read Only)
N * |        |          |This bit is set if RDAIEN (UART_INTEN[0]) and RDAIF (UART_INTSTS[0]) are both set to 1.
N * |        |          |0 = No RDA interrupt is generated.
N * |        |          |1 = RDA interrupt is generated.
N * |[9]     |THREINT   |Transmit Holding Register Empty Interrupt Indicator (Read Only)
N * |        |          |This bit is set if THREIEN (UART_INTEN[1])and THREIF(UART_INTSTS[1]) are both set to 1.
N * |        |          |0 = No DATE interrupt is generated.
N * |        |          |1 = DATE interrupt is generated.
N * |[10]    |RLSINT    |Receive Line Status Interrupt Indicator (Read Only)
N * |        |          |This bit is set if RLSIEN (UART_INTEN[2]) and RLSIF(UART_INTSTS[2]) are both set to 1.
N * |        |          |0 = No RLS interrupt is generated.
N * |        |          |1 = RLS interrupt is generated.
N * |[11]    |MODEMINT  |MODEM Status Interrupt Indicator (Read Only)
N * |        |          |This bit is set if MODEMIEN(UART_INTEN[3]) and MODEMIF(UART_INTSTS[4]) are both set to 1
N * |        |          |0 = No Modem interrupt is generated.
N * |        |          |1 = Modem interrupt is generated.
N * |[12]    |RXTOINT   |Time-Out Interrupt Indicator (Read Only)
N * |        |          |This bit is set if TOUTIEN(UART_INTEN[4]) and RXTOIF(UART_INTSTS[4]) are both set to 1.
N * |        |          |0 = No Tout interrupt is generated.
N * |        |          |1 = Tout interrupt is generated.
N * |[13]    |BUFERRINT |Buffer Error Interrupt Indicator (Read Only)
N * |        |          |This bit is set if BFERRIEN(UART_INTEN[5]) and BERRIF(UART_INTSTS[5]) are both set to 1.
N * |        |          |0 = No buffer error interrupt is generated.
N * |        |          |1 = Buffer error interrupt is generated.
N * |[15]    |LININT    |LIN Bus Interrupt Indicator (Read Only)(Not Available in UART2/UART3 Channel)
N * |        |          |This bit is set if LINIEN (UART_INTEN[8]) and LIN IF(UART_INTSTS[7]) are both set to 1.
N * |        |          |0 = No LIN Bus interrupt is generated.
N * |        |          |1 = The LIN Bus interrupt is generated.
N * |[16]    |CTSWKIF   |nCTS Wake-Up Interrupt Flag (Read Only)
N * |        |          |0 = Chip stays in power-down state.
N * |        |          |1 = Chip wake-up from power-down state by nCTS wake-up.
N * |        |          |Note1: If WKCTSIEN (UART_INTEN[9])is enabled, the wake-up interrupt is generated.
N * |        |          |Note2: This bit is read only, but can be cleared by writing '1' to it.
N * |[17]    |DATWKIF   |Data Wake-Up Interrupt Flag (Read Only)
N * |        |          |This bit is set if chip wake-up from power-down state by data wake-up.
N * |        |          |0 = Chip stays in power-down state.
N * |        |          |1 = Chip wake-up from power-down state by data wake-up.
N * |        |          |Note1: If WKDATIEN (UART_INTEN[10]) is enabled, the wake-up interrupt is generated.
N * |        |          |Note2: This bit is read only, but can be cleared by writing '1' to it.
N * |[18]    |HWRLSIF   |In DMA Mode, Receive Line Status Flag (Read Only)
N * |        |          |This bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF (UART_FIFOSTS[6]), FEF (UART_FIFOSTS[5]) and PEF (UART_FIFOSTS[4]) is set).
N * |        |          |If RLSIEN (UART_INTEN [2]) is enabled, the RLS interrupt will be generated.
N * |        |          |0 = No RLS interrupt flag is generated.
N * |        |          |1 = RLS interrupt flag is generated.
N * |        |          |Note1: In RS-485 function mode, this field include receiver detect any address byte received address byte character (bit9 = '1') bit.
N * |        |          |Note2: In UART function mode, this bit is read only and reset to 0 when all bits of BIF(UART_FIFOSTS[6]) , FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]) are cleared.
N * |        |          |Note3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UART_FIFOSTS[6]) , FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]) and ADDRDETF (UART_FIFOSTS[3]) are cleared
N * |[19]    |HWMODIF   |In DMA Mode, MODEM Interrupt Flag (Read Only)
N * |        |          |This bit is set when the nCTS pin has state change (CTSDETF (UART_CTSDETF[0] =1)).
N * |        |          |If MODEMIEN (UART_INTEN [3]) is enabled, the Modem interrupt will be generated.
N * |        |          |0 = No Modem interrupt flag is generated.
N * |        |          |1 = Modem interrupt flag is generated.
N * |        |          |Note: This bit is read only and reset to 0 when the bit UART_CTSDETF (US_MSR[0]) is cleared by writing 1 on CTSDETF (UART_CTSDETF [0]).
N * |[20]    |HWTOIF    |In DMA Mode, Time-Out Interrupt Flag (Read Only)
N * |        |          |This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC (UART_TOUT[7:0]).
N * |        |          |If TOUTIEN (UART_INTEN [4]) is enabled, the Tout interrupt will be generated.
N * |        |          |0 = No Time-out interrupt flag is generated.
N * |        |          |1 = Time-out interrupt flag is generated.
N * |        |          |Note: This bit is read only and user can read UART_DAT (RX is in active) to clear it.
N * |[21]    |HWBUFEIF  |In DMA Mode, Buffer Error Interrupt Flag (Read Only)
N * |        |          |This bit is set when the TX or RX FIFO overflows (TXOVIF (UART_FIFOSTS [24]) or RXOVIF (UART_FIFOSTS[0]) is set).
N * |        |          |When BERRIF (UART_INTSTS[5]) is set, the transfer maybe is not correct.
N * |        |          |If BFERRIEN (UART_INTEN [5]) is enabled, the buffer error interrupt will be generated.
N * |        |          |0 = No buffer error interrupt flag is generated.
N * |        |          |1 = Buffer error interrupt flag is generated.
N * |        |          |Note: This bit is cleared when both TXOVIF (UART_FIFOSTS[24]]) and RXOVIF (UART_FIFOSTS[0]) are cleared.
N * |[26]    |HWRLSINT  |In DMA Mode, Receive Line Status Interrupt Indicator (Read Only)
N * |        |          |This bit is set if RLSIEN (UART_INTEN[2])and HWRLSIF(UART_INTSTS[18]) are both set to 1.
N * |        |          |0 = No RLS interrupt is generated in DMA mode.
N * |        |          |1 = RLS interrupt is generated in DMA mode.
N * |[27]    |HWMODINT  |In DMA Mode, MODEM Status Interrupt Indicator (Read Only)
N * |        |          |This bit is set if MODEMIEN(UART_INTEN[3]) and HWMODIF(UART_INTSTS[3]) are both set to 1.
N * |        |          |0 = No Modem interrupt is generated in DMA mode.
N * |        |          |1 = Modem interrupt is generated in DMA mode.
N * |[28]    |HWTOINT   |In DMA Mode, Time-Out Interrupt Indicator (Read Only)
N * |        |          |This bit is set if TOUTIEN (UART_INTEN[4])and HWTOIF(UART_INTSTS[20]) are both set to 1.
N * |        |          |0 = No Tout interrupt is generated in DMA mode.
N * |        |          |1 = Tout interrupt is generated in DMA mode.
N * |[29]    |HWBUFEINT |In DMA Mode, Buffer Error Interrupt Indicator (Read Only)
N * |        |          |This bit is set if BFERRIEN (UART_INTEN[5]) and HWBEIF (UART_INTSTS[5])are both set to 1.
N * |        |          |0 = No buffer error interrupt is generated in DMA mode.
N * |        |          |1 = Buffer error interrupt is generated in DMA mode.
N * @var UART_T::TOUT
N * Offset: 0x20  UART Time-out Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |TOIC      |Time-Out Interrupt Comparator
N * |        |          |The time-out counter resets and starts counting (the counting clock = baud rate) whenever the RX FIFO receives a new data word.
N * |        |          |Once the content of time-out counter is equal to that of time-out interrupt comparator (TOIC (UART_TOUT[7:0])), a receiver time-out interrupt (RXTOINT(UART_INTSTS[12])) is generated if RXTOIEN (UART_INTEN [4]) enabled.
N * |        |          |A new incoming data word or RX FIFO empty will clear RXTOINT(UART_INTSTS[12]).
N * |        |          |In order to avoid receiver time-out interrupt generation immediately during one character is being received, TOIC value should be set between 40 and 255.
N * |        |          |So, for example, if TOIC is set with 40, the time-out interrupt is generated after four characters are not received when 1 stop bit and no parity check is set for UART transfer.
N * |[15:8]  |DLY       |TX Delay Time Value
N * |        |          |This field is used to programming the transfer delay time between the last stop bit and next start bit.
N * |        |          |The unit is bit time.
N * @var UART_T::BAUD
N * Offset: 0x24  UART Baud Rate Divisor Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |BRD       |Baud Rate Divider
N * |        |          |The field indicates the baud rate divider.
N * |        |          |This filed is used in baud rate calculation.
N * |        |          |The detail description is shown in Table 6.21-2.
N * |[27:24] |EDIVM1    |Extra Divider For BAUD Rate Mode 1
N * |        |          |This field is used for baud rate calculation in mode 1 and has no effect for baud rate calculation in mode 0 and mode 2.
N * |        |          |The detail description is shown in Table 6.21-2.
N * |[28]    |BAUDM0    |BAUD Rate Mode Selection Bit 0
N * |        |          |This bit is baud rate mode selection bit 0.
N * |        |          |UART provides three baud rate calculation modes.
N * |        |          |This bit combines with BAUDM1 (UART_BAUD[29]) to select baud rate calculation mode.
N * |        |          |The detail description is shown in Table 6.21-2.
N * |[29]    |BAUDM1    |BAUD Rate Mode Selection Bit 1
N * |        |          |This bit is baud rate mode selection bit 1.
N * |        |          |UART provides three baud rate calculation modes.
N * |        |          |This bit combines with BAUDM0 (UART_BAUD[28]) to select baud rate calculation mode.
N * |        |          |The detail description is shown in Table 6.21-2.
N * |        |          |Note: In IrDA mode must be operated in mode 0.
N * @var UART_T::IRDA
N * Offset: 0x28  UART IrDA Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1]     |TXEN      |IrDA Receiver/Transmitter Selection Enable Bit
N * |        |          |0 = IrDA Transmitter Disabled and Receiver Enabled. (Default)
N * |        |          |1 = IrDA Transmitter Enabled and Receiver Disabled.
N * |        |          |Note: In IrDA function mode (FUNCSEL(UART_FUNCSEL[1:0])=10), the first received data is unreliable and it should be skipped if IrDA receiver is enabled (TXEN(UART_IRDA[1])=0) at the first time.
N * |[5]     |TXINV     |IrDA Inverse Transmitting Output Signal
N * |        |          |0 = None inverse transmitting signal. (Default)
N * |        |          |1 = Inverse transmitting output signal.
N * |[6]     |RXINV     |IrDA Inverse Receive Input Signal
N * |        |          |0 = None inverse receiving input signal.
N * |        |          |1 = Inverse receiving input signal. (Default)
N * @var UART_T::ALTCTL
N * Offset: 0x2C  UART Alternate Control/Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |BRKFL     |UART LIN Break Field Length (Only Available In UART0/UART1 Channel)
N * |        |          |This field indicates a 4-bit LIN TX break field count.
N * |        |          |Note1: This break field length is BRKFL + 1
N * |        |          |Note2: According to LIN spec, the reset value is 0xC (break field length = 13).
N * |[6]     |LINRXEN   |LIN RX Enable Bit (Only Available In UART0/UART1 Channel)
N * |        |          |0 = LIN RX mode Disabled.
N * |        |          |1 = LIN RX mode Enabled.
N * |[7]     |LINTXEN   |LIN TX Break Mode Enable Bit (Only Available In UART0/UART1 Channel)
N * |        |          |0 = LIN TX Break mode Disabled.
N * |        |          |1 = LIN TX Break mode Enabled.
N * |        |          |Note: When TX break field transfer operation finished, this bit will be cleared automatically.
N * |[8]     |RS485NMM  |RS-485 Normal Multi-Drop Operation Mode (NMM)
N * |        |          |0 = RS-485 Normal Multi-drop Operation mode (NMM) Disabled.
N * |        |          |1 = RS-485 Normal Multi-drop Operation mode (NMM) Enabled.
N * |        |          |Note: It cannot be active with RS-485_AAD operation mode.
N * |[9]     |RS485AAD  |RS-485 Auto Address Detection Operation Mode (AAD)
N * |        |          |0 = RS-485 Auto Address Detection Operation mode (AAD) Disabled.
N * |        |          |1 = RS-485 Auto Address Detection Operation mode (AAD) Enabled.
N * |        |          |Note: It cannot be active with RS-485_NMM operation mode.
N * |[10]    |RS485AUD  |RS-485 Auto Direction Function (AUD)
N * |        |          |0 = RS-485 Auto Direction Operation function (AUD) Disabled.
N * |        |          |1 = RS-485 Auto Direction Operation function (AUD) Enabled.
N * |        |          |Note: It can be active with RS-485_AAD or RS-485_NMM operation mode.
N * |[15]    |ADDRDEN   |RS-485 Address Detection Enable Bit
N * |        |          |This bit is used to enable RS-485 Address Detection mode.
N * |        |          |0 = Address detection mode Disabled.
N * |        |          |1 = Address detection mode Enabled.
N * |        |          |Note: This bit is used for RS-485 any operation mode.
N * |[17]    |ABRIF     |Auto-Baud Rate Interrupt Flag (Read Only)
N * |        |          |This bit is set when auto-baud rate detection function finished or the auto-baud rate counter was overflow and if ABRIEN(UART_INTEN [18]) is set then the auto-baud rate interrupt will be generated.
N * |        |          |Note: This bit is read only, but it can be cleared by writing "1" to ABRDTOIF (UART_FIFOSTS[2]) and ABRDIF(UART_FIFOSTS[1])
N * |[18]    |ABRDEN    |Auto-Baud Rate Detect Enable Bit
N * |        |          |0 = Auto-baud rate detect function Disabled.
N * |        |          |1 = Auto-baud rate detect function Enabled.
N * |        |          |This bit is cleared automatically after auto-baud detection is finished.
N * |[20:19] |ABRDBITS  |Auto-Baud Rate Detect Bit Length
N * |        |          |00 = 1-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x01.
N * |        |          |01 = 2-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x02.
N * |        |          |10 = 4-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x08.
N * |        |          |11 = 8-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x80.
N * |        |          |Note : The calculation of bit number includes the START bit.
N * |[31:24] |ADDRMV    |Address Match Value
N * |        |          |This field contains the RS-485 address match values.
N * |        |          |Note: This field is used for RS-485 auto address detection mode.
N * @var UART_T::FUNCSEL
N * Offset: 0x30  UART Function Select Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |FUNCSEL   |Function Select
N * |        |          |00 = UART function.
N * |        |          |01 = LIN function (Only Available in UART0/UART1 Channel).
N * |        |          |10 = IrDA function.
N * |        |          |11 = RS-485 function.
N * |        |          |Note: In IrDA function mode (FUNCSEL(UART_FUNCSEL[1:0])=10), the first received data is unreliable and it should be skipped if IrDA receiver is enabled (TXEN(UART_IRDA[1])=0) at the first time.
N * @var UART_T::LINCTL
N * Offset: 0x34  UART LIN Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |SLVEN     |LIN Slave Mode Enable Bit
N * |        |          |0 = LIN slave mode Disabled.
N * |        |          |1 = LIN slave mode Enabled.
N * |[1]     |SLVHDEN   |LIN Slave Header Detection Enable Bit
N * |        |          |0 = LIN slave header detection Disabled.
N * |        |          |1 = LIN slave header detection Enabled.
N * |        |          |Note1: This bit only valid when in LIN slave mode (SLVEN (UART_LINCTL[0]) = 1).
N * |        |          |Note2: In LIN function mode, when detect header field (break + sync + frame ID), SLVHDETF (UART_LINSTS [0]) flag will be asserted.
N * |        |          |If the LINIEN (UART_INTEN[8]) = 1, an interrupt will be generated.
N * |[2]     |SLVAREN   |LIN Slave Automatic Resynchronization Mode Enable Bit
N * |        |          |0 = LIN automatic resynchronization Disabled.
N * |        |          |1 = LIN automatic resynchronization Enabled.
N * |        |          |Note1: This bit only valid when in LIN slave mode (SLVEN (UART_LINCTL[0]) = 1).
N * |        |          |Note2: When operation in Automatic Resynchronization mode, the baud rate setting must be mode2 (BAUDM1 (UART_BAUD [29]) and BAUDM0 (UART_BAUD [28]) must be 1).
N * |        |          |Note3: The control and interactions of this field are explained in 6.21.5.9(Slave mode with automatic resynchronization).
N * |[3]     |SLVDUEN   |LIN Slave Divider Update Method Enable Bit
N * |        |          |0 = UART_BAUD updated is written by software (if no automatic resynchronization update occurs at the same time).
N * |        |          |1 = UART_BAUD is updated at the next received character.
N * |        |          |User must set the bit before checksum reception.
N * |        |          |Note1: This bit only valid when in LIN slave mode (SLVEN (UART_LINCTL[0]) = 1).
N * |        |          |Note2: This bit used for LIN Slave Automatic Resynchronization mode.
N * |        |          |(for Non-Automatic Resynchronization mode, this bit should be kept cleared).
N * |        |          |Note3: The control and interactions of this field are explained in 6.21.5.9 (Slave mode with automatic resynchronization).
N * |[4]     |MUTE      |LIN Mute Mode Enable Bit
N * |        |          |0 = LIN mute mode Disabled.
N * |        |          |1 = LIN mute mode Enabled.
N * |        |          |Note: The exit from mute mode condition and each control and interactions of this field are explained in 6.21.5.9 (LIN slave mode).
N * |[8]     |SENDH     |LIN TX Send Header Enable Bit
N * |        |          |The LIN TX header can be "break field" or "break and sync field" or "break, sync and frame ID field", it is depend on setting HSEL (UART_LINCTL[23:22]).
N * |        |          |0 = Send LIN TX header Disabled.
N * |        |          |1 = Send LIN TX header Enabled.
N * |        |          |Note1: These registers are shadow registers of SENDH (UART_ALTCTL [7]); user can read/write it by setting SENDH (UART_ALTCTL [7]) or SENDH (UART_LINCTL [8]).
N * |        |          |Note2: When transmitter header field (it may be "break" or "break + sync" or "break + sync + frame ID" selected by HSEL (UART_LINCTL[23:22]) field) transfer operation finished, this bit will be cleared automatically.
N * |[9]     |IDPEN     |LIN ID Parity Enable Bit
N * |        |          |0 = LIN frame ID parity Disabled.
N * |        |          |1 = LIN frame ID parity Enabled.
N * |        |          |Note1: This bit can be used for LIN master to sending header field (SENDH (UART_LINCTL[8]) = 1 and HSEL (UART_LINCTL[23:22]) = 10) or be used for enable LIN slave received frame ID parity checked.
N * |        |          |Note2: This bit is only use when the operation header transmitter is in HSEL (UART_LINCTL[23:22]) = 10
N * |[10]    |BRKDETEN  |LIN Break Detection Enable Bit
N * |        |          |When detect consecutive dominant greater than 11 bits, and are followed by a delimiter character, the BRKDETF (UART_LINSTS[8]) flag is set in UART_LINSTS register at the end of break field.
N * |        |          |If the LINIEN (UART_INTEN [8])=1, an interrupt will be generated.
N * |        |          |0 = LIN break detection Disabled .
N * |        |          |1 = LIN break detection Enabled.
N * |[11]    |RXOFF     |LIN Receiver Disable Bit
N * |        |          |If the receiver is enabled (RXOFF (UART_LINCTL[11] ) = 0), 
N * |        |          |all received byte data will be accepted and stored in the RX-FIFO, 
N * |        |          |and if the receiver is disabled (RXOFF (UART_LINCTL[11]) = 1), all received byte data will be ignore.
N * |        |          |0 = LIN receiver Enabled.
N * |        |          |1 = LIN receiver Disabled.
N * |        |          |Note: This bit is only valid when operating in LIN function mode (FUNCSEL (UART_FUNCSEL[1:0]) = 01).
N * |[12]    |BITERREN  |Bit Error Detect Enable Bit
N * |        |          |0 = Bit error detection function Disabled.
N * |        |          |1 = Bit error detection Enabled.
N * |        |          |Note: In LIN function mode, when occur bit error, the BITEF (UART_LINSTS[9]) flag will be asserted.
N * |        |          |If the LINIEN (UART_INTEN[8]) = 1, an interrupt will be generated.
N * |[19:16] |BRKFL     |LIN Break Field Length
N * |        |          |This field indicates a 4-bit LIN TX break field count.
N * |        |          |Note1: These registers are shadow registers of BRKFL, User can read/write it by setting BRKFL (UART_ALTCTL[3:0]) or BRKFL (UART_LINCTL[19:16]).
N * |        |          |Note2: This break field length is BRKFL + 1.
N * |        |          |Note3: According to LIN spec, the reset value is 12 (break field length = 13).
N * |[21:20] |BSL       |LIN Break/Sync Delimiter Length
N * |        |          |00 = The LIN break/sync delimiter length is 1-bit time.
N * |        |          |01 = The LIN break/sync delimiter length is 2-bit time.
N * |        |          |10 = The LIN break/sync delimiter length is 3-bit time.
N * |        |          |11 = The LIN break/sync delimiter length is 4-bit time.
N * |        |          |Note: This bit used for LIN master to sending header field.
N * |[23:22] |HSEL      |LIN Header Select
N * |        |          |00 = The LIN header includes "break field".
N * |        |          |01 = The LIN header includes "break field" and "sync field".
N * |        |          |10 = The LIN header includes "break field", "sync field" and "frame ID field".
N * |        |          |11 = Reserved.
N * |        |          |Note: This bit is used to master mode for LIN to send header field (SENDH (UART_LINCTL [8]) = 1) or used to slave to indicates exit from mute mode condition (MUTE (UART_LINCTL[4]) = 1).
N * |[31:24] |PID       |LIN PID Bits
N * |        |          |This field contains the LIN frame ID value when in LIN function mode, the frame ID parity can be generated by software or hardware depends on IDPEN (UART_LINCTL[9]) = 1.
N * |        |          |If the parity generated by hardware, user fill ID0~ID5, (PID [29:24] )hardware will calculate P0 (PID[30]) and P1 (PID[31]), otherwise user must filled frame ID and parity in this field.
N * |        |          |Note1: User can fill any 8-bit value to this field and the bit 24 indicates ID0 (LSB first).
N * |        |          |Note2: This field can be used for LIN master mode or slave mode.
N * @var UART_T::LINSTS
N * Offset: 0x38  UART LIN Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |SLVHDETF  |LIN Slave Header Detection Flag (Read Only)
N * |        |          |This bit is set by hardware when a LIN header is detected in LIN slave mode and be cleared by writing 1 to it.
N * |        |          |0 = LIN header not detected.
N * |        |          |1 = LIN header detected (break + sync + frame ID).
N * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2: This bit is only valid when in LIN slave mode (SLVEN (UART_LINCTL [0]) = 1) and enable LIN slave header detection function (SLVHDEN (UART_LINCTL [1])).
N * |        |          |Note3: When enable ID parity check IDPEN (UART_LINCTL [9]), if hardware detect complete header ("break + sync + frame ID"), the SLVHDETF will be set whether the frame ID correct or not.
N * |[1]     |SLVHEF    |LIN Slave Header Error Flag (Read Only)
N * |        |          |This bit is set by hardware when a LIN header error is detected in LIN slave mode and be cleared by writing 1 to it.
N * |        |          |The header errors include "break delimiter is too short (less than 0.5 bit time)", "frame error in sync field or Identifier field", "sync field data is not 0x55 in Non-Automatic Resynchronization mode", "sync field deviation error with Automatic Resynchronization mode", "sync field measure time-out with Automatic Resynchronization mode" and "LIN header reception time-out".
N * |        |          |0 = LIN header error not detected.
N * |        |          |1 = LIN header error detected.
N * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2: This bit is only valid when UART is operated in LIN slave mode (SLVEN (UART_LINCTL [0]) = 1) and enables LIN slave header detection function (SLVHDEN (UART_LINCTL [1])).
N * |[2]     |SLVIDPEF  |LIN Slave ID Parity Error Flag
N * |        |          |This bit is set by hardware when receipted frame ID parity is not correct.
N * |        |          |0 = No active.
N * |        |          |1 = Receipted frame ID parity is not correct.
N * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2: This bit is only valid when in LIN slave mode (SLVEN (UART_LINCTL [0])= 1) and enable LIN frame ID parity check function IDPEN (UART_LINCTL [9]).
N * |[3]     |SLVSYNCF  |LIN Slave Sync Field (Read Only)
N * |        |          |This bit indicates that the LIN sync field is being analyzed in Automatic Resynchronization mode.
N * |        |          |When the receiver header have some error been detect, user must reset the internal circuit to re-search new frame header by writing 1 to this bit.
N * |        |          |0 = The current character is not at LIN sync state.
N * |        |          |1 = The current character is at LIN sync state.
N * |        |          |Note1: This bit is only valid when in LIN Slave mode (SLVEN(UART_LINCTL[0]) = 1).
N * |        |          |Note2: This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note3: When writing 1 to it, hardware will reload the initial baud rate and re-search a new frame header.
N * |[8]     |BRKDETF   |LIN Break Detection Flag (Read Only)
N * |        |          |This bit is set by hardware when a break is detected and be cleared by writing 1 to it through software.
N * |        |          |0 = LIN break not detected.
N * |        |          |1 = LIN break detected.
N * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2: This bit is only valid when LIN break detection function is enabled (BRKDETEN (UART_LINCTL[10]) =1).
N * |[9]     |BITEF     |Bit Error Detect Status Flag (Read Only)
N * |        |          |At TX transfer state, hardware will monitoring the bus state, if the input pin (SIN) state not equals to the output pin (SOUT) state, BITEF (UART_LINSTS[9]) will be set.
N * |        |          |When occur bit error, if the LINIEN (UART_INTEN[8]) = 1, an interrupt will be generated.
N * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2: This bit is only valid when enable bit error detection function (BITERREN (UART_LINCTL [12]) = 1).
N */
N
N    __IO uint32_t DAT;           /* Offset: 0x00  UART Receive/Transmit Buffer Register                              */
X    volatile uint32_t DAT;            
N    __IO uint32_t INTEN;         /* Offset: 0x04  UART Interrupt Enable Register                                     */
X    volatile uint32_t INTEN;          
N    __IO uint32_t FIFO;          /* Offset: 0x08  UART FIFO Control Register                                         */
X    volatile uint32_t FIFO;           
N    __IO uint32_t LINE;          /* Offset: 0x0C  UART Line Control Register                                         */
X    volatile uint32_t LINE;           
N    __IO uint32_t MODEM;         /* Offset: 0x10  UART Modem Control Register                                        */
X    volatile uint32_t MODEM;          
N    __IO uint32_t MODEMSTS;      /* Offset: 0x14  UART Modem Status Register                                         */
X    volatile uint32_t MODEMSTS;       
N    __IO uint32_t FIFOSTS;       /* Offset: 0x18  UART FIFO Status Register                                          */
X    volatile uint32_t FIFOSTS;        
N    __IO uint32_t INTSTS;        /* Offset: 0x1C  UART Interrupt Status Register                                     */
X    volatile uint32_t INTSTS;         
N    __IO uint32_t TOUT;          /* Offset: 0x20  UART Time-out Register                                             */
X    volatile uint32_t TOUT;           
N    __IO uint32_t BAUD;          /* Offset: 0x24  UART Baud Rate Divisor Register                                    */
X    volatile uint32_t BAUD;           
N    __IO uint32_t IRDA;          /* Offset: 0x28  UART IrDA Control Register                                         */
X    volatile uint32_t IRDA;           
N    __IO uint32_t ALTCTL;        /* Offset: 0x2C  UART Alternate Control/Status Register                             */
X    volatile uint32_t ALTCTL;         
N    __IO uint32_t FUNCSEL;       /* Offset: 0x30  UART Function Select Register                                      */
X    volatile uint32_t FUNCSEL;        
N    __IO uint32_t LINCTL;        /* Offset: 0x34  UART LIN Control Register                                          */
X    volatile uint32_t LINCTL;         
N    __IO uint32_t LINSTS;        /* Offset: 0x38  UART LIN Status Register                                           */
X    volatile uint32_t LINSTS;         
N
N} UART_T;
N
N
N
N/**
N    @addtogroup UART_CONST UART Bit Field Definition
N    Constant Definitions for UART Controller
N@{ */
N
N#define UART_DAT_DAT_Pos                 (0)                                               /*!< UART_T::DAT: DAT Position                 */
N#define UART_DAT_DAT_Msk                 (0xfful << UART_DAT_DAT_Pos)                      /*!< UART_T::DAT: DAT Mask                     */
N
N#define UART_INTEN_RDAIEN_Pos            (0)                                               /*!< UART_T::INTEN: RDAIEN Position            */
N#define UART_INTEN_RDAIEN_Msk            (0x1ul << UART_INTEN_RDAIEN_Pos)                  /*!< UART_T::INTEN: RDAIEN Mask                */
N
N#define UART_INTEN_THREIEN_Pos           (1)                                               /*!< UART_T::INTEN: THREIEN Position           */
N#define UART_INTEN_THREIEN_Msk           (0x1ul << UART_INTEN_THREIEN_Pos)                 /*!< UART_T::INTEN: THREIEN Mask               */
N
N#define UART_INTEN_RLSIEN_Pos            (2)                                               /*!< UART_T::INTEN: RLSIEN Position            */
N#define UART_INTEN_RLSIEN_Msk            (0x1ul << UART_INTEN_RLSIEN_Pos)                  /*!< UART_T::INTEN: RLSIEN Mask                */
N
N#define UART_INTEN_MODEMIEN_Pos          (3)                                               /*!< UART_T::INTEN: MODEMIEN Position          */
N#define UART_INTEN_MODEMIEN_Msk          (0x1ul << UART_INTEN_MODEMIEN_Pos)                /*!< UART_T::INTEN: MODEMIEN Mask              */
N
N#define UART_INTEN_RXTOIEN_Pos           (4)                                               /*!< UART_T::INTEN: RXTOIEN Position           */
N#define UART_INTEN_RXTOIEN_Msk           (0x1ul << UART_INTEN_RXTOIEN_Pos)                 /*!< UART_T::INTEN: RXTOIEN Mask               */
N
N#define UART_INTEN_BUFERRIEN_Pos         (5)                                               /*!< UART_T::INTEN: BUFERRIEN Position         */
N#define UART_INTEN_BUFERRIEN_Msk         (0x1ul << UART_INTEN_BUFERRIEN_Pos)               /*!< UART_T::INTEN: BUFERRIEN Mask             */
N
N#define UART_INTEN_LINIEN_Pos            (8)                                               /*!< UART_T::INTEN: LINIEN Position            */
N#define UART_INTEN_LINIEN_Msk            (0x1ul << UART_INTEN_LINIEN_Pos)                  /*!< UART_T::INTEN: LINIEN Mask                */
N
N#define UART_INTEN_WKCTSIEN_Pos          (9)                                               /*!< UART_T::INTEN: WKCTSIEN Position          */
N#define UART_INTEN_WKCTSIEN_Msk          (0x1ul << UART_INTEN_WKCTSIEN_Pos)                /*!< UART_T::INTEN: WKCTSIEN Mask              */
N
N#define UART_INTEN_WKDATIEN_Pos          (10)                                              /*!< UART_T::INTEN: WKDATIEN Position          */
N#define UART_INTEN_WKDATIEN_Msk          (0x1ul << UART_INTEN_WKDATIEN_Pos)                /*!< UART_T::INTEN: WKDATIEN Mask              */
N
N#define UART_INTEN_TOCNTEN_Pos           (11)                                              /*!< UART_T::INTEN: TOCNTEN Position           */
N#define UART_INTEN_TOCNTEN_Msk           (0x1ul << UART_INTEN_TOCNTEN_Pos)                 /*!< UART_T::INTEN: TOCNTEN Mask               */
N
N#define UART_INTEN_ATORTSEN_Pos          (12)                                              /*!< UART_T::INTEN: ATORTSEN Position          */
N#define UART_INTEN_ATORTSEN_Msk          (0x1ul << UART_INTEN_ATORTSEN_Pos)                /*!< UART_T::INTEN: ATORTSEN Mask              */
N
N#define UART_INTEN_ATOCTSEN_Pos          (13)                                              /*!< UART_T::INTEN: ATOCTSEN Position          */
N#define UART_INTEN_ATOCTSEN_Msk          (0x1ul << UART_INTEN_ATOCTSEN_Pos)                /*!< UART_T::INTEN: ATOCTSEN Mask              */
N
N#define UART_INTEN_TXPDMAEN_Pos          (14)                                              /*!< UART_T::INTEN: TXPDMAEN Position          */
N#define UART_INTEN_TXPDMAEN_Msk          (0x1ul << UART_INTEN_TXPDMAEN_Pos)                /*!< UART_T::INTEN: TXPDMAEN Mask              */
N
N#define UART_INTEN_RXPDMAEN_Pos          (15)                                              /*!< UART_T::INTEN: RXPDMAEN Position          */
N#define UART_INTEN_RXPDMAEN_Msk          (0x1ul << UART_INTEN_RXPDMAEN_Pos)                /*!< UART_T::INTEN: RXPDMAEN Mask              */
N
N#define UART_INTEN_ABRIEN_Pos            (18)                                              /*!< UART_T::INTEN: ABRIEN Position            */
N#define UART_INTEN_ABRIEN_Msk            (0x1ul << UART_INTEN_ABRIEN_Pos)                  /*!< UART_T::INTEN: ABRIEN Mask                */
N
N#define UART_FIFO_RXRST_Pos              (1)                                               /*!< UART_T::FIFO: RXRST Position              */
N#define UART_FIFO_RXRST_Msk              (0x1ul << UART_FIFO_RXRST_Pos)                    /*!< UART_T::FIFO: RXRST Mask                  */
N
N#define UART_FIFO_TXRST_Pos              (2)                                               /*!< UART_T::FIFO: TXRST Position              */
N#define UART_FIFO_TXRST_Msk              (0x1ul << UART_FIFO_TXRST_Pos)                    /*!< UART_T::FIFO: TXRST Mask                  */
N
N#define UART_FIFO_RFITL_Pos              (4)                                               /*!< UART_T::FIFO: RFITL Position              */
N#define UART_FIFO_RFITL_Msk              (0xful << UART_FIFO_RFITL_Pos)                    /*!< UART_T::FIFO: RFITL Mask                  */
N
N#define UART_FIFO_RXOFF_Pos              (8)                                               /*!< UART_T::FIFO: RXOFF Position              */
N#define UART_FIFO_RXOFF_Msk              (0x1ul << UART_FIFO_RXOFF_Pos)                    /*!< UART_T::FIFO: RXOFF Mask                  */
N
N#define UART_FIFO_RTSTRGLV_Pos           (16)                                              /*!< UART_T::FIFO: RTSTRGLV Position           */
N#define UART_FIFO_RTSTRGLV_Msk           (0xful << UART_FIFO_RTSTRGLV_Pos)                 /*!< UART_T::FIFO: RTSTRGLV Mask               */
N
N#define UART_LINE_WLS_Pos                (0)                                               /*!< UART_T::LINE: WLS Position                */
N#define UART_LINE_WLS_Msk                (0x3ul << UART_LINE_WLS_Pos)                      /*!< UART_T::LINE: WLS Mask                    */
N
N#define UART_LINE_NSB_Pos                (2)                                               /*!< UART_T::LINE: NSB Position                */
N#define UART_LINE_NSB_Msk                (0x1ul << UART_LINE_NSB_Pos)                      /*!< UART_T::LINE: NSB Mask                    */
N
N#define UART_LINE_PBE_Pos                (3)                                               /*!< UART_T::LINE: PBE Position                */
N#define UART_LINE_PBE_Msk                (0x1ul << UART_LINE_PBE_Pos)                      /*!< UART_T::LINE: PBE Mask                    */
N
N#define UART_LINE_EPE_Pos                (4)                                               /*!< UART_T::LINE: EPE Position                */
N#define UART_LINE_EPE_Msk                (0x1ul << UART_LINE_EPE_Pos)                      /*!< UART_T::LINE: EPE Mask                    */
N
N#define UART_LINE_SPE_Pos                (5)                                               /*!< UART_T::LINE: SPE Position                */
N#define UART_LINE_SPE_Msk                (0x1ul << UART_LINE_SPE_Pos)                      /*!< UART_T::LINE: SPE Mask                    */
N
N#define UART_LINE_BCB_Pos                (6)                                               /*!< UART_T::LINE: BCB Position                */
N#define UART_LINE_BCB_Msk                (0x1ul << UART_LINE_BCB_Pos)                      /*!< UART_T::LINE: BCB Mask                    */
N
N#define UART_MODEM_RTS_Pos               (1)                                               /*!< UART_T::MODEM: RTS Position               */
N#define UART_MODEM_RTS_Msk               (0x1ul << UART_MODEM_RTS_Pos)                     /*!< UART_T::MODEM: RTS Mask                   */
N
N#define UART_MODEM_RTSACTLV_Pos          (9)                                               /*!< UART_T::MODEM: RTSACTLV Position          */
N#define UART_MODEM_RTSACTLV_Msk          (0x1ul << UART_MODEM_RTSACTLV_Pos)                /*!< UART_T::MODEM: RTSACTLV Mask              */
N
N#define UART_MODEM_RTSSTS_Pos            (13)                                              /*!< UART_T::MODEM: RTSSTS Position            */
N#define UART_MODEM_RTSSTS_Msk            (0x1ul << UART_MODEM_RTSSTS_Pos)                  /*!< UART_T::MODEM: RTSSTS Mask                */
N
N#define UART_MODEMSTS_CTSDETF_Pos        (0)                                               /*!< UART_T::MODEMSTS: CTSDETF Position        */
N#define UART_MODEMSTS_CTSDETF_Msk        (0x1ul << UART_MODEMSTS_CTSDETF_Pos)              /*!< UART_T::MODEMSTS: CTSDETF Mask            */
N
N#define UART_MODEMSTS_CTSSTS_Pos         (4)                                               /*!< UART_T::MODEMSTS: CTSSTS Position         */
N#define UART_MODEMSTS_CTSSTS_Msk         (0x1ul << UART_MODEMSTS_CTSSTS_Pos)               /*!< UART_T::MODEMSTS: CTSSTS Mask             */
N
N#define UART_MODEMSTS_CTSACTLV_Pos       (8)                                               /*!< UART_T::MODEMSTS: CTSACTLV Position       */
N#define UART_MODEMSTS_CTSACTLV_Msk       (0x1ul << UART_MODEMSTS_CTSACTLV_Pos)             /*!< UART_T::MODEMSTS: CTSACTLV Mask           */
N
N#define UART_FIFOSTS_RXOVIF_Pos          (0)                                               /*!< UART_T::FIFOSTS: RXOVIF Position          */
N#define UART_FIFOSTS_RXOVIF_Msk          (0x1ul << UART_FIFOSTS_RXOVIF_Pos)                /*!< UART_T::FIFOSTS: RXOVIF Mask              */
N
N#define UART_FIFOSTS_ABRDIF_Pos          (1)                                               /*!< UART_T::FIFOSTS: ABRDIF Position          */
N#define UART_FIFOSTS_ABRDIF_Msk          (0x1ul << UART_FIFOSTS_ABRDIF_Pos)                /*!< UART_T::FIFOSTS: ABRDIF Mask              */
N
N#define UART_FIFOSTS_ABRDTOIF_Pos        (2)                                               /*!< UART_T::FIFOSTS: ABRDTOIF Position        */
N#define UART_FIFOSTS_ABRDTOIF_Msk        (0x1ul << UART_FIFOSTS_ABRDTOIF_Pos)              /*!< UART_T::FIFOSTS: ABRDTOIF Mask            */
N
N#define UART_FIFOSTS_ADDRDETF_Pos        (3)                                               /*!< UART_T::FIFOSTS: ADDRDETF Position        */
N#define UART_FIFOSTS_ADDRDETF_Msk        (0x1ul << UART_FIFOSTS_ADDRDETF_Pos)              /*!< UART_T::FIFOSTS: ADDRDETF Mask            */
N
N#define UART_FIFOSTS_PEF_Pos             (4)                                               /*!< UART_T::FIFOSTS: PEF Position             */
N#define UART_FIFOSTS_PEF_Msk             (0x1ul << UART_FIFOSTS_PEF_Pos)                   /*!< UART_T::FIFOSTS: PEF Mask                 */
N
N#define UART_FIFOSTS_FEF_Pos             (5)                                               /*!< UART_T::FIFOSTS: FEF Position             */
N#define UART_FIFOSTS_FEF_Msk             (0x1ul << UART_FIFOSTS_FEF_Pos)                   /*!< UART_T::FIFOSTS: FEF Mask                 */
N
N#define UART_FIFOSTS_BIF_Pos             (6)                                               /*!< UART_T::FIFOSTS: BIF Position             */
N#define UART_FIFOSTS_BIF_Msk             (0x1ul << UART_FIFOSTS_BIF_Pos)                   /*!< UART_T::FIFOSTS: BIF Mask                 */
N
N#define UART_FIFOSTS_RXPTR_Pos           (8)                                               /*!< UART_T::FIFOSTS: RXPTR Position           */
N#define UART_FIFOSTS_RXPTR_Msk           (0x3ful << UART_FIFOSTS_RXPTR_Pos)                /*!< UART_T::FIFOSTS: RXPTR Mask               */
N
N#define UART_FIFOSTS_RXEMPTY_Pos         (14)                                              /*!< UART_T::FIFOSTS: RXEMPTY Position         */
N#define UART_FIFOSTS_RXEMPTY_Msk         (0x1ul << UART_FIFOSTS_RXEMPTY_Pos)               /*!< UART_T::FIFOSTS: RXEMPTY Mask             */
N
N#define UART_FIFOSTS_RXFULL_Pos          (15)                                              /*!< UART_T::FIFOSTS: RXFULL Position          */
N#define UART_FIFOSTS_RXFULL_Msk          (0x1ul << UART_FIFOSTS_RXFULL_Pos)                /*!< UART_T::FIFOSTS: RXFULL Mask              */
N
N#define UART_FIFOSTS_TXPTR_Pos           (16)                                              /*!< UART_T::FIFOSTS: TXPTR Position           */
N#define UART_FIFOSTS_TXPTR_Msk           (0x3ful << UART_FIFOSTS_TXPTR_Pos)                /*!< UART_T::FIFOSTS: TXPTR Mask               */
N
N#define UART_FIFOSTS_TXEMPTY_Pos         (22)                                              /*!< UART_T::FIFOSTS: TXEMPTY Position         */
N#define UART_FIFOSTS_TXEMPTY_Msk         (0x1ul << UART_FIFOSTS_TXEMPTY_Pos)               /*!< UART_T::FIFOSTS: TXEMPTY Mask             */
N
N#define UART_FIFOSTS_TXFULL_Pos          (23)                                              /*!< UART_T::FIFOSTS: TXFULL Position          */
N#define UART_FIFOSTS_TXFULL_Msk          (0x1ul << UART_FIFOSTS_TXFULL_Pos)                /*!< UART_T::FIFOSTS: TXFULL Mask              */
N
N#define UART_FIFOSTS_TXOVIF_Pos          (24)                                              /*!< UART_T::FIFOSTS: TXOVIF Position          */
N#define UART_FIFOSTS_TXOVIF_Msk          (0x1ul << UART_FIFOSTS_TXOVIF_Pos)                /*!< UART_T::FIFOSTS: TXOVIF Mask              */
N
N#define UART_FIFOSTS_TXEMPTYF_Pos        (28)                                              /*!< UART_T::FIFOSTS: TXEMPTYF Position        */
N#define UART_FIFOSTS_TXEMPTYF_Msk        (0x1ul << UART_FIFOSTS_TXEMPTYF_Pos)              /*!< UART_T::FIFOSTS: TXEMPTYF Mask            */
N
N#define UART_INTSTS_RDAIF_Pos            (0)                                               /*!< UART_T::INTSTS: RDAIF Position            */
N#define UART_INTSTS_RDAIF_Msk            (0x1ul << UART_INTSTS_RDAIF_Pos)                  /*!< UART_T::INTSTS: RDAIF Mask                */
N
N#define UART_INTSTS_THREIF_Pos           (1)                                               /*!< UART_T::INTSTS: THREIF Position           */
N#define UART_INTSTS_THREIF_Msk           (0x1ul << UART_INTSTS_THREIF_Pos)                 /*!< UART_T::INTSTS: THREIF Mask               */
N
N#define UART_INTSTS_RLSIF_Pos            (2)                                               /*!< UART_T::INTSTS: RLSIF Position            */
N#define UART_INTSTS_RLSIF_Msk            (0x1ul << UART_INTSTS_RLSIF_Pos)                  /*!< UART_T::INTSTS: RLSIF Mask                */
N
N#define UART_INTSTS_MODEMIF_Pos          (3)                                               /*!< UART_T::INTSTS: MODEMIF Position          */
N#define UART_INTSTS_MODEMIF_Msk          (0x1ul << UART_INTSTS_MODEMIF_Pos)                /*!< UART_T::INTSTS: MODEMIF Mask              */
N
N#define UART_INTSTS_RXTOIF_Pos           (4)                                               /*!< UART_T::INTSTS: RXTOIF Position           */
N#define UART_INTSTS_RXTOIF_Msk           (0x1ul << UART_INTSTS_RXTOIF_Pos)                 /*!< UART_T::INTSTS: RXTOIF Mask               */
N
N#define UART_INTSTS_BUFERRIF_Pos         (5)                                               /*!< UART_T::INTSTS: BUFERRIF Position         */
N#define UART_INTSTS_BUFERRIF_Msk         (0x1ul << UART_INTSTS_BUFERRIF_Pos)               /*!< UART_T::INTSTS: BUFERRIF Mask             */
N
N#define UART_INTSTS_WKIF_Pos             (6)                                               /*!< UART_T::INTSTS: WKIF Position             */
N#define UART_INTSTS_WKIF_Msk             (0x1ul << UART_INTSTS_WKIF_Pos)                   /*!< UART_T::INTSTS: WKIF Mask                 */
N
N#define UART_INTSTS_LINIF_Pos            (7)                                               /*!< UART_T::INTSTS: LINIF Position            */
N#define UART_INTSTS_LINIF_Msk            (0x1ul << UART_INTSTS_LINIF_Pos)                  /*!< UART_T::INTSTS: LINIF Mask                */
N
N#define UART_INTSTS_RDAINT_Pos           (8)                                               /*!< UART_T::INTSTS: RDAINT Position           */
N#define UART_INTSTS_RDAINT_Msk           (0x1ul << UART_INTSTS_RDAINT_Pos)                 /*!< UART_T::INTSTS: RDAINT Mask               */
N
N#define UART_INTSTS_THREINT_Pos          (9)                                               /*!< UART_T::INTSTS: THREINT Position          */
N#define UART_INTSTS_THREINT_Msk          (0x1ul << UART_INTSTS_THREINT_Pos)                /*!< UART_T::INTSTS: THREINT Mask              */
N
N#define UART_INTSTS_RLSINT_Pos           (10)                                              /*!< UART_T::INTSTS: RLSINT Position           */
N#define UART_INTSTS_RLSINT_Msk           (0x1ul << UART_INTSTS_RLSINT_Pos)                 /*!< UART_T::INTSTS: RLSINT Mask               */
N
N#define UART_INTSTS_MODEMINT_Pos         (11)                                              /*!< UART_T::INTSTS: MODEMINT Position         */
N#define UART_INTSTS_MODEMINT_Msk         (0x1ul << UART_INTSTS_MODEMINT_Pos)               /*!< UART_T::INTSTS: MODEMINT Mask             */
N
N#define UART_INTSTS_RXTOINT_Pos          (12)                                              /*!< UART_T::INTSTS: RXTOINT Position          */
N#define UART_INTSTS_RXTOINT_Msk          (0x1ul << UART_INTSTS_RXTOINT_Pos)                /*!< UART_T::INTSTS: RXTOINT Mask              */
N
N#define UART_INTSTS_BUFERRINT_Pos        (13)                                              /*!< UART_T::INTSTS: BUFERRINT Position        */
N#define UART_INTSTS_BUFERRINT_Msk        (0x1ul << UART_INTSTS_BUFERRINT_Pos)              /*!< UART_T::INTSTS: BUFERRINT Mask            */
N
N#define UART_INTSTS_LININT_Pos           (15)                                              /*!< UART_T::INTSTS: LININT Position           */
N#define UART_INTSTS_LININT_Msk           (0x1ul << UART_INTSTS_LININT_Pos)                 /*!< UART_T::INTSTS: LININT Mask               */
N
N#define UART_INTSTS_CTSWKIF_Pos          (16)                                              /*!< UART_T::INTSTS: CTSWKIF Position          */
N#define UART_INTSTS_CTSWKIF_Msk          (0x1ul << UART_INTSTS_CTSWKIF_Pos)                /*!< UART_T::INTSTS: CTSWKIF Mask              */
N
N#define UART_INTSTS_DATWKIF_Pos          (17)                                              /*!< UART_T::INTSTS: DATWKIF Position          */
N#define UART_INTSTS_DATWKIF_Msk          (0x1ul << UART_INTSTS_DATWKIF_Pos)                /*!< UART_T::INTSTS: DATWKIF Mask              */
N
N#define UART_INTSTS_HWRLSIF_Pos          (18)                                              /*!< UART_T::INTSTS: HWRLSIF Position          */
N#define UART_INTSTS_HWRLSIF_Msk          (0x1ul << UART_INTSTS_HWRLSIF_Pos)                /*!< UART_T::INTSTS: HWRLSIF Mask              */
N
N#define UART_INTSTS_HWMODIF_Pos          (19)                                              /*!< UART_T::INTSTS: HWMODIF Position          */
N#define UART_INTSTS_HWMODIF_Msk          (0x1ul << UART_INTSTS_HWMODIF_Pos)                /*!< UART_T::INTSTS: HWMODIF Mask              */
N
N#define UART_INTSTS_HWTOIF_Pos           (20)                                              /*!< UART_T::INTSTS: HWTOIF Position           */
N#define UART_INTSTS_HWTOIF_Msk           (0x1ul << UART_INTSTS_HWTOIF_Pos)                 /*!< UART_T::INTSTS: HWTOIF Mask               */
N
N#define UART_INTSTS_HWBUFEIF_Pos         (21)                                              /*!< UART_T::INTSTS: HWBUFEIF Position         */
N#define UART_INTSTS_HWBUFEIF_Msk         (0x1ul << UART_INTSTS_HWBUFEIF_Pos)               /*!< UART_T::INTSTS: HWBUFEIF Mask             */
N
N#define UART_INTSTS_HWRLSINT_Pos         (26)                                              /*!< UART_T::INTSTS: HWRLSINT Position         */
N#define UART_INTSTS_HWRLSINT_Msk         (0x1ul << UART_INTSTS_HWRLSINT_Pos)               /*!< UART_T::INTSTS: HWRLSINT Mask             */
N
N#define UART_INTSTS_HWMODINT_Pos         (27)                                              /*!< UART_T::INTSTS: HWMODINT Position         */
N#define UART_INTSTS_HWMODINT_Msk         (0x1ul << UART_INTSTS_HWMODINT_Pos)               /*!< UART_T::INTSTS: HWMODINT Mask             */
N
N#define UART_INTSTS_HWTOINT_Pos          (28)                                              /*!< UART_T::INTSTS: HWTOINT Position          */
N#define UART_INTSTS_HWTOINT_Msk          (0x1ul << UART_INTSTS_HWTOINT_Pos)                /*!< UART_T::INTSTS: HWTOINT Mask              */
N
N#define UART_INTSTS_HWBUFEINT_Pos        (29)                                              /*!< UART_T::INTSTS: HWBUFEINT Position        */
N#define UART_INTSTS_HWBUFEINT_Msk        (0x1ul << UART_INTSTS_HWBUFEINT_Pos)              /*!< UART_T::INTSTS: HWBUFEINT Mask            */
N
N#define UART_TOUT_TOIC_Pos               (0)                                               /*!< UART_T::TOUT: TOIC Position               */
N#define UART_TOUT_TOIC_Msk               (0xfful << UART_TOUT_TOIC_Pos)                    /*!< UART_T::TOUT: TOIC Mask                   */
N
N#define UART_TOUT_DLY_Pos                (8)                                               /*!< UART_T::TOUT: DLY Position                */
N#define UART_TOUT_DLY_Msk                (0xfful << UART_TOUT_DLY_Pos)                     /*!< UART_T::TOUT: DLY Mask                    */
N
N#define UART_BAUD_BRD_Pos                (0)                                               /*!< UART_T::BAUD: BRD Position                */
N#define UART_BAUD_BRD_Msk                (0xfffful << UART_BAUD_BRD_Pos)                   /*!< UART_T::BAUD: BRD Mask                    */
N
N#define UART_BAUD_EDIVM1_Pos             (24)                                              /*!< UART_T::BAUD: EDIVM1 Position             */
N#define UART_BAUD_EDIVM1_Msk             (0xful << UART_BAUD_EDIVM1_Pos)                   /*!< UART_T::BAUD: EDIVM1 Mask                 */
N
N#define UART_BAUD_BAUDM0_Pos             (28)                                              /*!< UART_T::BAUD: BAUDM0 Position             */
N#define UART_BAUD_BAUDM0_Msk             (0x1ul << UART_BAUD_BAUDM0_Pos)                   /*!< UART_T::BAUD: BAUDM0 Mask                 */
N
N#define UART_BAUD_BAUDM1_Pos             (29)                                              /*!< UART_T::BAUD: BAUDM1 Position             */
N#define UART_BAUD_BAUDM1_Msk             (0x1ul << UART_BAUD_BAUDM1_Pos)                   /*!< UART_T::BAUD: BAUDM1 Mask                 */
N
N#define UART_IRDA_TXEN_Pos               (1)                                               /*!< UART_T::IRDA: TXEN Position               */
N#define UART_IRDA_TXEN_Msk               (0x1ul << UART_IRDA_TXEN_Pos)                     /*!< UART_T::IRDA: TXEN Mask                   */
N
N#define UART_IRDA_TXINV_Pos              (5)                                               /*!< UART_T::IRDA: TXINV Position              */
N#define UART_IRDA_TXINV_Msk              (0x1ul << UART_IRDA_TXINV_Pos)                    /*!< UART_T::IRDA: TXINV Mask                  */
N
N#define UART_IRDA_RXINV_Pos              (6)                                               /*!< UART_T::IRDA: RXINV Position              */
N#define UART_IRDA_RXINV_Msk              (0x1ul << UART_IRDA_RXINV_Pos)                    /*!< UART_T::IRDA: RXINV Mask                  */
N
N#define UART_ALTCTL_BRKFL_Pos            (0)                                               /*!< UART_T::ALTCTL: BRKFL Position            */
N#define UART_ALTCTL_BRKFL_Msk            (0xful << UART_ALTCTL_BRKFL_Pos)                  /*!< UART_T::ALTCTL: BRKFL Mask                */
N
N#define UART_ALTCTL_LINRXEN_Pos          (6)                                               /*!< UART_T::ALTCTL: LINRXEN Position          */
N#define UART_ALTCTL_LINRXEN_Msk          (0x1ul << UART_ALTCTL_LINRXEN_Pos)                /*!< UART_T::ALTCTL: LINRXEN Mask              */
N
N#define UART_ALTCTL_LINTXEN_Pos          (7)                                               /*!< UART_T::ALTCTL: LINTXEN Position          */
N#define UART_ALTCTL_LINTXEN_Msk          (0x1ul << UART_ALTCTL_LINTXEN_Pos)                /*!< UART_T::ALTCTL: LINTXEN Mask              */
N
N#define UART_ALTCTL_RS485NMM_Pos         (8)                                               /*!< UART_T::ALTCTL: RS485NMM Position         */
N#define UART_ALTCTL_RS485NMM_Msk         (0x1ul << UART_ALTCTL_RS485NMM_Pos)               /*!< UART_T::ALTCTL: RS485NMM Mask             */
N
N#define UART_ALTCTL_RS485AAD_Pos         (9)                                               /*!< UART_T::ALTCTL: RS485AAD Position         */
N#define UART_ALTCTL_RS485AAD_Msk         (0x1ul << UART_ALTCTL_RS485AAD_Pos)               /*!< UART_T::ALTCTL: RS485AAD Mask             */
N
N#define UART_ALTCTL_RS485AUD_Pos         (10)                                              /*!< UART_T::ALTCTL: RS485AUD Position         */
N#define UART_ALTCTL_RS485AUD_Msk         (0x1ul << UART_ALTCTL_RS485AUD_Pos)               /*!< UART_T::ALTCTL: RS485AUD Mask             */
N
N#define UART_ALTCTL_ADDRDEN_Pos          (15)                                              /*!< UART_T::ALTCTL: ADDRDEN Position          */
N#define UART_ALTCTL_ADDRDEN_Msk          (0x1ul << UART_ALTCTL_ADDRDEN_Pos)                /*!< UART_T::ALTCTL: ADDRDEN Mask              */
N
N#define UART_ALTCTL_ABRIF_Pos            (17)                                              /*!< UART_T::ALTCTL: ABRIF Position            */
N#define UART_ALTCTL_ABRIF_Msk            (0x1ul << UART_ALTCTL_ABRIF_Pos)                  /*!< UART_T::ALTCTL: ABRIF Mask                */
N
N#define UART_ALTCTL_ABRDEN_Pos           (18)                                              /*!< UART_T::ALTCTL: ABRDEN Position           */
N#define UART_ALTCTL_ABRDEN_Msk           (0x1ul << UART_ALTCTL_ABRDEN_Pos)                 /*!< UART_T::ALTCTL: ABRDEN Mask               */
N
N#define UART_ALTCTL_ABRDBITS_Pos         (19)                                              /*!< UART_T::ALTCTL: ABRDBITS Position         */
N#define UART_ALTCTL_ABRDBITS_Msk         (0x3ul << UART_ALTCTL_ABRDBITS_Pos)               /*!< UART_T::ALTCTL: ABRDBITS Mask             */
N
N#define UART_ALTCTL_ADDRMV_Pos           (24)                                              /*!< UART_T::ALTCTL: ADDRMV Position           */
N#define UART_ALTCTL_ADDRMV_Msk           (0xfful << UART_ALTCTL_ADDRMV_Pos)                /*!< UART_T::ALTCTL: ADDRMV Mask               */
N
N#define UART_FUNCSEL_FUNCSEL_Pos         (0)                                               /*!< UART_T::FUNCSEL: FUNCSEL Position         */
N#define UART_FUNCSEL_FUNCSEL_Msk         (0x3ul << UART_FUNCSEL_FUNCSEL_Pos)               /*!< UART_T::FUNCSEL: FUNCSEL Mask             */
N
N#define UART_LINCTL_SLVEN_Pos            (0)                                               /*!< UART_T::LINCTL: SLVEN Position            */
N#define UART_LINCTL_SLVEN_Msk            (0x1ul << UART_LINCTL_SLVEN_Pos)                  /*!< UART_T::LINCTL: SLVEN Mask                */
N
N#define UART_LINCTL_SLVHDEN_Pos          (1)                                               /*!< UART_T::LINCTL: SLVHDEN Position          */
N#define UART_LINCTL_SLVHDEN_Msk          (0x1ul << UART_LINCTL_SLVHDEN_Pos)                /*!< UART_T::LINCTL: SLVHDEN Mask              */
N
N#define UART_LINCTL_SLVAREN_Pos          (2)                                               /*!< UART_T::LINCTL: SLVAREN Position          */
N#define UART_LINCTL_SLVAREN_Msk          (0x1ul << UART_LINCTL_SLVAREN_Pos)                /*!< UART_T::LINCTL: SLVAREN Mask              */
N
N#define UART_LINCTL_SLVDUEN_Pos          (3)                                               /*!< UART_T::LINCTL: SLVDUEN Position          */
N#define UART_LINCTL_SLVDUEN_Msk          (0x1ul << UART_LINCTL_SLVDUEN_Pos)                /*!< UART_T::LINCTL: SLVDUEN Mask              */
N
N#define UART_LINCTL_MUTE_Pos             (4)                                               /*!< UART_T::LINCTL: MUTE Position             */
N#define UART_LINCTL_MUTE_Msk             (0x1ul << UART_LINCTL_MUTE_Pos)                   /*!< UART_T::LINCTL: MUTE Mask                 */
N
N#define UART_LINCTL_SENDH_Pos            (8)                                               /*!< UART_T::LINCTL: SENDH Position            */
N#define UART_LINCTL_SENDH_Msk            (0x1ul << UART_LINCTL_SENDH_Pos)                  /*!< UART_T::LINCTL: SENDH Mask                */
N
N#define UART_LINCTL_IDPEN_Pos            (9)                                               /*!< UART_T::LINCTL: IDPEN Position            */
N#define UART_LINCTL_IDPEN_Msk            (0x1ul << UART_LINCTL_IDPEN_Pos)                  /*!< UART_T::LINCTL: IDPEN Mask                */
N
N#define UART_LINCTL_BRKDETEN_Pos         (10)                                              /*!< UART_T::LINCTL: BRKDETEN Position         */
N#define UART_LINCTL_BRKDETEN_Msk         (0x1ul << UART_LINCTL_BRKDETEN_Pos)               /*!< UART_T::LINCTL: BRKDETEN Mask             */
N
N#define UART_LINCTL_RXOFF_Pos            (11)                                              /*!< UART_T::LINCTL: RXOFF Position            */
N#define UART_LINCTL_RXOFF_Msk            (0x1ul << UART_LINCTL_RXOFF_Pos)                  /*!< UART_T::LINCTL: RXOFF Mask                */
N
N#define UART_LINCTL_BITERREN_Pos         (12)                                              /*!< UART_T::LINCTL: BITERREN Position         */
N#define UART_LINCTL_BITERREN_Msk         (0x1ul << UART_LINCTL_BITERREN_Pos)               /*!< UART_T::LINCTL: BITERREN Mask             */
N
N#define UART_LINCTL_BRKFL_Pos            (16)                                              /*!< UART_T::LINCTL: BRKFL Position            */
N#define UART_LINCTL_BRKFL_Msk            (0xful << UART_LINCTL_BRKFL_Pos)                  /*!< UART_T::LINCTL: BRKFL Mask                */
N
N#define UART_LINCTL_BSL_Pos              (20)                                              /*!< UART_T::LINCTL: BSL Position              */
N#define UART_LINCTL_BSL_Msk              (0x3ul << UART_LINCTL_BSL_Pos)                    /*!< UART_T::LINCTL: BSL Mask                  */
N
N#define UART_LINCTL_HSEL_Pos             (22)                                              /*!< UART_T::LINCTL: HSEL Position             */
N#define UART_LINCTL_HSEL_Msk             (0x3ul << UART_LINCTL_HSEL_Pos)                   /*!< UART_T::LINCTL: HSEL Mask                 */
N
N#define UART_LINCTL_PID_Pos              (24)                                              /*!< UART_T::LINCTL: PID Position              */
N#define UART_LINCTL_PID_Msk              (0xfful << UART_LINCTL_PID_Pos)                   /*!< UART_T::LINCTL: PID Mask                  */
N
N#define UART_LINSTS_SLVHDETF_Pos         (0)                                               /*!< UART_T::LINSTS: SLVHDETF Position         */
N#define UART_LINSTS_SLVHDETF_Msk         (0x1ul << UART_LINSTS_SLVHDETF_Pos)               /*!< UART_T::LINSTS: SLVHDETF Mask             */
N
N#define UART_LINSTS_SLVHEF_Pos           (1)                                               /*!< UART_T::LINSTS: SLVHEF Position           */
N#define UART_LINSTS_SLVHEF_Msk           (0x1ul << UART_LINSTS_SLVHEF_Pos)                 /*!< UART_T::LINSTS: SLVHEF Mask               */
N
N#define UART_LINSTS_SLVIDPEF_Pos         (2)                                               /*!< UART_T::LINSTS: SLVIDPEF Position         */
N#define UART_LINSTS_SLVIDPEF_Msk         (0x1ul << UART_LINSTS_SLVIDPEF_Pos)               /*!< UART_T::LINSTS: SLVIDPEF Mask             */
N
N#define UART_LINSTS_SLVSYNCF_Pos         (3)                                               /*!< UART_T::LINSTS: SLVSYNCF Position         */
N#define UART_LINSTS_SLVSYNCF_Msk         (0x1ul << UART_LINSTS_SLVSYNCF_Pos)               /*!< UART_T::LINSTS: SLVSYNCF Mask             */
N
N#define UART_LINSTS_BRKDETF_Pos          (8)                                               /*!< UART_T::LINSTS: BRKDETF Position          */
N#define UART_LINSTS_BRKDETF_Msk          (0x1ul << UART_LINSTS_BRKDETF_Pos)                /*!< UART_T::LINSTS: BRKDETF Mask              */
N
N#define UART_LINSTS_BITEF_Pos            (9)                                               /*!< UART_T::LINSTS: BITEF Position            */
N#define UART_LINSTS_BITEF_Msk            (0x1ul << UART_LINSTS_BITEF_Pos)                  /*!< UART_T::LINSTS: BITEF Mask                */
N
N
N/**@}*/ /* UART_CONST */
N/**@}*/ /* end of UART register group */
N
N
N/*---------------------- Universal Serial Bus Controller -------------------------*/
N/**
N    @addtogroup USB Universal Serial Bus Controller(USB)
N    Memory Mapped Structure for USB Controller
N@{ */
N
N/**
N  * @brief USBD endpoints register
N  */
N
Ntypedef struct
N{
N
N
N/**
N * @var USBD_EP_T::BUFSEG
N * Offset: 0x500/0x510/0x520/0x530/0x540/0x550/0x560/0x570  Endpoint 0~7 Buffer Segmentation Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[8:3]   |BUFSEG    |Endpoint Buffer Segmentation
N * |        |          |It is used to indicate the offset address for each endpoint with the USB SRAM starting address The effective starting address of the endpoint is
N * |        |          |USB_SRAM address + { BUFSEG[8:3], 3'b000}
N * |        |          |Where the USB_SRAM address = USBD_BA+0x100h.
N * |        |          |Refer to the section 5.4.4.7 for the endpoint SRAM structure and its description.
N * @var USBD_EP_T::MXPLD
N * Offset: 0x504/0x514/0x524/0x534/0x544/0x554/0x564/0x574  Endpoint 0~7 Maximal Payload Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[8:0]   |MXPLD     |Maximal Payload
N * |        |          |Define the data length which is transmitted to host (IN token) or the actual data length which is received from the host (OUT token).
N * |        |          |It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.
N * |        |          |(1) When the register is written by CPU,
N * |        |          |For IN token, the value of MXPLD is used to define the data length to be transmitted and indicate the data buffer is ready.
N * |        |          |For OUT token, it means that the controller is ready to receive data from the host and the value of MXPLD is the maximal data length comes from host.
N * |        |          |(2) When the register is read by CPU,
N * |        |          |For IN token, the value of MXPLD is indicated by the data length be transmitted to host
N * |        |          |For OUT token, the value of MXPLD is indicated the actual data length receiving from host.
N * |        |          |Note: Once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.
N * @var USBD_EP_T::CFG
N * Offset: 0x508/0x518/0x528/0x538/0x548/0x558/0x568/0x578  Endpoint 0~7 Configuration Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |EPNUM     |Endpoint Number
N * |        |          |These bits are used to define the endpoint number of the current endpoint.
N * |[4]     |ISOCH     |Isochronous Endpoint
N * |        |          |This bit is used to set the endpoint as Isochronous endpoint, no handshake.
N * |        |          |0 = No Isochronous endpoint.
N * |        |          |1 = Isochronous endpoint.
N * |[6:5]   |STATE     |Endpoint STATE
N * |        |          |00 = Endpoint is Disabled.
N * |        |          |01 = Out endpoint.
N * |        |          |10 = IN endpoint.
N * |        |          |11 = Undefined.
N * |[7]     |DSQSYNC   |Data Sequence Synchronization
N * |        |          |0 = DATA0 PID.
N * |        |          |1 = DATA1 PID.
N * |        |          |Note: It is used to specify the DATA0 or DATA1 PID in the following IN token transaction.
N * |        |          |Hardware will toggle automatically in IN token base on the bit.
N * |[9]     |CSTALL    |Clear STALL Response
N * |        |          |0 = Disable the device to clear the STALL handshake in setup stage.
N * |        |          |1 = Clear the device to response STALL handshake in setup stage.
N * @var USBD_EP_T::CFGP
N * Offset: 0x50C/0x51C/0x52C/0x53C/0x54C/0x55C/0x56C/0x57C  Endpoint 0~7 Set Stall and Clear In/Out Ready Control Register
N    * ---------------------------------------------------------------------------------------------------
N    * |Bits    |Field     |Descriptions
N    * | :----: | :----:   | :---- |
N    * |[0]     |CLRRDY    |Clear Ready
N    * |        |          |When the USB_MXPLD register is set by user, it means that the endpoint is ready to transmit or receive data.
N    * |        |          |If the user wants to turn off this transaction before the transaction start, users can set this bit to 1 to turn it off and it will be cleared to 0 automatically.
N    * |        |          |For IN token, write 1 to clear the IN token had ready to transmit the data to USB.
N    * |        |          |For OUT token, write 1 to clear the OUT token had ready to receive the data from USB.
N    * |        |          |This bit is write 1 only and is always 0 when it is read back.
N    * |[1]     |SSTALL    |Set STALL
N    * |        |          |0 = Disable the device to response STALL.
N    * |        |          |1 = Set the device to respond STALL automatically.
N    */
N
N    __IO uint32_t BUFSEG;        /* Offset: 0x500/0x510/0x520/0x530/0x540/0x550/0x560/0x570  Endpoint 0~7 Buffer Segmentation Register */
X    volatile uint32_t BUFSEG;         
N    __IO uint32_t MXPLD;         /* Offset: 0x504/0x514/0x524/0x534/0x544/0x554/0x564/0x574  Endpoint 0~7 Maximal Payload Register */
X    volatile uint32_t MXPLD;          
N    __IO uint32_t CFG;           /* Offset: 0x508/0x518/0x528/0x538/0x548/0x558/0x568/0x578  Endpoint 0~7 Configuration Register */
X    volatile uint32_t CFG;            
N    __IO uint32_t CFGP;          /* Offset: 0x50C/0x51C/0x52C/0x53C/0x54C/0x55C/0x56C/0x57C  Endpoint 0~7 Set Stall and Clear In/Out Ready Control Register */
X    volatile uint32_t CFGP;           
N
N} USBD_EP_T;
N
N
N
N
N
Ntypedef struct
N{
N
N
N/**
N * @var USBD_T::INTEN
N * Offset: 0x00  USB Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |BUSIEN    |Bus Event Interrupt Enable
N * |        |          |0 = BUS event interrupt Disabled.
N * |        |          |1 = BUS event interrupt Enabled.
N * |[1]     |USBIEN    |USB Event Interrupt Enable
N * |        |          |0 = USB event interrupt Disabled.
N * |        |          |1 = USB event interrupt Enabled.
N * |[2]     |VBDETIEN  |VBUS Detection Interrupt Enable
N * |        |          |0 = Floating detection Interrupt Disabled.
N * |        |          |1 = Floating detection Interrupt Enabled.
N * |[3]     |NEVWKIEN  |USB No-Event-Wake-Up Interrupt Enable
N * |        |          |0 = No-Event-Wake-up Interrupt Disabled.
N * |        |          |1 = No-Event-Wake-up Interrupt Enabled.
N * |[8]     |WKEN      |Wake-Up Function Enable
N * |        |          |0 = USB wake-up function Disabled.
N * |        |          |1 = USB wake-up function Enabled.
N * |[15]    |INNAKEN   |Active NAK Function And Its Status In IN Token
N * |        |          |0 = When device responds NAK after receiving IN token, IN NAK status will not be
N * |        |          |    updated to USBD_EPSTS register, so that the USB interrupt event will not be asserted.
N * |        |          |1 = IN NAK status will be updated to USBD_EPSTS register and the USB interrupt event
N * |        |          |    will be asserted, when the device responds NAK after receiving IN token.
N * @var USBD_T::INTSTS
N * Offset: 0x04  USB Interrupt Event Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |BUSIF     |BUS Interrupt Status
N * |        |          |The BUS event means that there is one of the suspense or the resume function in the bus.
N * |        |          |0 = No BUS event occurred.
N * |        |          |1 = Bus event occurred; check USB_ATTR[3:0] to know which kind of bus event was occurred, cleared by write 1 to USB_INTSTS[0].
N * |[1]     |USBIF     |USB Event Interrupt Status
N * |        |          |The USB event includes the SETUP Token, IN Token, OUT ACK, ISO IN, or ISO OUT events in the bus.
N * |        |          |0 = No USB event occurred.
N * |        |          |1 = USB event occurred, check EPSTS0~7 to know which kind of USB event occurred.
N * |        |          |Cleared by write 1 to USB_INTSTS[1] or EPEVT0~7 and SETUP (USB_INTSTS[31]).
N * |[2]     |VBDETIF   |VBUS Detection Interrupt Status
N * |        |          |0 = There is not attached/detached event in the USB.
N * |        |          |1 = There is attached/detached event in the USB bus and it is cleared by write 1 to USB_INTSTS[2].
N * |[3]     |NEVWKIF   |USB No-Event-Wake-Up Interrupt Status
N * |        |          |0 = No Wake-up event occurred.
N * |        |          |1 = Wake-up event occurred, cleared by write 1 to USB_INTSTS[3].
N * |[16]    |EPEVT0    |Endpoint 0's USB Event Status
N * |        |          |0 = No event occurred on endpoint 0.
N * |        |          |1 = USB event occurred on Endpoint 0, check USB_EPSTS[10:8] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[16] or USB_INTSTS[1].
N * |[17]    |EPEVT1    |Endpoint 1's USB Event Status
N * |        |          |0 = No event occurred on endpoint 1.
N * |        |          |1 = USB event occurred on Endpoint 1, check USB_EPSTS[13:11] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[17] or USB_INTSTS[1].
N * |[18]    |EPEVT2    |Endpoint 2's USB Event Status
N * |        |          |0 = No event occurred on endpoint 2.
N * |        |          |1 = USB event occurred on Endpoint 2, check USB_EPSTS[16:14] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[18] or USB_INTSTS[1].
N * |[19]    |EPEVT3    |Endpoint 3's USB Event Status
N * |        |          |0 = No event occurred on endpoint 3.
N * |        |          |1 = USB event occurred on Endpoint 3, check USB_EPSTS[19:17] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[19] or USB_INTSTS[1].
N * |[20]    |EPEVT4    |Endpoint 4's USB Event Status
N * |        |          |0 = No event occurred on endpoint 4.
N * |        |          |1 = USB event occurred on Endpoint 4, check USB_EPSTS[22:20] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[20] or USB_INTSTS[1].
N * |[21]    |EPEVT5    |Endpoint 5's USB Event Status
N * |        |          |0 = No event occurred on endpoint 5.
N * |        |          |1 = USB event occurred on Endpoint 5, check USB_EPSTS[25:23] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[21] or USB_INTSTS[1].
N * |[22]    |EPEVT6    |Endpoint 6's USB Event Status
N * |        |          |0 = No event occurred on endpoint 6.
N * |        |          |1 = USB event occurred on Endpoint 6, check USB_EPSTS[28:26] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[22] or USB_INTSTS[1].
N * |[23]    |EPEVT7    |Endpoint 7's USB Event Status
N * |        |          |0 = No event occurred on endpoint 7.
N * |        |          |1 = USB event occurred on Endpoint 7, check USB_EPSTS[31:29] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[23] or USB_INTSTS[1].
N * |[31]    |SETUP     |Setup Event Status
N * |        |          |0 = No Setup event.
N * |        |          |1 = SETUP event occurred, cleared by write 1 to USB_INTSTS[31].
N * @var USBD_T::FADDR
N * Offset: 0x08  USB Device Function Address Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[6:0]   |FADDR     |USB Device Function Address
N * @var USBD_T::EPSTS
N * Offset: 0x0C  USB Endpoint Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7]     |OV        |Overrun
N * |        |          |It indicates that the received data is over the maximum payload number or not.
N * |        |          |0 = No overrun.
N * |        |          |1 = Out Data is more than the Max Payload in MXPLD register or the Setup Data is more than 8 Bytes.
N * |[10:8]  |EPSTS0    |Endpoint 0 Bus Status
N * |        |          |These bits are used to indicate the current status of this endpoint
N * |        |          |000 = In ACK.
N * |        |          |001 = In NAK.
N * |        |          |010 = Out Packet Data0 ACK.
N * |        |          |110 = Out Packet Data1 ACK.
N * |        |          |011 = Setup ACK.
N * |        |          |111 = Isochronous transfer end.
N * |[13:11] |EPSTS1    |Endpoint 1 Bus Status
N * |        |          |These bits are used to indicate the current status of this endpoint
N * |        |          |000 = In ACK.
N * |        |          |001 = In NAK.
N * |        |          |010 = Out Packet Data0 ACK.
N * |        |          |110 = Out Packet Data1 ACK.
N * |        |          |011 = Setup ACK.
N * |        |          |111 = Isochronous transfer end.
N * |[16:14] |EPSTS2    |Endpoint 2 Bus Status
N * |        |          |These bits are used to indicate the current status of this endpoint
N * |        |          |000 = In ACK.
N * |        |          |001 = In NAK.
N * |        |          |010 = Out Packet Data0 ACK.
N * |        |          |110 = Out Packet Data1 ACK.
N * |        |          |011 = Setup ACK.
N * |        |          |111 = Isochronous transfer end.
N * |[19:17] |EPSTS3    |Endpoint 3 Bus Status
N * |        |          |These bits are used to indicate the current status of this endpoint
N * |        |          |000 = In ACK.
N * |        |          |001 = In NAK.
N * |        |          |010 = Out Packet Data0 ACK.
N * |        |          |110 = Out Packet Data1 ACK.
N * |        |          |011 = Setup ACK.
N * |        |          |111 = Isochronous transfer end.
N * |[22:20] |EPSTS4    |Endpoint 4 Bus Status
N * |        |          |These bits are used to indicate the current status of this endpoint
N * |        |          |000 = In ACK.
N * |        |          |001 = In NAK.
N * |        |          |010 = Out Packet Data0 ACK.
N * |        |          |110 = Out Packet Data1 ACK.
N * |        |          |011 = Setup ACK.
N * |        |          |111 = Isochronous transfer end.
N * |[25:23] |EPSTS5    |Endpoint 5 Bus Status
N * |        |          |These bits are used to indicate the current status of this endpoint
N * |        |          |000 = In ACK.
N * |        |          |001 = In NAK.
N * |        |          |010 = Out Packet Data0 ACK.
N * |        |          |110 = Out Packet Data1 ACK.
N * |        |          |011 = Setup ACK.
N * |        |          |111 = Isochronous transfer end.
N * |[28:26] |EPSTS6    |Endpoint 6 Bus Status
N * |        |          |These bits are used to indicate the current status of this endpoint
N * |        |          |000 = In ACK.
N * |        |          |001 = In NAK.
N * |        |          |010 = Out Packet Data0 ACK.
N * |        |          |110 = Out Packet Data1 ACK.
N * |        |          |011 = Setup ACK.
N * |        |          |111 = Isochronous transfer end.
N * |[31:29] |EPSTS7    |Endpoint 7 Bus Status
N * |        |          |These bits are used to indicate the current status of this endpoint
N * |        |          |000 = In ACK.
N * |        |          |001 = In NAK.
N * |        |          |010 = Out Packet Data0 ACK.
N * |        |          |110 = Out Packet Data1 ACK.
N * |        |          |011 = Setup ACK.
N * |        |          |111 = Isochronous transfer end.
N * @var USBD_T::ATTR
N * Offset: 0x10  USB Bus Status and Attribution Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |USBRST    |USB Reset Status
N * |        |          |0 = Bus no reset.
N * |        |          |1 = Bus reset when SE0 (single-ended 0) is presented more than 2.5us.
N * |        |          |Note: This bit is read only.
N * |[1]     |SUSPEND   |Suspend Status
N * |        |          |0 = Bus no suspend.
N * |        |          |1 = Bus idle more than 3ms, either cable is plugged off or host is sleeping.
N * |        |          |Note: This bit is read only.
N * |[2]     |RESUME    |Resume Status
N * |        |          |0 = No bus resume.
N * |        |          |1 = Resume from suspend.
N * |        |          |Note: This bit is read only.
N * |[3]     |TOUT      |Time-Out Status
N * |        |          |0 = No time-out.
N * |        |          |1 = No Bus response more than 18 bits time.
N * |        |          |Note: This bit is read only.
N * |[4]     |PHYEN     |PHY Transceiver Function Enable
N * |        |          |0 = PHY transceiver function Disabled.
N * |        |          |1 = PHY transceiver function Enabled.
N * |[5]     |RWAKEUP   |Remote Wake-Up
N * |        |          |0 = Release the USB bus from K state.
N * |        |          |1 = Force USB bus to K (USB_D+ low, USB_D- high) state, used for remote wake-up.
N * |[7]     |USBEN     |USB Controller Enable
N * |        |          |0 = USB Controller Disabled.
N * |        |          |1 = USB Controller Enabled.
N * |[8]     |DPPUEN    |Pull-Up Resistor On USB_D+ Enable
N * |        |          |0 = Pull-up resistor in USB_D+ pin Disabled.
N * |        |          |1 = Pull-up resistor in USB_D+ pin Enabled.
N * |[9]     |PWRDN     |Power Down PHY Transceiver, Low Active (M45xD/M45xC Only)
N * |        |          |0 = Power down related circuits of PHY transceiver.
N * |        |          |1 = Turn on related circuits of  PHY transceiver.
N * |[10]    |BYTEM     |CPU Access USB SRAM Size Mode Selection
N * |        |          |0 = Word mode: The size of the transfer from CPU to USB SRAM can be Word only.
N * |        |          |1 = Byte mode: The size of the transfer from CPU to USB SRAM can be Byte only.
N * @var USBD_T::VBUSDET
N * Offset: 0x14  USB Device VBUS Detection Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |FLDET     |Device VBUS Detected
N * |        |          |0 = Controller is not attached into the USB host.
N * |        |          |1 =Controller is attached into the BUS.
N * @var USBD_T::STBUFSEG
N * Offset: 0x18  Setup Token Buffer Segmentation Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[8:3]   |STBUFSEG  |Setup Token Buffer Segmentation
N * |        |          |It is used to indicate the offset address for the SETUP token with the USB Device SRAM starting address The effective starting address is
N * |        |          |USB_SRAM address + {STBUFSEG[8:3], 3'b000}
N * |        |          |Where the USB_SRAM address = USBD_BA+0x100h.
N * |        |          |Note: It is used for SETUP token only.
N * @var USBD_T::SE0
N * Offset: 0x90  USB Drive SE0 Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |DRVSE0    |Drive Single Ended Zero In USB Bus
N * |        |          |The Single Ended Zero (SE0) is when both lines (USB_D+ and USB_D-) are being pulled low.
N * |        |          |0 = None.
N * |        |          |1 = Force USB PHY transceiver to drive SE0.
N * @var USBD_T::EP
N * Offset: 0x500 ~ 0x57C  USB End Point 0 ~ 7 Configuration Register
N * ---------------------------------------------------------------------------------------------------
N */
N
N    __IO uint32_t INTEN;         /* Offset: 0x00  USB Interrupt Enable Register                                      */
X    volatile uint32_t INTEN;          
N    __IO uint32_t INTSTS;        /* Offset: 0x04  USB Interrupt Event Status Register                                */
X    volatile uint32_t INTSTS;         
N    __IO uint32_t FADDR;         /* Offset: 0x08  USB Device Function Address Register                               */
X    volatile uint32_t FADDR;          
N    __I  uint32_t EPSTS;         /* Offset: 0x0C  USB Endpoint Status Register                                       */
X    volatile const  uint32_t EPSTS;          
N    __IO uint32_t ATTR;          /* Offset: 0x10  USB Bus Status and Attribution Register                            */
X    volatile uint32_t ATTR;           
N    __I  uint32_t VBUSDET;       /* Offset: 0x14  USB Device VBUS Detection Register                                 */
X    volatile const  uint32_t VBUSDET;        
N    __IO uint32_t STBUFSEG;      /* Offset: 0x18  Setup Token Buffer Segmentation Register                           */
X    volatile uint32_t STBUFSEG;       
N    __I  uint32_t RESERVE0[29]; 
X    volatile const  uint32_t RESERVE0[29]; 
N    __IO uint32_t SE0;           /* Offset: 0x90  USB Drive SE0 Control Register                                     */
X    volatile uint32_t SE0;            
N    __I  uint32_t RESERVE1[283];
X    volatile const  uint32_t RESERVE1[283];
N    USBD_EP_T     EP[8];         /* Offset: 0x500 ~ 0x57C  USB End Point 0 ~ 7 Configuration Register                */
N
N} USBD_T;
N
N
N
N/**
N    @addtogroup USB_CONST USB Bit Field Definition
N    Constant Definitions for USB Controller
N@{ */
N
N#define USBD_INTEN_BUSIEN_Pos            (0)                                               /*!< USBD_T::INTEN: BUSIEN Position            */
N#define USBD_INTEN_BUSIEN_Msk            (0x1ul << USBD_INTEN_BUSIEN_Pos)                  /*!< USBD_T::INTEN: BUSIEN Mask                */
N
N#define USBD_INTEN_USBIEN_Pos            (1)                                               /*!< USBD_T::INTEN: USBIEN Position            */
N#define USBD_INTEN_USBIEN_Msk            (0x1ul << USBD_INTEN_USBIEN_Pos)                  /*!< USBD_T::INTEN: USBIEN Mask                */
N
N#define USBD_INTEN_VBDETIEN_Pos          (2)                                               /*!< USBD_T::INTEN: VBDETIEN Position          */
N#define USBD_INTEN_VBDETIEN_Msk          (0x1ul << USBD_INTEN_VBDETIEN_Pos)                /*!< USBD_T::INTEN: VBDETIEN Mask              */
N
N#define USBD_INTEN_NEVWKIEN_Pos          (3)                                               /*!< USBD_T::INTEN: NEVWKIEN Position          */
N#define USBD_INTEN_NEVWKIEN_Msk          (0x1ul << USBD_INTEN_NEVWKIEN_Pos)                /*!< USBD_T::INTEN: NEVWKIEN Mask              */
N
N#define USBD_INTEN_WKEN_Pos              (8)                                               /*!< USBD_T::INTEN: WKEN Position              */
N#define USBD_INTEN_WKEN_Msk              (0x1ul << USBD_INTEN_WKEN_Pos)                    /*!< USBD_T::INTEN: WKEN Mask                  */
N
N#define USBD_INTEN_INNAKEN_Pos           (15)                                              /*!< USBD_T::INTEN: INNAKEN Position           */
N#define USBD_INTEN_INNAKEN_Msk           (0x1ul << USBD_INTEN_INNAKEN_Pos)                 /*!< USBD_T::INTEN: INNAKEN Mask               */
N
N#define USBD_INTSTS_BUSIF_Pos            (0)                                               /*!< USBD_T::INTSTS: BUSIF Position            */
N#define USBD_INTSTS_BUSIF_Msk            (0x1ul << USBD_INTSTS_BUSIF_Pos)                  /*!< USBD_T::INTSTS: BUSIF Mask                */
N
N#define USBD_INTSTS_USBIF_Pos            (1)                                               /*!< USBD_T::INTSTS: USBIF Position            */
N#define USBD_INTSTS_USBIF_Msk            (0x1ul << USBD_INTSTS_USBIF_Pos)                  /*!< USBD_T::INTSTS: USBIF Mask                */
N
N#define USBD_INTSTS_VBDETIF_Pos          (2)                                               /*!< USBD_T::INTSTS: VBDETIF Position          */
N#define USBD_INTSTS_VBDETIF_Msk          (0x1ul << USBD_INTSTS_VBDETIF_Pos)                /*!< USBD_T::INTSTS: VBDETIF Mask              */
N
N#define USBD_INTSTS_NEVWKIF_Pos          (3)                                               /*!< USBD_T::INTSTS: NEVWKIF Position          */
N#define USBD_INTSTS_NEVWKIF_Msk          (0x1ul << USBD_INTSTS_NEVWKIF_Pos)                /*!< USBD_T::INTSTS: NEVWKIF Mask              */
N
N#define USBD_INTSTS_EPEVT0_Pos           (16)                                              /*!< USBD_T::INTSTS: EPEVT0 Position           */
N#define USBD_INTSTS_EPEVT0_Msk           (0x1ul << USBD_INTSTS_EPEVT0_Pos)                 /*!< USBD_T::INTSTS: EPEVT0 Mask               */
N
N#define USBD_INTSTS_EPEVT1_Pos           (17)                                              /*!< USBD_T::INTSTS: EPEVT1 Position           */
N#define USBD_INTSTS_EPEVT1_Msk           (0x1ul << USBD_INTSTS_EPEVT1_Pos)                 /*!< USBD_T::INTSTS: EPEVT1 Mask               */
N
N#define USBD_INTSTS_EPEVT2_Pos           (18)                                              /*!< USBD_T::INTSTS: EPEVT2 Position           */
N#define USBD_INTSTS_EPEVT2_Msk           (0x1ul << USBD_INTSTS_EPEVT2_Pos)                 /*!< USBD_T::INTSTS: EPEVT2 Mask               */
N
N#define USBD_INTSTS_EPEVT3_Pos           (19)                                              /*!< USBD_T::INTSTS: EPEVT3 Position           */
N#define USBD_INTSTS_EPEVT3_Msk           (0x1ul << USBD_INTSTS_EPEVT3_Pos)                 /*!< USBD_T::INTSTS: EPEVT3 Mask               */
N
N#define USBD_INTSTS_EPEVT4_Pos           (20)                                              /*!< USBD_T::INTSTS: EPEVT4 Position           */
N#define USBD_INTSTS_EPEVT4_Msk           (0x1ul << USBD_INTSTS_EPEVT4_Pos)                 /*!< USBD_T::INTSTS: EPEVT4 Mask               */
N
N#define USBD_INTSTS_EPEVT5_Pos           (21)                                              /*!< USBD_T::INTSTS: EPEVT5 Position           */
N#define USBD_INTSTS_EPEVT5_Msk           (0x1ul << USBD_INTSTS_EPEVT5_Pos)                 /*!< USBD_T::INTSTS: EPEVT5 Mask               */
N
N#define USBD_INTSTS_EPEVT6_Pos           (22)                                              /*!< USBD_T::INTSTS: EPEVT6 Position           */
N#define USBD_INTSTS_EPEVT6_Msk           (0x1ul << USBD_INTSTS_EPEVT6_Pos)                 /*!< USBD_T::INTSTS: EPEVT6 Mask               */
N
N#define USBD_INTSTS_EPEVT7_Pos           (23)                                              /*!< USBD_T::INTSTS: EPEVT7 Position           */
N#define USBD_INTSTS_EPEVT7_Msk           (0x1ul << USBD_INTSTS_EPEVT7_Pos)                 /*!< USBD_T::INTSTS: EPEVT7 Mask               */
N
N#define USBD_INTSTS_SETUP_Pos            (31)                                              /*!< USBD_T::INTSTS: SETUP Position            */
N#define USBD_INTSTS_SETUP_Msk            (0x1ul << USBD_INTSTS_SETUP_Pos)                  /*!< USBD_T::INTSTS: SETUP Mask                */
N
N#define USBD_FADDR_FADDR_Pos             (0)                                               /*!< USBD_T::FADDR: FADDR Position             */
N#define USBD_FADDR_FADDR_Msk             (0x7ful << USBD_FADDR_FADDR_Pos)                  /*!< USBD_T::FADDR: FADDR Mask                 */
N
N#define USBD_EPSTS_OV_Pos                (7)                                               /*!< USBD_T::EPSTS: OV Position                */
N#define USBD_EPSTS_OV_Msk                (0x1ul << USBD_EPSTS_OV_Pos)                      /*!< USBD_T::EPSTS: OV Mask                    */
N
N#define USBD_EPSTS_EPSTS0_Pos            (8)                                               /*!< USBD_T::EPSTS: EPSTS0 Position            */
N#define USBD_EPSTS_EPSTS0_Msk            (0x7ul << USBD_EPSTS_EPSTS0_Pos)                  /*!< USBD_T::EPSTS: EPSTS0 Mask                */
N
N#define USBD_EPSTS_EPSTS1_Pos            (11)                                              /*!< USBD_T::EPSTS: EPSTS1 Position            */
N#define USBD_EPSTS_EPSTS1_Msk            (0x7ul << USBD_EPSTS_EPSTS1_Pos)                  /*!< USBD_T::EPSTS: EPSTS1 Mask                */
N
N#define USBD_EPSTS_EPSTS2_Pos            (14)                                              /*!< USBD_T::EPSTS: EPSTS2 Position            */
N#define USBD_EPSTS_EPSTS2_Msk            (0x7ul << USBD_EPSTS_EPSTS2_Pos)                  /*!< USBD_T::EPSTS: EPSTS2 Mask                */
N
N#define USBD_EPSTS_EPSTS3_Pos            (17)                                              /*!< USBD_T::EPSTS: EPSTS3 Position            */
N#define USBD_EPSTS_EPSTS3_Msk            (0x7ul << USBD_EPSTS_EPSTS3_Pos)                  /*!< USBD_T::EPSTS: EPSTS3 Mask                */
N
N#define USBD_EPSTS_EPSTS4_Pos            (20)                                              /*!< USBD_T::EPSTS: EPSTS4 Position            */
N#define USBD_EPSTS_EPSTS4_Msk            (0x7ul << USBD_EPSTS_EPSTS4_Pos)                  /*!< USBD_T::EPSTS: EPSTS4 Mask                */
N
N#define USBD_EPSTS_EPSTS5_Pos            (23)                                              /*!< USBD_T::EPSTS: EPSTS5 Position            */
N#define USBD_EPSTS_EPSTS5_Msk            (0x7ul << USBD_EPSTS_EPSTS5_Pos)                  /*!< USBD_T::EPSTS: EPSTS5 Mask                */
N
N#define USBD_EPSTS_EPSTS6_Pos            (26)                                              /*!< USBD_T::EPSTS: EPSTS6 Position            */
N#define USBD_EPSTS_EPSTS6_Msk            (0x7ul << USBD_EPSTS_EPSTS6_Pos)                  /*!< USBD_T::EPSTS: EPSTS6 Mask                */
N
N#define USBD_EPSTS_EPSTS7_Pos            (29)                                              /*!< USBD_T::EPSTS: EPSTS7 Position            */
N#define USBD_EPSTS_EPSTS7_Msk            (0x7ul << USBD_EPSTS_EPSTS7_Pos)                  /*!< USBD_T::EPSTS: EPSTS7 Mask                */
N
N#define USBD_ATTR_USBRST_Pos             (0)                                               /*!< USBD_T::ATTR: USBRST Position             */
N#define USBD_ATTR_USBRST_Msk             (0x1ul << USBD_ATTR_USBRST_Pos)                   /*!< USBD_T::ATTR: USBRST Mask                 */
N
N#define USBD_ATTR_SUSPEND_Pos            (1)                                               /*!< USBD_T::ATTR: SUSPEND Position            */
N#define USBD_ATTR_SUSPEND_Msk            (0x1ul << USBD_ATTR_SUSPEND_Pos)                  /*!< USBD_T::ATTR: SUSPEND Mask                */
N
N#define USBD_ATTR_RESUME_Pos             (2)                                               /*!< USBD_T::ATTR: RESUME Position             */
N#define USBD_ATTR_RESUME_Msk             (0x1ul << USBD_ATTR_RESUME_Pos)                   /*!< USBD_T::ATTR: RESUME Mask                 */
N
N#define USBD_ATTR_TOUT_Pos               (3)                                               /*!< USBD_T::ATTR: TOUT Position               */
N#define USBD_ATTR_TOUT_Msk               (0x1ul << USBD_ATTR_TOUT_Pos)                     /*!< USBD_T::ATTR: TOUT Mask                   */
N
N#define USBD_ATTR_PHYEN_Pos              (4)                                               /*!< USBD_T::ATTR: PHYEN Position              */
N#define USBD_ATTR_PHYEN_Msk              (0x1ul << USBD_ATTR_PHYEN_Pos)                    /*!< USBD_T::ATTR: PHYEN Mask                  */
N
N#define USBD_ATTR_RWAKEUP_Pos            (5)                                               /*!< USBD_T::ATTR: RWAKEUP Position            */
N#define USBD_ATTR_RWAKEUP_Msk            (0x1ul << USBD_ATTR_RWAKEUP_Pos)                  /*!< USBD_T::ATTR: RWAKEUP Mask                */
N
N#define USBD_ATTR_USBEN_Pos              (7)                                               /*!< USBD_T::ATTR: USBEN Position              */
N#define USBD_ATTR_USBEN_Msk              (0x1ul << USBD_ATTR_USBEN_Pos)                    /*!< USBD_T::ATTR: USBEN Mask                  */
N
N#define USBD_ATTR_DPPUEN_Pos             (8)                                               /*!< USBD_T::ATTR: DPPUEN Position             */
N#define USBD_ATTR_DPPUEN_Msk             (0x1ul << USBD_ATTR_DPPUEN_Pos)                   /*!< USBD_T::ATTR: DPPUEN Mask                 */
N
N#define USBD_ATTR_PWRDN_Pos              (9)                                               /*!< USBD_T::ATTR: PWRDN Position              */
N#define USBD_ATTR_PWRDN_Msk              (0x1ul << USBD_ATTR_PWRDN_Pos)                    /*!< USBD_T::ATTR: PWRDN Mask                  */
N
N#define USBD_ATTR_BYTEM_Pos              (10)                                              /*!< USBD_T::ATTR: BYTEM Position              */
N#define USBD_ATTR_BYTEM_Msk              (0x1ul << USBD_ATTR_BYTEM_Pos)                    /*!< USBD_T::ATTR: BYTEM Mask                  */
N
N#define USBD_VBUSDET_VBUSDET_Pos         (0)                                               /*!< USBD_T::VBUSDET: VBUSDET Position         */
N#define USBD_VBUSDET_VBUSDET_Msk         (0x1ul << USBD_VBUSDET_VBUSDET_Pos)               /*!< USBD_T::VBUSDET: VBUSDET Mask             */
N
N#define USBD_STBUFSEG_STBUFSEG_Pos       (3)                                               /*!< USBD_T::STBUFSEG: STBUFSEG Position       */
N#define USBD_STBUFSEG_STBUFSEG_Msk       (0x3ful << USBD_STBUFSEG_STBUFSEG_Pos)            /*!< USBD_T::STBUFSEG: STBUFSEG Mask           */
N
N#define USBD_SE0_SE0_Pos                 (0)                                               /*!< USBD_T::SE0: SE0 Position                 */
N#define USBD_SE0_SE0_Msk                 (0x1ul << USBD_SE0_SE0_Pos)                       /*!< USBD_T::SE0: SE0 Mask                     */
N
N#define USBD_BUFSEG_BUFSEG_Pos           (3)                                               /*!< USBD_EP_T::BUFSEG: BUFSEG Position          */
N#define USBD_BUFSEG_BUFSEG_Msk           (0x3ful << USBD_BUFSEG_BUFSEG_Pos)                /*!< USBD_EP_T::BUFSEG: BUFSEG Mask              */
N
N#define USBD_MXPLD_MXPLD_Pos             (0)                                               /*!< USBD_EP_T::MXPLD: MXPLD Position            */
N#define USBD_MXPLD_MXPLD_Msk             (0x1fful << USBD_MXPLD_MXPLD_Pos)                 /*!< USBD_EP_T::MXPLD: MXPLD Mask                */
N
N#define USBD_CFG_EPNUM_Pos               (0)                                               /*!< USBD_EP_T::CFG: EPNUM Position              */
N#define USBD_CFG_EPNUM_Msk               (0xful << USBD_CFG_EPNUM_Pos)                     /*!< USBD_EP_T::CFG: EPNUM Mask                  */
N
N#define USBD_CFG_ISOCH_Pos               (4)                                               /*!< USBD_EP_T::CFG: ISOCH Position              */
N#define USBD_CFG_ISOCH_Msk               (0x1ul << USBD_CFG_ISOCH_Pos)                     /*!< USBD_EP_T::CFG: ISOCH Mask                  */
N
N#define USBD_CFG_STATE_Pos               (5)                                               /*!< USBD_EP_T::CFG: STATE Position              */
N#define USBD_CFG_STATE_Msk               (0x3ul << USBD_CFG_STATE_Pos)                     /*!< USBD_EP_T::CFG: STATE Mask                  */
N
N#define USBD_CFG_DSQSYNC_Pos             (7)                                               /*!< USBD_EP_T::CFG: DSQSYNC Position            */
N#define USBD_CFG_DSQSYNC_Msk             (0x1ul << USBD_CFG_DSQSYNC_Pos)                   /*!< USBD_EP_T::CFG: DSQSYNC Mask                */
N
N#define USBD_CFG_CSTALL_Pos              (9)                                               /*!< USBD_EP_T::CFG: CSTALL Position             */
N#define USBD_CFG_CSTALL_Msk              (0x1ul << USBD_CFG_CSTALL_Pos)                    /*!< USBD_EP_T::CFG: CSTALL Mask                 */
N
N#define USBD_CFGP_CLRRDY_Pos             (0)                                               /*!< USBD_EP_T::CFGP: CLRRDY Position            */
N#define USBD_CFGP_CLRRDY_Msk             (0x1ul << USBD_CFGP_CLRRDY_Pos)                   /*!< USBD_EP_T::CFGP: CLRRDY Mask                */
N
N#define USBD_CFGP_SSTALL_Pos             (1)                                               /*!< USBD_EP_T::CFGP: SSTALL Position            */
N#define USBD_CFGP_SSTALL_Msk             (0x1ul << USBD_CFGP_SSTALL_Pos)                   /*!< USBD_EP_T::CFGP: SSTALL Mask                */
N
N/**@}*/ /* USB_CONST */
N/**@}*/ /* end of USB register group */
N
N
N/*---------------------- USB Host Controller -------------------------*/
N/**
N    @addtogroup USBH USB Host Controller(USBH)
N    Memory Mapped Structure for USBH Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N
N
N/**
N * @var USBH_T::HcRevision
N * Offset: 0x00  Host Controller Revision Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |REV       |Revision Number
N * |        |          |Indicates the Open HCI Specification revision number implemented by the Hardware.
N * |        |          |Host Controller supports 1.1 specification.
N * |        |          |(X.Y = XYh).
N * @var USBH_T::HcControl
N * Offset: 0x04  Host Controller Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |CBSR      |Control Bulk Service Ratio
N * |        |          |This specifies the service ratio between Control and Bulk EDs.
N * |        |          |Before processing any of the non-periodic lists, HC must compare the ratio specified with its internal count on how many nonempty Control EDs have been processed, in determining whether to continue serving another Control ED or switching to Bulk EDs.
N * |        |          |The internal count will be retained when crossing the frame boundary.
N * |        |          |In case of reset, HCD is responsible for restoring this.
N * |        |          |Value.
N * |        |          |00 = Number of Control EDs over Bulk EDs served is 1:1.
N * |        |          |01 = Number of Control EDs over Bulk EDs served is 2:1.
N * |        |          |10 = Number of Control EDs over Bulk EDs served is 3:1.
N * |        |          |11 = Number of Control EDs over Bulk EDs served is 4:1.
N * |[2]     |PLE       |Periodic List Enable Bit
N * |        |          |When set, this bit enables processing of the Periodic (interrupt and Isochronous) list.
N * |        |          |The Host Controller checks this bit prior to attempting any periodic transfers in a frame.
N * |        |          |0 = Disable the processing of the Periodic (Interrupt and Isochronous) list after next SOF (Start-Of-Frame).
N * |        |          |1 = Enable the processing of the Periodic (Interrupt and Isochronous) list in the next frame.
N * |        |          |Note: To enable the processing of the Isochronous list, user has to set both PLE and IE (HcControl[3]) high.
N * |[3]     |IE        |Isochronous List Enable Bit
N * |        |          |Both ISOEn and PLE (HcControl[2]) high enables Host Controller to process the Isochronous list.
N * |        |          |Either ISOEn or PLE (HcControl[2]) is low disables Host Controller to process the Isochronous list.
N * |        |          |0 = Disable the processing of the Isochronous list after next SOF (Start-Of-Frame).
N * |        |          |1 = Enable the processing of the Isochronous list in the next frame if the PLE (HcControl[2]) is high, too.
N * |[4]     |CLE       |Control List Enable Bit
N * |        |          |0 = Disable processing of the Control list after next SOF (Start-Of-Frame).
N * |        |          |1 = Enable processing of the Control list in the next frame.
N * |[5]     |BLE       |Bulk List Enable Bit
N * |        |          |0 = Disable processing of the Bulk list after next SOF (Start-Of-Frame).
N * |        |          |1 = Enable processing of the Bulk list in the next frame.
N * |[7:6]   |HCFS      |Host Controller Functional State
N * |        |          |This field sets the Host Controller state.
N * |        |          |The Controller may force a state change from USBSUSPEND to USBRESUME after detecting resume signaling from a downstream port.
N * |        |          |States are:
N * |        |          |00 = USBSUSPEND.
N * |        |          |01 = USBRESUME.
N * |        |          |10 = USBOPERATIONAL.
N * |        |          |11 = USBRESET.
N * @var USBH_T::HcCommandStatus
N * Offset: 0x08  Host Controller CMD Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |HCR       |Host Controller Reset
N * |        |          |This bit is set to initiate the software reset of Host Controller.
N * |        |          |This bit is cleared by the Host Controller, upon completed of the reset operation.
N * |        |          |This bit, when set, didn't reset the Root Hub and no subsequent reset signaling be asserted to its downstream ports.
N * |        |          |0 = Host Controller is not in software reset state.
N * |        |          |1 = Host Controller is in software reset state.
N * |[1]     |CLF       |Control List Filled
N * |        |          |Set high to indicate there is an active TD on the Control List.
N * |        |          |It may be set by either software or the Host Controller and cleared by the Host Controller each time it begins processing the head of the Control List.
N * |        |          |0 = No active TD found or Host Controller begins to process the head of the Control list.
N * |        |          |1 = An active TD added or found on the Control list.
N * |[2]     |BLF       |Bulk List Filled
N * |        |          |Set high to indicate there is an active TD on the Bulk list.
N * |        |          |This bit may be set by either software or the Host Controller and cleared by the Host Controller each time it begins processing the head of the Bulk list.
N * |        |          |0 = No active TD found or Host Controller begins to process the head of the Bulk list.
N * |        |          |1 = An active TD added or found on the Bulk list.
N * |[17:16] |SOC       |Schedule Overrun Count
N * |        |          |These bits are incremented on each scheduling overrun error.
N * |        |          |It is initialized to 00b and wraps around at 11b.
N * |        |          |This will be incremented when a scheduling overrun is detected even if SO (HcIntSts[0]) has already been set.
N * @var USBH_T::HcInterruptStatus
N * Offset: 0x0C  Host Controller Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |SO        |Scheduling Overrun
N * |        |          |Set when the List Processor determines a Schedule Overrun has occurred.
N * |        |          |0 = Schedule Overrun didn't occur.
N * |        |          |1 = Schedule Overrun has occurred.
N * |[1]     |WDH       |Write Back Done Head
N * |        |          |Set after the Host Controller has written HcDoneHead to HccaDoneHead.
N * |        |          |Further updates of the HccaDoneHead will not occur until this bit has been cleared.
N * |        |          |0 =.Host Controller didn't update HccaDoneHead.
N * |        |          |1 =.Host Controller has written HcDoneHead to HccaDoneHead.
N * |[2]     |SF        |Start Of Frame
N * |        |          |Set when the Frame Management functional block signals a 'Start of Frame' event.
N * |        |          |Host Control generates a SOF token at the same time.
N * |        |          |0 =.Not the start of a frame.
N * |        |          |1 =.Indicate the start of a frame and Host Controller generates a SOF token.
N * |[3]     |RD        |Resume Detected
N * |        |          |Set when Host Controller detects resume signaling on a downstream port.
N * |        |          |0 = No resume signaling detected on a downstream port.
N * |        |          |1 = Resume signaling detected on a downstream port.
N * |[5]     |FNO       |Frame Number Overflow
N * |        |          |This bit is set when bit 15 of Frame Number changes from 1 to 0 or from 0 to 1.
N * |        |          |0 = The bit 15 of Frame Number didn't change.
N * |        |          |1 = The bit 15 of Frame Number changes from 1 to 0 or from 0 to 1.
N * |[6]     |RHSC      |Root Hub Status Change
N * |        |          |This bit is set when the content of HcRhSts or the content of HcRhPrt1 register has changed.
N * |        |          |0 = The content of HcRhSts and the content of HcRhPrt1 register didn't change.
N * |        |          |1 = The content of HcRhSts or the content of HcRhPrt1 register has changed.
N * @var USBH_T::HcInterruptEnable
N * Offset: 0x10  Host Controller Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |SO        |Scheduling Overrun Enable Bit
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Enable interrupt generation due to SO (HcIntSts[0]).
N * |        |          |Read Operation:
N * |        |          |0 = Interrupt generation due to SO (HcIntSts[0]) disabled.
N * |        |          |1 = Interrupt generation due to SO (HcIntSts[0]) enabled.
N * |[1]     |WDH       |Write Back Done Head Enable Bit
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Enable interrupt generation due to WDH (HcIntSts[1]).
N * |        |          |Read Operation:
N * |        |          |0 = Interrupt generation due to WDH (HcIntSts[1]) disabled.
N * |        |          |1 = Interrupt generation due to WDH (HcIntSts[1]) enabled.
N * |[2]     |SF        |Start Of Frame Enable Bit
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Enable interrupt generation due to SF (HcIntSts[2]).
N * |        |          |Read Operation:
N * |        |          |0 = Interrupt generation due to SF (HcIntSts[2]) disabled.
N * |        |          |1 = Interrupt generation due to SF (HcIntSts[2]) enabled.
N * |[3]     |RD        |Resume Detected Enable Bit
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Enable interrupt generation due to RD (HcIntSts[3]).
N * |        |          |Read Operation:
N * |        |          |0 = Interrupt generation due to RD (HcIntSts[3]) disabled.
N * |        |          |1 = Interrupt generation due to RD (HcIntSts[3]) enabled.
N * |[5]     |FNO       |Frame Number Overflow Enable Bit
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Enable interrupt generation due to FNO (HcIntSts[5]).
N * |        |          |Read Operation:
N * |        |          |0 = Interrupt generation due to FNO (HcIntSts[5]) disabled.
N * |        |          |1 = Interrupt generation due to FNO (HcIntSts[5]) enabled.
N * |[6]     |RHSC      |Root Hub Status Change Enable Bit
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Enable interrupt generation due to RHSC (HcIntSts[6]).
N * |        |          |Read Operation:
N * |        |          |0 = Interrupt generation due to RHSC (HcIntSts[6]) disabled.
N * |        |          |1 = Interrupt generation due to RHSC (HcIntSts[6]) enabled.
N * |[31]    |MIE       |Master Interrupt Enable Bit
N * |        |          |This bit is a global interrupt enable.
N * |        |          |A write of '1' allows interrupts to be enabled via the specific enable bits listed above.
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Enable interrupt generation due to RHSC (HcIntSts[6]), FNO (HcIntSts[5]), RD (HcIntSts[3]), SF (HcIntSts[2]), WDH (HcIntSts[1]) or SO (HcIntSts[0]) if the corresponding bit in HcIntEn is high.
N * |        |          |Read Operation:
N * |        |          |0 = Interrupt generation due to RHSC (HcIntSts[6]), FNO (HcIntSts[5]), RD (HcIntSts[3]), SF (HcIntSts[2]), WDH (HcIntSts[1]) or SO (HcIntSts[0]) disabled even if the corresponding bit in HcIntEn is high.
N * |        |          |1 = Interrupt generation due to RHSC (HcIntSts[6]), FNO (HcIntSts[5]), RD (HcIntSts[3]), SF (HcIntSts[2]), WDH (HcIntSts[1]) or SO (HcIntSts[0]) enabled if the corresponding bit in HcIntEn is high.
N * @var USBH_T::HcInterruptDisable
N * Offset: 0x14  Host Controller Interrupt Disable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |SO        |Scheduling Overrun Disable Bit
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Disable interrupt generation due to SO (HcIntSts[0]).
N * |        |          |Read Operation:
N * |        |          |0 = Interrupt generation due to SO (HcIntSts[0]) disabled.
N * |        |          |1 = Interrupt generation due to SO (HcIntSts[0]) enabled.
N * |[1]     |WDH       |Write Back Done Head Disable Bit
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Disable interrupt generation due to WDH (HcIntSts[1]).
N * |        |          |Read Operation:
N * |        |          |0 = Interrupt generation due to WDH (HcIntSts[1]) disabled.
N * |        |          |1 = Interrupt generation due to WDH (HcIntSts[1]) enabled.
N * |[2]     |SF        |Start Of Frame Disable Bit
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Disable interrupt generation due to SF (HcIntSts[2]).
N * |        |          |Read Operation:
N * |        |          |0 = Interrupt generation due to SF (HcIntSts[2]) disabled.
N * |        |          |1 = Interrupt generation due to SF (HcIntSts[2]) enabled.
N * |[3]     |RD        |Resume Detected Disable Bit
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Disable interrupt generation due to RD (HcIntSts[3]).
N * |        |          |Read Operation:
N * |        |          |0 = Interrupt generation due to RD (HcIntSts[3]) disabled.
N * |        |          |1 = Interrupt generation due to RD (HcIntSts[3]) enabled.
N * |[5]     |FNO       |Frame Number Overflow Disable Bit
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Disable interrupt generation due to FNO (HcIntSts[5]).
N * |        |          |Read Operation:
N * |        |          |0 = Interrupt generation due to FNO (HcIntSts[5]) disabled.
N * |        |          |1 = Interrupt generation due to FNO (HcIntSts[5]) enabled.
N * |[6]     |RHSC      |Root Hub Status Change Disable Bit
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Disable interrupt generation due to RHSC (HcIntSts[6]).
N * |        |          |Read Operation:
N * |        |          |0 = Interrupt generation due to RHSC (HcIntSts[6]) disabled.
N * |        |          |1 = Interrupt generation due to RHSC (HcIntSts[6]) enabled.
N * |[31]    |MIE       |Master Interrupt Disable Bit
N * |        |          |Global interrupt disable. Writing '1' to disable all interrupts.
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Disable interrupt generation due to RHSC (HcIntSts[6]), FNO (HcIntSts[5]), RD (HcIntSts[3]), SF (HcIntSts[2]), WDH (HcIntSts[1]) or SO (HcIntSts[0]) if the corresponding bit in HcIntEn is high.
N * |        |          |Read Operation:
N * |        |          |0 = Interrupt generation due to RHSC (HcIntSts[6]), FNO (HcIntSts[5]), RD (HcIntSts[3]), SF (HcIntSts[2]), WDH (HcIntSts[1]) or SO (HcIntSts[0]) disabled even if the corresponding bit in HcIntEn is high.
N * |        |          |1 = Interrupt generation due to RHSC (HcIntSts[6]), FNO (HcIntSts[5]), RD (HcIntSts[3]), SF (HcIntSts[2]), WDH (HcIntSts[1]) or SO (HcIntSts[0]) enabled if the corresponding bit in HcIntEn is high.
N * @var USBH_T::HcHCCA
N * Offset: 0x18  Host Controller Communication Area Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:8]  |HCCA      |Host Controller Communication Area
N * |        |          |Pointer to indicate base address of the Host Controller Communication Area (HCCA).
N * @var USBH_T::HcPeriodCurrentED
N * Offset: 0x1C  Host Controller Period Current ED Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:4]  |PCED      |Periodic Current ED
N * |        |          |Pointer to indicate physical address of the current Isochronous or Interrupt Endpoint Descriptor.
N * @var USBH_T::HcControlHeadED
N * Offset: 0x20  Host Controller Control Head ED Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:4]  |CHED      |Control Head ED
N * |        |          |Pointer to indicate physical address of the first Endpoint Descriptor of the Control list.
N * @var USBH_T::HcControlCurrentED
N * Offset: 0x24  Host Controller Control Current ED Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:4]  |CCED      |Control Current Head ED
N * |        |          |Pointer to indicate the physical address of the current Endpoint Descriptor of the Control list.
N * @var USBH_T::HcBulkHeadED
N * Offset: 0x28  Host Controller Bulk Head ED Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:4]  |BHED      |Bulk Head ED
N * |        |          |Pointer to indicate the physical address of the first Endpoint Descriptor of the Bulk list.
N * @var USBH_T::HcBulkCurrentED
N * Offset: 0x2C  Host Controller Bulk Current ED Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:4]  |BCED      |Bulk Current Head ED
N * |        |          |Pointer to indicate the physical address of the current endpoint of the Bulk list.
N * @var USBH_T::HcDoneHead
N * Offset: 0x30  Host Controller Done Head Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:4]  |DH        |Done Head
N * |        |          |Pointer to indicate the physical address of the last completed Transfer Descriptor that was added to the Done queue.
N * @var USBH_T::HcFmInterval
N * Offset: 0x34  Host Controller Frame Interval Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[13:0]  |FI        |Frame Interval
N * |        |          |This field specifies the length of a frame as (bit times - 1).
N * |        |          |For 12,000 bit times in a frame, a value of 11,999 is stored here.
N * |[30:16] |FSMPS     |FS Largest Data Packet
N * |        |          |This field specifies a value that is loaded into the Largest Data Packet Counter at the beginning of each frame.
N * |[31]    |FIT       |Frame Interval Toggle
N * |        |          |This bit is toggled by Host Controller Driver when it loads a new value into FI (HcFmIntv[13:0]).
N * |        |          |0 = Host Controller Driver didn't load new value into FI (HcFmIntv[13:0]).
N * |        |          |1 = Host Controller Driver loads a new value into FI (HcFmIntv[13:0]).
N * @var USBH_T::HcFmRemaining
N * Offset: 0x38  Host Controller Frame Remaining Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[13:0]  |FR        |Frame Remaining
N * |        |          |When the Host Controller is in the USBOPERATIONAL state, this 14-bit field decrements each 12 MHz clock period.
N * |        |          |When the count reaches 0, (end of frame) the counter reloads with Frame Interval.
N * |        |          |In addition, the counter loads when the Host Controller transitions into USBOPERATIONAL.
N * |[31]    |FRT       |Frame Remaining Toggle
N * |        |          |This bit is loaded from the FIT (HcFmIntv[31]) whenever FR (HcFmRem[13:0]) reaches 0.
N * @var USBH_T::HcFmNumber
N * Offset: 0x3C  Host Controller Frame Number Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |FN        |Frame Number
N * |        |          |This 16-bit incrementing counter field is incremented coincident with the re-load of FR (HcFmRem[13:0]).
N * |        |          |The count rolls over from 'FFFFh' to '0h.'.
N * @var USBH_T::HcPeriodicStart
N * Offset: 0x40  Host Controller Periodic Start Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[13:0]  |PS        |Periodic Start
N * |        |          |This field contains a value used by the List Processor to determine where in a frame the Periodic List processing must begin.
N * @var USBH_T::HcLSThreshold
N * Offset: 0x44  Host Controller Low-speed Threshold Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |LST       |Low-Speed Threshold
N * |        |          |This field contains a value which is compared to the FR (HcFmRem[13:0]) field prior to initiating a Low-speed transaction.
N * |        |          |The transaction is started only if FR (HcFmRem[13:0]) >= this field.
N * |        |          |The value is calculated by Host Controller Driver with the consideration of transmission and setup overhead.
N * @var USBH_T::HcRhDescriptorA
N * Offset: 0x48  Host Controller Root Hub Descriptor A Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |NDP       |Number Downstream Ports
N * |        |          |USB host control supports two downstream ports and only one port is available in this series of chip.
N * |[8]     |PSM       |Power Switching Mode
N * |        |          |This bit is used to specify how the power switching of the Root Hub ports is controlled.
N * |        |          |0 = Global Switching.
N * |        |          |1 = Individual Switching.
N * |[11]    |OCPM      |Over Current Protection Mode
N * |        |          |This bit describes how the over current status for the Root Hub ports reported.
N * |        |          |This bit is only valid when NOCP (HcRhDeA[12]) is cleared.
N * |        |          |0 = Global Over current.
N * |        |          |1 = Individual Over current.
N * |[12]    |NOCP      |No Over Current Protection
N * |        |          |This bit describes how the over current status for the Root Hub ports reported.
N * |        |          |0 = Over current status is reported.
N * |        |          |1 = Over current status is not reported.
N * @var USBH_T::HcRhDescriptorB
N * Offset: 0x4C  Host Controller Root Hub Descriptor B Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:16] |PPCM      |Port Power Control Mask
N * |        |          |Global power switching.
N * |        |          |This field is only valid if PowerSwitchingMode is set (individual port switching).
N * |        |          |When set, the port only responds to individual port power switching commands (Set/ClearPortPower).
N * |        |          |When cleared, the port only responds to global power switching commands (Set/ClearGlobalPower).
N * |        |          |0 = Port power controlled by global power switching.
N * |        |          |1 = Port power controlled by port power switching.
N * |        |          |Note: PPCM[15:2] and PPCM[0] are reserved.
N * @var USBH_T::HcRhStatus
N * Offset: 0x50  Host Controller Root Hub Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |LPS       |Clear Global Power
N * |        |          |In global power mode (PSM (HcRhDeA[8]) = 0), this bit is written to one to clear all ports' power.
N * |        |          |This bit always read as zero.
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Clear global power.
N * |[1]     |OCI       |Over Current Indicator
N * |        |          |This bit reflects the state of the over current status pin.
N * |        |          |This field is only valid if NOCP (HcRhDesA[12]) and OCPM (HcRhDesA[11]) are cleared.
N * |        |          |0 = No over current condition.
N * |        |          |1 = Over current condition.
N * |[15]    |DRWE      |Device Remote Wakeup Enable Bit
N * |        |          |This bit controls if port's Connect Status Change as a remote wake-up event.
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Enable Connect Status Change as a remote wake-up event.
N * |        |          |Read Operation:
N * |        |          |0 = Connect Status Change as a remote wake-up event disabled.
N * |        |          |1 = Connect Status Change as a remote wake-up event enabled.
N * |[16]    |LPSC      |Set Global Power
N * |        |          |In global power mode (PSM (HcRhDeA[8]) = 0), this bit is written to one to enable power to all ports.
N * |        |          |This bit always read as zero.
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Set global power.
N * |[17]    |OCIC      |Over Current Indicator Change
N * |        |          |This bit is set by hardware when a change has occurred in OCI (HcRhSts[1]).
N * |        |          |Write 1 to clear this bit to zero.
N * |        |          |0 = OCI (HcRhSts[1]) didn't change.
N * |        |          |1 = OCI (HcRhSts[1]) change.
N * |[31]    |CRWE      |Clear Remote Wake-up Enable Bit
N * |        |          |This bit is use to clear DRWE (HcRhSts[15]).
N * |        |          |This bit always read as zero.
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Clear DRWE (HcRhSts[15]).
N * @var USBH_T::HcRhPortStatus
N * Offset: 0x54  Host Controller Root Hub Port Status [1]
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CCS       |CurrentConnectStatus (Read) Or ClearPortEnable Bit (Write)
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Clear port enable.
N * |        |          |Read Operation:
N * |        |          |0 = No device connected.
N * |        |          |1 = Device connected.
N * |[1]     |PES       |Port Enable Status
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Set port enable.
N * |        |          |Read Operation:
N * |        |          |0 = Port Disabled.
N * |        |          |1 = Port Enabled.
N * |[2]     |PSS       |Port Suspend Status
N * |        |          |This bit indicates the port is suspended
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Set port suspend.
N * |        |          |Read Operation:
N * |        |          |0 = Port is not suspended.
N * |        |          |1 = Port is selectively suspended.
N * |[3]     |POCI      |Port Over Current Indicator (Read) Or Clear Port Suspend (Write)
N * |        |          |This bit reflects the state of the over current status pin dedicated to this port.
N * |        |          |This field is only valid if NOCP (HcRhDeA[12]) is cleared and OCPM (HcRhDeA[11]) is set.
N * |        |          |This bit is also used to initiate the selective result sequence for the port.
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Clear port suspend.
N * |        |          |Read Operation:
N * |        |          |0 = No over current condition.
N * |        |          |1 = Over current condition.
N * |[4]     |PRS       |Port Reset Status
N * |        |          |This bit reflects the reset state of the port.
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Set port reset.
N * |        |          |Read Operation
N * |        |          |0 = Port reset signal is not active.
N * |        |          |1 = Port reset signal is active.
N * |[8]     |PPS       |Port Power Status
N * |        |          |This bit reflects the power state of the port regardless of the power switching mode.
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Port Power Enabled.
N * |        |          |Read Operation:
N * |        |          |0 = Port power is Disabled.
N * |        |          |1 = Port power is Enabled.
N * |[9]     |LSDA      |Low Speed Device Attached (Read) Or Clear Port Power (Write)
N * |        |          |This bit defines the speed (and bud idle) of the attached device.
N * |        |          |It is only valid when CCS (HcRhPrt1[0]) is set.
N * |        |          |This bit is also used to clear port power.
N * |        |          |Write Operation:
N * |        |          |0 = No effect.
N * |        |          |1 = Clear PPS (HcRhPrt1[8]).
N * |        |          |Read Operation:
N * |        |          |0 = Full Speed device.
N * |        |          |1 = Low-speed device.
N * |[16]    |CSC       |Connect Status Change
N * |        |          |This bit indicates connect or disconnect event has been detected (CCS
N * |        |          |(HcRhPrt1[0]) changed).
N * |        |          |Write 1 to clear this bit to zero.
N * |        |          |0 = No connect/disconnect event (CCS (HcRhPrt1[0]) didn't change).
N * |        |          |1 = Hardware detection of connect/disconnect event (CCS
N * |        |          |(HcRhPrt1[0]) changed).
N * |[17]    |PESC      |Port Enable Status Change
N * |        |          |This bit indicates that the port has been disabled (PES (HcRhPrt1[1]) cleared) due to a hardware event.
N * |        |          |Write 1 to clear this bit to zero.
N * |        |          |0 = PES (HcRhPrt1[1]) didn't change.
N * |        |          |1 = PES (HcRhPrt1[1]) changed.
N * |[18]    |PSSC      |Port Suspend Status Change
N * |        |          |This bit indicates the completion of the selective resume sequence for the port.
N * |        |          |Write 1 to clear this bit to zero.
N * |        |          |0 = Port resume is not completed.
N * |        |          |1 = Port resume completed.
N * |[19]    |OCIC      |Port Over Current Indicator Change
N * |        |          |This bit is set when POCI (HcRhPrt1[3]) changes.
N * |        |          |Write 1 to clear this bit to zero.
N * |        |          |0 = POCI (HcRhPrt1[3]) didn't change.
N * |        |          |1 = POCI (HcRhPrt1[3]) changes.
N * |[20]    |PRSC      |Port Reset Status Change
N * |        |          |This bit indicates that the port reset signal has completed.
N * |        |          |Write 1 to clear this bit to zero.
N * |        |          |0 = Port reset is not complete.
N * |        |          |1 = Port reset is complete.
N * @var USBH_T::HcPhyControl
N * Offset: 0x200  USB Host Controller PHY Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[27]    |STBYEN    |USB Transceiver Standby Enable Bit
N * |        |          |This bit controls if USB transceiver could enter the standby mode to reduce power consumption.
N * |        |          |0 = The USB transceiver would never enter the standby mode.
N * |        |          |1 = The USB transceiver will enter standby mode while port is in power off state (port power is inactive).
N * @var USBH_T::HcMiscControl
N * Offset: 0x204  USB Host Controller Miscellaneous Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1]     |ABORT     |AHB Bus ERROR Response
N * |        |          |This bit indicates there is an ERROR response received in AHB bus.
N * |        |          |0 = No ERROR response received.
N * |        |          |1 = ERROR response received.
N * |[3]     |OCAL      |Over Current Active Low
N * |        |          |This bit controls the polarity of over current flag from external power IC.
N * |        |          |0 = Over current flag is high active.
N * |        |          |1 = Over current flag is low active.
N * |[16]    |DPRT1     |Disable Port 1
N * |        |          |This bit controls if the connection between USB host controller and transceiver of port 1 is disabled.
N * |        |          |If the connection is disabled, the USB host controller will not recognize any event of USB bus.
N * |        |          |Set this bit high, the transceiver of port 1 will also be forced into the standby mode no matter what USB host controller operation is.
N * |        |          |0 = The connection between USB host controller and transceiver of port 1 is enabled.
N * |        |          |1 = The connection between USB host controller and transceiver of port 1 is disabled and the transceiver of port 1 will also be forced into the standby mode.
N    */
N
N    __I  uint32_t HcRevision;    /* Offset: 0x00  Host Controller Revision Register                                  */
X    volatile const  uint32_t HcRevision;     
N    __IO uint32_t HcControl;     /* Offset: 0x04  Host Controller Control Register                                   */
X    volatile uint32_t HcControl;      
N    __IO uint32_t HcCommandStatus; /* Offset: 0x08  Host Controller CMD Status Register                                */
X    volatile uint32_t HcCommandStatus;  
N    __IO uint32_t HcInterruptStatus; /* Offset: 0x0C  Host Controller Interrupt Status Register                          */
X    volatile uint32_t HcInterruptStatus;  
N    __IO uint32_t HcInterruptEnable; /* Offset: 0x10  Host Controller Interrupt Enable Register                          */
X    volatile uint32_t HcInterruptEnable;  
N    __IO uint32_t HcInterruptDisable; /* Offset: 0x14  Host Controller Interrupt Disable Register                         */
X    volatile uint32_t HcInterruptDisable;  
N    __IO uint32_t HcHCCA;        /* Offset: 0x18  Host Controller Communication Area Register                        */
X    volatile uint32_t HcHCCA;         
N    __IO uint32_t HcPeriodCurrentED; /* Offset: 0x1C  Host Controller Period Current ED Register                         */
X    volatile uint32_t HcPeriodCurrentED;  
N    __IO uint32_t HcControlHeadED; /* Offset: 0x20  Host Controller Control Head ED Register                           */
X    volatile uint32_t HcControlHeadED;  
N    __IO uint32_t HcControlCurrentED; /* Offset: 0x24  Host Controller Control Current ED Register                        */
X    volatile uint32_t HcControlCurrentED;  
N    __IO uint32_t HcBulkHeadED;  /* Offset: 0x28  Host Controller Bulk Head ED Register                              */
X    volatile uint32_t HcBulkHeadED;   
N    __IO uint32_t HcBulkCurrentED; /* Offset: 0x2C  Host Controller Bulk Current ED Register                           */
X    volatile uint32_t HcBulkCurrentED;  
N    __IO uint32_t HcDoneHead;    /* Offset: 0x30  Host Controller Done Head Register                                 */
X    volatile uint32_t HcDoneHead;     
N    __IO uint32_t HcFmInterval;  /* Offset: 0x34  Host Controller Frame Interval Register                            */
X    volatile uint32_t HcFmInterval;   
N    __I  uint32_t HcFmRemaining; /* Offset: 0x38  Host Controller Frame Remaining Register                           */
X    volatile const  uint32_t HcFmRemaining;  
N    __I  uint32_t HcFmNumber;    /* Offset: 0x3C  Host Controller Frame Number Register                              */
X    volatile const  uint32_t HcFmNumber;     
N    __IO uint32_t HcPeriodicStart; /* Offset: 0x40  Host Controller Periodic Start Register                            */
X    volatile uint32_t HcPeriodicStart;  
N    __IO uint32_t HcLSThreshold; /* Offset: 0x44  Host Controller Low-speed Threshold Register                       */
X    volatile uint32_t HcLSThreshold;  
N    __IO uint32_t HcRhDescriptorA; /* Offset: 0x48  Host Controller Root Hub Descriptor A Register                     */
X    volatile uint32_t HcRhDescriptorA;  
N    __IO uint32_t HcRhDescriptorB; /* Offset: 0x4C  Host Controller Root Hub Descriptor B Register                     */
X    volatile uint32_t HcRhDescriptorB;  
N    __IO uint32_t HcRhStatus;    /* Offset: 0x50  Host Controller Root Hub Status Register                           */
X    volatile uint32_t HcRhStatus;     
N    __IO uint32_t HcRhPortStatus[2]; /* Offset: 0x54  Host Controller Root Hub Port Status [1]                           */
X    volatile uint32_t HcRhPortStatus[2];  
N    __I  uint32_t RESERVE0[105];
X    volatile const  uint32_t RESERVE0[105];
N    __IO uint32_t HcPhyControl;  /* Offset: 0x200  USB Host Controller PHY Control Register                          */
X    volatile uint32_t HcPhyControl;   
N    __IO uint32_t HcMiscControl; /* Offset: 0x204  USB Host Controller Miscellaneous Control Register                */
X    volatile uint32_t HcMiscControl;  
N
N} USBH_T;
N
N
N
N
N/**
N    @addtogroup USBH_CONST USBH Bit Field Definition
N    Constant Definitions for USBH Controller
N@{ */
N
N#define USBH_HcRevision_REV_Pos          (0)                                               /*!< USBH_T::HcRevision: REV Position          */
N#define USBH_HcRevision_REV_Msk          (0xfful << USBH_HcRevision_REV_Pos)               /*!< USBH_T::HcRevision: REV Mask              */
N
N#define USBH_HcControl_CBSR_Pos          (0)                                               /*!< USBH_T::HcControl: CBSR Position          */
N#define USBH_HcControl_CBSR_Msk          (0x3ul << USBH_HcControl_CBSR_Pos)                /*!< USBH_T::HcControl: CBSR Mask              */
N
N#define USBH_HcControl_PLE_Pos           (2)                                               /*!< USBH_T::HcControl: CBSR Position          */
N#define USBH_HcControl_PLE_Msk           (0x1ul << USBH_HcControl_PLE_Pos)                 /*!< USBH_T::HcControl: CBSR Mask              */
N
N#define USBH_HcControl_IE_Pos            (3)                                               /*!< USBH_T::HcControl: IE Position            */
N#define USBH_HcControl_IE_Msk            (0x1ul << USBH_HcControl_IE_Pos)                  /*!< USBH_T::HcControl: IE Mask                */
N
N#define USBH_HcControl_CLE_Pos           (4)                                               /*!< USBH_T::HcControl: CLE Position           */
N#define USBH_HcControl_CLE_Msk           (0x1ul << USBH_HcControl_CLE_Pos)                 /*!< USBH_T::HcControl: CLE Mask               */
N
N#define USBH_HcControl_BLE_Pos           (5)                                               /*!< USBH_T::HcControl: BLE Position           */
N#define USBH_HcControl_BLE_Msk           (0x1ul << USBH_HcControl_BLE_Pos)                 /*!< USBH_T::HcControl: BLE Mask               */
N
N#define USBH_HcControl_HCFS_Pos          (6)                                               /*!< USBH_T::HcControl: HCFS Position          */
N#define USBH_HcControl_HCFS_Msk          (0x3ul << USBH_HcControl_HCFS_Pos)                /*!< USBH_T::HcControl: HCFS Mask              */
N
N#define USBH_HcCommandStatus_HCR_Pos     (0)                                               /*!< USBH_T::HcCommandStatus: HCR Position     */
N#define USBH_HcCommandStatus_HCR_Msk     (0x1ul << USBH_HcCommandStatus_HCR_Pos)           /*!< USBH_T::HcCommandStatus: HCR Mask         */
N
N#define USBH_HcCommandStatus_CLF_Pos     (1)                                               /*!< USBH_T::HcCommandStatus: CLF Position     */
N#define USBH_HcCommandStatus_CLF_Msk     (0x1ul << USBH_HcCommandStatus_CLF_Pos)           /*!< USBH_T::HcCommandStatus: CLF Mask         */
N
N#define USBH_HcCommandStatus_BLF_Pos     (2)                                               /*!< USBH_T::HcCommandStatus: BLF Position     */
N#define USBH_HcCommandStatus_BLF_Msk     (0x1ul << USBH_HcCommandStatus_BLF_Pos)           /*!< USBH_T::HcCommandStatus: BLF Mask         */
N
N#define USBH_HcCommandStatus_SOC_Pos     (16)                                              /*!< USBH_T::HcCommandStatus: SOC Position     */
N#define USBH_HcCommandStatus_SOC_Msk     (0x3ul << USBH_HcCommandStatus_SOC_Pos)           /*!< USBH_T::HcCommandStatus: SOC Mask         */
N
N#define USBH_HcInterruptStatus_SO_Pos    (0)                                               /*!< USBH_T::HcInterruptStatus: SO Position    */
N#define USBH_HcInterruptStatus_SO_Msk    (0x1ul << USBH_HcInterruptStatus_SO_Pos)          /*!< USBH_T::HcInterruptStatus: SO Mask        */
N
N#define USBH_HcInterruptStatus_WDH_Pos   (1)                                               /*!< USBH_T::HcInterruptStatus: WDH Position   */
N#define USBH_HcInterruptStatus_WDH_Msk   (0x1ul << USBH_HcInterruptStatus_WDH_Pos)         /*!< USBH_T::HcInterruptStatus: WDH Mask       */
N
N#define USBH_HcInterruptStatus_SF_Pos    (2)                                               /*!< USBH_T::HcInterruptStatus: SF Position    */
N#define USBH_HcInterruptStatus_SF_Msk    (0x1ul << USBH_HcInterruptStatus_SF_Pos)          /*!< USBH_T::HcInterruptStatus: SF Mask        */
N
N#define USBH_HcInterruptStatus_RD_Pos    (3)                                               /*!< USBH_T::HcInterruptStatus: RD Position    */
N#define USBH_HcInterruptStatus_RD_Msk    (0x1ul << USBH_HcInterruptStatus_RD_Pos)          /*!< USBH_T::HcInterruptStatus: RD Mask        */
N
N#define USBH_HcInterruptStatus_FNO_Pos   (5)                                               /*!< USBH_T::HcInterruptStatus: FNO Position   */
N#define USBH_HcInterruptStatus_FNO_Msk   (0x1ul << USBH_HcInterruptStatus_FNO_Pos)         /*!< USBH_T::HcInterruptStatus: FNO Mask       */
N
N#define USBH_HcInterruptStatus_RHSC_Pos  (6)                                               /*!< USBH_T::HcInterruptStatus: RHSC Position  */
N#define USBH_HcInterruptStatus_RHSC_Msk  (0x1ul << USBH_HcInterruptStatus_RHSC_Pos)        /*!< USBH_T::HcInterruptStatus: RHSC Mask      */
N
N#define USBH_HcInterruptEnable_SO_Pos    (0)                                               /*!< USBH_T::HcInterruptEnable: SO Position    */
N#define USBH_HcInterruptEnable_SO_Msk    (0x1ul << USBH_HcInterruptEnable_SO_Pos)          /*!< USBH_T::HcInterruptEnable: SO Mask        */
N
N#define USBH_HcInterruptEnable_WDH_Pos   (1)                                               /*!< USBH_T::HcInterruptEnable: WDH Position   */
N#define USBH_HcInterruptEnable_WDH_Msk   (0x1ul << USBH_HcInterruptEnable_WDH_Pos)         /*!< USBH_T::HcInterruptEnable: WDH Mask       */
N
N#define USBH_HcInterruptEnable_SF_Pos    (2)                                               /*!< USBH_T::HcInterruptEnable: SF Position    */
N#define USBH_HcInterruptEnable_SF_Msk    (0x1ul << USBH_HcInterruptEnable_SF_Pos)          /*!< USBH_T::HcInterruptEnable: SF Mask        */
N
N#define USBH_HcInterruptEnable_RD_Pos    (3)                                               /*!< USBH_T::HcInterruptEnable: RD Position    */
N#define USBH_HcInterruptEnable_RD_Msk    (0x1ul << USBH_HcInterruptEnable_RD_Pos)          /*!< USBH_T::HcInterruptEnable: RD Mask        */
N
N#define USBH_HcInterruptEnable_FNO_Pos   (5)                                               /*!< USBH_T::HcInterruptEnable: FNO Position   */
N#define USBH_HcInterruptEnable_FNO_Msk   (0x1ul << USBH_HcInterruptEnable_FNO_Pos)         /*!< USBH_T::HcInterruptEnable: FNO Mask       */
N
N#define USBH_HcInterruptEnable_RHSC_Pos  (6)                                               /*!< USBH_T::HcInterruptEnable: RHSC Position  */
N#define USBH_HcInterruptEnable_RHSC_Msk  (0x1ul << USBH_HcInterruptEnable_RHSC_Pos)        /*!< USBH_T::HcInterruptEnable: RHSC Mask      */
N
N#define USBH_HcInterruptEnable_MIE_Pos   (31)                                              /*!< USBH_T::HcInterruptEnable: MIE Position   */
N#define USBH_HcInterruptEnable_MIE_Msk   (0x1ul << USBH_HcInterruptEnable_MIE_Pos)         /*!< USBH_T::HcInterruptEnable: MIE Mask       */
N
N#define USBH_HcInterruptDisable_SO_Pos   (0)                                               /*!< USBH_T::HcInterruptDisable: SO Position   */
N#define USBH_HcInterruptDisable_SO_Msk   (0x1ul << USBH_HcInterruptDisable_SO_Pos)         /*!< USBH_T::HcInterruptDisable: SO Mask       */
N
N#define USBH_HcInterruptDisable_WDH_Pos  (1)                                               /*!< USBH_T::HcInterruptDisable: WDH Position  */
N#define USBH_HcInterruptDisable_WDH_Msk  (0x1ul << USBH_HcInterruptDisable_WDH_Pos)        /*!< USBH_T::HcInterruptDisable: WDH Mask      */
N
N#define USBH_HcInterruptDisable_SF_Pos   (2)                                               /*!< USBH_T::HcInterruptDisable: SF Position   */
N#define USBH_HcInterruptDisable_SF_Msk   (0x1ul << USBH_HcInterruptDisable_SF_Pos)         /*!< USBH_T::HcInterruptDisable: SF Mask       */
N
N#define USBH_HcInterruptDisable_RD_Pos   (3)                                               /*!< USBH_T::HcInterruptDisable: RD Position   */
N#define USBH_HcInterruptDisable_RD_Msk   (0x1ul << USBH_HcInterruptDisable_RD_Pos)         /*!< USBH_T::HcInterruptDisable: RD Mask       */
N
N#define USBH_HcInterruptDisable_FNO_Pos  (5)                                               /*!< USBH_T::HcInterruptDisable: FNO Position  */
N#define USBH_HcInterruptDisable_FNO_Msk  (0x1ul << USBH_HcInterruptDisable_FNO_Pos)        /*!< USBH_T::HcInterruptDisable: FNO Mask      */
N
N#define USBH_HcInterruptDisable_RHSC_Pos (6)                                               /*!< USBH_T::HcInterruptDisable: RHSC Position */
N#define USBH_HcInterruptDisable_RHSC_Msk (0x1ul << USBH_HcInterruptDisable_RHSC_Pos)       /*!< USBH_T::HcInterruptDisable: RHSC Mask     */
N
N#define USBH_HcInterruptDisable_MIE_Pos  (31)                                              /*!< USBH_T::HcInterruptDisable: MIE Position  */
N#define USBH_HcInterruptDisable_MIE_Msk  (0x1ul << USBH_HcInterruptDisable_MIE_Pos)        /*!< USBH_T::HcInterruptDisable: MIE Mask      */
N
N#define USBH_HcHCCA_HCCA_Pos             (8)                                               /*!< USBH_T::HcHCCA: HCCA Position             */
N#define USBH_HcHCCA_HCCA_Msk             (0xfffffful << USBH_HcHCCA_HCCA_Pos)              /*!< USBH_T::HcHCCA: HCCA Mask                 */
N
N#define USBH_HcPeriodCurrentED_PCED_Pos  (4)                                               /*!< USBH_T::HcPeriodCurrentED: PCED Position  */
N#define USBH_HcPeriodCurrentED_PCED_Msk  (0xffffffful << USBH_HcPeriodCurrentED_PCED_Pos)  /*!< USBH_T::HcPeriodCurrentED: PCED Mask      */
N
N#define USBH_HcControlHeadED_CHED_Pos    (4)                                               /*!< USBH_T::HcControlHeadED: CHED Position    */
N#define USBH_HcControlHeadED_CHED_Msk    (0xffffffful << USBH_HcControlHeadED_CHED_Pos)    /*!< USBH_T::HcControlHeadED: CHED Mask        */
N
N#define USBH_HcControlCurrentED_CCED_Pos (4)                                               /*!< USBH_T::HcControlCurrentED: CCED Position */
N#define USBH_HcControlCurrentED_CCED_Msk (0xffffffful << USBH_HcControlCurrentED_CCED_Pos) /*!< USBH_T::HcControlCurrentED: CCED Mask     */
N
N#define USBH_HcBulkHeadED_BHED_Pos       (4)                                               /*!< USBH_T::HcBulkHeadED: BHED Position       */
N#define USBH_HcBulkHeadED_BHED_Msk       (0xffffffful << USBH_HcBulkHeadED_BHED_Pos)       /*!< USBH_T::HcBulkHeadED: BHED Mask           */
N
N#define USBH_HcBulkCurrentED_BCED_Pos    (4)                                               /*!< USBH_T::HcBulkCurrentED: BCED Position    */
N#define USBH_HcBulkCurrentED_BCED_Msk    (0xffffffful << USBH_HcBulkCurrentED_BCED_Pos)    /*!< USBH_T::HcBulkCurrentED: BCED Mask        */
N
N#define USBH_HcDoneHead_DH_Pos           (4)                                               /*!< USBH_T::HcDoneHead: DH Position           */
N#define USBH_HcDoneHead_DH_Msk           (0xffffffful << USBH_HcDoneHead_DH_Pos)           /*!< USBH_T::HcDoneHead: DH Mask               */
N
N#define USBH_HcFmInterval_FI_Pos         (0)                                               /*!< USBH_T::HcFmInterval: FI Position         */
N#define USBH_HcFmInterval_FI_Msk         (0x3ffful << USBH_HcFmInterval_FI_Pos)            /*!< USBH_T::HcFmInterval: FI Mask             */
N
N#define USBH_HcFmInterval_FSMPS_Pos      (16)                                              /*!< USBH_T::HcFmInterval: FSMPS Position      */
N#define USBH_HcFmInterval_FSMPS_Msk      (0x7ffful << USBH_HcFmInterval_FSMPS_Pos)         /*!< USBH_T::HcFmInterval: FSMPS Mask          */
N
N#define USBH_HcFmInterval_FIT_Pos        (31)                                              /*!< USBH_T::HcFmInterval: FIT Position        */
N#define USBH_HcFmInterval_FIT_Msk        (0x1ul << USBH_HcFmInterval_FIT_Pos)              /*!< USBH_T::HcFmInterval: FIT Mask            */
N
N#define USBH_HcFmRemaining_FR_Pos        (0)                                               /*!< USBH_T::HcFmRemaining: FR Position        */
N#define USBH_HcFmRemaining_FR_Msk        (0x3ffful << USBH_HcFmRemaining_FR_Pos)           /*!< USBH_T::HcFmRemaining: FR Mask            */
N
N#define USBH_HcFmRemaining_FRT_Pos       (31)                                              /*!< USBH_T::HcFmRemaining: FRT Position       */
N#define USBH_HcFmRemaining_FRT_Msk       (0x1ul << USBH_HcFmRemaining_FRT_Pos)             /*!< USBH_T::HcFmRemaining: FRT Mask           */
N
N#define USBH_HcFmNumber_FN_Pos           (0)                                               /*!< USBH_T::HcFmNumber: FN Position           */
N#define USBH_HcFmNumber_FN_Msk           (0xfffful << USBH_HcFmNumber_FN_Pos)              /*!< USBH_T::HcFmNumber: FN Mask               */
N
N#define USBH_HcPeriodicStart_PS_Pos      (0)                                               /*!< USBH_T::HcPeriodicStart: PS Position      */
N#define USBH_HcPeriodicStart_PS_Msk      (0x3ffful << USBH_HcPeriodicStart_PS_Pos)         /*!< USBH_T::HcPeriodicStart: PS Mask          */
N
N#define USBH_HcLSThreshold_LST_Pos       (0)                                               /*!< USBH_T::HcLSThreshold: LST Position       */
N#define USBH_HcLSThreshold_LST_Msk       (0xffful << USBH_HcLSThreshold_LST_Pos)           /*!< USBH_T::HcLSThreshold: LST Mask           */
N
N#define USBH_HcRhDescriptorA_NDP_Pos     (0)                                               /*!< USBH_T::HcRhDescriptorA: NDP Position     */
N#define USBH_HcRhDescriptorA_NDP_Msk     (0xfful << USBH_HcRhDescriptorA_NDP_Pos)          /*!< USBH_T::HcRhDescriptorA: NDP Mask         */
N
N#define USBH_HcRhDescriptorA_PSM_Pos     (8)                                               /*!< USBH_T::HcRhDescriptorA: PSM Position     */
N#define USBH_HcRhDescriptorA_PSM_Msk     (0x1ul << USBH_HcRhDescriptorA_PSM_Pos)           /*!< USBH_T::HcRhDescriptorA: PSM Mask         */
N
N#define USBH_HcRhDescriptorA_OCPM_Pos    (11)                                              /*!< USBH_T::HcRhDescriptorA: OCPM Position    */
N#define USBH_HcRhDescriptorA_OCPM_Msk    (0x1ul << USBH_HcRhDescriptorA_OCPM_Pos)          /*!< USBH_T::HcRhDescriptorA: OCPM Mask        */
N
N#define USBH_HcRhDescriptorA_NOCP_Pos    (12)                                              /*!< USBH_T::HcRhDescriptorA: NOCP Position    */
N#define USBH_HcRhDescriptorA_NOCP_Msk    (0x1ul << USBH_HcRhDescriptorA_NOCP_Pos)          /*!< USBH_T::HcRhDescriptorA: NOCP Mask        */
N
N#define USBH_HcRhDescriptorB_PPCM_Pos    (16)                                              /*!< USBH_T::HcRhDescriptorB: PPCM Position    */
N#define USBH_HcRhDescriptorB_PPCM_Msk    (0xfffful << USBH_HcRhDescriptorB_PPCM_Pos)       /*!< USBH_T::HcRhDescriptorB: PPCM Mask        */
N
N#define USBH_HcRhStatus_LPS_Pos          (0)                                               /*!< USBH_T::HcRhStatus: LPS Position          */
N#define USBH_HcRhStatus_LPS_Msk          (0x1ul << USBH_HcRhStatus_LPS_Pos)                /*!< USBH_T::HcRhStatus: LPS Mask              */
N
N#define USBH_HcRhStatus_OCI_Pos          (1)                                               /*!< USBH_T::HcRhStatus: OCI Position          */
N#define USBH_HcRhStatus_OCI_Msk          (0x1ul << USBH_HcRhStatus_OCI_Pos)                /*!< USBH_T::HcRhStatus: OCI Mask              */
N
N#define USBH_HcRhStatus_DRWE_Pos         (15)                                              /*!< USBH_T::HcRhStatus: DRWE Position         */
N#define USBH_HcRhStatus_DRWE_Msk         (0x1ul << USBH_HcRhStatus_DRWE_Pos)               /*!< USBH_T::HcRhStatus: DRWE Mask             */
N
N#define USBH_HcRhStatus_LPSC_Pos         (16)                                              /*!< USBH_T::HcRhStatus: LPSC Position         */
N#define USBH_HcRhStatus_LPSC_Msk         (0x1ul << USBH_HcRhStatus_LPSC_Pos)               /*!< USBH_T::HcRhStatus: LPSC Mask             */
N
N#define USBH_HcRhStatus_OCIC_Pos         (17)                                              /*!< USBH_T::HcRhStatus: OCIC Position         */
N#define USBH_HcRhStatus_OCIC_Msk         (0x1ul << USBH_HcRhStatus_OCIC_Pos)               /*!< USBH_T::HcRhStatus: OCIC Mask             */
N
N#define USBH_HcRhStatus_CRWE_Pos         (31)                                              /*!< USBH_T::HcRhStatus: CRWE Position         */
N#define USBH_HcRhStatus_CRWE_Msk         (0x1ul << USBH_HcRhStatus_CRWE_Pos)               /*!< USBH_T::HcRhStatus: CRWE Mask             */
N
N#define USBH_HcRhPortStatus_CCS_Pos      (0)                                               /*!< USBH_T::HcRhPortStatus: CCS Position      */
N#define USBH_HcRhPortStatus_CCS_Msk      (0x1ul << USBH_HcRhPortStatus_CCS_Pos)             /*!< USBH_T::HcRhPortStatus: CCS Mask         */
N
N#define USBH_HcRhPortStatus_PES_Pos      (1)                                               /*!< USBH_T::HcRhPortStatus: PES Position      */
N#define USBH_HcRhPortStatus_PES_Msk      (0x1ul << USBH_HcRhPortStatus_PES_Pos)            /*!< USBH_T::HcRhPortStatus: PES Mask          */
N
N#define USBH_HcRhPortStatus_PSS_Pos      (2)                                               /*!< USBH_T::HcRhPortStatus: PSS Position      */
N#define USBH_HcRhPortStatus_PSS_Msk      (0x1ul << USBH_HcRhPortStatus_PSS_Pos)            /*!< USBH_T::HcRhPortStatus: PSS Mask          */
N
N#define USBH_HcRhPortStatus_POCI_Pos     (3)                                               /*!< USBH_T::HcRhPortStatus: POCI Position     */
N#define USBH_HcRhPortStatus_POCI_Msk     (0x1ul << USBH_HcRhPortStatus_POCI_Pos)           /*!< USBH_T::HcRhPortStatus: POCI Mask         */
N
N#define USBH_HcRhPortStatus_PRS_Pos      (4)                                               /*!< USBH_T::HcRhPortStatus: PRS Position      */
N#define USBH_HcRhPortStatus_PRS_Msk      (0x1ul << USBH_HcRhPortStatus_PRS_Pos)            /*!< USBH_T::HcRhPortStatus: PRS Mask          */
N
N#define USBH_HcRhPortStatus_PPS_Pos      (8)                                               /*!< USBH_T::HcRhPortStatus: PPS Position      */
N#define USBH_HcRhPortStatus_PPS_Msk      (0x1ul << USBH_HcRhPortStatus_PPS_Pos)            /*!< USBH_T::HcRhPortStatus: PPS Mask          */
N
N#define USBH_HcRhPortStatus_LSDA_Pos     (9)                                               /*!< USBH_T::HcRhPortStatus: LSDA Position     */
N#define USBH_HcRhPortStatus_LSDA_Msk     (0x1ul << USBH_HcRhPortStatus_LSDA_Pos)           /*!< USBH_T::HcRhPortStatus: LSDA Mask         */
N
N#define USBH_HcRhPortStatus_CSC_Pos      (16)                                              /*!< USBH_T::HcRhPortStatus: CSC Position      */
N#define USBH_HcRhPortStatus_CSC_Msk      (0x1ul << USBH_HcRhPortStatus_CSC_Pos)            /*!< USBH_T::HcRhPortStatus: CSC Mask          */
N
N#define USBH_HcRhPortStatus_PESC_Pos     (17)                                              /*!< USBH_T::HcRhPortStatus: PESC Position     */
N#define USBH_HcRhPortStatus_PESC_Msk     (0x1ul << USBH_HcRhPortStatus_PESC_Pos)           /*!< USBH_T::HcRhPortStatus: PESC Mask         */
N
N#define USBH_HcRhPortStatus_PSSC_Pos     (18)                                              /*!< USBH_T::HcRhPortStatus: PSSC Position     */
N#define USBH_HcRhPortStatus_PSSC_Msk     (0x1ul << USBH_HcRhPortStatus_PSSC_Pos)           /*!< USBH_T::HcRhPortStatus: PSSC Mask         */
N
N#define USBH_HcRhPortStatus_OCIC_Pos     (19)                                              /*!< USBH_T::HcRhPortStatus: OCIC Position     */
N#define USBH_HcRhPortStatus_OCIC_Msk     (0x1ul << USBH_HcRhPortStatus_OCIC_Pos)           /*!< USBH_T::HcRhPortStatus: OCIC Mask         */
N
N#define USBH_HcRhPortStatus_PRSC_Pos     (20)                                              /*!< USBH_T::HcRhPortStatus: PRSC Position     */
N#define USBH_HcRhPortStatus_PRSC_Msk     (0x1ul << USBH_HcRhPortStatus_PRSC_Pos)           /*!< USBH_T::HcRhPortStatus: PRSC Mask         */
N
N#define USBH_HcPhyControl_STBYEN_Pos     (27)                                              /*!< USBH_T::HcPhyControl: STBYEN Position     */
N#define USBH_HcPhyControl_STBYEN_Msk     (0x1ul << USBH_HcPhyControl_STBYEN_Pos)           /*!< USBH_T::HcPhyControl: STBYEN Mask         */
N
N#define USBH_HcMiscControl_ABORT_Pos     (1)                                               /*!< USBH_T::HcMiscControl: ABORT Position     */
N#define USBH_HcMiscControl_ABORT_Msk     (0x1ul << USBH_HcMiscControl_ABORT_Pos)           /*!< USBH_T::HcMiscControl: ABORT Mask         */
N
N#define USBH_HcMiscControl_OCAL_Pos      (3)                                               /*!< USBH_T::HcMiscControl: OCAL Position      */
N#define USBH_HcMiscControl_OCAL_Msk      (0x1ul << USBH_HcMiscControl_OCAL_Pos)            /*!< USBH_T::HcMiscControl: OCAL Mask          */
N
N#define USBH_HcMiscControl_DPRT1_Pos     (16)                                              /*!< USBH_T::HcMiscControl: DPRT1 Position     */
N#define USBH_HcMiscControl_DPRT1_Msk     (0x1ul << USBH_HcMiscControl_DPRT1_Pos)           /*!< USBH_T::HcMiscControl: DPRT1 Mask         */
N
N/**@}*/ /* USBH_CONST */
N/**@}*/ /* end of USBH register group */
N
N
N/*---------------------- Watch Dog Timer Controller -------------------------*/
N/**
N    @addtogroup WDT Watch Dog Timer Controller(WDT)
N    Memory Mapped Structure for WDT Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N
N
N/**
N * @var WDT_T::CTL
N * Offset: 0x00  WDT Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RSTCNT    |Reset WDT Up Counter (Write Protect)
N * |        |          |0 = No effect.
N * |        |          |1 = Reset the internal 18-bit WDT up counter value.
N * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |        |          |Note2: This bit will be automatically cleared by hardware.
N * |[1]     |RSTEN     |WDT Time-Out Reset Enable Control (Write Protect)
N * |        |          |Setting this bit will enable the WDT time-out reset function If the WDT up counter value has not been cleared after the specific WDT reset delay period expires.
N * |        |          |0 = WDT time-out reset function Disabled.
N * |        |          |1 = WDT time-out reset function Enabled.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[2]     |RSTF      |WDT Time-Out Reset Flag
N * |        |          |This bit indicates the system has been reset by WDT time-out reset or not.
N * |        |          |0 = WDT time-out reset did not occur.
N * |        |          |1 = WDT time-out reset occurred.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * |[3]     |IF        |WDT Time-Out Interrupt Flag
N * |        |          |This bit will set to 1 while WDT up counter value reaches the selected WDT time-out interval
N * |        |          |0 = WDT time-out interrupt did not occur.
N * |        |          |1 = WDT time-out interrupt occurred.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * |[4]     |WKEN      |WDT Time-Out Wake-Up Function Control (Write Protect)
N * |        |          |If this bit is set to 1, while WDT time-out interrupt flag IF (WDT_CTL[3]) is generated to 1 and interrupt enable bit INTEN (WDT_CTL[6]) is enabled, the WDT time-out interrupt signal will generate a wake-up trigger event to chip.
N * |        |          |0 = Wake-up trigger event Disabled if WDT time-out interrupt signal generated.
N * |        |          |1 = Wake-up trigger event Enabled if WDT time-out interrupt signal generated.
N * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |        |          |Note2: Chip can be woken-up by WDT time-out interrupt signal generated only if WDT clock source is selected to 10 kHz oscillator.
N * |[5]     |WKF       |WDT Time-Out Wake-Up Flag
N * |        |          |This bit indicates the interrupt wake-up flag status of WDT
N * |        |          |0 = WDT does not cause chip wake-up.
N * |        |          |1 = Chip wake-up from Idle or Power-down mode if WDT time-out interrupt signal generated.
N * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |        |          |Note2: This bit is cleared by writing 1 to it.
N * |[6]     |INTEN     |WDT Time-Out Interrupt Enable Control (Write Protect)
N * |        |          |If this bit is enabled, the WDT time-out interrupt signal is generated and inform to CPU.
N * |        |          |0 = WDT time-out interrupt Disabled.
N * |        |          |1 = WDT time-out interrupt Enabled.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[7]     |WDTEN     |WDT Enable Control (Write Protect)
N * |        |          |0 = WDT Disabled (This action will reset the internal up counter value).
N * |        |          |1 = WDT Enabled.
N * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |        |          |Note2: If CWDTEN[2:0] (combined by Config0[31] and Config0[4:3]) bits is not configure to 111, this bit is forced as 1 and user cannot change this bit to 0.
N * |[10:8]  |TOUTSEL   |WDT Time-Out Interval Selection (Write Protect)
N * |        |          |These three bits select the time-out interval period for the WDT.
N * |        |          |000 = (2^4)*TWDT.
N * |        |          |001 = (2^6)*TWDT.
N * |        |          |010 = (2^8)*TWDT.
N * |        |          |011 = (2^10)*TWDT.
N * |        |          |100 = (2^12)*TWDT.
N * |        |          |101 = (2^14)*TWDT.
N * |        |          |110 = (2^16)*TWDT.
N * |        |          |111 = (2^18)*TWDT.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable Control (Write Protect)
N * |        |          |0 = ICE debug mode acknowledgement affects WDT counting.
N * |        |          |WDT up counter will be held while CPU is held by ICE.
N * |        |          |1 = ICE debug mode acknowledgement Disabled.
N * |        |          |WDT up counter will keep going no matter CPU is held by ICE or not.
N * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N * @var WDT_T::ALTCTL
N * Offset: 0x04  WDT Alternative Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |RSTDSEL   |WDT Reset Delay Selection (Write Protect)
N * |        |          |When WDT time-out happened, user has a time named WDT Reset Delay Period to clear WDT counter by setting RSTCNT (WDT_CTL[0]) to prevent WDT time-out reset happened.
N * |        |          |User can select a suitable setting of RSTDSEL for different WDT Reset Delay Period.
N * |        |          |00 = WDT Reset Delay Period is 1026 * WDT_CLK.
N * |        |          |01 = WDT Reset Delay Period is 130 * WDT_CLK.
N * |        |          |10 = WDT Reset Delay Period is 18 * WDT_CLK.
N * |        |          |11 = WDT Reset Delay Period is 3 * WDT_CLK.
N * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
N * |        |          |Note2: This register will be reset to 0 if WDT time-out reset happened.
N */
N
N    __IO uint32_t CTL;           /* Offset: 0x00  WDT Control Register                                               */
X    volatile uint32_t CTL;            
N    __IO uint32_t ALTCTL;        /* Offset: 0x04  WDT Alternative Control Register                                   */
X    volatile uint32_t ALTCTL;         
N
N} WDT_T;
N
N
N
N/**
N    @addtogroup WDT_CONST WDT Bit Field Definition
N    Constant Definitions for WDT Controller
N@{ */
N
N#define WDT_CTL_RSTCNT_Pos               (0)                                               /*!< WDT_T::CTL: RSTCNT Position               */
N#define WDT_CTL_RSTCNT_Msk               (0x1ul << WDT_CTL_RSTCNT_Pos)                     /*!< WDT_T::CTL: RSTCNT Mask                   */
N
N#define WDT_CTL_RSTEN_Pos                (1)                                               /*!< WDT_T::CTL: RSTEN Position                */
N#define WDT_CTL_RSTEN_Msk                (0x1ul << WDT_CTL_RSTEN_Pos)                      /*!< WDT_T::CTL: RSTEN Mask                    */
N
N#define WDT_CTL_RSTF_Pos                 (2)                                               /*!< WDT_T::CTL: RSTF Position                 */
N#define WDT_CTL_RSTF_Msk                 (0x1ul << WDT_CTL_RSTF_Pos)                       /*!< WDT_T::CTL: RSTF Mask                     */
N
N#define WDT_CTL_IF_Pos                   (3)                                               /*!< WDT_T::CTL: IF Position                   */
N#define WDT_CTL_IF_Msk                   (0x1ul << WDT_CTL_IF_Pos)                         /*!< WDT_T::CTL: IF Mask                       */
N
N#define WDT_CTL_WKEN_Pos                 (4)                                               /*!< WDT_T::CTL: WKEN Position                 */
N#define WDT_CTL_WKEN_Msk                 (0x1ul << WDT_CTL_WKEN_Pos)                       /*!< WDT_T::CTL: WKEN Mask                     */
N
N#define WDT_CTL_WKF_Pos                  (5)                                               /*!< WDT_T::CTL: WKF Position                  */
N#define WDT_CTL_WKF_Msk                  (0x1ul << WDT_CTL_WKF_Pos)                        /*!< WDT_T::CTL: WKF Mask                      */
N
N#define WDT_CTL_INTEN_Pos                (6)                                               /*!< WDT_T::CTL: INTEN Position                */
N#define WDT_CTL_INTEN_Msk                (0x1ul << WDT_CTL_INTEN_Pos)                      /*!< WDT_T::CTL: INTEN Mask                    */
N
N#define WDT_CTL_WDTEN_Pos                (7)                                               /*!< WDT_T::CTL: WDTEN Position                */
N#define WDT_CTL_WDTEN_Msk                (0x1ul << WDT_CTL_WDTEN_Pos)                      /*!< WDT_T::CTL: WDTEN Mask                    */
N
N#define WDT_CTL_TOUTSEL_Pos              (8)                                               /*!< WDT_T::CTL: TOUTSEL Position              */
N#define WDT_CTL_TOUTSEL_Msk              (0x7ul << WDT_CTL_TOUTSEL_Pos)                    /*!< WDT_T::CTL: TOUTSEL Mask                  */
N
N#define WDT_CTL_ICEDEBUG_Pos             (31)                                              /*!< WDT_T::CTL: ICEDEBUG Position             */
N#define WDT_CTL_ICEDEBUG_Msk             (0x1ul << WDT_CTL_ICEDEBUG_Pos)                   /*!< WDT_T::CTL: ICEDEBUG Mask                 */
N
N#define WDT_ALTCTL_RSTDSEL_Pos           (0)                                               /*!< WDT_T::ALTCTL: RSTDSEL Position           */
N#define WDT_ALTCTL_RSTDSEL_Msk           (0x3ul << WDT_ALTCTL_RSTDSEL_Pos)                 /*!< WDT_T::ALTCTL: RSTDSEL Mask               */
N
N/**@}*/ /* WDT_CONST */
N/**@}*/ /* end of WDT register group */
N
N
N/*---------------------- Window Watchdog Timer -------------------------*/
N/**
N    @addtogroup WWDT Window Watchdog Timer(WWDT)
N    Memory Mapped Structure for WWDT Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N
N
N/**
N * @var WWDT_T::RLDCNT
N * Offset: 0x00  WWDT Reload Counter Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |WWDT_RLDCNT|WWDT Reload Counter Register
N * |        |          |Writing 0x00005AA5 to this register will reload the WWDT counter value to 0x3F.
N * |        |          |Note: User can only write WWDT_RLDCNT register to reload WWDT counter value when current WWDT counter value between 0 and CMPDAT (WWDT_CTL[21:16]).
N * |        |          |If user writes WWDT_RLDCNT when current WWDT counter value is larger than CMPDAT , WWDT reset signal will generate immediately.
N * @var WWDT_T::CTL
N * Offset: 0x04  WWDT Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WWDTEN    |WWDT Enable Control Bit
N * |        |          |Set this bit to enable WWDT counter counting.
N * |        |          |0 = WWDT counter is stopped.
N * |        |          |1 = WWDT counter is starting counting.
N * |[1]     |INTEN     |WWDT Interrupt Enable Control Bit
N * |        |          |If this bit is enabled, the WWDT counter compare match interrupt signal is generated and inform to CPU.
N * |        |          |0 = WWDT counter compare match interrupt Disabled.
N * |        |          |1 = WWDT counter compare match interrupt Enabled.
N * |[11:8]  |PSCSEL    |WWDT Counter Prescale Period Selection
N * |        |          |0000 = Pre-scale is 1; Max time-out period is 1 * 64 * TWWDT.
N * |        |          |0001 = Pre-scale is 2; Max time-out period is 2 * 64 * TWWDT.
N * |        |          |0010 = Pre-scale is 4; Max time-out period is 4 * 64 * TWWDT.
N * |        |          |0011 = Pre-scale is 8; Max time-out period is 8 * 64 * TWWDT.
N * |        |          |0100 = Pre-scale is 16; Max time-out period is 16 * 64 * TWWDT.
N * |        |          |0101 = Pre-scale is 32; Max time-out period is 32 * 64 * TWWDT.
N * |        |          |0110 = Pre-scale is 64; Max time-out period is 64 * 64 * TWWDT.
N * |        |          |0111 = Pre-scale is 128; Max time-out period is 128 * 64 * TWWDT.
N * |        |          |1000 = Pre-scale is 192; Max time-out period is 192 * 64 * TWWDT.
N * |        |          |1001 = Pre-scale is 256; Max time-out period is 256 * 64 * TWWDT.
N * |        |          |1010 = Pre-scale is 384; Max time-out period is 384 * 64 * TWWDT.
N * |        |          |1011 = Pre-scale is 512; Max time-out period is 512 * 64 * TWWDT.
N * |        |          |1100 = Pre-scale is 768; Max time-out period is 768 * 64 * TWWDT.
N * |        |          |1101 = Pre-scale is 1024; Max time-out period is 1024 * 64 * TWWDT.
N * |        |          |1110 = Pre-scale is 1536; Max time-out period is 1536 * 64 * TWWDT.
N * |        |          |1111 = Pre-scale is 2048; Max time-out period is 2048 * 64 * TWWDT.
N * |[21:16] |CMPDAT    |WWDT Window Compare Register
N * |        |          |Set this register to adjust the valid reload window.
N * |        |          |Note: User can only write WWDT_RLDCNT register to reload WWDT counter value when current WWDT counter value between 0 and CMPDAT.
N * |        |          |If user writes WWDT_RLDCNT register when current WWDT counter value larger than CMPDAT, WWDT reset signal will generate immediately.
N * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable Control
N * |        |          |0 = ICE debug mode acknowledgement effects WWDT counting.
N * |        |          |WWDT down counter will be held while CPU is held by ICE.
N * |        |          |1 = ICE debug mode acknowledgement Disabled.
N * |        |          |WWDT down counter will keep going no matter CPU is held by ICE or not.
N * @var WWDT_T::STATUS
N * Offset: 0x08  WWDT Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WWDTIF    |WWDT Compare Match Interrupt Flag
N * |        |          |This bit indicates the interrupt flag status of WWDT while WWDT counter value matches CMPDAT (WWDT_CTL[21:16]).
N * |        |          |0 = No effect.
N * |        |          |1 = WWDT counter value matches CMPDAT.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * |[1]     |WWDTRF    |WWDT Timer-Out Reset Flag
N * |        |          |This bit indicates the system has been reset by WWDT time-out reset or not.
N * |        |          |0 = WWDT time-out reset did not occur.
N * |        |          |1 = WWDT time-out reset occurred.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * @var WWDT_T::CNT
N * Offset: 0x0C  WWDT Counter Value Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |CNTDAT    |WWDT Counter Value
N * |        |          |CNTDAT will be updated continuously to monitor 6-bit WWDT down counter value.
N */
N
N    __O  uint32_t RLDCNT;        /* Offset: 0x00  WWDT Reload Counter Register                                       */
X    volatile  uint32_t RLDCNT;         
N    __IO uint32_t CTL;           /* Offset: 0x04  WWDT Control Register                                              */
X    volatile uint32_t CTL;            
N    __IO uint32_t STATUS;        /* Offset: 0x08  WWDT Status Register                                               */
X    volatile uint32_t STATUS;         
N    __I  uint32_t CNT;           /* Offset: 0x0C  WWDT Counter Value Register                                        */
X    volatile const  uint32_t CNT;            
N
N} WWDT_T;
N
N
N
N/**
N    @addtogroup WWDT_CONST WWDT Bit Field Definition
N    Constant Definitions for WWDT Controller
N@{ */
N
N#define WWDT_RLDCNT_WWDT_RLDCNT_Pos      (0)                                               /*!< WWDT_T::RLDCNT: WWDT_RLDCNT Position      */
N#define WWDT_RLDCNT_WWDT_RLDCNT_Msk      (0xfffffffful << WWDT_RLDCNT_WWDT_RLDCNT_Pos)     /*!< WWDT_T::RLDCNT: WWDT_RLDCNT Mask          */
N
N#define WWDT_CTL_WWDTEN_Pos              (0)                                               /*!< WWDT_T::CTL: WWDTEN Position              */
N#define WWDT_CTL_WWDTEN_Msk              (0x1ul << WWDT_CTL_WWDTEN_Pos)                    /*!< WWDT_T::CTL: WWDTEN Mask                  */
N
N#define WWDT_CTL_INTEN_Pos               (1)                                               /*!< WWDT_T::CTL: INTEN Position               */
N#define WWDT_CTL_INTEN_Msk               (0x1ul << WWDT_CTL_INTEN_Pos)                     /*!< WWDT_T::CTL: INTEN Mask                   */
N
N#define WWDT_CTL_PSCSEL_Pos              (8)                                               /*!< WWDT_T::CTL: PSCSEL Position              */
N#define WWDT_CTL_PSCSEL_Msk              (0xful << WWDT_CTL_PSCSEL_Pos)                    /*!< WWDT_T::CTL: PSCSEL Mask                  */
N
N#define WWDT_CTL_CMPDAT_Pos              (16)                                              /*!< WWDT_T::CTL: CMPDAT Position              */
N#define WWDT_CTL_CMPDAT_Msk              (0x3ful << WWDT_CTL_CMPDAT_Pos)                   /*!< WWDT_T::CTL: CMPDAT Mask                  */
N
N#define WWDT_CTL_ICEDEBUG_Pos            (31)                                              /*!< WWDT_T::CTL: ICEDEBUG Position            */
N#define WWDT_CTL_ICEDEBUG_Msk            (0x1ul << WWDT_CTL_ICEDEBUG_Pos)                  /*!< WWDT_T::CTL: ICEDEBUG Mask                */
N
N#define WWDT_STATUS_WWDTIF_Pos           (0)                                               /*!< WWDT_T::STATUS: WWDTIF Position           */
N#define WWDT_STATUS_WWDTIF_Msk           (0x1ul << WWDT_STATUS_WWDTIF_Pos)                 /*!< WWDT_T::STATUS: WWDTIF Mask               */
N
N#define WWDT_STATUS_WWDTRF_Pos           (1)                                               /*!< WWDT_T::STATUS: WWDTRF Position           */
N#define WWDT_STATUS_WWDTRF_Msk           (0x1ul << WWDT_STATUS_WWDTRF_Pos)                 /*!< WWDT_T::STATUS: WWDTRF Mask               */
N
N#define WWDT_CNT_CNTDAT_Pos              (0)                                               /*!< WWDT_T::CNT: CNTDAT Position              */
N#define WWDT_CNT_CNTDAT_Msk              (0x3ful << WWDT_CNT_CNTDAT_Pos)                   /*!< WWDT_T::CNT: CNTDAT Mask                  */
N
N/**@}*/ /* WWDT_CONST */
N/**@}*/ /* end of WWDT register group */
N
N
N/**@}*/ /* end of REGISTER group */
N
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/** @addtogroup MemoryMap Memory Mapping
N  @{
N*/
N
N/* Peripheral and SRAM base address */
N#define SRAM_BASE            (0x20000000UL)                              /*!< (SRAM      ) Base Address */
N#define PERIPH_BASE          (0x40000000UL)                              /*!< (Peripheral) Base Address */
N
N
N/* Peripheral memory map */
N#define AHBPERIPH_BASE       PERIPH_BASE
N#define APBPERIPH_BASE       (PERIPH_BASE + 0x00040000)
N
N/*!< AHB peripherals */
N#define GCR_BASE             (AHBPERIPH_BASE + 0x00000)               
N#define CLK_BASE             (AHBPERIPH_BASE + 0x00200)
N#define INT_BASE             (AHBPERIPH_BASE + 0x00300)
N#define GPIO_BASE            (AHBPERIPH_BASE + 0x04000)
N#define GPIOA_BASE           (AHBPERIPH_BASE + 0x04000)
N#define GPIOB_BASE           (AHBPERIPH_BASE + 0x04040)
N#define GPIOC_BASE           (AHBPERIPH_BASE + 0x04080)
N#define GPIOD_BASE           (AHBPERIPH_BASE + 0x040C0)
N#define GPIOE_BASE           (AHBPERIPH_BASE + 0x04100)
N#define GPIOF_BASE           (AHBPERIPH_BASE + 0x04140)
N#define GPIO_DBCTL_BASE      (AHBPERIPH_BASE + 0x04440)
N#define GPIO_PIN_DATA_BASE   (AHBPERIPH_BASE + 0x04800)
N#define PDMA_BASE            (AHBPERIPH_BASE + 0x08000)
N#define USBH_BASE            (AHBPERIPH_BASE + 0x09000)
N#define FMC_BASE             (AHBPERIPH_BASE + 0x0C000)
N#define EBI_BASE             (AHBPERIPH_BASE + 0x10000)
N#define CRC_BASE             (AHBPERIPH_BASE + 0x31000)
N
N/*!< APB0 peripherals */
N#define WDT_BASE             (APBPERIPH_BASE + 0x00000)
N#define WWDT_BASE            (APBPERIPH_BASE + 0x00100)
N#define TMR01_BASE           (APBPERIPH_BASE + 0x10000)
N#define PWM0_BASE            (APBPERIPH_BASE + 0x18000)
N#define SPI0_BASE            (APBPERIPH_BASE + 0x20000)
N#define SPI2_BASE            (APBPERIPH_BASE + 0x22000)
N#define UART0_BASE           (APBPERIPH_BASE + 0x30000)
N#define UART2_BASE           (APBPERIPH_BASE + 0x32000)
N#define I2C0_BASE            (APBPERIPH_BASE + 0x40000)
N#define SC0_BASE             (APBPERIPH_BASE + 0x50000)
N#define CAN0_BASE            (APBPERIPH_BASE + 0x60000)
N#define USBD_BASE            (APBPERIPH_BASE + 0x80000)
N#define TK_BASE              (APBPERIPH_BASE + 0xA2000)
N
N/*!< APB1 peripherals */
N#define RTC_BASE             (APBPERIPH_BASE + 0x01000)
N#define EADC0_BASE           (APBPERIPH_BASE + 0x03000)
N#define ACMP01_BASE          (APBPERIPH_BASE + 0x05000)
N#define DAC_BASE             (APBPERIPH_BASE + 0x07000)
N#define OTG_BASE             (APBPERIPH_BASE + 0x0D000)
N#define TMR23_BASE           (APBPERIPH_BASE + 0x11000)
N#define PWM1_BASE            (APBPERIPH_BASE + 0x19000)
N#define SPI1_BASE            (APBPERIPH_BASE + 0x21000)
N#define UART1_BASE           (APBPERIPH_BASE + 0x31000)
N#define UART3_BASE           (APBPERIPH_BASE + 0x33000)
N#define I2C1_BASE            (APBPERIPH_BASE + 0x41000)
N/*@}*/ /* end of group MemoryMap */
N
N
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/
N/** @addtogroup PeripheralDecl Peripheral Declaration
N  @{
N*/
N
N
N#define SYS                  ((SYS_T *)   GCR_BASE)
N#define SYSINT               ((SYS_INT_T *) INT_BASE)                   
N#define CLK                  ((CLK_T *)   CLK_BASE)
N#define PA                   ((GPIO_T *)  GPIOA_BASE)
N#define PB                   ((GPIO_T *)  GPIOB_BASE)
N#define PC                   ((GPIO_T *)  GPIOC_BASE)
N#define PD                   ((GPIO_T *)  GPIOD_BASE)
N#define PE                   ((GPIO_T *)  GPIOE_BASE)
N#define PF                   ((GPIO_T *)  GPIOF_BASE)
N#define GPIO                 ((GPIO_DBCTL_T *) GPIO_DBCTL_BASE)
N#define PDMA                 ((PDMA_T *)  PDMA_BASE)
N#define USBH                 ((USBH_T *)  USBH_BASE)
N#define FMC                  ((FMC_T *)   FMC_BASE)
N#define EBI                  ((EBI_T *)   EBI_BASE)
N#define CRC                  ((CRC_T *)   CRC_BASE)
N
N#define WDT                  ((WDT_T *)   WDT_BASE)
N#define WWDT                 ((WWDT_T *)  WWDT_BASE)
N#define RTC                  ((RTC_T *)   RTC_BASE)
N#define EADC                  ((EADC_T *)   EADC0_BASE)
N#define ACMP01               ((ACMP_T *)  ACMP01_BASE)
N
N#define USBD                 ((USBD_T *)  USBD_BASE)
N#define OTG                  ((OTG_T *)   OTG_BASE)
N#define TIMER0               ((TIMER_T *) TMR01_BASE)
N#define TIMER1               ((TIMER_T *) (TMR01_BASE + 0x20))
N#define TIMER2               ((TIMER_T *) TMR23_BASE)
N#define TIMER3               ((TIMER_T *) (TMR23_BASE+ 0x20))
N#define PWM0                 ((PWM_T *)   PWM0_BASE)
N#define PWM1                 ((PWM_T *)   PWM1_BASE)
N#define DAC                  ((DAC_T *)   DAC_BASE)
N#define SPI0                 ((SPI_T *)   SPI0_BASE)
N#define SPI1                 ((SPI_T *)   SPI1_BASE)
N#define SPI2                 ((SPI_T *)   SPI2_BASE)
N#define UART0                ((UART_T *)  UART0_BASE)
N#define UART1                ((UART_T *)  UART1_BASE)
N#define UART2                ((UART_T *)  UART2_BASE)
N#define UART3                ((UART_T *)  UART3_BASE)
N#define I2C0                 ((I2C_T *)   I2C0_BASE)
N#define I2C1                 ((I2C_T *)   I2C1_BASE)
N#define SC0                  ((SC_T *)    SC0_BASE)
N#define CAN0                 ((CAN_T *)   CAN0_BASE)
N#define TK                   ((TK_T *)   TK_BASE)
N
N/* One Bit Mask Definitions */
N#define BIT0    0x00000001
N#define BIT1    0x00000002
N#define BIT2    0x00000004
N#define BIT3    0x00000008
N#define BIT4    0x00000010
N#define BIT5    0x00000020
N#define BIT6    0x00000040
N#define BIT7    0x00000080
N#define BIT8    0x00000100
N#define BIT9    0x00000200
N#define BIT10   0x00000400
N#define BIT11   0x00000800
N#define BIT12   0x00001000
N#define BIT13   0x00002000
N#define BIT14   0x00004000
N#define BIT15   0x00008000
N#define BIT16   0x00010000
N#define BIT17   0x00020000
N#define BIT18   0x00040000
N#define BIT19   0x00080000
N#define BIT20   0x00100000
N#define BIT21   0x00200000
N#define BIT22   0x00400000
N#define BIT23   0x00800000
N#define BIT24   0x01000000
N#define BIT25   0x02000000
N#define BIT26   0x04000000
N#define BIT27   0x08000000
N#define BIT28   0x10000000
N#define BIT29   0x20000000
N#define BIT30   0x40000000
N#define BIT31   0x80000000
N
N/* Byte Mask Definitions */
N#define BYTE0_Msk               (0x000000FF)
N#define BYTE1_Msk               (0x0000FF00)
N#define BYTE2_Msk               (0x00FF0000)
N#define BYTE3_Msk               (0xFF000000)
N
N#define _GET_BYTE0(u32Param)    (((u32Param) & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
N#define _GET_BYTE1(u32Param)    (((u32Param) & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
N#define _GET_BYTE2(u32Param)    (((u32Param) & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
N#define _GET_BYTE3(u32Param)    (((u32Param) & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
N
N#ifndef TRUE
N# define TRUE 1
N#endif
N#ifndef FALSE
N# define FALSE 0
N#endif
N
N#ifndef NULL
N#define NULL        0
N#endif
N
N#include "sys.h"
L 1 "..\..\..\..\Library\StdDriver\inc\sys.h" 1
N/**************************************************************************//**
N * @file     SYS.h
N * @version  V3.0
N * $Revision  1 $
N * $Date: 15/08/11 10:26a $
N * @brief    M451 Series SYS Header File
N *
N * @note
N * Copyright (C) 2013~2015 Nuvoton Technology Corp. All rights reserved.
N ******************************************************************************/
N
N#ifndef __SYS_H__
N#define __SYS_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup SYS_Driver SYS Driver
N  @{
N*/
N
N/** @addtogroup SYS_EXPORTED_CONSTANTS SYS Exported Constants
N  @{
N*/
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Module Reset Control Resister constant definitions.                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_RST    ((0x0<<24) | SYS_IPRST0_PDMARST_Pos )   /*!< Reset PDMA */
N#define EBI_RST     ((0x0<<24) | SYS_IPRST0_EBIRST_Pos )    /*!< Reset EBI */
N#define USBH_RST    ((0x0<<24) | SYS_IPRST0_USBHRST_Pos )   /*!< Reset USBH */
N#define CRC_RST     ((0x0<<24) | SYS_IPRST0_CRCRST_Pos )    /*!< Reset CRC */
N
N#define GPIO_RST    ((0x4<<24) | SYS_IPRST1_GPIORST_Pos )   /*!< Reset GPIO */
N#define TMR0_RST    ((0x4<<24) | SYS_IPRST1_TMR0RST_Pos )   /*!< Reset TMR0 */
N#define TMR1_RST    ((0x4<<24) | SYS_IPRST1_TMR1RST_Pos )   /*!< Reset TMR1 */
N#define TMR2_RST    ((0x4<<24) | SYS_IPRST1_TMR2RST_Pos )   /*!< Reset TMR2 */
N#define TMR3_RST    ((0x4<<24) | SYS_IPRST1_TMR3RST_Pos )   /*!< Reset TMR3 */
N#define ACMP01_RST  ((0x4<<24) | SYS_IPRST1_ACMP01RST_Pos ) /*!< Reset ACMP01 */
N#define I2C0_RST    ((0x4<<24) | SYS_IPRST1_I2C0RST_Pos )   /*!< Reset I2C0 */
N#define I2C1_RST    ((0x4<<24) | SYS_IPRST1_I2C1RST_Pos )   /*!< Reset I2C1 */
N#define SPI0_RST    ((0x4<<24) | SYS_IPRST1_SPI0RST_Pos )   /*!< Reset SPI0 */
N#define SPI1_RST    ((0x4<<24) | SYS_IPRST1_SPI1RST_Pos )   /*!< Reset SPI1 */
N#define SPI2_RST    ((0x4<<24) | SYS_IPRST1_SPI2RST_Pos )   /*!< Reset SPI2 */
N#define UART0_RST   ((0x4<<24) | SYS_IPRST1_UART0RST_Pos )  /*!< Reset UART0 */
N#define UART1_RST   ((0x4<<24) | SYS_IPRST1_UART1RST_Pos )  /*!< Reset UART1 */
N#define UART2_RST   ((0x4<<24) | SYS_IPRST1_UART2RST_Pos )  /*!< Reset UART2 */
N#define UART3_RST   ((0x4<<24) | SYS_IPRST1_UART3RST_Pos )  /*!< Reset UART3 */
N#define CAN0_RST    ((0x4<<24) | SYS_IPRST1_CAN0RST_Pos )   /*!< Reset CAN0 */
N#define OTG_RST     ((0x4<<24) | SYS_IPRST1_OTGRST_Pos )    /*!< Reset OTG */
N#define USBD_RST    ((0x4<<24) | SYS_IPRST1_USBDRST_Pos )   /*!< Reset USBD */
N#define EADC_RST    ((0x4<<24) | SYS_IPRST1_EADCRST_Pos )   /*!< Reset EADC */
N
N#define SC0_RST     ((0x8<<24) | SYS_IPRST2_SC0RST_Pos )    /*!< Reset SC0 */
N#define DAC_RST     ((0x8<<24) | SYS_IPRST2_DACRST_Pos )    /*!< Reset DAC */
N#define PWM0_RST    ((0x8<<24) | SYS_IPRST2_PWM0RST_Pos )   /*!< Reset PWM0 */
N#define PWM1_RST    ((0x8<<24) | SYS_IPRST2_PWM1RST_Pos )   /*!< Reset PWM1 */
N#define TK_RST      ((0x8<<24) | SYS_IPRST2_TKRST_Pos )     /*!< Reset TK */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Brown Out Detector Threshold Voltage Selection constant definitions.                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYS_BODCTL_BOD_RST_EN           (1UL<<SYS_BODCTL_BODRSTEN_Pos)    /*!< Brown-out Reset Enable */
N#define SYS_BODCTL_BOD_INTERRUPT_EN     (0UL<<SYS_BODCTL_BODRSTEN_Pos)    /*!< Brown-out Interrupt Enable */
N#define SYS_BODCTL_BODVL_4_5V           (3UL<<SYS_BODCTL_BODVL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 4.5V */
N#define SYS_BODCTL_BODVL_3_7V           (2UL<<SYS_BODCTL_BODVL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 3.7V */
N#define SYS_BODCTL_BODVL_2_7V           (1UL<<SYS_BODCTL_BODVL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 2.7V */
N#define SYS_BODCTL_BODVL_2_2V           (0UL<<SYS_BODCTL_BODVL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 2.2V */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  VREFCTL constant definitions. (Write-Protection Register)                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYS_VREFCTL_VREF_2_56V      (0x3UL<<SYS_VREFCTL_VREFCTL_Pos)    /*!< VOUT = 2.56V */
N#define SYS_VREFCTL_VREF_2_048V     (0x7UL<<SYS_VREFCTL_VREFCTL_Pos)    /*!< VOUT = 2.048V */
N#define SYS_VREFCTL_VREF_3_072V     (0xBUL<<SYS_VREFCTL_VREFCTL_Pos)    /*!< VOUT = 3.072V */
N#define SYS_VREFCTL_VREF_4_096V     (0xFUL<<SYS_VREFCTL_VREFCTL_Pos)    /*!< VOUT = 4.096V */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  USBPHY constant definitions. (Write-Protection Register)                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYS_USBPHY_USBROLE_OTG_V33_EN (0x1UL<<SYS_USBPHY_LDO33EN_Pos)   /*!<  USB LDO33 Enabled  */
N#define SYS_USBPHY_USBROLE_STD_USBD   (0x0UL<<SYS_USBPHY_USBROLE_Pos)   /*!<  Standard USB device */
N#define SYS_USBPHY_USBROLE_STD_USBH   (0x1UL<<SYS_USBPHY_USBROLE_Pos)   /*!<  Standard USB host */
N#define SYS_USBPHY_USBROLE_ID_DEPH    (0x2UL<<SYS_USBPHY_USBROLE_Pos)   /*!<  ID dependent device */
N#define SYS_USBPHY_USBROLE_ON_THE_GO  (0x3UL<<SYS_USBPHY_USBROLE_Pos)   /*!<  On-The-Go device */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Multi-Function constant definitions.                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N/* How to use below #define?
NExample 1: If user want to set PA.0 as SC0_CLK in initial function,
N           user can issue following command to achieve it.
N
N           SYS->GPA_MFPL  = (SYS->GPA_MFPL & (~SYS_GPA_MFPL_PA0MFP_Msk) ) | SYS_GPA_MFPL_PA0_MFP_SC0_CLK  ;
N
N*/
N//PA0 MFP
N#define SYS_GPA_MFPL_PA0MFP_GPIO               (0ul << SYS_GPA_MFPL_PA0MFP_Pos)        /*!< GPA_MFPL PA0 setting for GPIO*/
N#define SYS_GPA_MFPL_PA0MFP_UART1_nCTS         (1ul << SYS_GPA_MFPL_PA0MFP_Pos)        /*!< GPA_MFPL PA0 setting for UART1_nCTS*/
N#define SYS_GPA_MFPL_PA0MFP_UART1_TXD          (3ul << SYS_GPA_MFPL_PA0MFP_Pos)        /*!< GPA_MFPL PA0 setting for UART1_TXD*/
N#define SYS_GPA_MFPL_PA0MFP_CAN0_RXD           (4ul << SYS_GPA_MFPL_PA0MFP_Pos)        /*!< GPA_MFPL PA0 setting for CAN0_RXD*/
N#define SYS_GPA_MFPL_PA0MFP_SC0_CLK            (5ul << SYS_GPA_MFPL_PA0MFP_Pos)        /*!< GPA_MFPL PA0 setting for SC0_CLK*/
N#define SYS_GPA_MFPL_PA0MFP_PWM1_CH5           (6ul << SYS_GPA_MFPL_PA0MFP_Pos)        /*!< GPA_MFPL PA0 setting for PWM1_CH5*/
N#define SYS_GPA_MFPL_PA0MFP_EBI_AD0            (7ul << SYS_GPA_MFPL_PA0MFP_Pos)        /*!< GPA_MFPL PA0 setting for EBI_AD0*/
N#define SYS_GPA_MFPL_PA0MFP_INT0               (8ul << SYS_GPA_MFPL_PA0MFP_Pos)        /*!< GPA_MFPL PA0 setting for INT0*/
N#define SYS_GPA_MFPL_PA0MFP_SPI1_I2SMCLK       (9ul << SYS_GPA_MFPL_PA0MFP_Pos)        /*!< GPA_MFPL PA0 setting for SPI1_I2SMCLK*/
N
N//PA1 MFP
N#define SYS_GPA_MFPL_PA1MFP_GPIO               (0ul << SYS_GPA_MFPL_PA1MFP_Pos)        /*!< GPA_MFPL PA1 setting for GPIO*/
N#define SYS_GPA_MFPL_PA1MFP_UART1_nRTS         (1ul << SYS_GPA_MFPL_PA1MFP_Pos)        /*!< GPA_MFPL PA1 setting for UART1_nRTS*/
N#define SYS_GPA_MFPL_PA1MFP_UART1_RXD          (3ul << SYS_GPA_MFPL_PA1MFP_Pos)        /*!< GPA_MFPL PA1 setting for UART1_RXD*/
N#define SYS_GPA_MFPL_PA1MFP_CAN0_TXD           (4ul << SYS_GPA_MFPL_PA1MFP_Pos)        /*!< GPA_MFPL PA1 setting for CAN0_TXD*/
N#define SYS_GPA_MFPL_PA1MFP_SC0_DAT            (5ul << SYS_GPA_MFPL_PA1MFP_Pos)        /*!< GPA_MFPL PA1 setting for SC0_DAT*/
N#define SYS_GPA_MFPL_PA1MFP_PWM1_CH4           (6ul << SYS_GPA_MFPL_PA1MFP_Pos)        /*!< GPA_MFPL PA1 setting for PWM1_CH4*/
N#define SYS_GPA_MFPL_PA1MFP_EBI_AD1            (7ul << SYS_GPA_MFPL_PA1MFP_Pos)        /*!< GPA_MFPL PA1 setting for EBI_AD1*/
N#define SYS_GPA_MFPL_PA1MFP_STADC              (10ul << SYS_GPA_MFPL_PA1MFP_Pos)       /*!< GPA_MFPL PA1 setting for STADC*/
N
N//PA2 MFP
N#define SYS_GPA_MFPL_PA2MFP_GPIO               (0ul << SYS_GPA_MFPL_PA2MFP_Pos)        /*!< GPA_MFPL PA2 setting for GPIO*/
N#define SYS_GPA_MFPL_PA2MFP_USB_VBUS_EN        (1ul << SYS_GPA_MFPL_PA2MFP_Pos)        /*!< GPA_MFPL PA2 setting for USB_VBUS_EN*/
N#define SYS_GPA_MFPL_PA2MFP_UART0_TXD          (2ul << SYS_GPA_MFPL_PA2MFP_Pos)        /*!< GPA_MFPL PA2 setting for UART0_TXD*/
N#define SYS_GPA_MFPL_PA2MFP_UART0_nCTS         (3ul << SYS_GPA_MFPL_PA2MFP_Pos)        /*!< GPA_MFPL PA2 setting for UART0_nCTS*/
N#define SYS_GPA_MFPL_PA2MFP_I2C0_SDA           (4ul << SYS_GPA_MFPL_PA2MFP_Pos)        /*!< GPA_MFPL PA2 setting for I2C0_SDA*/
N#define SYS_GPA_MFPL_PA2MFP_SC0_RST            (5ul << SYS_GPA_MFPL_PA2MFP_Pos)        /*!< GPA_MFPL PA2 setting for SC0_RST*/
N#define SYS_GPA_MFPL_PA2MFP_PWM1_CH3           (6ul << SYS_GPA_MFPL_PA2MFP_Pos)        /*!< GPA_MFPL PA2 setting for PWM1_CH3*/
N#define SYS_GPA_MFPL_PA2MFP_EBI_AD2            (7ul << SYS_GPA_MFPL_PA2MFP_Pos)        /*!< GPA_MFPL PA2 setting for EBI_AD2*/
N
N//PA3 MFP
N#define SYS_GPA_MFPL_PA3MFP_GPIO               (0ul << SYS_GPA_MFPL_PA3MFP_Pos)        /*!< GPA_MFPL PA3 setting for GPIO*/
N#define SYS_GPA_MFPL_PA3MFP_USB_VBUS_ST       (1ul << SYS_GPA_MFPL_PA3MFP_Pos)        /*!< GPA_MFPL PA3 setting for USB_VBUS_ST*/
N#define SYS_GPA_MFPL_PA3MFP_UART0_RXD          (2ul << SYS_GPA_MFPL_PA3MFP_Pos)        /*!< GPA_MFPL PA3 setting for UART0_RXD*/
N#define SYS_GPA_MFPL_PA3MFP_UART0_nRTS         (3ul << SYS_GPA_MFPL_PA3MFP_Pos)        /*!< GPA_MFPL PA3 setting for UART0_nRTS*/
N#define SYS_GPA_MFPL_PA3MFP_I2C0_SCL           (4ul << SYS_GPA_MFPL_PA3MFP_Pos)        /*!< GPA_MFPL PA3 setting for I2C0_SCL*/
N#define SYS_GPA_MFPL_PA3MFP_SC0_PWR            (5ul << SYS_GPA_MFPL_PA3MFP_Pos)        /*!< GPA_MFPL PA3 setting for SC0_PWR*/
N#define SYS_GPA_MFPL_PA3MFP_PWM1_CH2           (6ul << SYS_GPA_MFPL_PA3MFP_Pos)        /*!< GPA_MFPL PA3 setting for PWM1_CH2*/
N#define SYS_GPA_MFPL_PA3MFP_EBI_AD3            (7ul << SYS_GPA_MFPL_PA3MFP_Pos)        /*!< GPA_MFPL PA3 setting for EBI_AD3*/
N
N//PA4 MFP
N#define SYS_GPA_MFPL_PA4MFP_GPIO               (0ul << SYS_GPA_MFPL_PA4MFP_Pos)        /*!< GPA_MFPL PA4 setting for GPIO*/
N#define SYS_GPA_MFPL_PA4MFP_SPI1_SS            (2ul << SYS_GPA_MFPL_PA4MFP_Pos)        /*!< GPA_MFPL PA4 setting for SPI1_SS*/
N#define SYS_GPA_MFPL_PA4MFP_EBI_AD4            (7ul << SYS_GPA_MFPL_PA4MFP_Pos)        /*!< GPA_MFPL PA4 setting for EBI_AD4*/
N
N//PA5 MFP
N#define SYS_GPA_MFPL_PA5MFP_GPIO               (0ul << SYS_GPA_MFPL_PA5MFP_Pos)        /*!< GPA_MFPL PA5 setting for GPIO*/
N#define SYS_GPA_MFPL_PA5MFP_SPI1_MOSI          (2ul << SYS_GPA_MFPL_PA5MFP_Pos)        /*!< GPA_MFPL PA5 setting for SPI1_MOSI*/
N#define SYS_GPA_MFPL_PA5MFP_T2_EXT             (3ul << SYS_GPA_MFPL_PA5MFP_Pos)        /*!< GPA_MFPL PA5 setting for T2_EXT*/
N#define SYS_GPA_MFPL_PA5MFP_EBI_AD5            (7ul << SYS_GPA_MFPL_PA5MFP_Pos)        /*!< GPA_MFPL PA5 setting for EBI_AD5*/
N
N//PA6 MFP
N#define SYS_GPA_MFPL_PA6MFP_GPIO               (0ul << SYS_GPA_MFPL_PA6MFP_Pos)        /*!< GPA_MFPL PA6 setting for GPIO*/
N#define SYS_GPA_MFPL_PA6MFP_SPI1_MISO          (2ul << SYS_GPA_MFPL_PA6MFP_Pos)        /*!< GPA_MFPL PA6 setting for SPI1_MISO*/
N#define SYS_GPA_MFPL_PA6MFP_T1_EXT             (3ul << SYS_GPA_MFPL_PA6MFP_Pos)        /*!< GPA_MFPL PA6 setting for T1_EXT*/
N#define SYS_GPA_MFPL_PA6MFP_EBI_AD6            (7ul << SYS_GPA_MFPL_PA6MFP_Pos)        /*!< GPA_MFPL PA6 setting for EBI_AD6*/
N
N//PA7 MFP
N#define SYS_GPA_MFPL_PA7MFP_GPIO               (0ul << SYS_GPA_MFPL_PA7MFP_Pos)        /*!< GPA_MFPL PA7 setting for GPIO*/
N#define SYS_GPA_MFPL_PA7MFP_SPI1_CLK           (2ul << SYS_GPA_MFPL_PA7MFP_Pos)        /*!< GPA_MFPL PA7 setting for SPI1_CLK*/
N#define SYS_GPA_MFPL_PA7MFP_T0_EXT             (3ul << SYS_GPA_MFPL_PA7MFP_Pos)        /*!< GPA_MFPL PA7 setting for T0_EXT*/
N#define SYS_GPA_MFPL_PA7MFP_EBI_AD7            (7ul << SYS_GPA_MFPL_PA7MFP_Pos)        /*!< GPA_MFPL PA7 setting for EBI_AD7*/
N
N//PA8 MFP
N#define SYS_GPA_MFPH_PA8MFP_GPIO               (0ul << SYS_GPA_MFPH_PA8MFP_Pos)        /*!< GPA_MFPH PA8 setting for GPIO*/
N#define SYS_GPA_MFPH_PA8MFP_UART3_TXD          (3ul << SYS_GPA_MFPH_PA8MFP_Pos)        /*!< GPA_MFPH PA8 setting for UART3_TXD*/
N
N//PA9 MFP
N#define SYS_GPA_MFPH_PA9MFP_GPIO               (0ul << SYS_GPA_MFPH_PA9MFP_Pos)        /*!< GPA_MFPH PA9 setting for GPIO*/
N#define SYS_GPA_MFPH_PA9MFP_UART3_RXD          (3ul << SYS_GPA_MFPH_PA9MFP_Pos)        /*!< GPA_MFPH PA9 setting for UART3_RXD*/
N
N//PA10 MFP
N#define SYS_GPA_MFPH_PA10MFP_GPIO              (0ul << SYS_GPA_MFPH_PA10MFP_Pos)        /*!< GPA_MFPH PA10 setting for GPIO*/
N#define SYS_GPA_MFPH_PA10MFP_UART3_nCTS        (3ul << SYS_GPA_MFPH_PA10MFP_Pos)        /*!< GPA_MFPH PA10 setting for UART3_nCTS*/
N
N//PA11 MFP
N#define SYS_GPA_MFPH_PA11MFP_GPIO              (0ul << SYS_GPA_MFPH_PA11MFP_Pos)        /*!< GPA_MFPH PA11 setting for GPIO*/
N#define SYS_GPA_MFPH_PA11MFP_UART3_nRTS        (3ul << SYS_GPA_MFPH_PA11MFP_Pos)        /*!< GPA_MFPH PA11 setting for UART3_nRTS*/
N
N//PA12 MFP
N#define SYS_GPA_MFPH_PA12MFP_GPIO              (0ul << SYS_GPA_MFPH_PA12MFP_Pos)        /*!< GPA_MFPH PA12 setting for GPIO*/
N#define SYS_GPA_MFPH_PA12MFP_SPI1_I2SMCLK      (2ul << SYS_GPA_MFPH_PA12MFP_Pos)        /*!< GPA_MFPH PA12 setting for SPI1_I2SMCLK*/
N#define SYS_GPA_MFPH_PA12MFP_CAN0_TXD          (4ul << SYS_GPA_MFPH_PA12MFP_Pos)        /*!< GPA_MFPH PA12 setting for CAN0_TXD*/
N
N//PA13 MFP
N#define SYS_GPA_MFPH_PA13MFP_GPIO              (0ul << SYS_GPA_MFPH_PA13MFP_Pos)        /*!< GPA_MFPH PA13 setting for GPIO*/
N#define SYS_GPA_MFPH_PA13MFP_CAN0_RXD          (4ul << SYS_GPA_MFPH_PA13MFP_Pos)        /*!< GPA_MFPH PA13 setting for CAN0_RXD*/
N
N//PA14 MFP
N#define SYS_GPA_MFPH_PA14MFP_GPIO              (0ul << SYS_GPA_MFPH_PA14MFP_Pos)        /*!< GPA_MFPH PA14 setting for GPIO*/
N#define SYS_GPA_MFPH_PA14MFP_UART2_nCTS        (3ul << SYS_GPA_MFPH_PA14MFP_Pos)        /*!< GPA_MFPH PA14 setting for UART2_nCTS*/
N#define SYS_GPA_MFPH_PA14MFP_I2C0_SMBAL        (4ul << SYS_GPA_MFPH_PA14MFP_Pos)        /*!< GPA_MFPH PA14 setting for I2C0_SMBAL*/
N
N//PA15 MFP
N#define SYS_GPA_MFPH_PA15MFP_GPIO              (0ul << SYS_GPA_MFPH_PA15MFP_Pos)        /*!< GPA_MFPH PA15 setting for GPIO*/
N#define SYS_GPA_MFPH_PA15MFP_UART2_nRTS        (3ul << SYS_GPA_MFPH_PA15MFP_Pos)        /*!< GPA_MFPH PA15 setting for UART2_nRTS*/
N#define SYS_GPA_MFPH_PA15MFP_I2C0_SMBSUS       (4ul << SYS_GPA_MFPH_PA15MFP_Pos)        /*!< GPA_MFPH PA15 setting for I2C0_SMBSUS*/
N
N//PB0 MFP
N#define SYS_GPB_MFPL_PB0MFP_GPIO               (0ul << SYS_GPB_MFPL_PB0MFP_Pos)        /*!< GPB_MFPL PB0 setting for GPIO*/
N#define SYS_GPB_MFPL_PB0MFP_EADC_CH0           (1ul << SYS_GPB_MFPL_PB0MFP_Pos)        /*!< GPB_MFPL PB0 setting for EADC_CH0*/
N#define SYS_GPB_MFPL_PB0MFP_SPI0_MOSI1         (2ul << SYS_GPB_MFPL_PB0MFP_Pos)        /*!< GPB_MFPL PB0 setting for SPI0_MOSI1*/
N#define SYS_GPB_MFPL_PB0MFP_UART2_RXD          (3ul << SYS_GPB_MFPL_PB0MFP_Pos)        /*!< GPB_MFPL PB0 setting for UART2_RXD*/
N#define SYS_GPB_MFPL_PB0MFP_T2                 (4ul << SYS_GPB_MFPL_PB0MFP_Pos)        /*!< GPB_MFPL PB0 setting for T2*/
N#define SYS_GPB_MFPL_PB0MFP_DAC                (5ul << SYS_GPB_MFPL_PB0MFP_Pos)        /*!< GPB_MFPL PB0 setting for DAC*/
N#define SYS_GPB_MFPL_PB0MFP_EBI_nWRL           (7ul << SYS_GPB_MFPL_PB0MFP_Pos)        /*!< GPB_MFPL PB0 setting for EBI_nWRL*/
N#define SYS_GPB_MFPL_PB0MFP_INT1               (8ul << SYS_GPB_MFPL_PB0MFP_Pos)        /*!< GPB_MFPL PB0 setting for INT1*/
N
N//PB1 MFP
N#define SYS_GPB_MFPL_PB1MFP_GPIO               (0ul << SYS_GPB_MFPL_PB1MFP_Pos)        /*!< GPB_MFPL PB1 setting for GPIO*/
N#define SYS_GPB_MFPL_PB1MFP_EADC_CH1           (1ul << SYS_GPB_MFPL_PB1MFP_Pos)        /*!< GPB_MFPL PB1 setting for EADC_CH1*/
N#define SYS_GPB_MFPL_PB1MFP_SPI0_MISO1         (2ul << SYS_GPB_MFPL_PB1MFP_Pos)        /*!< GPB_MFPL PB1 setting for SPI0_MISO1*/
N#define SYS_GPB_MFPL_PB1MFP_UART2_TXD          (3ul << SYS_GPB_MFPL_PB1MFP_Pos)        /*!< GPB_MFPL PB1 setting for UART2_TXD*/
N#define SYS_GPB_MFPL_PB1MFP_T3                 (4ul << SYS_GPB_MFPL_PB1MFP_Pos)        /*!< GPB_MFPL PB1 setting for T3*/
N#define SYS_GPB_MFPL_PB1MFP_SC0_RST            (5ul << SYS_GPB_MFPL_PB1MFP_Pos)        /*!< GPB_MFPL PB1 setting for SC0_RST*/
N#define SYS_GPB_MFPL_PB1MFP_PWM0_SYNC_OUT      (6ul << SYS_GPB_MFPL_PB1MFP_Pos)        /*!< GPB_MFPL PB1 setting for PWM0_SYNC_OUT*/
N#define SYS_GPB_MFPL_PB1MFP_EBI_nWRH           (7ul << SYS_GPB_MFPL_PB1MFP_Pos)        /*!< GPB_MFPL PB1 setting for EBI_nWRH*/
N
N//PB2 MFP
N#define SYS_GPB_MFPL_PB2MFP_GPIO               (0ul << SYS_GPB_MFPL_PB2MFP_Pos)        /*!< GPB_MFPL PB2 setting for GPIO*/
N#define SYS_GPB_MFPL_PB2MFP_EADC_CH2           (1ul << SYS_GPB_MFPL_PB2MFP_Pos)        /*!< GPB_MFPL PB2 setting for EADC_CH2*/
N#define SYS_GPB_MFPL_PB2MFP_SPI0_CLK           (2ul << SYS_GPB_MFPL_PB2MFP_Pos)        /*!< GPB_MFPL PB2 setting for SPI0_CLK*/
N#define SYS_GPB_MFPL_PB2MFP_SPI1_CLK           (3ul << SYS_GPB_MFPL_PB2MFP_Pos)        /*!< GPB_MFPL PB2 setting for SPI1_CLK*/
N#define SYS_GPB_MFPL_PB2MFP_UART1_RXD          (4ul << SYS_GPB_MFPL_PB2MFP_Pos)        /*!< GPB_MFPL PB2 setting for UART1_RXD*/
N#define SYS_GPB_MFPL_PB2MFP_SC0_CD             (5ul << SYS_GPB_MFPL_PB2MFP_Pos)        /*!< GPB_MFPL PB2 setting for SC0_CD*/
N#define SYS_GPB_MFPL_PB2MFP_UART3_RXD          (9ul << SYS_GPB_MFPL_PB2MFP_Pos)        /*!< GPB_MFPL PB2 setting for UART3_RXD*/
N#define SYS_GPB_MFPL_PB2MFP_T2_EXT             (11ul << SYS_GPB_MFPL_PB2MFP_Pos)       /*!< GPB_MFPL PB2 setting for T2_EXT*/
N
N//PB3
N#define SYS_GPB_MFPL_PB3MFP_GPIO               (0ul << SYS_GPB_MFPL_PB3MFP_Pos)        /*!< GPB_MFPL PB3 setting for GPIO*/
N#define SYS_GPB_MFPL_PB3MFP_EADC_CH3           (1ul << SYS_GPB_MFPL_PB3MFP_Pos)        /*!< GPB_MFPL PB3 setting for EADC_CH3*/
N#define SYS_GPB_MFPL_PB3MFP_SPI0_MISO0         (2ul << SYS_GPB_MFPL_PB3MFP_Pos)        /*!< GPB_MFPL PB3 setting for SPI0_MISO0*/
N#define SYS_GPB_MFPL_PB3MFP_SPI1_MISO          (3ul << SYS_GPB_MFPL_PB3MFP_Pos)        /*!< GPB_MFPL PB3 setting for SPI1_MISO*/
N#define SYS_GPB_MFPL_PB3MFP_UART1_TXD          (4ul << SYS_GPB_MFPL_PB3MFP_Pos)        /*!< GPB_MFPL PB3 setting for UART1_TXD*/
N#define SYS_GPB_MFPL_PB3MFP_UART3_TXD          (9ul << SYS_GPB_MFPL_PB3MFP_Pos)        /*!< GPB_MFPL PB3 setting for UART3_TXD*/
N#define SYS_GPB_MFPL_PB3MFP_T0_EXT             (11ul << SYS_GPB_MFPL_PB3MFP_Pos)       /*!< GPB_MFPL PB3 setting for T0_EXT*/
N
N//PB4
N#define SYS_GPB_MFPL_PB4MFP_GPIO               (0ul << SYS_GPB_MFPL_PB4MFP_Pos)        /*!< GPB_MFPL PB4 setting for GPIO*/
N#define SYS_GPB_MFPL_PB4MFP_EADC_CH4           (1ul << SYS_GPB_MFPL_PB4MFP_Pos)        /*!< GPB_MFPL PB4 setting for EADC_CH4*/
N#define SYS_GPB_MFPL_PB4MFP_SPI0_SS            (2ul << SYS_GPB_MFPL_PB4MFP_Pos)        /*!< GPB_MFPL PB4 setting for SPI0_SS*/
N#define SYS_GPB_MFPL_PB4MFP_SPI1_SS            (3ul << SYS_GPB_MFPL_PB4MFP_Pos)        /*!< GPB_MFPL PB4 setting for SPI1_SS*/
N#define SYS_GPB_MFPL_PB4MFP_UART1_nCTS         (4ul << SYS_GPB_MFPL_PB4MFP_Pos)        /*!< GPB_MFPL PB4 setting for UART1_nCTS*/
N#define SYS_GPB_MFPL_PB4MFP_ACMP0_N            (5ul << SYS_GPB_MFPL_PB4MFP_Pos)        /*!< GPB_MFPL PB4 setting for ACMP0_N*/
N#define SYS_GPB_MFPL_PB4MFP_EBI_AD7            (7ul << SYS_GPB_MFPL_PB4MFP_Pos)        /*!< GPB_MFPL PB4 setting for EBI_AD7*/
N#define SYS_GPB_MFPL_PB4MFP_UART2_TXD          (9ul << SYS_GPB_MFPL_PB4MFP_Pos)        /*!< GPB_MFPL PB4 setting for UART2_TXD*/
N#define SYS_GPB_MFPL_PB4MFP_T1_EXT             (11ul << SYS_GPB_MFPL_PB4MFP_Pos)       /*!< GPB_MFPL PB4 setting for T1_EXT*/
N
N//PB5
N#define SYS_GPB_MFPL_PB5MFP_GPIO               (0ul << SYS_GPB_MFPL_PB5MFP_Pos)        /*!< GPB_MFPL PB5 setting for GPIO*/
N#define SYS_GPB_MFPL_PB5MFP_EADC_CH13          (1ul << SYS_GPB_MFPL_PB5MFP_Pos)        /*!< GPB_MFPL PB5 setting for EADC_CH13*/
N#define SYS_GPB_MFPL_PB5MFP_SPI0_MOSI0         (2ul << SYS_GPB_MFPL_PB5MFP_Pos)        /*!< GPB_MFPL PB5 setting for SPI0_MOSI0*/
N#define SYS_GPB_MFPL_PB5MFP_SPI1_MOSI          (3ul << SYS_GPB_MFPL_PB5MFP_Pos)        /*!< GPB_MFPL PB5 setting for SPI1_MOSI*/
N#define SYS_GPB_MFPL_PB5MFP_TK3                (4ul << SYS_GPB_MFPL_PB5MFP_Pos)        /*!< GPB_MFPL PB5 setting for TK3*/
N#define SYS_GPB_MFPL_PB5MFP_ACMP0_P2           (5ul << SYS_GPB_MFPL_PB5MFP_Pos)        /*!< GPB_MFPL PB5 setting for ACMP0_P2*/
N#define SYS_GPB_MFPL_PB5MFP_EBI_AD6            (7ul << SYS_GPB_MFPL_PB5MFP_Pos)        /*!< GPB_MFPL PB5 setting for EBI_AD6*/
N#define SYS_GPB_MFPL_PB5MFP_UART2_RXD          (9ul << SYS_GPB_MFPL_PB5MFP_Pos)        /*!< GPB_MFPL PB5 setting for UART2_RXD*/
N
N//PB6
N#define SYS_GPB_MFPL_PB6MFP_GPIO               (0ul << SYS_GPB_MFPL_PB6MFP_Pos)        /*!< GPB_MFPL PB6 setting for GPIO*/
N#define SYS_GPB_MFPL_PB6MFP_EADC_CH14          (1ul << SYS_GPB_MFPL_PB6MFP_Pos)        /*!< GPB_MFPL PB6 setting for EADC_CH14*/
N#define SYS_GPB_MFPL_PB6MFP_SPI0_MISO0         (2ul << SYS_GPB_MFPL_PB6MFP_Pos)        /*!< GPB_MFPL PB6 setting for SPI0_MISO0*/
N#define SYS_GPB_MFPL_PB6MFP_SPI1_MISO          (3ul << SYS_GPB_MFPL_PB6MFP_Pos)        /*!< GPB_MFPL PB6 setting for SPI1_MISO*/
N#define SYS_GPB_MFPL_PB6MFP_TK4                (4ul << SYS_GPB_MFPL_PB6MFP_Pos)        /*!< GPB_MFPL PB6 setting for TK4*/
N#define SYS_GPB_MFPL_PB6MFP_ACMP0_P1           (5ul << SYS_GPB_MFPL_PB6MFP_Pos)        /*!< GPB_MFPL PB6 setting for ACMP0_P1*/
N#define SYS_GPB_MFPL_PB6MFP_EBI_AD5            (7ul << SYS_GPB_MFPL_PB6MFP_Pos)        /*!< GPB_MFPL PB6 setting for EBI_AD5*/
N
N//PB7
N#define SYS_GPB_MFPL_PB7MFP_GPIO               (0ul << SYS_GPB_MFPL_PB7MFP_Pos)        /*!< GPB_MFPL PB7 setting for GPIO*/
N#define SYS_GPB_MFPL_PB7MFP_EADC_CH15          (1ul << SYS_GPB_MFPL_PB7MFP_Pos)        /*!< GPB_MFPL PB7 setting for EADC_CH15*/
N#define SYS_GPB_MFPL_PB7MFP_SPI0_CLK           (2ul << SYS_GPB_MFPL_PB7MFP_Pos)        /*!< GPB_MFPL PB7 setting for SPI0_CLK*/
N#define SYS_GPB_MFPL_PB7MFP_SPI1_CLK           (3ul << SYS_GPB_MFPL_PB7MFP_Pos)        /*!< GPB_MFPL PB7 setting for SPI1_CLK*/
N#define SYS_GPB_MFPL_PB7MFP_TK5                (4ul << SYS_GPB_MFPL_PB7MFP_Pos)        /*!< GPB_MFPL PB7 setting for TK5*/
N#define SYS_GPB_MFPL_PB7MFP_ACMP0_P0           (5ul << SYS_GPB_MFPL_PB7MFP_Pos)        /*!< GPB_MFPL PB7 setting for ACMP0_P0*/
N#define SYS_GPB_MFPL_PB7MFP_EBI_AD4            (7ul << SYS_GPB_MFPL_PB7MFP_Pos)        /*!< GPB_MFPL PB7 setting for EBI_AD4*/
N#define SYS_GPB_MFPL_PB7MFP_STADC              (10ul << SYS_GPB_MFPL_PB7MFP_Pos)       /*!< GPB_MFPL PB7 setting for STADC*/
N
N//PB8
N#define SYS_GPB_MFPH_PB8MFP_GPIO               (0ul << SYS_GPB_MFPH_PB8MFP_Pos)        /*!< GPB_MFPH PB8 setting for GPIO*/
N#define SYS_GPB_MFPH_PB8MFP_EADC_CH5           (1ul << SYS_GPB_MFPH_PB8MFP_Pos)        /*!< GPB_MFPH PB8 setting for EADC_CH5*/
N#define SYS_GPB_MFPH_PB8MFP_UART1_nRTS         (4ul << SYS_GPB_MFPH_PB8MFP_Pos)        /*!< GPB_MFPH PB8 setting for UART1_nRTS*/
N#define SYS_GPB_MFPH_PB8MFP_PWM0_CH2           (6ul << SYS_GPB_MFPH_PB8MFP_Pos)        /*!< GPB_MFPH PB8 setting for PWM0_CH2*/
N
N//PB9
N#define SYS_GPB_MFPH_PB9MFP_GPIO               (0ul << SYS_GPB_MFPH_PB9MFP_Pos)        /*!< GPB_MFPH PB9 setting for GPIO*/
N#define SYS_GPB_MFPH_PB9MFP_EADC_CH6           (1ul << SYS_GPB_MFPH_PB9MFP_Pos)        /*!< GPB_MFPH PB9 setting for EADC_CH6*/
N
N//PB10
N#define SYS_GPB_MFPH_PB10MFP_GPIO              (0ul << SYS_GPB_MFPH_PB10MFP_Pos)        /*!< GPB_MFPH_ PB10 setting for GPIO*/
N#define SYS_GPB_MFPH_PB10MFP_EADC_CH7          (1ul << SYS_GPB_MFPH_PB10MFP_Pos)        /*!< GPB_MFPH_ PB10 setting for EADC_CH7*/
N
N//PB11
N#define SYS_GPB_MFPH_PB11MFP_GPIO              (0ul << SYS_GPB_MFPH_PB11MFP_Pos)        /*!< GPB_MFPH_ PB11 setting for GPIO*/
N#define SYS_GPB_MFPH_PB11MFP_EADC_CH8          (1ul << SYS_GPB_MFPH_PB11MFP_Pos)        /*!< GPB_MFPH_ PB11 setting for EADC_CH8*/
N#define SYS_GPB_MFPH_PB11MFP_TK0               (4ul << SYS_GPB_MFPH_PB11MFP_Pos)        /*!< GPB_MFPH_ PB11 setting for TK0*/
N
N//PB12
N#define SYS_GPB_MFPH_PB12MFP_GPIO              (0ul << SYS_GPB_MFPH_PB12MFP_Pos)        /*!< GPB_MFPH_ PB12 setting for GPIO*/
N#define SYS_GPB_MFPH_PB12MFP_EADC_CH9          (1ul << SYS_GPB_MFPH_PB12MFP_Pos)        /*!< GPB_MFPH_ PB12 setting for EADC_CH9*/
N#define SYS_GPB_MFPH_PB12MFP_TK1               (4ul << SYS_GPB_MFPH_PB12MFP_Pos)        /*!< GPB_MFPH_ PB12 setting for TK1*/
N
N//PB13
N#define SYS_GPB_MFPH_PB13MFP_GPIO              (0ul << SYS_GPB_MFPH_PB13MFP_Pos)        /*!< GPB_MFPH PB13 setting for GPIO*/
N#define SYS_GPB_MFPH_PB13MFP_EADC_CH10         (1ul << SYS_GPB_MFPH_PB13MFP_Pos)        /*!< GPB_MFPH PB13 setting for EADC_CH10*/
N
N//PB14
N#define SYS_GPB_MFPH_PB14MFP_GPIO              (0ul << SYS_GPB_MFPH_PB14MFP_Pos)        /*!< GPB_MFPH PB14 setting for GPIO*/
N#define SYS_GPB_MFPH_PB14MFP_EADC_CH11         (1ul << SYS_GPB_MFPH_PB14MFP_Pos)        /*!< GPB_MFPH PB14 setting for EADC_CH11*/
N
N//PB15
N#define SYS_GPB_MFPH_PB15MFP_GPIO              (0ul << SYS_GPB_MFPH_PB15MFP_Pos)        /*!< GPB_MFPH PB15 setting for GPIO*/
N#define SYS_GPB_MFPH_PB15MFP_EADC_CH12         (1ul << SYS_GPB_MFPH_PB15MFP_Pos)        /*!< GPB_MFPH PB15 setting for EADC_CH12*/
N#define SYS_GPB_MFPH_PB15MFP_TK2               (4ul << SYS_GPB_MFPH_PB15MFP_Pos)        /*!< GPB_MFPH PB15 setting for TK2*/
N#define SYS_GPB_MFPH_PB15MFP_ACMP0_P3          (5ul << SYS_GPB_MFPH_PB15MFP_Pos)        /*!< GPB_MFPH PB15 setting for ACMP0_P3*/
N#define SYS_GPB_MFPH_PB15MFP_EBI_nCS1          (7ul << SYS_GPB_MFPH_PB15MFP_Pos)        /*!< GPB_MFPH PB15 setting for EBI_nCS1*/
N
N//PC0
N#define SYS_GPC_MFPL_PC0MFP_GPIO               (0ul << SYS_GPC_MFPL_PC0MFP_Pos)        /*!< GPC_MFPL PC0 setting for GPIO*/
N#define SYS_GPC_MFPL_PC0MFP_SPI2_CLK           (2ul << SYS_GPC_MFPL_PC0MFP_Pos)        /*!< GPC_MFPL PC0 setting for SPI2_CLK*/
N#define SYS_GPC_MFPL_PC0MFP_UART2_nCTS         (3ul << SYS_GPC_MFPL_PC0MFP_Pos)        /*!< GPC_MFPL PC0 setting for UART2_nCTS*/
N#define SYS_GPC_MFPL_PC0MFP_CAN0_TXD           (4ul << SYS_GPC_MFPL_PC0MFP_Pos)        /*!< GPC_MFPL PC0 setting for CAN0_TXD*/
N#define SYS_GPC_MFPL_PC0MFP_PWM0_CH0           (6ul << SYS_GPC_MFPL_PC0MFP_Pos)        /*!< GPC_MFPL PC0 setting for PWM0_CH0*/
N#define SYS_GPC_MFPL_PC0MFP_EBI_AD8            (7ul << SYS_GPC_MFPL_PC0MFP_Pos)        /*!< GPC_MFPL PC0 setting for EBI_AD8*/
N#define SYS_GPC_MFPL_PC0MFP_INT2               (8ul << SYS_GPC_MFPL_PC0MFP_Pos)        /*!< GPC_MFPL PC0 setting for INT2*/
N#define SYS_GPC_MFPL_PC0MFP_UART3_TXD          (9ul << SYS_GPC_MFPL_PC0MFP_Pos)        /*!< GPC_MFPL PC0 setting for UART3_TXD*/
N#define SYS_GPC_MFPL_PC0MFP_T3_EXT             (11ul << SYS_GPC_MFPL_PC0MFP_Pos)       /*!< GPC_MFPL PC0 setting for T3_EXT*/
N
N//PC1
N#define SYS_GPC_MFPL_PC1MFP_GPIO               (0ul << SYS_GPC_MFPL_PC1MFP_Pos)        /*!< GPC_MFPL PC1 setting for GPIO*/
N#define SYS_GPC_MFPL_PC1MFP_CLKO               (1ul << SYS_GPC_MFPL_PC1MFP_Pos)        /*!< GPC_MFPL PC1 setting for CLKO*/
N#define SYS_GPC_MFPL_PC1MFP_STDAC              (2ul << SYS_GPC_MFPL_PC1MFP_Pos)        /*!< GPC_MFPL PC1 setting for STDAC*/
N#define SYS_GPC_MFPL_PC1MFP_UART2_nRTS         (3ul << SYS_GPC_MFPL_PC1MFP_Pos)        /*!< GPC_MFPL PC1 setting for UART2_nRTS*/
N#define SYS_GPC_MFPL_PC1MFP_CAN0_RXD           (4ul << SYS_GPC_MFPL_PC1MFP_Pos)        /*!< GPC_MFPL PC1 setting for CAN0_RXD*/
N#define SYS_GPC_MFPL_PC1MFP_PWM0_CH1           (6ul << SYS_GPC_MFPL_PC1MFP_Pos)        /*!< GPC_MFPL PC1 setting for PWM0_CH1*/
N#define SYS_GPC_MFPL_PC1MFP_EBI_AD9            (7ul << SYS_GPC_MFPL_PC1MFP_Pos)        /*!< GPC_MFPL PC1 setting for EBI_AD9*/
N#define SYS_GPC_MFPL_PC1MFP_UART3_RXD          (9ul << SYS_GPC_MFPL_PC1MFP_Pos)        /*!< GPC_MFPL PC1 setting for UART3_RXD*/
N
N//PC2
N#define SYS_GPC_MFPL_PC2MFP_GPIO               (0ul << SYS_GPC_MFPL_PC2MFP_Pos)        /*!< GPC_MFPL PC2 setting for GPIO*/
N#define SYS_GPC_MFPL_PC2MFP_SPI2_SS            (2ul << SYS_GPC_MFPL_PC2MFP_Pos)        /*!< GPC_MFPL PC2 setting for SPI2_SS*/
N#define SYS_GPC_MFPL_PC2MFP_UART2_TXD          (3ul << SYS_GPC_MFPL_PC2MFP_Pos)        /*!< GPC_MFPL PC2 setting for UART2_TXD*/
N#define SYS_GPC_MFPL_PC2MFP_ACMP1_O            (5ul << SYS_GPC_MFPL_PC2MFP_Pos)        /*!< GPC_MFPL PC2 setting for ACMP1_O*/
N#define SYS_GPC_MFPL_PC2MFP_PWM0_CH2           (6ul << SYS_GPC_MFPL_PC2MFP_Pos)        /*!< GPC_MFPL PC2 setting for PWM0_CH2*/
N#define SYS_GPC_MFPL_PC2MFP_EBI_AD10           (7ul << SYS_GPC_MFPL_PC2MFP_Pos)        /*!< GPC_MFPL PC2 setting for EBI_AD10*/
N
N//PC3
N#define SYS_GPC_MFPL_PC3MFP_GPIO               (0ul << SYS_GPC_MFPL_PC3MFP_Pos)        /*!< GPC_MFPL PC3 setting for GPIO*/
N#define SYS_GPC_MFPL_PC3MFP_SPI2_MOSI          (2ul << SYS_GPC_MFPL_PC3MFP_Pos)        /*!< GPC_MFPL PC3 setting for SPI2_MOSI*/
N#define SYS_GPC_MFPL_PC3MFP_UART2_RXD          (3ul << SYS_GPC_MFPL_PC3MFP_Pos)        /*!< GPC_MFPL PC3 setting for UART2_RXD*/
N#define SYS_GPC_MFPL_PC3MFP_USB_VBUS_ST        (4ul << SYS_GPC_MFPL_PC3MFP_Pos)        /*!< GPC_MFPL PC3 setting for USB_VBUS_ST*/
N#define SYS_GPC_MFPL_PC3MFP_PWM0_CH3           (6ul << SYS_GPC_MFPL_PC3MFP_Pos)        /*!< GPC_MFPL PC3 setting for PWM0_CH3*/
N#define SYS_GPC_MFPL_PC3MFP_EBI_AD11           (7ul << SYS_GPC_MFPL_PC3MFP_Pos)        /*!< GPC_MFPL PC3 setting for EBI_AD11*/
N
N//PC4
N#define SYS_GPC_MFPL_PC4MFP_GPIO               (0ul << SYS_GPC_MFPL_PC4MFP_Pos)        /*!< GPC_MFPL PC4 setting for GPIO*/
N#define SYS_GPC_MFPL_PC4MFP_SPI2_MISO          (2ul << SYS_GPC_MFPL_PC4MFP_Pos)        /*!< GPC_MFPL PC4 setting for SPI2_MISO*/
N#define SYS_GPC_MFPL_PC4MFP_I2C1_SCL           (3ul << SYS_GPC_MFPL_PC4MFP_Pos)        /*!< GPC_MFPL PC4 setting for I2C1_SCL*/
N#define SYS_GPC_MFPL_PC4MFP_USB_VBUS_EN        (4ul << SYS_GPC_MFPL_PC4MFP_Pos)        /*!< GPC_MFPL PC4 setting for USB_VBUS_EN*/
N#define SYS_GPC_MFPL_PC4MFP_PWM0_CH4           (6ul << SYS_GPC_MFPL_PC4MFP_Pos)        /*!< GPC_MFPL PC4 setting for PWM0_CH4*/
N#define SYS_GPC_MFPL_PC4MFP_EBI_AD12           (7ul << SYS_GPC_MFPL_PC4MFP_Pos)        /*!< GPC_MFPL PC4 setting for EBI_AD12*/
N
N//PC5
N#define SYS_GPC_MFPL_PC5MFP_GPIO               (0ul << SYS_GPC_MFPL_PC5MFP_Pos)        /*!< GPC_MFPL PC5 setting for GPIO*/
N#define SYS_GPC_MFPL_PC5MFP_SPI2_I2SMCLK       (2ul << SYS_GPC_MFPL_PC5MFP_Pos)        /*!< GPC_MFPL PC5 setting for SPI2_I2SMCLK*/
N#define SYS_GPC_MFPL_PC5MFP_PWM0_CH5           (6ul << SYS_GPC_MFPL_PC5MFP_Pos)        /*!< GPC_MFPL PC5 setting for PWM0_CH5*/
N#define SYS_GPC_MFPL_PC5MFP_EBI_AD13           (7ul << SYS_GPC_MFPL_PC5MFP_Pos)        /*!< GPC_MFPL PC5 setting for EBI_AD13*/
N
N//PC6
N#define SYS_GPC_MFPL_PC6MFP_GPIO               (0ul << SYS_GPC_MFPL_PC6MFP_Pos)        /*!< GPC_MFPL PC6 setting for GPIO*/
N#define SYS_GPC_MFPL_PC6MFP_I2C1_SMBAL         (3ul << SYS_GPC_MFPL_PC6MFP_Pos)        /*!< GPC_MFPL PC6 setting for I2C1_SMBAL*/
N#define SYS_GPC_MFPL_PC6MFP_ACMP1_O            (5ul << SYS_GPC_MFPL_PC6MFP_Pos)        /*!< GPC_MFPL PC6 setting for ACMP1_O*/
N#define SYS_GPC_MFPL_PC6MFP_PWM1_CH0           (6ul << SYS_GPC_MFPL_PC6MFP_Pos)        /*!< GPC_MFPL PC6 setting for PWM1_CH0*/
N#define SYS_GPC_MFPL_PC6MFP_EBI_AD14           (7ul << SYS_GPC_MFPL_PC6MFP_Pos)        /*!< GPC_MFPL PC6 setting for EBI_AD14*/
N#define SYS_GPC_MFPL_PC6MFP_UART0_TXD          (9ul << SYS_GPC_MFPL_PC6MFP_Pos)        /*!< GPC_MFPL PC6 setting for UART0_TXD*/
N
N//PC7
N#define SYS_GPC_MFPL_PC7MFP_GPIO               (0ul << SYS_GPC_MFPL_PC7MFP_Pos)        /*!< GPC_MFPL PC7 setting for GPIO*/
N#define SYS_GPC_MFPL_PC7MFP_I2C1_SMBSUS        (3ul << SYS_GPC_MFPL_PC7MFP_Pos)        /*!< GPC_MFPL PC7 setting for I2C1_SMBSUS*/
N#define SYS_GPC_MFPL_PC7MFP_PWM1_CH1           (6ul << SYS_GPC_MFPL_PC7MFP_Pos)        /*!< GPC_MFPL PC7 setting for PWM1_CH1*/
N#define SYS_GPC_MFPL_PC7MFP_EBI_AD15           (7ul << SYS_GPC_MFPL_PC7MFP_Pos)        /*!< GPC_MFPL PC7 setting for EBI_AD15*/
N#define SYS_GPC_MFPL_PC7MFP_UART0_RXD          (9ul << SYS_GPC_MFPL_PC7MFP_Pos)        /*!< GPC_MFPL PC7 setting for UART0_RXD*/
N
N//PC8
N#define SYS_GPC_MFPH_PC8MFP_GPIO               (0ul << SYS_GPC_MFPH_PC8MFP_Pos)        /*!< GPC_MFPH_ PC8 setting for GPIO*/
N#define SYS_GPC_MFPH_PC8MFP_TK7                (4ul << SYS_GPC_MFPH_PC8MFP_Pos)        /*!< GPC_MFPH_ PC8 setting for TK7*/
N
N//PC9
N#define SYS_GPC_MFPH_PC9MFP_GPIO               (0ul << SYS_GPC_MFPH_PC9MFP_Pos)        /*!< GPC_MFPH PC9 setting for GPIO*/
N#define SYS_GPC_MFPH_PC9MFP_SPI2_I2SMCLK       (2ul << SYS_GPC_MFPH_PC9MFP_Pos)        /*!< GPC_MFPH PC9 setting for SPI2_I2SMCLK*/
N#define SYS_GPC_MFPH_PC9MFP_PWM1_CH0           (6ul << SYS_GPC_MFPH_PC9MFP_Pos)        /*!< GPC_MFPH PC9 setting for PWM1_CH0*/
N
N//PC10
N#define SYS_GPC_MFPH_PC10MFP_GPIO              (0ul << SYS_GPC_MFPH_PC10MFP_Pos)        /*!< GPC_MFPH PC10 setting for GPIO*/
N#define SYS_GPC_MFPH_PC10MFP_SPI2_MOSI         (2ul << SYS_GPC_MFPH_PC10MFP_Pos)        /*!< GPC_MFPH PC10 setting for SPI2_MOSI*/
N#define SYS_GPC_MFPH_PC10MFP_PWM1_CH1          (6ul << SYS_GPC_MFPH_PC10MFP_Pos)        /*!< GPC_MFPH PC10 setting for PWM1_CH1*/
N
N//PC11
N#define SYS_GPC_MFPH_PC11MFP_GPIO              (0ul << SYS_GPC_MFPH_PC11MFP_Pos)        /*!< GPC_MFPH PC11 setting for GPIO*/
N#define SYS_GPC_MFPH_PC11MFP_SPI2_MISO         (2ul << SYS_GPC_MFPH_PC11MFP_Pos)        /*!< GPC_MFPH PC11 setting for SPI2_MISO*/
N#define SYS_GPC_MFPH_PC11MFP_PWM1_CH2          (6ul << SYS_GPC_MFPH_PC11MFP_Pos)        /*!< GPC_MFPH PC11 setting for PWM1_CH2*/
N
N//PC12
N#define SYS_GPC_MFPH_PC12MFP_GPIO              (0ul << SYS_GPC_MFPH_PC12MFP_Pos)        /*!< GPC_MFPH PC12 setting for GPIO*/
N#define SYS_GPC_MFPH_PC12MFP_SPI2_CLK          (2ul << SYS_GPC_MFPH_PC12MFP_Pos)        /*!< GPC_MFPH PC12 setting for SPI2_CLK*/
N#define SYS_GPC_MFPH_PC12MFP_PWM1_CH3          (6ul << SYS_GPC_MFPH_PC12MFP_Pos)        /*!< GPC_MFPH PC12 setting for PWM1_CH3*/
N
N//PC13
N#define SYS_GPC_MFPH_PC13MFP_GPIO              (0ul << SYS_GPC_MFPH_PC13MFP_Pos)        /*!< GPC_MFPH PC13 setting for GPIO*/
N#define SYS_GPC_MFPH_PC13MFP_SPI2_SS           (2ul << SYS_GPC_MFPH_PC13MFP_Pos)        /*!< GPC_MFPH PC13 setting for SPI2_SS*/
N#define SYS_GPC_MFPH_PC13MFP_PWM1_CH4          (6ul << SYS_GPC_MFPH_PC13MFP_Pos)        /*!< GPC_MFPH PC13 setting for PWM1_CH4*/
N
N//PC14
N#define SYS_GPC_MFPH_PC14MFP_GPIO              (0ul << SYS_GPC_MFPH_PC14MFP_Pos)        /*!< GPC_MFPH PC14 setting for GPIO*/
N#define SYS_GPC_MFPH_PC14MFP_PWM1_CH5          (6ul << SYS_GPC_MFPH_PC14MFP_Pos)        /*!< GPC_MFPH PC14 setting for PWM1_CH5*/
N
N//PC15
N#define SYS_GPC_MFPH_PC15MFP_GPIO              (0ul << SYS_GPC_MFPH_PC15MFP_Pos)        /*!< GPC_MFPH PC15 setting for GPIO*/
N#define SYS_GPC_MFPH_PC15MFP_PWM1_CH0          (6ul << SYS_GPC_MFPH_PC15MFP_Pos)        /*!< GPC_MFPH PC15 setting for PWM1_CH0*/
N
N//PD0
N#define SYS_GPD_MFPL_PD0MFP_GPIO            (0ul << SYS_GPD_MFPL_PD0MFP_Pos)        /*!< GPD_MFPL PD0 setting for GPIO*/
N#define SYS_GPD_MFPL_PD0MFP_EADC_CH6        (1ul << SYS_GPD_MFPL_PD0MFP_Pos)        /*!< GPD_MFPL PD0 setting for EADC_CH6*/
N#define SYS_GPD_MFPL_PD0MFP_SPI1_I2SMCLK    (2ul << SYS_GPD_MFPL_PD0MFP_Pos)        /*!< GPD_MFPL PD0 setting for SPI1_I2SMCLK*/
N#define SYS_GPD_MFPL_PD0MFP_UART0_RXD       (3ul << SYS_GPD_MFPL_PD0MFP_Pos)        /*!< GPD_MFPL PD0 setting for UART0_RXD*/
N#define SYS_GPD_MFPL_PD0MFP_TK6             (4ul << SYS_GPD_MFPL_PD0MFP_Pos)        /*!< GPD_MFPL PD0 setting for TK6*/
N#define SYS_GPD_MFPL_PD0MFP_ACMP1_N         (5ul << SYS_GPD_MFPL_PD0MFP_Pos)        /*!< GPD_MFPL PD0 setting for ACMP1_N*/
N#define SYS_GPD_MFPL_PD0MFP_INT3            (8ul << SYS_GPD_MFPL_PD0MFP_Pos)        /*!< GPD_MFPL PD0 setting for INT3*/
N#define SYS_GPD_MFPL_PD0MFP_T3              (11ul << SYS_GPD_MFPL_PD0MFP_Pos)       /*!< GPD_MFPL PD0 setting for T3*/
N
N//PD1
N#define SYS_GPD_MFPL_PD1MFP_GPIO            (0ul << SYS_GPD_MFPL_PD1MFP_Pos)        /*!< GPD_MFPL PD1 setting for GPIO*/
N#define SYS_GPD_MFPL_PD1MFP_EADC_CH11       (1ul << SYS_GPD_MFPL_PD1MFP_Pos)        /*!< GPD_MFPL PD1 setting for EADC_CH11*/
N#define SYS_GPD_MFPL_PD1MFP_PWM0_SYNC_IN    (2ul << SYS_GPD_MFPL_PD1MFP_Pos)        /*!< GPD_MFPL PD1 setting for PWM0_SYNC_IN*/
N#define SYS_GPD_MFPL_PD1MFP_UART0_TXD       (3ul << SYS_GPD_MFPL_PD1MFP_Pos)        /*!< GPD_MFPL PD1 setting for UART0_TXD*/
N#define SYS_GPD_MFPL_PD1MFP_TK10            (4ul << SYS_GPD_MFPL_PD1MFP_Pos)        /*!< GPD_MFPL PD1 setting for TK10*/
N#define SYS_GPD_MFPL_PD1MFP_ACMP1_P2        (5ul << SYS_GPD_MFPL_PD1MFP_Pos)        /*!< GPD_MFPL PD1 setting for ACMP1_P2*/
N#define SYS_GPD_MFPL_PD1MFP_T0              (6ul << SYS_GPD_MFPL_PD1MFP_Pos)        /*!< GPD_MFPL PD1 setting for T0*/
N#define SYS_GPD_MFPL_PD1MFP_EBI_nRD         (7ul << SYS_GPD_MFPL_PD1MFP_Pos)        /*!< GPD_MFPL PD1 setting for EBI_nRD*/
N
N//PD2
N#define SYS_GPD_MFPL_PD2MFP_GPIO            (0ul << SYS_GPD_MFPL_PD2MFP_Pos)        /*!< GPD_MFPL PD2 setting for GPIO*/
N#define SYS_GPD_MFPL_PD2MFP_STADC           (1ul << SYS_GPD_MFPL_PD2MFP_Pos)        /*!< GPD_MFPL PD2 setting for STADC*/
N#define SYS_GPD_MFPL_PD2MFP_T0_EXT          (3ul << SYS_GPD_MFPL_PD2MFP_Pos)        /*!< GPD_MFPL PD2 setting for T0_EXT*/
N#define SYS_GPD_MFPL_PD2MFP_TK11            (4ul << SYS_GPD_MFPL_PD2MFP_Pos)        /*!< GPD_MFPL PD2 setting for TK11*/
N#define SYS_GPD_MFPL_PD2MFP_ACMP1_P1        (5ul << SYS_GPD_MFPL_PD2MFP_Pos)        /*!< GPD_MFPL PD2 setting for ACMP1_P1*/
N#define SYS_GPD_MFPL_PD2MFP_PWM0_BRAKE0     (6ul << SYS_GPD_MFPL_PD2MFP_Pos)        /*!< GPD_MFPL PD2 setting for PWM0_BRAKE0*/
N#define SYS_GPD_MFPL_PD2MFP_EBI_nWR         (7ul << SYS_GPD_MFPL_PD2MFP_Pos)        /*!< GPD_MFPL PD2 setting for EBI_nWR*/
N#define SYS_GPD_MFPL_PD2MFP_INT0            (8ul << SYS_GPD_MFPL_PD2MFP_Pos)        /*!< GPD_MFPL PD2 setting for INT0*/
N
N//PD3
N#define SYS_GPD_MFPL_PD3MFP_GPIO            (0ul << SYS_GPD_MFPL_PD3MFP_Pos)        /*!< GPD_MFPL PD3 setting for GPIO*/
N#define SYS_GPD_MFPL_PD3MFP_T2              (1ul << SYS_GPD_MFPL_PD3MFP_Pos)        /*!< GPD_MFPL PD3 setting for T2*/
N#define SYS_GPD_MFPL_PD3MFP_T1_EXT          (3ul << SYS_GPD_MFPL_PD3MFP_Pos)        /*!< GPD_MFPL PD3 setting for T1_EXT*/
N#define SYS_GPD_MFPL_PD3MFP_TK12            (4ul << SYS_GPD_MFPL_PD3MFP_Pos)        /*!< GPD_MFPL PD3 setting for TK12*/
N#define SYS_GPD_MFPL_PD3MFP_ACMP1_P0        (5ul << SYS_GPD_MFPL_PD3MFP_Pos)        /*!< GPD_MFPL PD3 setting for ACMP1_P0*/
N#define SYS_GPD_MFPL_PD3MFP_PWM0_BRAKE1     (6ul << SYS_GPD_MFPL_PD3MFP_Pos)        /*!< GPD_MFPL PD3 setting for PWM0_BRAKE1*/
N#define SYS_GPD_MFPL_PD3MFP_EBI_MCLK        (7ul << SYS_GPD_MFPL_PD3MFP_Pos)        /*!< GPD_MFPL PD3 setting for EBI_MCLK*/
N#define SYS_GPD_MFPL_PD3MFP_INT1            (8ul << SYS_GPD_MFPL_PD3MFP_Pos)        /*!< GPD_MFPL PD3 setting for INT1*/
N
N//PD4
N#define SYS_GPD_MFPL_PD4MFP_GPIO            (0ul << SYS_GPD_MFPL_PD4MFP_Pos)        /*!< GPD_MFPL PD4 setting for GPIO*/
N#define SYS_GPD_MFPL_PD4MFP_SPI1_CLK        (2ul << SYS_GPD_MFPL_PD4MFP_Pos)        /*!< GPD_MFPL PD4 setting for SPI1_CLK*/
N#define SYS_GPD_MFPL_PD4MFP_I2C0_SDA        (3ul << SYS_GPD_MFPL_PD4MFP_Pos)        /*!< GPD_MFPL PD4 setting for I2C0_SDA*/
N#define SYS_GPD_MFPL_PD4MFP_TK13            (4ul << SYS_GPD_MFPL_PD4MFP_Pos)        /*!< GPD_MFPL PD4 setting for TK13*/
N#define SYS_GPD_MFPL_PD4MFP_PWM0_BRAKE0     (5ul << SYS_GPD_MFPL_PD4MFP_Pos)        /*!< GPD_MFPL PD4 setting for PWM0_BRAKE0*/
N#define SYS_GPD_MFPL_PD4MFP_T0              (6ul << SYS_GPD_MFPL_PD4MFP_Pos)        /*!< GPD_MFPL PD4 setting for T0*/
N
N//PD5
N#define SYS_GPD_MFPL_PD5MFP_GPIO            (0ul << SYS_GPD_MFPL_PD5MFP_Pos)        /*!< GPD_MFPL PD5 setting for GPIO*/
N#define SYS_GPD_MFPL_PD5MFP_CLKO            (1ul << SYS_GPD_MFPL_PD5MFP_Pos)        /*!< GPD_MFPL PD5 setting for CLKO*/
N#define SYS_GPD_MFPL_PD5MFP_SPI1_MISO       (2ul << SYS_GPD_MFPL_PD5MFP_Pos)        /*!< GPD_MFPL PD5 setting for SPI1_MISO*/
N#define SYS_GPD_MFPL_PD5MFP_I2C0_SCL        (3ul << SYS_GPD_MFPL_PD5MFP_Pos)        /*!< GPD_MFPL PD5 setting for I2C0_SCL*/
N#define SYS_GPD_MFPL_PD5MFP_TK14            (4ul << SYS_GPD_MFPL_PD5MFP_Pos)        /*!< GPD_MFPL PD5 setting for TK14*/
N#define SYS_GPD_MFPL_PD5MFP_PWM0_BRAKE1     (5ul << SYS_GPD_MFPL_PD5MFP_Pos)        /*!< GPD_MFPL PD5 setting for PWM0_BRAKE1*/
N#define SYS_GPD_MFPL_PD5MFP_T1              (6ul << SYS_GPD_MFPL_PD5MFP_Pos)        /*!< GPD_MFPL PD5 setting for T1*/
N
N//PD6
N#define SYS_GPD_MFPL_PD6MFP_GPIO            (0ul << SYS_GPD_MFPL_PD6MFP_Pos)        /*!< GPD_MFPL PD6 setting for GPIO*/
N#define SYS_GPD_MFPL_PD6MFP_CLKO            (1ul << SYS_GPD_MFPL_PD6MFP_Pos)        /*!< GPD_MFPL PD6 setting for CLKO*/
N#define SYS_GPD_MFPL_PD6MFP_SPI1_SS         (2ul << SYS_GPD_MFPL_PD6MFP_Pos)        /*!< GPD_MFPL PD6 setting for SPI1_SS*/
N#define SYS_GPD_MFPL_PD6MFP_UART0_RXD       (3ul << SYS_GPD_MFPL_PD6MFP_Pos)        /*!< GPD_MFPL PD6 setting for UART0_RXD*/
N#define SYS_GPD_MFPL_PD6MFP_TK16            (4ul << SYS_GPD_MFPL_PD6MFP_Pos)        /*!< GPD_MFPL PD6 setting for TK16*/
N#define SYS_GPD_MFPL_PD6MFP_ACMP0_O         (5ul << SYS_GPD_MFPL_PD6MFP_Pos)        /*!< GPD_MFPL PD6 setting for ACMP0_O*/
N#define SYS_GPD_MFPL_PD6MFP_PWM0_CH5        (6ul << SYS_GPD_MFPL_PD6MFP_Pos)        /*!< GPD_MFPL PD6 setting for PWM0_CH5*/
N#define SYS_GPD_MFPL_PD6MFP_EBI_nWR         (7ul << SYS_GPD_MFPL_PD6MFP_Pos)        /*!< GPD_MFPL PD6 setting for EBI_nWR*/
N
N//PD7
N#define SYS_GPD_MFPL_PD7MFP_GPIO           (0ul << SYS_GPD_MFPL_PD7MFP_Pos)        /*!< GPD_MFPL PD7 setting for GPIO*/
N#define SYS_GPD_MFPL_PD7MFP_PWM0_SYNC_IN   (3ul << SYS_GPD_MFPL_PD7MFP_Pos)        /*!< GPD_MFPL PD7 setting for PWM0_SYNC_IN*/
N#define SYS_GPD_MFPL_PD7MFP_T1             (4ul << SYS_GPD_MFPL_PD7MFP_Pos)        /*!< GPD_MFPL PD7 setting for T1*/
N#define SYS_GPD_MFPL_PD7MFP_ACMP0_O        (5ul << SYS_GPD_MFPL_PD7MFP_Pos)        /*!< GPD_MFPL PD7 setting for ACMP0_O*/
N#define SYS_GPD_MFPL_PD7MFP_PWM0_CH5       (6ul << SYS_GPD_MFPL_PD7MFP_Pos)        /*!< GPD_MFPL PD7 setting for PWM0_CH5*/
N#define SYS_GPD_MFPL_PD7MFP_EBI_nRD        (7ul << SYS_GPD_MFPL_PD7MFP_Pos)        /*!< GPD_MFPL PD7 setting for EBI_nRD*/
N
N//PD8
N#define SYS_GPD_MFPH_PD8MFP_GPIO               (0ul << SYS_GPD_MFPH_PD8MFP_Pos)        /*!< GPD_MFPH PD8 setting for GPIO*/
N#define SYS_GPD_MFPH_PD8MFP_EADC_CH7           (1ul << SYS_GPD_MFPH_PD8MFP_Pos)        /*!< GPD_MFPH PD8 setting for EADC_CH7*/
N#define SYS_GPD_MFPH_PD8MFP_TK8                (4ul << SYS_GPD_MFPH_PD8MFP_Pos)        /*!< GPD_MFPH PD8 setting for TK8*/
N#define SYS_GPD_MFPH_PD8MFP_EBI_nCS0           (7ul << SYS_GPD_MFPH_PD8MFP_Pos)        /*!< GPD_MFPH PD8 setting for EBI_nCS0*/
N
N//PD9
N#define SYS_GPD_MFPH_PD9MFP_GPIO               (0ul << SYS_GPD_MFPH_PD9MFP_Pos)        /*!< GPD_MFPH PD9 setting for GPIO*/
N#define SYS_GPD_MFPH_PD9MFP_EADC_CH10          (1ul << SYS_GPD_MFPH_PD9MFP_Pos)        /*!< GPD_MFPH PD9 setting for EADC_CH10*/
N#define SYS_GPD_MFPH_PD9MFP_TK9                (4ul << SYS_GPD_MFPH_PD9MFP_Pos)        /*!< GPD_MFPH PD9 setting for TK9*/
N#define SYS_GPD_MFPH_PD9MFP_ACMP1_P3           (5ul << SYS_GPD_MFPH_PD9MFP_Pos)        /*!< GPD_MFPH PD9 setting for ACMP1_P3*/
N#define SYS_GPD_MFPH_PD9MFP_EBI_ALE            (7ul << SYS_GPD_MFPH_PD9MFP_Pos)        /*!< GPD_MFPH PD9 setting for EBI_ALE*/
N
N//PD10
N#define SYS_GPD_MFPH_PD10MFP_GPIO              (0ul << SYS_GPD_MFPH_PD10MFP_Pos)        /*!< GPD_MFPH PD10 setting for GPIO*/
N#define SYS_GPD_MFPH_PD10MFP_T2                (4ul << SYS_GPD_MFPH_PD10MFP_Pos)        /*!< GPD_MFPH PD10 setting for T2*/
N
N//PD11
N#define SYS_GPD_MFPH_PD11MFP_GPIO              (0ul << SYS_GPD_MFPH_PD11MFP_Pos)        /*!< GPD_MFPH PD11 setting for GPIO*/
N#define SYS_GPD_MFPH_PD11MFP_T3                (4ul << SYS_GPD_MFPH_PD11MFP_Pos)        /*!< GPD_MFPH PD11 setting for T3*/
N
N//PD12
N#define SYS_GPD_MFPH_PD12MFP_GPIO              (0ul << SYS_GPD_MFPH_PD12MFP_Pos)        /*!< GPD_MFPH PD12 setting for GPIO*/
N#define SYS_GPD_MFPH_PD12MFP_SPI2_SS           (2ul << SYS_GPD_MFPH_PD12MFP_Pos)        /*!< GPD_MFPH PD12 setting for SPI2_SS*/
N#define SYS_GPD_MFPH_PD12MFP_UART3_TXD         (3ul << SYS_GPD_MFPH_PD12MFP_Pos)        /*!< GPD_MFPH PD12 setting for UART3_TXD*/
N#define SYS_GPD_MFPH_PD12MFP_PWM1_CH0          (6ul << SYS_GPD_MFPH_PD12MFP_Pos)        /*!< GPD_MFPH PD12 setting for PWM1_CH0*/
N#define SYS_GPD_MFPH_PD12MFP_EBI_ADR16         (7ul << SYS_GPD_MFPH_PD12MFP_Pos)        /*!< GPD_MFPH PD12 setting for EBI_ADR16*/
N
N//PD13
N#define SYS_GPD_MFPH_PD13MFP_GPIO              (0ul << SYS_GPD_MFPH_PD13MFP_Pos)        /*!< GPD_MFPH PD13 setting for GPIO*/
N#define SYS_GPD_MFPH_PD13MFP_SPI2_MOSI         (2ul << SYS_GPD_MFPH_PD13MFP_Pos)        /*!< GPD_MFPH PD13 setting for SPI2_MOSI*/
N#define SYS_GPD_MFPH_PD13MFP_UART3_RXD         (3ul << SYS_GPD_MFPH_PD13MFP_Pos)        /*!< GPD_MFPH PD13 setting for UART3_RXD*/
N#define SYS_GPD_MFPH_PD13MFP_PWM1_CH1          (6ul << SYS_GPD_MFPH_PD13MFP_Pos)        /*!< GPD_MFPH PD13 setting for PWM1_CH1*/
N#define SYS_GPD_MFPH_PD13MFP_EBI_ADR17         (7ul << SYS_GPD_MFPH_PD13MFP_Pos)        /*!< GPD_MFPH PD13 setting for EBI_ADR17*/
N
N//PD14
N#define SYS_GPD_MFPH_PD14MFP_GPIO              (0ul << SYS_GPD_MFPH_PD14MFP_Pos)        /*!< GPD_MFPH_ PD14 setting for GPIO*/
N#define SYS_GPD_MFPH_PD14MFP_SPI2_MISO         (2ul << SYS_GPD_MFPH_PD14MFP_Pos)        /*!< GPD_MFPH_ PD14 setting for SPI2_MISO*/
N#define SYS_GPD_MFPH_PD14MFP_UART3_nCTS        (3ul << SYS_GPD_MFPH_PD14MFP_Pos)        /*!< GPD_MFPH_ PD14 setting for UART3_nCTS*/
N#define SYS_GPD_MFPH_PD14MFP_PWM1_CH2          (6ul << SYS_GPD_MFPH_PD14MFP_Pos)        /*!< GPD_MFPH_ PD14 setting for PWM1_CH2*/
N#define SYS_GPD_MFPH_PD14MFP_EBI_ADR18         (7ul << SYS_GPD_MFPH_PD14MFP_Pos)        /*!< GPD_MFPH_ PD14 setting for EBI_ADR18*/
N
N//PD15
N#define SYS_GPD_MFPH_PD15MFP_GPIO              (0ul << SYS_GPD_MFPH_PD15MFP_Pos)        /*!< GPD_MFPH_ PD15 setting for GPIO*/
N#define SYS_GPD_MFPH_PD15MFP_SPI2_CLK          (2ul << SYS_GPD_MFPH_PD15MFP_Pos)        /*!< GPD_MFPH_ PD15 setting for SPI2_CLK*/
N#define SYS_GPD_MFPH_PD15MFP_UART3_nRTS        (3ul << SYS_GPD_MFPH_PD15MFP_Pos)        /*!< GPD_MFPH_ PD15 setting for UART3_nRTS*/
N#define SYS_GPD_MFPH_PD15MFP_PWM1_CH3          (6ul << SYS_GPD_MFPH_PD15MFP_Pos)        /*!< GPD_MFPH_ PD15 setting for PWM1_CH3*/
N#define SYS_GPD_MFPH_PD15MFP_EBI_ADR19         (7ul << SYS_GPD_MFPH_PD15MFP_Pos)        /*!< GPD_MFPH_ PD15 setting for EBI_ADR19*/
N
N//PE0
N#define SYS_GPE_MFPL_PE0MFP_GPIO               (0ul << SYS_GPE_MFPL_PE0MFP_Pos)        /*!< GPE_MFPL PE0 setting for GPIO*/
N#define SYS_GPE_MFPL_PE0MFP_SPI2_CLK           (2ul << SYS_GPE_MFPL_PE0MFP_Pos)        /*!< GPE_MFPL PE0 setting for SPI2_CLK*/
N#define SYS_GPE_MFPL_PE0MFP_I2C1_SDA           (3ul << SYS_GPE_MFPL_PE0MFP_Pos)        /*!< GPE_MFPL PE0 setting for I2C1_SDA*/
N#define SYS_GPE_MFPL_PE0MFP_T2_EXT             (4ul << SYS_GPE_MFPL_PE0MFP_Pos)        /*!< GPE_MFPL PE0 setting for T2_EXT*/
N#define SYS_GPE_MFPL_PE0MFP_SC0_CD             (5ul << SYS_GPE_MFPL_PE0MFP_Pos)        /*!< GPE_MFPL PE0 setting for SC0_CD*/
N#define SYS_GPE_MFPL_PE0MFP_PWM0_CH0           (6ul << SYS_GPE_MFPL_PE0MFP_Pos)        /*!< GPE_MFPL PE0 setting for PWM0_CH0*/
N#define SYS_GPE_MFPL_PE0MFP_EBI_nCS1           (7ul << SYS_GPE_MFPL_PE0MFP_Pos)        /*!< GPE_MFPL PE0 setting for EBI_nCS1*/
N#define SYS_GPE_MFPL_PE0MFP_INT4               (8ul << SYS_GPE_MFPL_PE0MFP_Pos)        /*!< GPE_MFPL PE0 setting for INT4*/
N
N//PE1
N#define SYS_GPE_MFPL_PE1MFP_GPIO               (0ul << SYS_GPE_MFPL_PE1MFP_Pos)        /*!< GPE_MFPL PE1 setting for GPIO*/
N#define SYS_GPE_MFPL_PE1MFP_T3_EXT             (3ul << SYS_GPE_MFPL_PE1MFP_Pos)        /*!< GPE_MFPL PE1 setting for T3_EXT*/
N#define SYS_GPE_MFPL_PE1MFP_SC0_CD             (5ul << SYS_GPE_MFPL_PE1MFP_Pos)        /*!< GPE_MFPL PE1 setting for SC0_CD*/
N#define SYS_GPE_MFPL_PE1MFP_PWM0_CH1           (6ul << SYS_GPE_MFPL_PE1MFP_Pos)        /*!< GPE_MFPL PE1 setting for PWM0_CH1*/
N
N//PE2
N#define SYS_GPE_MFPL_PE2MFP_GPIO               (0ul << SYS_GPE_MFPL_PE2MFP_Pos)        /*!< GPE_MFPL PE2 setting for GPIO*/
N#define SYS_GPE_MFPL_PE2MFP_PWM1_CH1           (6ul << SYS_GPE_MFPL_PE2MFP_Pos)        /*!< GPE_MFPL PE2 setting for PWM1_CH1*/
N
N//PE3
N#define SYS_GPE_MFPL_PE3MFP_GPIO               (0ul << SYS_GPE_MFPL_PE3MFP_Pos)        /*!< GPE_MFPL PE3 setting for GPIO*/
N#define SYS_GPE_MFPL_PE3MFP_SPI1_MOSI          (2ul << SYS_GPE_MFPL_PE3MFP_Pos)        /*!< GPE_MFPL PE3 setting for SPI1_MOSI*/
N#define SYS_GPE_MFPL_PE3MFP_TK15               (4ul << SYS_GPE_MFPL_PE3MFP_Pos)        /*!< GPE_MFPL PE3 setting for TK15*/
N#define SYS_GPE_MFPL_PE3MFP_PWM0_CH3           (6ul << SYS_GPE_MFPL_PE3MFP_Pos)        /*!< GPE_MFPL PE3 setting for PWM0_CH3*/
N
N//PE4
N#define SYS_GPE_MFPL_PE4MFP_GPIO               (0ul << SYS_GPE_MFPL_PE4MFP_Pos)        /*!< GPE_MFPL PE4 setting for GPIO*/
N#define SYS_GPE_MFPL_PE4MFP_I2C1_SCL           (3ul << SYS_GPE_MFPL_PE4MFP_Pos)        /*!< GPE_MFPL PE4 setting for I2C1_SCL*/
N#define SYS_GPE_MFPL_PE4MFP_SC0_PWR            (5ul << SYS_GPE_MFPL_PE4MFP_Pos)        /*!< GPE_MFPL PE4 setting for SC0_PWR*/
N#define SYS_GPE_MFPL_PE4MFP_PWM1_BRAKE0        (6ul << SYS_GPE_MFPL_PE4MFP_Pos)        /*!< GPE_MFPL PE4 setting for PWM1_BRAKE0*/
N#define SYS_GPE_MFPL_PE4MFP_EBI_nCS0           (7ul << SYS_GPE_MFPL_PE4MFP_Pos)        /*!< GPE_MFPL PE4 setting for EBI_nCS0*/
N#define SYS_GPE_MFPL_PE4MFP_INT0               (8ul << SYS_GPE_MFPL_PE4MFP_Pos)        /*!< GPE_MFPL PE4 setting for INT0*/
N
N//PE5
N#define SYS_GPE_MFPL_PE5MFP_GPIO               (0ul << SYS_GPE_MFPL_PE5MFP_Pos)        /*!< GPE_MFPL PE5 setting for GPIO*/
N#define SYS_GPE_MFPL_PE5MFP_I2C1_SDA           (3ul << SYS_GPE_MFPL_PE5MFP_Pos)        /*!< GPE_MFPL PE5 setting for I2C1_SDA*/
N#define SYS_GPE_MFPL_PE5MFP_SC0_RST            (5ul << SYS_GPE_MFPL_PE5MFP_Pos)        /*!< GPE_MFPL PE5 setting for SC0_RST*/
N#define SYS_GPE_MFPL_PE5MFP_PWM1_BRAKE1        (6ul << SYS_GPE_MFPL_PE5MFP_Pos)        /*!< GPE_MFPL PE5 setting for PWM1_BRAKE1*/
N#define SYS_GPE_MFPL_PE5MFP_EBI_ALE            (7ul << SYS_GPE_MFPL_PE5MFP_Pos)        /*!< GPE_MFPL PE5 setting for EBI_ALE*/
N#define SYS_GPE_MFPL_PE5MFP_INT1               (8ul << SYS_GPE_MFPL_PE5MFP_Pos)        /*!< GPE_MFPL PE5 setting for INT1*/
N
N//PE6
N#define SYS_GPE_MFPL_PE6MFP_GPIO               (0ul << SYS_GPE_MFPL_PE6MFP_Pos)        /*!< GPE_MFPL PE6 setting for GPIO*/
N#define SYS_GPE_MFPL_PE6MFP_T3_EXT             (3ul << SYS_GPE_MFPL_PE6MFP_Pos)        /*!< GPE_MFPL PE6 setting for T3_EXT*/
N
N//PE7
N#define SYS_GPE_MFPL_PE7MFP_GPIO               (0ul << SYS_GPE_MFPL_PE7MFP_Pos)        /*!< GPE_MFPL PE7 setting for GPIO*/
N
N//PE8
N#define SYS_GPE_MFPH_PE8MFP_GPIO               (0ul << SYS_GPE_MFPH_PE8MFP_Pos)        /*!< GPE_MFPH PE8 setting for GPIO*/
N#define SYS_GPE_MFPH_PE8MFP_UART1_TXD          (1ul << SYS_GPE_MFPH_PE8MFP_Pos)        /*!< GPE_MFPH PE8 setting for UART1_TXD*/
N#define SYS_GPE_MFPH_PE8MFP_SPI0_MISO1         (2ul << SYS_GPE_MFPH_PE8MFP_Pos)        /*!< GPE_MFPH PE8 setting for SPI0_MISO1*/
N#define SYS_GPE_MFPH_PE8MFP_I2C1_SCL           (4ul << SYS_GPE_MFPH_PE8MFP_Pos)        /*!< GPE_MFPH PE8 setting for I2C1_SCL*/
N#define SYS_GPE_MFPH_PE8MFP_SC0_PWR            (5ul << SYS_GPE_MFPH_PE8MFP_Pos)        /*!< GPE_MFPH PE8 setting for SC0_PWR*/
N#define SYS_GPE_MFPH_PE8MFP_CLKO               (9ul << SYS_GPE_MFPH_PE8MFP_Pos)        /*!< GPE_MFPH PE8 setting for CLKO*/
N#define SYS_GPE_MFPH_PE8MFP_PWM0_BRAKE0        (10ul << SYS_GPE_MFPH_PE8MFP_Pos)       /*!< GPE_MFPH PE8 setting for PWM0_BRAKE0*/
N#define SYS_GPE_MFPH_PE8MFP_T1                 (11ul << SYS_GPE_MFPH_PE8MFP_Pos)       /*!< GPE_MFPH PE8 setting for T1*/
N
N//PE9
N#define SYS_GPE_MFPH_PE9MFP_GPIO               (0ul << SYS_GPE_MFPH_PE9MFP_Pos)        /*!< GPE_MFPH PE9 setting for GPIO*/
N#define SYS_GPE_MFPH_PE9MFP_UART1_RXD          (1ul << SYS_GPE_MFPH_PE9MFP_Pos)        /*!< GPE_MFPH PE9 setting for UART1_RXD*/
N#define SYS_GPE_MFPH_PE9MFP_SPI0_MOSI1         (2ul << SYS_GPE_MFPH_PE9MFP_Pos)        /*!< GPE_MFPH PE9 setting for SPI0_MOSI1*/
N#define SYS_GPE_MFPH_PE9MFP_I2C1_SDA           (4ul << SYS_GPE_MFPH_PE9MFP_Pos)        /*!< GPE_MFPH PE9 setting for I2C1_SDA*/
N#define SYS_GPE_MFPH_PE9MFP_SC0_RST            (5ul << SYS_GPE_MFPH_PE9MFP_Pos)        /*!< GPE_MFPH PE9 setting for SC0_RST*/
N#define SYS_GPE_MFPH_PE9MFP_SPI1_I2SMCLK       (9ul << SYS_GPE_MFPH_PE9MFP_Pos)        /*!< GPE_MFPH PE9 setting for SPI1_I2SMCLK*/
N#define SYS_GPE_MFPH_PE9MFP_PWM1_BRAKE1        (10ul << SYS_GPE_MFPH_PE9MFP_Pos)       /*!< GPE_MFPH PE9 setting for PWM1_BRAKE1*/
N#define SYS_GPE_MFPH_PE9MFP_T2                 (11ul << SYS_GPE_MFPH_PE9MFP_Pos)       /*!< GPE_MFPH PE9 setting for T2*/
N
N//PE10
N#define SYS_GPE_MFPH_PE10MFP_GPIO              (0ul << SYS_GPE_MFPH_PE10MFP_Pos)        /*!< GPE_MFPH PE10 setting for GPIO*/
N#define SYS_GPE_MFPH_PE10MFP_SPI1_MISO         (1ul << SYS_GPE_MFPH_PE10MFP_Pos)        /*!< GPE_MFPH PE10 setting for SPI1_MISO*/
N#define SYS_GPE_MFPH_PE10MFP_SPI0_MISO0        (2ul << SYS_GPE_MFPH_PE10MFP_Pos)        /*!< GPE_MFPH PE10 setting for SPI0_MISO0*/
N#define SYS_GPE_MFPH_PE10MFP_UART1_nCTS        (3ul << SYS_GPE_MFPH_PE10MFP_Pos)        /*!< GPE_MFPH PE10 setting for UART1_nCTS*/
N#define SYS_GPE_MFPH_PE10MFP_I2C0_SMBAL        (4ul << SYS_GPE_MFPH_PE10MFP_Pos)        /*!< GPE_MFPH PE10 setting for I2C0_SMBAL*/
N#define SYS_GPE_MFPH_PE10MFP_SC0_DAT           (5ul << SYS_GPE_MFPH_PE10MFP_Pos)        /*!< GPE_MFPH PE10 setting for SC0_DAT*/
N#define SYS_GPE_MFPH_PE10MFP_UART3_TXD         (9ul << SYS_GPE_MFPH_PE10MFP_Pos)        /*!< GPE_MFPH PE10 setting for UART3_TXD*/
N#define SYS_GPE_MFPH_PE10MFP_I2C1_SCL          (11ul << SYS_GPE_MFPH_PE10MFP_Pos)       /*!< GPE_MFPH PE10 setting for I2C1_SCL*/
N
N//PE11
N#define SYS_GPE_MFPH_PE11MFP_GPIO              (0ul << SYS_GPE_MFPH_PE11MFP_Pos)        /*!< GPE_MFPH PE11 setting for GPIO*/
N#define SYS_GPE_MFPH_PE11MFP_SPI1_MOSI         (1ul << SYS_GPE_MFPH_PE11MFP_Pos)        /*!< GPE_MFPH PE11 setting for SPI1_MOSI*/
N#define SYS_GPE_MFPH_PE11MFP_SPI0_MOSI0        (2ul << SYS_GPE_MFPH_PE11MFP_Pos)        /*!< GPE_MFPH PE11 setting for SPI0_MOSI0*/
N#define SYS_GPE_MFPH_PE11MFP_UART1_nRTS        (3ul << SYS_GPE_MFPH_PE11MFP_Pos)        /*!< GPE_MFPH PE11 setting for UART1_nRTS*/
N#define SYS_GPE_MFPH_PE11MFP_I2C0_SMBSUS       (4ul << SYS_GPE_MFPH_PE11MFP_Pos)        /*!< GPE_MFPH PE11 setting for I2C0_SMBSUS*/
N#define SYS_GPE_MFPH_PE11MFP_SC0_CLK           (5ul << SYS_GPE_MFPH_PE11MFP_Pos)        /*!< GPE_MFPH PE11 setting for SC0_CLK*/
N#define SYS_GPE_MFPH_PE11MFP_UART3_RXD         (9ul << SYS_GPE_MFPH_PE11MFP_Pos)        /*!< GPE_MFPH PE11 setting for UART3_RXD*/
N#define SYS_GPE_MFPH_PE11MFP_I2C1_SDA          (11ul << SYS_GPE_MFPH_PE11MFP_Pos)       /*!< GPE_MFPH PE11 setting for I2C1_SDA*/
N
N//PE12
N#define SYS_GPE_MFPH_PE12MFP_GPIO              (0ul << SYS_GPE_MFPH_PE12MFP_Pos)        /*!< GPE_MFPH PE12 setting for GPIO*/
N#define SYS_GPE_MFPH_PE12MFP_SPI1_SS           (1ul << SYS_GPE_MFPH_PE12MFP_Pos)        /*!< GPE_MFPH PE12 setting for SPI1_SS*/
N#define SYS_GPE_MFPH_PE12MFP_SPI0_SS           (2ul << SYS_GPE_MFPH_PE12MFP_Pos)        /*!< GPE_MFPH PE12 setting for SPI0_SS*/
N#define SYS_GPE_MFPH_PE12MFP_UART1_TXD         (3ul << SYS_GPE_MFPH_PE12MFP_Pos)        /*!< GPE_MFPH PE12 setting for UART1_TXD*/
N#define SYS_GPE_MFPH_PE12MFP_I2C0_SCL          (4ul << SYS_GPE_MFPH_PE12MFP_Pos)        /*!< GPE_MFPH PE12 setting for I2C0_SCL*/
N
N//PE13
N#define SYS_GPE_MFPH_PE13MFP_GPIO              (0ul << SYS_GPE_MFPH_PE13MFP_Pos)        /*!< GPE_MFPH PE13 setting for GPIO*/
N#define SYS_GPE_MFPH_PE13MFP_SPI1_CLK          (1ul << SYS_GPE_MFPH_PE13MFP_Pos)        /*!< GPE_MFPH PE13 setting for SPI1_CLK*/
N#define SYS_GPE_MFPH_PE13MFP_SPI0_CLK          (2ul << SYS_GPE_MFPH_PE13MFP_Pos)        /*!< GPE_MFPH PE13 setting for SPI0_CLK*/
N#define SYS_GPE_MFPH_PE13MFP_UART1_RXD         (3ul << SYS_GPE_MFPH_PE13MFP_Pos)        /*!< GPE_MFPH PE13 setting for UART1_RXD*/
N#define SYS_GPE_MFPH_PE13MFP_I2C0_SDA          (4ul << SYS_GPE_MFPH_PE13MFP_Pos)        /*!< GPE_MFPH PE13 setting for I2C0_SDA*/
N
N//PE14
N#define SYS_GPE_MFPH_PE14MFP_GPIO              (0ul << SYS_GPE_MFPH_PE14MFP_Pos)        /*!< GPE_MFPH PE14 setting for GPIO*/
N
N//PF0
N#define SYS_GPF_MFPL_PF0MFP_GPIO               (0ul << SYS_GPF_MFPL_PF0MFP_Pos)        /*!< GPF_MFPL PF0 setting for GPIO*/
N#define SYS_GPF_MFPL_PF0MFP_X32_OUT            (1ul << SYS_GPF_MFPL_PF0MFP_Pos)        /*!< GPF_MFPL PF0 setting for X32_OUT*/
N#define SYS_GPF_MFPL_PF0MFP_INT5               (8ul << SYS_GPF_MFPL_PF0MFP_Pos)        /*!< GPF_MFPL PF0 setting for INT5*/
N
N//PF1
N#define SYS_GPF_MFPL_PF1MFP_GPIO               (0ul << SYS_GPF_MFPL_PF1MFP_Pos)        /*!< GPF_MFPL PF1 setting for GPIO*/
N#define SYS_GPF_MFPL_PF1MFP_X32_IN             (1ul << SYS_GPF_MFPL_PF1MFP_Pos)        /*!< GPF_MFPL PF1 setting for X32_IN*/
N
N//PF2
N#define SYS_GPF_MFPL_PF2MFP_GPIO               (0ul << SYS_GPF_MFPL_PF2MFP_Pos)        /*!< GPF_MFPL PF2 setting for GPIO*/
N#define SYS_GPF_MFPL_PF2MFP_TAMPER             (1ul << SYS_GPF_MFPL_PF2MFP_Pos)        /*!< GPF_MFPL PF2 setting for TAMPER*/
N
N//PF3
N#define SYS_GPF_MFPL_PF3MFP_GPIO               (0ul << SYS_GPF_MFPL_PF3MFP_Pos)        /*!< GPF_MFPL PF3 setting for GPIO*/
N#define SYS_GPF_MFPL_PF3MFP_XT1_OUT            (1ul << SYS_GPF_MFPL_PF3MFP_Pos)        /*!< GPF_MFPL PF3 setting for XT1_OUT*/
N#define SYS_GPF_MFPL_PF3MFP_I2C1_SCL           (3ul << SYS_GPF_MFPL_PF3MFP_Pos)        /*!< GPF_MFPL PF3 setting for I2C1_SCL*/
N
N//PF4
N#define SYS_GPF_MFPL_PF4MFP_GPIO               (0ul << SYS_GPF_MFPL_PF4MFP_Pos)        /*!< GPF_MFPL PF4 setting for GPIO*/
N#define SYS_GPF_MFPL_PF4MFP_XT1_IN             (1ul << SYS_GPF_MFPL_PF4MFP_Pos)        /*!< GPF_MFPL PF4 setting for XT1_IN*/
N#define SYS_GPF_MFPL_PF4MFP_I2C1_SDA           (3ul << SYS_GPF_MFPL_PF4MFP_Pos)        /*!< GPF_MFPL PF4 setting for I2C1_SDA*/
N
N//PF5
N#define SYS_GPF_MFPL_PF5MFP_GPIO               (0ul << SYS_GPF_MFPL_PF5MFP_Pos)        /*!< GPF_MFPL PF5 setting for GPIO*/
N#define SYS_GPF_MFPL_PF5MFP_ICE_CLK            (1ul << SYS_GPF_MFPL_PF5MFP_Pos)        /*!< GPF_MFPL PF5 setting for ICE_CLK*/
N
N//PF6
N#define SYS_GPF_MFPL_PF6MFP_GPIO               (0ul << SYS_GPF_MFPL_PF6MFP_Pos)        /*!< GPF_MFPL PF6 setting for GPIO*/
N#define SYS_GPF_MFPL_PF6MFP_ICE_DAT            (1ul << SYS_GPF_MFPL_PF6MFP_Pos)        /*!< GPF_MFPL PF6 setting for ICE_DAT*/
N
N//PF7
N#define SYS_GPF_MFPL_PF7MFP_GPIO               (0ul << SYS_GPF_MFPL_PF7MFP_Pos)        /*!< GPF_MFPL PF7 setting for GPIO*/
N
N
N/*@}*/ /* end of group SYS_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup SYS_EXPORTED_FUNCTIONS SYS Exported Functions
N  @{
N*/
N
N
N/**
N  * @brief      Clear Brown-out detector interrupt flag
N  * @param      None
N  * @return     None
N  * @details    This macro clear Brown-out detector interrupt flag.
N  */
N#define SYS_CLEAR_BOD_INT_FLAG()        (SYS->BODCTL |= SYS_BODCTL_BODIF_Msk)
N
N/**
N  * @brief      Set Brown-out detector function to normal mode
N  * @param      None
N  * @return     None
N  * @details    This macro set Brown-out detector to normal mode.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_CLEAR_BOD_LPM()             (SYS->BODCTL &= ~SYS_BODCTL_BODLPM_Msk)
N
N/**
N  * @brief      Disable Brown-out detector function
N  * @param      None
N  * @return     None
N  * @details    This macro disable Brown-out detector function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_DISABLE_BOD()               (SYS->BODCTL &= ~SYS_BODCTL_BODEN_Msk)
N
N/**
N  * @brief      Enable Brown-out detector function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detector function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_ENABLE_BOD()                (SYS->BODCTL |= SYS_BODCTL_BODEN_Msk)
N
N/**
N  * @brief      Get Brown-out detector interrupt flag
N  * @param      None
N  * @retval     0   Brown-out detect interrupt flag is not set.
N  * @retval     >=1 Brown-out detect interrupt flag is set.
N  * @details    This macro get Brown-out detector interrupt flag.
N  */
N#define SYS_GET_BOD_INT_FLAG()          (SYS->BODCTL & SYS_BODCTL_BODIF_Msk)
N
N/**
N  * @brief      Get Brown-out detector status
N  * @param      None
N  * @retval     0   System voltage is higher than BOD threshold voltage setting or BOD function is disabled.
N  * @retval     >=1 System voltage is lower than BOD threshold voltage setting.
N  * @details    This macro get Brown-out detector output status.
N  *             If the BOD function is disabled, this function always return 0.
N  */
N#define SYS_GET_BOD_OUTPUT()            (SYS->BODCTL & SYS_BODCTL_BODOUT_Msk)
N
N/**
N  * @brief      Enable Brown-out detector interrupt function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detector interrupt function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_DISABLE_BOD_RST()           (SYS->BODCTL &= ~SYS_BODCTL_BODRSTEN_Msk)
N
N/**
N  * @brief      Enable Brown-out detector reset function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detect reset function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_ENABLE_BOD_RST()            (SYS->BODCTL |= SYS_BODCTL_BODRSTEN_Msk)
N
N/**
N  * @brief      Set Brown-out detector function low power mode
N  * @param      None
N  * @return     None
N  * @details    This macro set Brown-out detector to low power mode.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_SET_BOD_LPM()               (SYS->BODCTL |= SYS_BODCTL_BODLPM_Msk)
N
N/**
N  * @brief      Set Brown-out detector voltage level
N  * @param[in]  u32Level is Brown-out voltage level. Including :
N  *             - \ref SYS_BODCTL_BODVL_4_5V
N  *             - \ref SYS_BODCTL_BODVL_3_7V
N  *             - \ref SYS_BODCTL_BODVL_2_7V
N  *             - \ref SYS_BODCTL_BODVL_2_2V
N  * @return     None
N  * @details    This macro set Brown-out detector voltage level.
N  *             The write-protection function should be disabled before using this macro.
N  */
N#define SYS_SET_BOD_LEVEL(u32Level)     (SYS->BODCTL = (SYS->BODCTL & ~SYS_BODCTL_BODVL_Msk) | (u32Level))
N
N/**
N  * @brief      Get reset source is from Brown-out detector reset
N  * @param      None
N  * @retval     0   Previous reset source is not from Brown-out detector reset
N  * @retval     >=1 Previous reset source is from Brown-out detector reset
N  * @details    This macro get previous reset source is from Brown-out detect reset or not.
N  */
N#define SYS_IS_BOD_RST()                (SYS->RSTSTS & SYS_RSTSTS_BODRF_Msk)
N
N/**
N  * @brief      Get reset source is from CPU reset
N  * @param      None
N  * @retval     0   Previous reset source is not from CPU reset
N  * @retval     >=1 Previous reset source is from CPU reset
N  * @details    This macro get previous reset source is from CPU reset.
N  */
N#define SYS_IS_CPU_RST()                (SYS->RSTSTS & SYS_RSTSTS_CPURF_Msk)
N
N/**
N  * @brief      Get reset source is from LVR Reset
N  * @param      None     
N  * @retval     0   Previous reset source is not from Low-Voltage-Reset
N  * @retval     >=1 Previous reset source is from Low-Voltage-Reset
N  * @details    This macro get previous reset source is from Low-Voltage-Reset.   
N  */
N#define SYS_IS_LVR_RST()                (SYS->RSTSTS & SYS_RSTSTS_LVRF_Msk)
N
N/**
N  * @brief      Get reset source is from Power-on Reset
N  * @param      None
N  * @retval     0   Previous reset source is not from Power-on Reset
N  * @retval     >=1 Previous reset source is from Power-on Reset
N  * @details    This macro get previous reset source is from Power-on Reset.
N  */
N#define SYS_IS_POR_RST()                (SYS->RSTSTS & SYS_RSTSTS_PORF_Msk)
N
N/**
N  * @brief      Get reset source is from reset pin reset
N  * @param      None
N  * @retval     0   Previous reset source is not from reset pin reset
N  * @retval     >=1 Previous reset source is from reset pin reset
N  * @details    This macro get previous reset source is from reset pin reset.
N  */
N#define SYS_IS_RSTPIN_RST()             (SYS->RSTSTS & SYS_RSTSTS_PINRF_Msk)
N
N/**
N  * @brief      Get reset source is from system reset
N  * @param      None
N  * @retval     0   Previous reset source is not from system reset
N  * @retval     >=1 Previous reset source is from system reset
N  * @details    This macro get previous reset source is from system reset.
N  */
N#define SYS_IS_SYSTEM_RST()             (SYS->RSTSTS & SYS_RSTSTS_SYSRF_Msk)
N
N/**
N  * @brief      Get reset source is from window watch dog reset
N  * @param      None
N  * @retval     0   Previous reset source is not from window watch dog reset
N  * @retval     >=1 Previous reset source is from window watch dog reset
N  * @details    This macro get previous reset source is from window watch dog reset.
N  */
N#define SYS_IS_WDT_RST()                (SYS->RSTSTS & SYS_RSTSTS_WDTRF_Msk)
N
N/**
N  * @brief      Disable Low-Voltage-Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro disable Low-Voltage-Reset function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_DISABLE_LVR()               (SYS->BODCTL &= ~SYS_BODCTL_LVREN_Msk)
N
N/**
N  * @brief      Enable Low-Voltage-Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Low-Voltage-Reset function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_ENABLE_LVR()                (SYS->BODCTL |= SYS_BODCTL_LVREN_Msk)
N
N/**
N  * @brief      Disable Power-on Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro disable Power-on Reset function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_DISABLE_POR()               (SYS->PORCTL = 0x5AA5)
N
N/**
N  * @brief      Enable Power-on Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Power-on Reset function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_ENABLE_POR()                (SYS->PORCTL = 0)
N
N/**
N  * @brief      Clear reset source flag
N  * @param[in]  u32RstSrc is reset source. Including :
N  *             - \ref SYS_RSTSTS_PORF_Msk
N  *             - \ref SYS_RSTSTS_PINRF_Msk
N  *             - \ref SYS_RSTSTS_WDTRF_Msk
N  *             - \ref SYS_RSTSTS_LVRF_Msk
N  *             - \ref SYS_RSTSTS_BODRF_Msk
N  *             - \ref SYS_RSTSTS_SYSRF_Msk
N  *             - \ref SYS_RSTSTS_CPURF_Msk
N  *             - \ref SYS_RSTSTS_CPULKRF_Msk
N  * @return     None
N  * @details    This macro clear reset source flag.
N  */
N#define SYS_CLEAR_RST_SOURCE(u32RstSrc) ((SYS->RSTSTS) = (u32RstSrc) )
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* static inline functions                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N
N
N/**
N  * @brief      Disable register write-protection function
N  * @param      None
N  * @return     None
N  * @details    This function disable register write-protection function.
N  *             To unlock the protected register to allow write access.
N  */
N__STATIC_INLINE void SYS_UnlockReg(void)
Xstatic __inline void SYS_UnlockReg(void)
N{
N    do
N    {
N        SYS->REGLCTL = 0x59;
X        ((SYS_T *) ((0x40000000UL) + 0x00000))->REGLCTL = 0x59;
N        SYS->REGLCTL = 0x16;
X        ((SYS_T *) ((0x40000000UL) + 0x00000))->REGLCTL = 0x16;
N        SYS->REGLCTL = 0x88;
X        ((SYS_T *) ((0x40000000UL) + 0x00000))->REGLCTL = 0x88;
N    }
N    while(SYS->REGLCTL == 0);
X    while(((SYS_T *) ((0x40000000UL) + 0x00000))->REGLCTL == 0);
N}
N
N/**
N  * @brief      Enable register write-protection function
N  * @param      None
N  * @return     None
N  * @details    This function is used to enable register write-protection function.
N  *             To lock the protected register to forbid write access.
N  */
N__STATIC_INLINE void SYS_LockReg(void)
Xstatic __inline void SYS_LockReg(void)
N{
N    SYS->REGLCTL = 0;
X    ((SYS_T *) ((0x40000000UL) + 0x00000))->REGLCTL = 0;
N}
N
N
Nvoid SYS_ClearResetSrc(uint32_t u32Src);
Nuint32_t SYS_GetBODStatus(void);
Nuint32_t SYS_GetResetSrc(void);
Nuint32_t SYS_IsRegLocked(void);
Nuint32_t SYS_ReadPDID(void);
Nvoid SYS_ResetChip(void);
Nvoid SYS_ResetCPU(void);
Nvoid SYS_ResetModule(uint32_t u32ModuleIndex);
Nvoid SYS_EnableBOD(int32_t i32Mode, uint32_t u32BODLevel);
Nvoid SYS_DisableBOD(void);
N
N
N/*@}*/ /* end of group SYS_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group SYS_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif  //__SYS_H__
L 17094 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N#include "clk.h"
L 1 "..\..\..\..\Library\StdDriver\inc\clk.h" 1
N/******************************************************************************
N * @file     CLK.h
N * @version  V3.0
N * $Revision  1 $
N * $Date: 15/08/11 10:26a $
N * @brief    M451 Series CLK Header File
N *
N * @note
N * Copyright (C) 2013~2015 Nuvoton Technology Corp. All rights reserved.
N ******************************************************************************/
N#ifndef __CLK_H__
N#define __CLK_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup CLK_Driver CLK Driver
N  @{
N*/
N
N/** @addtogroup CLK_EXPORTED_CONSTANTS CLK Exported Constants
N  @{
N*/
N
N
N#define FREQ_25MHZ         25000000
N#define FREQ_50MHZ         50000000
N#define FREQ_72MHZ         72000000
N#define FREQ_125MHZ        125000000
N#define FREQ_200MHZ        200000000
N#define FREQ_250MHZ        250000000
N#define FREQ_500MHZ        500000000
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL0 constant definitions.  (Write-protection)                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL0_HCLKSEL_HXT        (0x00UL<<CLK_CLKSEL0_HCLKSEL_Pos) /*!< Setting HCLK clock source as HXT */
N#define CLK_CLKSEL0_HCLKSEL_LXT        (0x01UL<<CLK_CLKSEL0_HCLKSEL_Pos) /*!< Setting HCLK clock source as LXT */
N#define CLK_CLKSEL0_HCLKSEL_PLL        (0x02UL<<CLK_CLKSEL0_HCLKSEL_Pos) /*!< Setting HCLK clock source as PLL */
N#define CLK_CLKSEL0_HCLKSEL_LIRC       (0x03UL<<CLK_CLKSEL0_HCLKSEL_Pos) /*!< Setting HCLK clock source as LIRC */
N#define CLK_CLKSEL0_HCLKSEL_HIRC       (0x07UL<<CLK_CLKSEL0_HCLKSEL_Pos) /*!< Setting HCLK clock source as HIRC */
N
N#define CLK_CLKSEL0_STCLKSEL_HXT       (0x00UL<<CLK_CLKSEL0_STCLKSEL_Pos) /*!< Setting SysTick clock source as HXT */
N#define CLK_CLKSEL0_STCLKSEL_LXT       (0x01UL<<CLK_CLKSEL0_STCLKSEL_Pos) /*!< Setting SysTick clock source as LXT */
N#define CLK_CLKSEL0_STCLKSEL_HXT_DIV2  (0x02UL<<CLK_CLKSEL0_STCLKSEL_Pos) /*!< Setting SysTick clock source as HXT */
N#define CLK_CLKSEL0_STCLKSEL_HCLK_DIV2 (0x03UL<<CLK_CLKSEL0_STCLKSEL_Pos) /*!< Setting SysTick clock source as HCLK/2 */
N#define CLK_CLKSEL0_STCLKSEL_HIRC_DIV2 (0x07UL<<CLK_CLKSEL0_STCLKSEL_Pos) /*!< Setting SysTick clock source as HIRC/2 */
N#define CLK_CLKSEL0_STCLKSEL_HCLK      (0x01UL<<SysTick_CTRL_CLKSOURCE_Pos) /*!< Setting SysTick clock source as HCLK */
N
N#define CLK_CLKSEL0_PCLK0SEL_HCLK      (0x00UL<<CLK_CLKSEL0_PCLK0SEL_Pos) /*!< Setting PCLK0 clock source as HCLK */
N#define CLK_CLKSEL0_PCLK0SEL_HCLK_DIV2 (0x01UL<<CLK_CLKSEL0_PCLK0SEL_Pos) /*!< Setting PCLK0 clock source as HCLK/2 */
N
N#define CLK_CLKSEL0_PCLK1SEL_HCLK      (0x00UL<<CLK_CLKSEL0_PCLK1SEL_Pos) /*!< Setting PCLK1 clock source as HCLK */
N#define CLK_CLKSEL0_PCLK1SEL_HCLK_DIV2 (0x01UL<<CLK_CLKSEL0_PCLK1SEL_Pos) /*!< Setting PCLK1 clock source as HCLK/2 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL1 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL1_WDTSEL_LXT           (0x1UL<<CLK_CLKSEL1_WDTSEL_Pos)  /*!< Setting WDT clock source as LXT */
N#define CLK_CLKSEL1_WDTSEL_PCLK0_DIV2048 (0x2UL<<CLK_CLKSEL1_WDTSEL_Pos)  /*!< Setting WDT clock source as PCLK0/2048 */
N#define CLK_CLKSEL1_WDTSEL_LIRC          (0x3UL<<CLK_CLKSEL1_WDTSEL_Pos)  /*!< Setting WDT clock source as LIRC */
N
N#define CLK_CLKSEL1_TMR0SEL_HXT          (0x0UL<<CLK_CLKSEL1_TMR0SEL_Pos) /*!< Setting Timer 0 clock source as HXT */
N#define CLK_CLKSEL1_TMR0SEL_LXT          (0x1UL<<CLK_CLKSEL1_TMR0SEL_Pos) /*!< Setting Timer 0 clock source as LXT */
N#define CLK_CLKSEL1_TMR0SEL_PCLK0        (0x2UL<<CLK_CLKSEL1_TMR0SEL_Pos) /*!< Setting Timer 0 clock source as PCLK0 */
N#define CLK_CLKSEL1_TMR0SEL_EXT_TRG      (0x3UL<<CLK_CLKSEL1_TMR0SEL_Pos) /*!< Setting Timer 0 clock source as external trigger */
N#define CLK_CLKSEL1_TMR0SEL_LIRC         (0x5UL<<CLK_CLKSEL1_TMR0SEL_Pos) /*!< Setting Timer 0 clock source as LIRC */
N#define CLK_CLKSEL1_TMR0SEL_HIRC         (0x7UL<<CLK_CLKSEL1_TMR0SEL_Pos) /*!< Setting Timer 0 clock source as HIRC */
N
N#define CLK_CLKSEL1_TMR1SEL_HXT          (0x0UL<<CLK_CLKSEL1_TMR1SEL_Pos) /*!< Setting Timer 1 clock source as HXT */
N#define CLK_CLKSEL1_TMR1SEL_LXT          (0x1UL<<CLK_CLKSEL1_TMR1SEL_Pos) /*!< Setting Timer 1 clock source as LXT */
N#define CLK_CLKSEL1_TMR1SEL_PCLK0        (0x2UL<<CLK_CLKSEL1_TMR1SEL_Pos) /*!< Setting Timer 1 clock source as PCLK0 */
N#define CLK_CLKSEL1_TMR1SEL_EXT_TRG      (0x3UL<<CLK_CLKSEL1_TMR1SEL_Pos) /*!< Setting Timer 1 clock source as external trigger */
N#define CLK_CLKSEL1_TMR1SEL_LIRC         (0x5UL<<CLK_CLKSEL1_TMR1SEL_Pos) /*!< Setting Timer 1 clock source as LIRC */
N#define CLK_CLKSEL1_TMR1SEL_HIRC         (0x7UL<<CLK_CLKSEL1_TMR1SEL_Pos) /*!< Setting Timer 1 clock source as HIRC */
N
N#define CLK_CLKSEL1_TMR2SEL_HXT          (0x0UL<<CLK_CLKSEL1_TMR2SEL_Pos) /*!< Setting Timer 2 clock source as HXT */
N#define CLK_CLKSEL1_TMR2SEL_LXT          (0x1UL<<CLK_CLKSEL1_TMR2SEL_Pos) /*!< Setting Timer 2 clock source as LXT */
N#define CLK_CLKSEL1_TMR2SEL_PCLK1        (0x2UL<<CLK_CLKSEL1_TMR2SEL_Pos) /*!< Setting Timer 2 clock source as PCLK1 */
N#define CLK_CLKSEL1_TMR2SEL_EXT_TRG      (0x3UL<<CLK_CLKSEL1_TMR2SEL_Pos) /*!< Setting Timer 2 clock source as external trigger */
N#define CLK_CLKSEL1_TMR2SEL_LIRC         (0x5UL<<CLK_CLKSEL1_TMR2SEL_Pos) /*!< Setting Timer 2 clock source as LIRC */
N#define CLK_CLKSEL1_TMR2SEL_HIRC         (0x7UL<<CLK_CLKSEL1_TMR2SEL_Pos) /*!< Setting Timer 2 clock source as HIRC */
N
N#define CLK_CLKSEL1_TMR3SEL_HXT          (0x0UL<<CLK_CLKSEL1_TMR3SEL_Pos) /*!< Setting Timer 3 clock source as HXT */
N#define CLK_CLKSEL1_TMR3SEL_LXT          (0x1UL<<CLK_CLKSEL1_TMR3SEL_Pos) /*!< Setting Timer 3 clock source as LXT */
N#define CLK_CLKSEL1_TMR3SEL_PCLK1        (0x2UL<<CLK_CLKSEL1_TMR3SEL_Pos) /*!< Setting Timer 3 clock source as PCLK1 */
N#define CLK_CLKSEL1_TMR3SEL_EXT_TRG      (0x3UL<<CLK_CLKSEL1_TMR3SEL_Pos) /*!< Setting Timer 3 clock source as external trigger */
N#define CLK_CLKSEL1_TMR3SEL_LIRC         (0x5UL<<CLK_CLKSEL1_TMR3SEL_Pos) /*!< Setting Timer 3 clock source as LIRC */
N#define CLK_CLKSEL1_TMR3SEL_HIRC         (0x7UL<<CLK_CLKSEL1_TMR3SEL_Pos) /*!< Setting Timer 3 clock source as HIRC */
N
N#define CLK_CLKSEL1_UARTSEL_HXT          (0x0UL<<CLK_CLKSEL1_UARTSEL_Pos) /*!< Setting UART clock source as HXT */
N#define CLK_CLKSEL1_UARTSEL_PLL          (0x1UL<<CLK_CLKSEL1_UARTSEL_Pos) /*!< Setting UART clock source as PLL */
N#define CLK_CLKSEL1_UARTSEL_LXT          (0x2UL<<CLK_CLKSEL1_UARTSEL_Pos) /*!< Setting UART clock source as LXT */
N#define CLK_CLKSEL1_UARTSEL_HIRC         (0x3UL<<CLK_CLKSEL1_UARTSEL_Pos) /*!< Setting UART clock source as HIRC */
N
N#define CLK_CLKSEL1_CLKOSEL_HXT          (0x0UL<<CLK_CLKSEL1_CLKOSEL_Pos) /*!< Setting CLKO clock source as HXT */
N#define CLK_CLKSEL1_CLKOSEL_LXT          (0x1UL<<CLK_CLKSEL1_CLKOSEL_Pos) /*!< Setting CLKO clock source as LXT */
N#define CLK_CLKSEL1_CLKOSEL_HCLK         (0x2UL<<CLK_CLKSEL1_CLKOSEL_Pos) /*!< Setting CLKO clock source as HCLK */
N#define CLK_CLKSEL1_CLKOSEL_HIRC         (0x3UL<<CLK_CLKSEL1_CLKOSEL_Pos) /*!< Setting CLKO clock source as HIRC */
N
N#define CLK_CLKSEL1_WWDTSEL_PCLK0_DIV2048 (0x2UL<<CLK_CLKSEL1_WWDTSEL_Pos) /*!< Setting WWDT clock source as PCLK0/2048 */
N#define CLK_CLKSEL1_WWDTSEL_LIRC          (0x3UL<<CLK_CLKSEL1_WWDTSEL_Pos) /*!< Setting WWDT clock source as LIRC */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL2 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL2_PWM0SEL_PLL            (0x0UL<<CLK_CLKSEL2_PWM0SEL_Pos) /*!< Setting PWM0 clock source as PLL */
N#define CLK_CLKSEL2_PWM0SEL_PCLK0          (0x1UL<<CLK_CLKSEL2_PWM0SEL_Pos) /*!< Setting PWM0 clock source as PCLK0 */
N
N#define CLK_CLKSEL2_PWM1SEL_PLL            (0x0UL<<CLK_CLKSEL2_PWM1SEL_Pos) /*!< Setting PWM1 clock source as PLL */
N#define CLK_CLKSEL2_PWM1SEL_PCLK1          (0x1UL<<CLK_CLKSEL2_PWM1SEL_Pos) /*!< Setting PWM1 clock source as PCLK1 */
N
N#define CLK_CLKSEL2_SPI0SEL_HXT            (0x0UL<<CLK_CLKSEL2_SPI0SEL_Pos) /*!< Setting SPI0 clock source as HXT */
N#define CLK_CLKSEL2_SPI0SEL_PLL            (0x1UL<<CLK_CLKSEL2_SPI0SEL_Pos) /*!< Setting SPI0 clock source as PLL */
N#define CLK_CLKSEL2_SPI0SEL_PCLK0          (0x2UL<<CLK_CLKSEL2_SPI0SEL_Pos) /*!< Setting SPI0 clock source as PCLK0 */
N#define CLK_CLKSEL2_SPI0SEL_HIRC           (0x3UL<<CLK_CLKSEL2_SPI0SEL_Pos) /*!< Setting SPI0 clock source as HIRC */
N
N#define CLK_CLKSEL2_SPI1SEL_HXT            (0x0UL<<CLK_CLKSEL2_SPI1SEL_Pos) /*!< Setting SPI1 clock source as HXT */
N#define CLK_CLKSEL2_SPI1SEL_PLL            (0x1UL<<CLK_CLKSEL2_SPI1SEL_Pos) /*!< Setting SPI1 clock source as PLL */
N#define CLK_CLKSEL2_SPI1SEL_PCLK1          (0x2UL<<CLK_CLKSEL2_SPI1SEL_Pos) /*!< Setting SPI1 clock source as PCLK1 */
N#define CLK_CLKSEL2_SPI1SEL_HIRC           (0x3UL<<CLK_CLKSEL2_SPI1SEL_Pos) /*!< Setting SPI1 clock source as HIRC */
N
N#define CLK_CLKSEL2_SPI2SEL_HXT            (0x0UL<<CLK_CLKSEL2_SPI2SEL_Pos) /*!< Setting SPI2 clock source as HXT */
N#define CLK_CLKSEL2_SPI2SEL_PLL            (0x1UL<<CLK_CLKSEL2_SPI2SEL_Pos) /*!< Setting SPI2 clock source as PLL */
N#define CLK_CLKSEL2_SPI2SEL_PCLK0          (0x2UL<<CLK_CLKSEL2_SPI2SEL_Pos) /*!< Setting SPI2 clock source as PCLK0 */
N#define CLK_CLKSEL2_SPI2SEL_HIRC           (0x3UL<<CLK_CLKSEL2_SPI2SEL_Pos) /*!< Setting SPI2 clock source as HIRC */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL3 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL3_SC0SEL_HXT             (0x0UL<<CLK_CLKSEL3_SC0SEL_Pos) /*!< Setting SC0 clock source as HXT */
N#define CLK_CLKSEL3_SC0SEL_PLL             (0x1UL<<CLK_CLKSEL3_SC0SEL_Pos) /*!< Setting SC0 clock source as PLL */
N#define CLK_CLKSEL3_SC0SEL_PCLK0           (0x2UL<<CLK_CLKSEL3_SC0SEL_Pos) /*!< Setting SC0 clock source as PCLK0 */
N#define CLK_CLKSEL3_SC0SEL_HIRC            (0x3UL<<CLK_CLKSEL3_SC0SEL_Pos) /*!< Setting SC0 clock source as HIRC */
N
N#define CLK_CLKSEL3_RTCSEL_LXT             (0x0UL<<CLK_CLKSEL3_RTCSEL_Pos) /*!< Setting RTC clock source as LXT */
N#define CLK_CLKSEL3_RTCSEL_LIRC            (0x1UL<<CLK_CLKSEL3_RTCSEL_Pos) /*!< Setting RTC clock source as LIRC */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKDIV0 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKDIV0_HCLK(x)     (((x)-1) << CLK_CLKDIV0_HCLKDIV_Pos) /*!< CLKDIV0 Setting for HCLK clock divider. It could be 1~16 */
N#define CLK_CLKDIV0_USB(x)      (((x)-1) << CLK_CLKDIV0_USBDIV_Pos)  /*!< CLKDIV0 Setting for USB clock divider. It could be 1~16 */
N#define CLK_CLKDIV0_UART(x)     (((x)-1) << CLK_CLKDIV0_UARTDIV_Pos) /*!< CLKDIV0 Setting for UART clock divider. It could be 1~16 */
N#define CLK_CLKDIV0_EADC(x)     (((x)-1) << CLK_CLKDIV0_EADCDIV_Pos) /*!< CLKDIV0 Setting for EADC clock divider. It could be 1~256 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKDIV1 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKDIV1_SC0(x)      (((x)-1) << CLK_CLKDIV1_SC0DIV_Pos) /*!< CLKDIV1 Setting for SC0 clock divider. It could be 1~256 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PLLCTL constant definitions. PLL = FIN * NF / NR / NO                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_PLLCTL_PLLSRC_HXT   0x00000000UL    /*!< For PLL clock source is HXT.  3.2MHz < FIN < 150MHz */
N#define CLK_PLLCTL_PLLSRC_HIRC  0x00080000UL    /*!< For PLL clock source is HIRC. 3.2MHz < FIN < 150MHz */
N
N#define CLK_PLLCTL_NF(x)        ((x)-2)         /*!< x must be constant and 2 <= x <= 513. 200MHz < FIN*NF/NR < 500MHz. (FIN*NF/NR > 250MHz is preferred.) */
N#define CLK_PLLCTL_NR(x)        (((x)-2)<<9)    /*!< x must be constant and 2 <= x <= 33.  1.6MHz < FIN/NR < 16MHz */
N
N#define CLK_PLLCTL_NO_1         0x0000UL        /*!< For output divider is 1 */
N#define CLK_PLLCTL_NO_2         0x4000UL        /*!< For output divider is 2 */
N#define CLK_PLLCTL_NO_4         0xC000UL        /*!< For output divider is 4 */
N
N#define CLK_PLLCTL_72MHz_HXT    (CLK_PLLCTL_PLLSRC_HXT  | CLK_PLLCTL_NR(2) | CLK_PLLCTL_NF( 48) | CLK_PLLCTL_NO_4) /*!< Predefined PLLCTL setting for 72MHz PLL output with HXT(12MHz X'tal) */
N#define CLK_PLLCTL_144MHz_HXT   (CLK_PLLCTL_PLLSRC_HXT  | CLK_PLLCTL_NR(2) | CLK_PLLCTL_NF( 48) | CLK_PLLCTL_NO_2) /*!< Predefined PLLCTL setting for 144MHz PLL output with HXT(12MHz X'tal) */
N#define CLK_PLLCTL_72MHz_HIRC   (CLK_PLLCTL_PLLSRC_HIRC | CLK_PLLCTL_NR(4) | CLK_PLLCTL_NF( 52) | CLK_PLLCTL_NO_4) /*!< Predefined PLLCTL setting for 71.8848MHz PLL output with HIRC(22.1184MHz IRC) */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  MODULE constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/* APBCLK(31:30)|CLKSEL(29:28)|CLKSEL_Msk(27:25) |CLKSEL_Pos(24:20)|CLKDIV(19:18)|CLKDIV_Msk(17:10)|CLKDIV_Pos(9:5)|IP_EN_Pos(4:0) */
N
N#define MODULE_APBCLK(x)        (((x) >>30) & 0x3)    /*!< Calculate AHBCLK/APBCLK offset on MODULE index, 0x0:AHBCLK, 0x1:APBCLK0, 0x2:APBCLK1 */
N#define MODULE_CLKSEL(x)        (((x) >>28) & 0x3)    /*!< Calculate CLKSEL offset on MODULE index, 0x0:CLKSEL0, 0x1:CLKSEL1, 0x2:CLKSEL2, 0x3:CLKSEL3 */
N#define MODULE_CLKSEL_Msk(x)    (((x) >>25) & 0x7)    /*!< Calculate CLKSEL mask offset on MODULE index */
N#define MODULE_CLKSEL_Pos(x)    (((x) >>20) & 0x1f)   /*!< Calculate CLKSEL position offset on MODULE index */
N#define MODULE_CLKDIV(x)        (((x) >>18) & 0x3)    /*!< Calculate APBCLK CLKDIV on MODULE index, 0x0:CLKDIV, 0x1:CLKDIV1 */
N#define MODULE_CLKDIV_Msk(x)    (((x) >>10) & 0xff)   /*!< Calculate CLKDIV mask offset on MODULE index */
N#define MODULE_CLKDIV_Pos(x)    (((x) >>5 ) & 0x1f)   /*!< Calculate CLKDIV position offset on MODULE index */
N#define MODULE_IP_EN_Pos(x)     (((x) >>0 ) & 0x1f)   /*!< Calculate APBCLK offset on MODULE index */
N#define MODULE_NoMsk            0x0                 /*!< Not mask on MODULE index */
N#define NA                      MODULE_NoMsk        /*!< Not Available */
N
N#define MODULE_APBCLK_ENC(x)        (((x) & 0x03) << 30)   /*!< MODULE index, 0x0:AHBCLK, 0x1:APBCLK0, 0x2:APBCLK1 */
N#define MODULE_CLKSEL_ENC(x)        (((x) & 0x03) << 28)   /*!< CLKSEL offset on MODULE index, 0x0:CLKSEL0, 0x1:CLKSEL1, 0x2:CLKSEL2, 0x3:CLKSEL3 */
N#define MODULE_CLKSEL_Msk_ENC(x)    (((x) & 0x07) << 25)   /*!< CLKSEL mask offset on MODULE index */
N#define MODULE_CLKSEL_Pos_ENC(x)    (((x) & 0x1f) << 20)   /*!< CLKSEL position offset on MODULE index */
N#define MODULE_CLKDIV_ENC(x)        (((x) & 0x03) << 18)   /*!< APBCLK CLKDIV on MODULE index, 0x0:CLKDIV, 0x1:CLKDIV1 */
N#define MODULE_CLKDIV_Msk_ENC(x)    (((x) & 0xff) << 10)   /*!< CLKDIV mask offset on MODULE index */
N#define MODULE_CLKDIV_Pos_ENC(x)    (((x) & 0x1f) <<  5)   /*!< CLKDIV position offset on MODULE index */
N#define MODULE_IP_EN_Pos_ENC(x)     (((x) & 0x1f) <<  0)   /*!< AHBCLK/APBCLK offset on MODULE index */
N
N
N//AHBCLK
N#define PDMA_MODULE    (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_PDMACKEN_Pos)  |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< PDMA Module */
X#define PDMA_MODULE    (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_PDMACKEN_Pos)  |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define ISP_MODULE     (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_ISPCKEN_Pos)  |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< ISP Module */
X#define ISP_MODULE     (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_ISPCKEN_Pos)  |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define EBI_MODULE     (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_EBICKEN_Pos)  |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< EBI Module */
X#define EBI_MODULE     (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_EBICKEN_Pos)  |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define USBH_MODULE    (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_USBHCKEN_Pos)  |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC(4))     /*!< USBH Module */
X#define USBH_MODULE    (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_USBHCKEN_Pos)  |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC(4))      
N
N#define CRC_MODULE     (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_CRCCKEN_Pos)  |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< CRC Module */
X#define CRC_MODULE     (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_CRCCKEN_Pos)  |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N
N//APBCLK0
N#define WDT_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_WDTCKEN_Pos)  |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 0)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< WDT Module */
X#define WDT_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_WDTCKEN_Pos)  |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 0)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define WWDT_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_WDTCKEN_Pos)  |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(30)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< WWDT Module */
X#define WWDT_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_WDTCKEN_Pos)  |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(30)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define RTC_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_RTCCKEN_Pos)  |\
N                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 8)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< RTC Module */
X#define RTC_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_RTCCKEN_Pos)  |                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 8)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define TMR0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_TMR0CKEN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC( 8)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< TMR0 Module */
X#define TMR0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_TMR0CKEN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC( 8)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define TMR1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_TMR1CKEN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(12)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< TMR1 Module */
X#define TMR1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_TMR1CKEN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(12)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define TMR2_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_TMR2CKEN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(16)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< TMR2 Module */
X#define TMR2_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_TMR2CKEN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(16)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define TMR3_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_TMR3CKEN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(20)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< TMR3 Module */
X#define TMR3_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_TMR3CKEN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(20)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define CLKO_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_CLKOCKEN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(28)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< CLKO Module */
X#define CLKO_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_CLKOCKEN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(28)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define ACMP01_MODULE  (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_ACMP01CKEN_Pos) |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< ACMP01 Module */
X#define ACMP01_MODULE  (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_ACMP01CKEN_Pos) |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define I2C0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_I2C0CKEN_Pos) |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< I2C0 Module */
X#define I2C0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_I2C0CKEN_Pos) |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define I2C1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_I2C1CKEN_Pos) |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< I2C1 Module */
X#define I2C1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_I2C1CKEN_Pos) |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define SPI0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_SPI0CKEN_Pos) |\
N                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 2)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< SPI0 Module */
X#define SPI0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_SPI0CKEN_Pos) |                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 2)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define SPI1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_SPI1CKEN_Pos) |\
N                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 4)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< SPI1 Module */
X#define SPI1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_SPI1CKEN_Pos) |                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 4)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define SPI2_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_SPI2CKEN_Pos) |\
N                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 6)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< SPI2 Module */
X#define SPI2_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_SPI2CKEN_Pos) |                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 6)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define UART0_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_UART0CKEN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))    /*!< UART0 Module */
X#define UART0_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_UART0CKEN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))     
N
N#define UART1_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_UART1CKEN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))    /*!< UART1 Module */
X#define UART1_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_UART1CKEN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))     
N
N#define UART2_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_UART2CKEN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))    /*!< UART2 Module */
X#define UART2_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_UART2CKEN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))     
N
N#define UART3_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_UART3CKEN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))    /*!< UART3 Module */
X#define UART3_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_UART3CKEN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))     
N
N#define CAN0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_CAN0CKEN_Pos) |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< CAN0 Module */
X#define CAN0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_CAN0CKEN_Pos) |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define OTG_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_OTGCKEN_Pos) |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC(4))     /*!< OTG Module */
X#define OTG_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_OTGCKEN_Pos) |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC(4))      
N
N#define USBD_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_USBDCKEN_Pos) |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC(4))     /*!< USBD Module */
X#define USBD_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_USBDCKEN_Pos) |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC(4))      
N
N#define EADC_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_EADCCKEN_Pos)  |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC(16))    /*!< EADC Module */
X#define EADC_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK0_EADCCKEN_Pos)  |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC(16))     
N
N
N//APBCLK1
N#define SC0_MODULE     (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_SC0CKEN_Pos)  |\
N                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 0)|\
N                        MODULE_CLKDIV_ENC( 1)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC( 0))    /*!< SC0 Module */
X#define SC0_MODULE     (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_SC0CKEN_Pos)  |                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 0)|                        MODULE_CLKDIV_ENC( 1)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC( 0))     
N
N#define DAC_MODULE     (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_DACCKEN_Pos)  |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< DAC Module */
X#define DAC_MODULE     (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_DACCKEN_Pos)  |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define PWM0_MODULE    (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_PWM0CKEN_Pos)|\
N                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 0)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< PWM0 Module */
X#define PWM0_MODULE    (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_PWM0CKEN_Pos)|                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 0)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define PWM1_MODULE    (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_PWM1CKEN_Pos)|\
N                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 1)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< PWM1 Module */
X#define PWM1_MODULE    (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_PWM1CKEN_Pos)|                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 1)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define TK_MODULE      (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_TKCKEN_Pos)|\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< TK Module */
X#define TK_MODULE      (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_TKCKEN_Pos)|                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N
N/*@}*/ /* end of group CLK_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup CLK_EXPORTED_FUNCTIONS CLK Exported Functions
N  @{
N*/
N
N
N/**
N  * @brief      Get PLL clock frequency
N  * @param      None
N  * @return     PLL frequency
N  * @details    This function get PLL frequency. The frequency unit is Hz.
N  */
N__STATIC_INLINE uint32_t CLK_GetPLLClockFreq(void)
Xstatic __inline uint32_t CLK_GetPLLClockFreq(void)
N{
N    uint32_t u32PllFreq = 0, u32PllReg;
N    uint32_t u32FIN, u32NF, u32NR, u32NO;
N    uint8_t au8NoTbl[4] = {1, 2, 2, 4};
N
N    u32PllReg = CLK->PLLCTL;
X    u32PllReg = ((CLK_T *) ((0x40000000UL) + 0x00200))->PLLCTL;
N
N    if(u32PllReg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk))
X    if(u32PllReg & ((0x1ul << (16)) | (0x1ul << (18))))
N        return 0;           /* PLL is in power down mode or fix low */
N
N    if(u32PllReg & CLK_PLLCTL_PLLSRC_HIRC)
X    if(u32PllReg & 0x00080000UL)
N        u32FIN = __HIRC;    /* PLL source clock from HIRC */
X        u32FIN = (22118400UL);     
N    else
N        u32FIN = __HXT;     /* PLL source clock from HXT */
X        u32FIN = (12000000UL);      
N
N    if(u32PllReg & CLK_PLLCTL_BP_Msk)
X    if(u32PllReg & (0x1ul << (17)))
N        return u32FIN;      /* PLL is in bypass mode */
N
N    /* PLL is output enabled in normal work mode */
N    u32NO = au8NoTbl[((u32PllReg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
X    u32NO = au8NoTbl[((u32PllReg & (0x3ul << (14))) >> (14))];
N    u32NF = ((u32PllReg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2;
X    u32NF = ((u32PllReg & (0x1fful << (0))) >> (0)) + 2;
N    u32NR = ((u32PllReg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 2;
X    u32NR = ((u32PllReg & (0x1ful << (9))) >> (9)) + 2;
N
N    /* u32FIN is shifted 2 bits to avoid overflow */
N    u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
N
N    return u32PllFreq;
N}
N
N/**
N  * @brief      This function execute delay function.
N  * @param      us  Delay time. The Max value is 2^24 / CPU Clock(MHz). Ex:
N  *                             72MHz => 233016us, 50MHz => 335544us,
N                                48MHz => 349525us, 28MHz => 699050us ...
N  * @return     None
N  * @details    Use the SysTick to generate the delay time and the unit is in us.
N  *             The SysTick clock source is from HCLK, i.e the same as system core clock.
N  */
N__STATIC_INLINE void CLK_SysTickDelay(uint32_t us)
Xstatic __inline void CLK_SysTickDelay(uint32_t us)
N{
N    SysTick->LOAD = us * CyclesPerUs;
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD = us * CyclesPerUs;
N    SysTick->VAL  = (0x00);
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL  = (0x00);
N    SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2) | (1UL << 0);
N
N    /* Waiting for down-count to zero */
N    while((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == 0);
X    while((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL & (1UL << 16)) == 0);
N    
N    /* Disable SysTick counter */
N    SysTick->CTRL = 0;
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = 0;
N}
N
N
Nvoid CLK_DisableCKO(void);
Nvoid CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En);
Nvoid CLK_PowerDown(void);
Nvoid CLK_Idle(void);
Nuint32_t CLK_GetHXTFreq(void);
Nuint32_t CLK_GetLXTFreq(void);
Nuint32_t CLK_GetHCLKFreq(void);
Nuint32_t CLK_GetPCLK0Freq(void);
Nuint32_t CLK_GetPCLK1Freq(void);
Nuint32_t CLK_GetCPUFreq(void);
Nuint32_t CLK_SetCoreClock(uint32_t u32Hclk);
Nvoid CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv);
Nvoid CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv);
Nvoid CLK_SetSysTickClockSrc(uint32_t u32ClkSrc);
Nvoid CLK_EnableXtalRC(uint32_t u32ClkMask);
Nvoid CLK_DisableXtalRC(uint32_t u32ClkMask);
Nvoid CLK_EnableModuleClock(uint32_t u32ModuleIdx);
Nvoid CLK_DisableModuleClock(uint32_t u32ModuleIdx);
Nuint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq);
Nvoid CLK_DisablePLL(void);
Nuint32_t CLK_WaitClockReady(uint32_t u32ClkMask);
Nvoid CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count);
Nvoid CLK_DisableSysTick(void);
N
N
N
N/*@}*/ /* end of group CLK_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group CLK_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif  //__CLK_H__
L 17095 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N#include "gpio.h"
L 1 "..\..\..\..\Library\StdDriver\inc\gpio.h" 1
N/**************************************************************************//**
N * @file     GPIO.h
N * @version  V3.00
N * $Revision: 21 $
N * $Date: 15/08/11 10:26a $
N * @brief    M451 series GPIO driver header file
N *
N * @note
N * Copyright (C) 2011~2015 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __GPIO_H__
N#define __GPIO_H__
N
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup GPIO_Driver GPIO Driver
N  @{
N*/
N
N/** @addtogroup GPIO_EXPORTED_CONSTANTS GPIO Exported Constants
N  @{
N*/
N
N
N#define GPIO_PIN_MAX            16 /*!< Specify Maximum Pins of Each GPIO Port */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  GPIO_MODE Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_MODE_INPUT          0x0UL /*!< Input Mode */
N#define GPIO_MODE_OUTPUT         0x1UL /*!< Output Mode */
N#define GPIO_MODE_OPEN_DRAIN     0x2UL /*!< Open-Drain Mode */
N#define GPIO_MODE_QUASI          0x3UL /*!< Quasi-bidirectional Mode */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  GPIO Interrupt Type Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_INT_RISING         0x00010000UL /*!< Interrupt enable by Input Rising Edge */
N#define GPIO_INT_FALLING        0x00000001UL /*!< Interrupt enable by Input Falling Edge */
N#define GPIO_INT_BOTH_EDGE      0x00010001UL /*!< Interrupt enable by both Rising Edge and Falling Edge */
N#define GPIO_INT_HIGH           0x01010000UL /*!< Interrupt enable by Level-High */
N#define GPIO_INT_LOW            0x01000001UL /*!< Interrupt enable by Level-Level */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  GPIO_INTTYPE Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_INTTYPE_EDGE           0UL /*!< GPIO_INTTYPE Setting for Edge Trigger Mode */
N#define GPIO_INTTYPE_LEVEL          1UL /*!< GPIO_INTTYPE Setting for Edge Level Mode */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  GPIO_DBCTL Constant Definitions                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_DBCTL_ICLK_ON            0x00000020UL /*!< GPIO_DBCTL setting for all IO pins edge detection circuit is always active after reset */
N#define GPIO_DBCTL_ICLK_OFF           0x00000000UL /*!< GPIO_DBCTL setting for edge detection circuit is active only if IO pin corresponding GPIOx_IEN bit is set to 1 */
N
N#define GPIO_DBCTL_DBCLKSRC_LIRC      0x00000010UL /*!< GPIO_DBCTL setting for de-bounce counter clock source is the internal 10 kHz */
N#define GPIO_DBCTL_DBCLKSRC_HCLK      0x00000000UL /*!< GPIO_DBCTL setting for de-bounce counter clock source is the HCLK */
N
N#define GPIO_DBCTL_DBCLKSEL_1         0x00000000UL /*!< GPIO_DBCTL setting for sampling cycle = 1 clocks */
N#define GPIO_DBCTL_DBCLKSEL_2         0x00000001UL /*!< GPIO_DBCTL setting for sampling cycle = 2 clocks */
N#define GPIO_DBCTL_DBCLKSEL_4         0x00000002UL /*!< GPIO_DBCTL setting for sampling cycle = 4 clocks */
N#define GPIO_DBCTL_DBCLKSEL_8         0x00000003UL /*!< GPIO_DBCTL setting for sampling cycle = 8 clocks */
N#define GPIO_DBCTL_DBCLKSEL_16        0x00000004UL /*!< GPIO_DBCTL setting for sampling cycle = 16 clocks */
N#define GPIO_DBCTL_DBCLKSEL_32        0x00000005UL /*!< GPIO_DBCTL setting for sampling cycle = 32 clocks */
N#define GPIO_DBCTL_DBCLKSEL_64        0x00000006UL /*!< GPIO_DBCTL setting for sampling cycle = 64 clocks */
N#define GPIO_DBCTL_DBCLKSEL_128       0x00000007UL /*!< GPIO_DBCTL setting for sampling cycle = 128 clocks */
N#define GPIO_DBCTL_DBCLKSEL_256       0x00000008UL /*!< GPIO_DBCTL setting for sampling cycle = 256 clocks */
N#define GPIO_DBCTL_DBCLKSEL_512       0x00000009UL /*!< GPIO_DBCTL setting for sampling cycle = 512 clocks */
N#define GPIO_DBCTL_DBCLKSEL_1024      0x0000000AUL /*!< GPIO_DBCTL setting for sampling cycle = 1024 clocks */
N#define GPIO_DBCTL_DBCLKSEL_2048      0x0000000BUL /*!< GPIO_DBCTL setting for sampling cycle = 2048 clocks */
N#define GPIO_DBCTL_DBCLKSEL_4096      0x0000000CUL /*!< GPIO_DBCTL setting for sampling cycle = 4096 clocks */
N#define GPIO_DBCTL_DBCLKSEL_8192      0x0000000DUL /*!< GPIO_DBCTL setting for sampling cycle = 8192 clocks */
N#define GPIO_DBCTL_DBCLKSEL_16384     0x0000000EUL /*!< GPIO_DBCTL setting for sampling cycle = 16384 clocks */
N#define GPIO_DBCTL_DBCLKSEL_32768     0x0000000FUL /*!< GPIO_DBCTL setting for sampling cycle = 32768 clocks */
N
N
N/* Define GPIO Pin Data Input/Output. It could be used to control each I/O pin by pin address mapping.
N   Example 1:
N
N       PA0 = 1;
N
N   It is used to set GPIO PA.0 to high;
N
N   Example 2:
N
N       if (PA0)
N           PA0 = 0;
N
N   If GPIO PA.0 pin status is high, then set GPIO PA.0 data output to low.
N */
N#define GPIO_PIN_DATA(port, pin)    (*((volatile uint32_t *)((GPIO_PIN_DATA_BASE+(0x40*(port))) + ((pin)<<2))))
N#define PA0             GPIO_PIN_DATA(0, 0 ) /*!< Specify PA.0 Pin Data Input/Output */
N#define PA1             GPIO_PIN_DATA(0, 1 ) /*!< Specify PA.1 Pin Data Input/Output */
N#define PA2             GPIO_PIN_DATA(0, 2 ) /*!< Specify PA.2 Pin Data Input/Output */
N#define PA3             GPIO_PIN_DATA(0, 3 ) /*!< Specify PA.3 Pin Data Input/Output */
N#define PA4             GPIO_PIN_DATA(0, 4 ) /*!< Specify PA.4 Pin Data Input/Output */
N#define PA5             GPIO_PIN_DATA(0, 5 ) /*!< Specify PA.5 Pin Data Input/Output */
N#define PA6             GPIO_PIN_DATA(0, 6 ) /*!< Specify PA.6 Pin Data Input/Output */
N#define PA7             GPIO_PIN_DATA(0, 7 ) /*!< Specify PA.7 Pin Data Input/Output */
N#define PA8             GPIO_PIN_DATA(0, 8 ) /*!< Specify PA.8 Pin Data Input/Output */
N#define PA9             GPIO_PIN_DATA(0, 9 ) /*!< Specify PA.9 Pin Data Input/Output */
N#define PA10            GPIO_PIN_DATA(0, 10) /*!< Specify PA.10 Pin Data Input/Output */
N#define PA11            GPIO_PIN_DATA(0, 11) /*!< Specify PA.11 Pin Data Input/Output */
N#define PA12            GPIO_PIN_DATA(0, 12) /*!< Specify PA.12 Pin Data Input/Output */
N#define PA13            GPIO_PIN_DATA(0, 13) /*!< Specify PA.13 Pin Data Input/Output */
N#define PA14            GPIO_PIN_DATA(0, 14) /*!< Specify PA.14 Pin Data Input/Output */
N#define PA15            GPIO_PIN_DATA(0, 15) /*!< Specify PA.15 Pin Data Input/Output */
N#define PB0             GPIO_PIN_DATA(1, 0 ) /*!< Specify PB.0 Pin Data Input/Output */
N#define PB1             GPIO_PIN_DATA(1, 1 ) /*!< Specify PB.1 Pin Data Input/Output */
N#define PB2             GPIO_PIN_DATA(1, 2 ) /*!< Specify PB.2 Pin Data Input/Output */
N#define PB3             GPIO_PIN_DATA(1, 3 ) /*!< Specify PB.3 Pin Data Input/Output */
N#define PB4             GPIO_PIN_DATA(1, 4 ) /*!< Specify PB.4 Pin Data Input/Output */
N#define PB5             GPIO_PIN_DATA(1, 5 ) /*!< Specify PB.5 Pin Data Input/Output */
N#define PB6             GPIO_PIN_DATA(1, 6 ) /*!< Specify PB.6 Pin Data Input/Output */
N#define PB7             GPIO_PIN_DATA(1, 7 ) /*!< Specify PB.7 Pin Data Input/Output */
N#define PB8             GPIO_PIN_DATA(1, 8 ) /*!< Specify PB.8 Pin Data Input/Output */
N#define PB9             GPIO_PIN_DATA(1, 9 ) /*!< Specify PB.9 Pin Data Input/Output */
N#define PB10            GPIO_PIN_DATA(1, 10) /*!< Specify PB.10 Pin Data Input/Output */
N#define PB11            GPIO_PIN_DATA(1, 11) /*!< Specify PB.11 Pin Data Input/Output */
N#define PB12            GPIO_PIN_DATA(1, 12) /*!< Specify PB.12 Pin Data Input/Output */
N#define PB13            GPIO_PIN_DATA(1, 13) /*!< Specify PB.13 Pin Data Input/Output */
N#define PB14            GPIO_PIN_DATA(1, 14) /*!< Specify PB.14 Pin Data Input/Output */
N#define PB15            GPIO_PIN_DATA(1, 15) /*!< Specify PB.15 Pin Data Input/Output */
N#define PC0             GPIO_PIN_DATA(2, 0 ) /*!< Specify PC.0 Pin Data Input/Output */
N#define PC1             GPIO_PIN_DATA(2, 1 ) /*!< Specify PC.1 Pin Data Input/Output */
N#define PC2             GPIO_PIN_DATA(2, 2 ) /*!< Specify PC.2 Pin Data Input/Output */
N#define PC3             GPIO_PIN_DATA(2, 3 ) /*!< Specify PC.3 Pin Data Input/Output */
N#define PC4             GPIO_PIN_DATA(2, 4 ) /*!< Specify PC.4 Pin Data Input/Output */
N#define PC5             GPIO_PIN_DATA(2, 5 ) /*!< Specify PC.5 Pin Data Input/Output */
N#define PC6             GPIO_PIN_DATA(2, 6 ) /*!< Specify PC.6 Pin Data Input/Output */
N#define PC7             GPIO_PIN_DATA(2, 7 ) /*!< Specify PC.7 Pin Data Input/Output */
N#define PC8             GPIO_PIN_DATA(2, 8 ) /*!< Specify PC.8 Pin Data Input/Output */
N#define PC9             GPIO_PIN_DATA(2, 9 ) /*!< Specify PC.9 Pin Data Input/Output */
N#define PC10            GPIO_PIN_DATA(2, 10) /*!< Specify PC.10 Pin Data Input/Output */
N#define PC11            GPIO_PIN_DATA(2, 11) /*!< Specify PC.11 Pin Data Input/Output */
N#define PC12            GPIO_PIN_DATA(2, 12) /*!< Specify PC.12 Pin Data Input/Output */
N#define PC13            GPIO_PIN_DATA(2, 13) /*!< Specify PC.13 Pin Data Input/Output */
N#define PC14            GPIO_PIN_DATA(2, 14) /*!< Specify PC.14 Pin Data Input/Output */
N#define PC15            GPIO_PIN_DATA(2, 15) /*!< Specify PC.15 Pin Data Input/Output */
N#define PD0             GPIO_PIN_DATA(3, 0 ) /*!< Specify PD.0 Pin Data Input/Output */
N#define PD1             GPIO_PIN_DATA(3, 1 ) /*!< Specify PD.1 Pin Data Input/Output */
N#define PD2             GPIO_PIN_DATA(3, 2 ) /*!< Specify PD.2 Pin Data Input/Output */
N#define PD3             GPIO_PIN_DATA(3, 3 ) /*!< Specify PD.3 Pin Data Input/Output */
N#define PD4             GPIO_PIN_DATA(3, 4 ) /*!< Specify PD.4 Pin Data Input/Output */
N#define PD5             GPIO_PIN_DATA(3, 5 ) /*!< Specify PD.5 Pin Data Input/Output */
N#define PD6             GPIO_PIN_DATA(3, 6 ) /*!< Specify PD.6 Pin Data Input/Output */
N#define PD7             GPIO_PIN_DATA(3, 7 ) /*!< Specify PD.7 Pin Data Input/Output */
N#define PD8             GPIO_PIN_DATA(3, 8 ) /*!< Specify PD.8 Pin Data Input/Output */
N#define PD9             GPIO_PIN_DATA(3, 9 ) /*!< Specify PD.9 Pin Data Input/Output */
N#define PD10            GPIO_PIN_DATA(3, 10) /*!< Specify PD.10 Pin Data Input/Output */
N#define PD11            GPIO_PIN_DATA(3, 11) /*!< Specify PD.11 Pin Data Input/Output */
N#define PD12            GPIO_PIN_DATA(3, 12) /*!< Specify PD.12 Pin Data Input/Output */
N#define PD13            GPIO_PIN_DATA(3, 13) /*!< Specify PD.13 Pin Data Input/Output */
N#define PD14            GPIO_PIN_DATA(3, 14) /*!< Specify PD.14 Pin Data Input/Output */
N#define PD15            GPIO_PIN_DATA(3, 15) /*!< Specify PD.15 Pin Data Input/Output */
N#define PE0             GPIO_PIN_DATA(4, 0 ) /*!< Specify PE.0 Pin Data Input/Output */
N#define PE1             GPIO_PIN_DATA(4, 1 ) /*!< Specify PE.1 Pin Data Input/Output */
N#define PE2             GPIO_PIN_DATA(4, 2 ) /*!< Specify PE.2 Pin Data Input/Output */
N#define PE3             GPIO_PIN_DATA(4, 3 ) /*!< Specify PE.3 Pin Data Input/Output */
N#define PE4             GPIO_PIN_DATA(4, 4 ) /*!< Specify PE.4 Pin Data Input/Output */
N#define PE5             GPIO_PIN_DATA(4, 5 ) /*!< Specify PE.5 Pin Data Input/Output */
N#define PE6             GPIO_PIN_DATA(4, 6 ) /*!< Specify PE.6 Pin Data Input/Output */
N#define PE7             GPIO_PIN_DATA(4, 7 ) /*!< Specify PE.7 Pin Data Input/Output */
N#define PE8             GPIO_PIN_DATA(4, 8 ) /*!< Specify PE.8 Pin Data Input/Output */
N#define PE9             GPIO_PIN_DATA(4, 9 ) /*!< Specify PE.9 Pin Data Input/Output */
N#define PE10            GPIO_PIN_DATA(4, 10) /*!< Specify PE.10 Pin Data Input/Output */
N#define PE11            GPIO_PIN_DATA(4, 11) /*!< Specify PE.11 Pin Data Input/Output */
N#define PE12            GPIO_PIN_DATA(4, 12) /*!< Specify PE.12 Pin Data Input/Output */
N#define PE13            GPIO_PIN_DATA(4, 13) /*!< Specify PE.13 Pin Data Input/Output */
N#define PE14            GPIO_PIN_DATA(4, 14) /*!< Specify PE.14 Pin Data Input/Output */
N#define PF0             GPIO_PIN_DATA(5, 0 ) /*!< Specify PF.0 Pin Data Input/Output */
N#define PF1             GPIO_PIN_DATA(5, 1 ) /*!< Specify PF.1 Pin Data Input/Output */
N#define PF2             GPIO_PIN_DATA(5, 2 ) /*!< Specify PF.2 Pin Data Input/Output */
N#define PF3             GPIO_PIN_DATA(5, 3 ) /*!< Specify PF.3 Pin Data Input/Output */
N#define PF4             GPIO_PIN_DATA(5, 4 ) /*!< Specify PF.4 Pin Data Input/Output */
N#define PF5             GPIO_PIN_DATA(5, 5 ) /*!< Specify PF.5 Pin Data Input/Output */
N#define PF6             GPIO_PIN_DATA(5, 6 ) /*!< Specify PF.6 Pin Data Input/Output */
N#define PF7             GPIO_PIN_DATA(5, 7 ) /*!< Specify PF.7 Pin Data Input/Output */
N
N
N/*@}*/ /* end of group GPIO_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup GPIO_EXPORTED_FUNCTIONS GPIO Exported Functions
N  @{
N*/
N
N/**
N * @brief       Clear GPIO Pin Interrupt Flag
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC and PD.
N *                          It could be BIT0 ~ BIT14 for PE.
N *                          It could be BIT0 ~ BIT7 for PF.
N *
N * @return      None
N *
N * @details     Clear the interrupt status of specified GPIO pin.
N */
N#define GPIO_CLR_INT_FLAG(port, u32PinMask)         ((port)->INTSRC = (u32PinMask))
N
N/**
N * @brief       Disable Pin De-bounce Function
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC and PD.
N *                          It could be BIT0 ~ BIT14 for PE.
N *                          It could be BIT0 ~ BIT7 for PF.
N *
N * @return      None
N *
N * @details     Disable the interrupt de-bounce function of specified GPIO pin.
N */
N#define GPIO_DISABLE_DEBOUNCE(port, u32PinMask)     ((port)->DBEN &= ~(u32PinMask))
N
N/**
N * @brief       Enable Pin De-bounce Function
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC and PD.
N *                          It could be BIT0 ~ BIT14 for PE.
N *                          It could be BIT0 ~ BIT7 for PF.
N * @return      None
N *
N * @details     Enable the interrupt de-bounce function of specified GPIO pin.
N */
N#define GPIO_ENABLE_DEBOUNCE(port, u32PinMask)      ((port)->DBEN |= (u32PinMask))
N
N/**
N * @brief       Disable I/O Digital Input Path
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC and PD.
N *                          It could be BIT0 ~ BIT14 for PE.
N *                          It could be BIT0 ~ BIT7 for PF.
N *
N * @return      None
N *
N * @details     Disable I/O digital input path of specified GPIO pin.
N */
N#define GPIO_DISABLE_DIGITAL_PATH(port, u32PinMask) ((port)->DINOFF |= ((u32PinMask)<<16))
N
N/**
N * @brief       Enable I/O Digital Input Path
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC and PD.
N *                          It could be BIT0 ~ BIT14 for PE.
N *                          It could be BIT0 ~ BIT7 for PF.
N *
N * @return      None
N *
N * @details     Enable I/O digital input path of specified GPIO pin.
N */
N#define GPIO_ENABLE_DIGITAL_PATH(port, u32PinMask)  ((port)->DINOFF &= ~((u32PinMask)<<16))
N
N/**
N * @brief       Disable I/O DOUT mask
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC and PD.
N *                          It could be BIT0 ~ BIT14 for PE.
N *                          It could be BIT0 ~ BIT7 for PF.
N *
N * @return      None
N *
N * @details     Disable I/O DOUT mask of specified GPIO pin.
N */
N#define GPIO_DISABLE_DOUT_MASK(port, u32PinMask)    ((port)->DATMSK &= ~(u32PinMask))    
N
N/**
N * @brief       Enable I/O DOUT mask
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC and PD.
N *                          It could be BIT0 ~ BIT14 for PE.
N *                          It could be BIT0 ~ BIT7 for PF.
N *
N * @return      None
N *
N * @details     Enable I/O DOUT mask of specified GPIO pin.
N */
N#define GPIO_ENABLE_DOUT_MASK(port, u32PinMask) ((port)->DATMSK |= (u32PinMask))
N
N/**
N * @brief       Get GPIO Pin Interrupt Flag
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC and PD.
N *                          It could be BIT0 ~ BIT14 for PE.
N *                          It could be BIT0 ~ BIT7 for PF.
N *
N * @retval      0           No interrupt at specified GPIO pin
N * @retval      1           The specified GPIO pin generate an interrupt
N *
N * @details     Get the interrupt status of specified GPIO pin.
N */
N#define GPIO_GET_INT_FLAG(port, u32PinMask)     ((port)->INTSRC & (u32PinMask))
N
N/**
N * @brief       Set De-bounce Sampling Cycle Time
N *
N * @param[in]   u32ClkSrc   The de-bounce counter clock source. It could be GPIO_DBCTL_DBCLKSRC_HCLK or GPIO_DBCTL_DBCLKSRC_LIRC.
N * @param[in]   u32ClkSel   The de-bounce sampling cycle selection. It could be
N *                            - \ref GPIO_DBCTL_DBCLKSEL_1
N *                            - \ref GPIO_DBCTL_DBCLKSEL_2 
N *                            - \ref GPIO_DBCTL_DBCLKSEL_4 
N *                            - \ref GPIO_DBCTL_DBCLKSEL_8
N *                            - \ref GPIO_DBCTL_DBCLKSEL_16 
N *                            - \ref GPIO_DBCTL_DBCLKSEL_32 
N *                            - \ref GPIO_DBCTL_DBCLKSEL_64 
N *                            - \ref GPIO_DBCTL_DBCLKSEL_128
N *                            - \ref GPIO_DBCTL_DBCLKSEL_256 
N *                            - \ref GPIO_DBCTL_DBCLKSEL_512 
N *                            - \ref GPIO_DBCTL_DBCLKSEL_1024 
N *                            - \ref GPIO_DBCTL_DBCLKSEL_2048
N *                            - \ref GPIO_DBCTL_DBCLKSEL_4096 
N *                            - \ref GPIO_DBCTL_DBCLKSEL_8192 
N *                            - \ref GPIO_DBCTL_DBCLKSEL_16384 
N *                            - \ref GPIO_DBCTL_DBCLKSEL_32768
N *
N * @return      None
N *
N * @details     Set the interrupt de-bounce sampling cycle time based on the debounce counter clock source. \n
N *              Example: _GPIO_SET_DEBOUNCE_TIME(GPIO_DBCTL_DBCLKSRC_LIRC, GPIO_DBCTL_DBCLKSEL_4). \n
N *              It's meaning the De-debounce counter clock source is internal 10 KHz and sampling cycle selection is 4. \n
N *              Then the target de-bounce sampling cycle time is (4)*(1/(10*1000)) s = 4*0.0001 s = 400 us,
N *              and system will sampling interrupt input once per 00 us.
N */
N#define GPIO_SET_DEBOUNCE_TIME(u32ClkSrc, u32ClkSel)    (GPIO->DBCTL = (GPIO_DBCTL_ICLKON_Msk | (u32ClkSrc) | (u32ClkSel)))
N
N/**
N * @brief       Get GPIO Port IN Data
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N *
N * @return      The specified port data
N *
N * @details     Get the PIN register of specified GPIO port.
N */
N#define GPIO_GET_IN_DATA(port)  ((port)->PIN)
N
N/**
N * @brief       Set GPIO Port OUT Data
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32Data     GPIO port data.
N *
N * @return      None
N *
N * @details     Set the Data into specified GPIO port.
N */
N#define GPIO_SET_OUT_DATA(port, u32Data)    ((port)->DOUT = (u32Data))
N
N/**
N * @brief       Toggle Specified GPIO pin
N *
N * @param[in]   u32Pin      Pxy
N *
N * @return      None
N *
N * @details     Toggle the specified GPIO pint.
N */
N#define GPIO_TOGGLE(u32Pin) ((u32Pin) ^= 1)
N
N
N/**
N* @brief       Enable External GPIO interrupt
N*
N* @param[in]   port            GPIO port. It could be PA, PB, PC, PD, PE or PF.
N* @param[in]   u32Pin          The pin of specified GPIO port.
N*                              It could be 0 ~ 15 for PA, PB, PC and PD GPIO port.
N*                              It could be 0 ~ 14 for PE GPIO port.
N*                              It could be 0 ~ 7 for PF GPIO port.
N* @param[in]   u32IntAttribs   The interrupt attribute of specified GPIO pin. It could be \n
N*                              GPIO_INT_RISING, GPIO_INT_FALLING, GPIO_INT_BOTH_EDGE, GPIO_INT_HIGH, GPIO_INT_LOW.
N*
N* @return      None
N*
N* @details     This function is used to enable specified GPIO pin interrupt.
N*/
N#define GPIO_EnableEINT     GPIO_EnableInt
N
N/**
N* @brief       Disable External GPIO interrupt
N*
N* @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N* @param[in]   u32Pin      The pin of specified GPIO port.
N*                          It could be 0 ~ 15 for PA, PB, PC and PD GPIO port.
N*                          It could be 0 ~ 14 for PE GPIO port.
N*                          It could be 0 ~ 7 for PF GPIO port.
N*
N* @return      None
N*
N* @details     This function is used to enable specified GPIO pin interrupt.
N*/
N#define GPIO_DisableEINT    GPIO_DisableInt
N
N
Nvoid GPIO_SetMode(GPIO_T *port, uint32_t u32PinMask, uint32_t u32Mode);
Nvoid GPIO_EnableInt(GPIO_T *port, uint32_t u32Pin, uint32_t u32IntAttribs);
Nvoid GPIO_DisableInt(GPIO_T *port, uint32_t u32Pin);
N
N
N/*@}*/ /* end of group GPIO_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group GPIO_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif  // __GPIO_H__
N
N/*** (C) COPYRIGHT 2013~2015 Nuvoton Technology Corp. ***/
L 17096 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N#include "i2c.h"
L 1 "..\..\..\..\Library\StdDriver\inc\i2c.h" 1
N/**************************************************************************//**
N * @file     I2C.h
N * @version  V3.0
N * $Revision: 19 $
N * $Date: 15/08/11 10:26a $
N * @brief    M451 Series I2C Driver Header File
N *
N * @note
N * Copyright (C) 2014~2015 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __I2C_H__
N#define __I2C_H__
N
N#include "M451Series.h"
L 1 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 1
N/******************************************************************************
N * @file     M451Series.h
N * @version  V3.10
N * $Revision: 179 $
N * $Date: 15/09/04 3:45p $
N * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File for M451 Series MCU
N *
N * @note
N * Copyright (C) 2014~2015 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N
N
N/**
N  \mainpage Introduction
N  *
N  *
N  * This user manual describes the usage of M451 Series MCU device driver
N  *
N  * <b>Disclaimer</b>
N  *
N  * The Software is furnished "AS IS", without warranty as to performance or results, and
N  * the entire risk as to performance or results is assumed by YOU. Nuvoton disclaims all
N  * warranties, express, implied or otherwise, with regard to the Software, its use, or
N  * operation, including without limitation any and all warranties of merchantability, fitness
N  * for a particular purpose, and non-infringement of intellectual property rights.
N  *
N  * <b>Copyright Notice</b>
N  *
N  * Copyright (C) 2014~2015 Nuvoton Technology Corp. All rights reserved.
N  */
N
N/**
N  * \page PG_REV Revision History
N  *
N  * <b>Revision 3.01.001</b>
N  * \li Added Nu-LB-M451, NuEdu and USB device sample code.
N  * \li Added a lacking macro SYS_IS_LVR_RST() to SYS driver.
N  * \li Added a sample code DAC_PDMA_ScatterGather_PWMTrigger to use PDMA scatter gather mode and trigger DAC by PWM.
N  * \li Added counter type constant definitions: PWM_UP_COUNTER, PWM_DOWN_COUNTER, and PWM_UP_DOWN_COUNTER.
N  * \li Added DAC_PDMA_PWMTrigger sample code to use PDMA and trigger DAC by PWM.
N  * \li Added a sample code EADC_PDMA_PWM_Trigger to trigger EADC with PWM and copy result by PDMA.
N  * \li Added a new function to control systick and select systick clock source CLK_EnableSysTick() and CLK_DisableSysTick() in CLK driver.
N  * \li Added 'NMIEN' and 'NMISTS' control registers to M451Series.h for NMI control.
N  * \li Added PDMA_ScatterGather_PingPongBuffer sample code to create ping-pong buffer with PDMA scatter gather mode.
N  * \li Added 'PE_DRVCTL' register of GPIO to M451Series.h for GPIO driving strength control.
N  * \li Added a sample code PWM_PDMA_Capture to transfer PWM capture data by PDMA.
N  * \li Added SCLIB_ActivateDelay API for initial SC with non-standard H/W design in SC driver
N  * \li Fixed the bug of EADC_IS_INT_FLAG_OV() that accesses the incorrect register.
N  * \li Fixed the bug of EADC_IS_SAMPLE_MODULE_OV() that accesses the incorrect register. 
N  * \li Fixed the bug of EADC_SetExtendSampleTime() for position shift error in EADC driver.
N  * \li Fixed the bug of EADC_SetTriggerDelayTime() for position shift error in EADC driver.
N  * \li Fixed the bug of PWM_ENABLE_OUTPUT_INVERTER () that output inverter function cannot be disabled.
N  * \li Fixed the bug of PWM_MASK_OUTPUT() in PWM driver that mask function cannot be disabled.
N  * \li Fixed CAN_STATUS_LEC_Msk from 0x03 to 0x07.
N  * \li Fixed the bug of CLK_SysTickDelay() that COUNTFLAG may not be cleared in CLK driver.
N  * \li Fixed CTL and PINCTL regsiter synchronize issue by waiting synchronized ready flag in SC driver.
N  * \li Fixed DAC_SetDelayTime() calculation error in DAC driver because the dac->TCTL only used 10 bits, not 14 bits.
N  * \li Fixed EADC_CMP_ADCMPIE_DISABLE definition error. 
N  * \li Fixed EADC_CMP_ADCMPIE_DISABLE definition error. 
N  * \li Fixed IAR entry point from __iar_program_start to Reset_Handler
N  * \li Fixed PWM_ConfigOutputChannel() return value bug in PWM driver.
N  * \li Fixed the bug of PWM_ConfigSyncPhase() that cannot configure synchronized source for channel2~5.
N  * \li Fixed SC_SET_STOP_BIT_LEN definition error.
N  * \li Fixed SCUART baudrate return error in SCUART_Open and SCUART_SetLineConfig API of SCUART driver.
N  * \li Fixed SCUART_PARITY_NONE/SCUART_PARITY_EVEN/SCUART_PARITY_ODD definition bug in SCUART driver.
N  * \li Fixed u32DataWidth setting error by sc->UARTCTL in SCUART_SetLineConfig API of SCUART driver.
N  * \li Fixed SMBD_Enable constant value definition error in I2C driver.
N  * \li Fixed the problem that MSC device detection is aborted due to REQUEST_SENSE command not ready.
N  * \li Fixed UART clock setting bug in UART_Open(), UART_SetLine_Config() and UART_SelectIrDAMode() of UART driver.
N  * \li Improved compatibility of USBH driver for pen driver.
N  * \li Improved EADC_ConfigSampleModule() to support rising and falling trigger at the same time.
N  * \li Improved EBI_SRAM sample code to add PDMA data transfer with EBI.
N  * \li Improved SC driver to support more than one SC port.
N  * \li Improved USBH driver to support composite HID devices
N  * \li Improved USBD driver to support more USB device sample code.
N  * \li Modified I2C_STOP() from #define to inline and add waiting STO bit clear to 0 . This modified is safe for next START coming soon.
N  * \li Removed CRC clock enabled in CRC_Open(). User should enable CRC clock in system initialization before any CRC operation.
N  * \li Removed FMC_ReadDID() in FMC driver. This function was no longer supported.
N  * \li Removed I2C_CTL_STA_STO_SI and I2C_CTL_STA_STO_SI_AA definitions to avoid STOP and START write to control bit at the same time.
N  *
N  * <b>Revision 3.00.005</b>
N  * \li Fixed EADC_CTL_DMOF_STRAIGHT_BINARY and EADC_CTL_DMOF_TWOS_COMPLEMENT definition error in EADC driver.
N  * \li Fixed EADC_FALLING_EDGE_TRIGGER definition error in EADC driver.
N  * \li Fixed EADC_RISING_EDGE_TRIGGER definition error in EADC driver.
N  * \li Fixed UART transmit data bug in UART_TEST_HANDLE() of UART_TxRxFunction sample code.
N  * \li Fixed the data missing bug when BULK IN transfer is end by max packet size packet at last packet in USBD_VCOM sample code.
N  * \li Fixed program user configuration area without erase in USBD_MassStorage_DataFlash sample code.
N  * \li Fixed the bug of switching HCLK to HIRC before enabling PLL in CLK_SetCoreClock() of CLK driver.
N  * \li Fixed isochronous transfer bugs of USB Host library.
N  * \li Fixed Clear Modem Status Interrupt flag bug in UART_ClearIntFlag() of UART driver.
N  * \li Fixed the time-out flag clear bug in I2C_ClearTimeoutFlag() of I2C driver.
N  * \li Replaced PERIOD0~5 with PERIOD[6] in PWM_T, and modified PERIOD bit field constant definition in M451Series.h.
N  * \li Replaced CMPDAT0~5 with CMPDAT0[6] in PWM_T, and modified CMPDAT bit field constant definition in M451Series.h.
N  * \li Replaced CNT0~5 with CNT[6] in PWM_T, and modified CNT bit field constant definition in M451Series.h.
N  * \li Replaced PBUF0~5 with PBUF[6] in PWM_T, and modified PBUF bit field constant definition in M451Series.h.
N  * \li Replaced CMPBUF0~5 with CMPBUF[6] in PWM_T, and modified CMPBUF bit field constant definition in M451Series.h.
N  * \li Replaced CURSCAT0~CURSCAT11 with CURSCAT[12] in PDMA_T of M451Series.h.
N  * \li Modified CLK_WaitClockReady() time-out to about 300 ms in CLK driver.
N  * \li Updated USB USBD_MassStorage_DataFlash sample code and USB Driver to pass USB-IF MSC test. (The MassStorage size must be greater than 64 KB; otherwise, Command Set test will fail in MSC test).
N  * \li Replaced old HID library file (open source) with Nuvoton HID library in USB Host library. 
N  * \li Added USBH_Audio_Class and USBH_UAC_HID sample code for USB Host to support UAC + HID device.
N  *
N  * <b>Revision 3.00.004</b>
N  * \li Fixed the time-out from 5 ms to 300 ms in CLK_WaitClockReady() of CLK driver.
N  * \li Fixed the bug of UART_ClearIntFlag() in UART driver to only clear one flag at one time.
N  * \li Fixed the missing parameter, UART clock source LXT, for CLK_SetModuleClock() in UART driver.
N  * \li Fixed the bug of clearing data and CTS wake-up flag to clear one flag at one time in UART1_IRQHandler() of UART_Wakeup sample code.
N  * \li Fixed the bug of RS485_HANDLE() in the UART_RS485_Slave sample code to only clear one flag at one time.
N  * \li Fixed the bug of clearing auto baud rate detect finished and time-out flag to clear one flag at one time in AutoBaudRate_RxTest() of UART_AutoBaudRate_Slave sample code.
N  * \li Fixed NVIC_EnableIRQ() to NVIC_DisableIRQ() after chip wake-up in I2C_Wakeup_Slave sample code.
N  * \li Fixed multi-function setting error of SC CD pin in USBD_CCID sample code.
N  * \li Fixed PD.7 (Headphone output control pin) output mode configuration in WAU8822_Setup() of USBD_Audio_NAU8822 sample code.
N  * \li Fixed wrong CLK_WaitClockReady parameter in I2C_GCMode_Slave sample code.
N  * \li Fixed UART data transfer bug of USBD_VCOM sample code.
N  * \li Updated CLK driver to avoid HIRC force enabled in CLK_SetHCLK() and CLK_SetCoreClock().
N  * \li Updated USBD driver to pass USB-IF MSC test.
N  * \li Updated USBD_MassStorage_DataFlash sample code to pass USB-IF MSC test.
N  * \li Updated driver of VCOM for win8 certification in USBD_VCOM sample code.
N  * \li Added HID Media key supporting in USBD_Audio_HID_NAU8822 sample code.
N  * \li Added new sample code USBH_UAC_HID of USB Host to support UAC + HID device.
N  * \li Added new sample code USBH_Audio_Class to support USB audio class device (UAC).
N  *
N  * <b>Revision 3.00.003</b>
N  * \li Added USBD_Audio_HID_NAU8822 sample code.
N  *
N  * <b>Revision 3.00.002</b>
N  * \li Fixed serial number code in device descriptor.
N  * \li Fixed EBI_Open API did not perform u32CSActiveLevel parameters to set CS pin polar.
N  * \li Fixed SMBus bus time-out and Clock Lo time-out API.
N  * \li Fixed I2C0,1 IP reset of SYS_IPRST1.
N  * \li Fixed include path of CMSIS.
N  * \li Fixed SPI_CLR_UNIT_TRANS_INT_FLAG( ) definition.
N  * \li Fixed USBD_INT_WAKEUP definition.
N  * \li Modified USBD driver to support USB remote wake-up function.
N  *
N  * <b>Revision 3.00.001</b>
N  * \li Initial Release.
N*/
N
N#ifndef __M451SERIES_H__
S#define __M451SERIES_H__
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
S
S/******************************************************************************/
S/*                Processor and Core Peripherals                              */
S/******************************************************************************/
S/** @addtogroup CMSIS Device CMSIS Definitions
S  Configuration of the Cortex-M4 Processor and Core Peripherals
S  @{
S*/
S
S/*
S * ==========================================================================
S * ---------- Interrupt Number Definition -----------------------------------
S * ==========================================================================
S */
S
Stypedef enum IRQn
S{
S    /******  Cortex-M4 Processor Exceptions Numbers ***************************************************/
S    NonMaskableInt_IRQn           = -14,      /*!<  2 Non Maskable Interrupt                        */
S    MemoryManagement_IRQn         = -12,      /*!<  4 Memory Management Interrupt                   */
S    BusFault_IRQn                 = -11,      /*!<  5 Bus Fault Interrupt                           */
S    UsageFault_IRQn               = -10,      /*!<  6 Usage Fault Interrupt                         */
S    SVCall_IRQn                   = -5,       /*!< 11 SV Call Interrupt                             */
S    DebugMonitor_IRQn             = -4,       /*!< 12 Debug Monitor Interrupt                       */
S    PendSV_IRQn                   = -2,       /*!< 14 Pend SV Interrupt                             */
S    SysTick_IRQn                  = -1,       /*!< 15 System Tick Interrupt                         */
S
S    /******  M451 Specific Interrupt Numbers ********************************************************/
S
S    BOD_IRQn                      = 0,        /*!< Brown Out detection Interrupt                    */
S    IRC_IRQn                      = 1,        /*!< Internal RC Interrupt                            */
S    PWRWU_IRQn                    = 2,        /*!< Power Down Wake Up Interrupt                     */
S    RAMPE_IRQn                    = 3,        /*!< SRAM parity check failed Interrupt               */
S    CKFAIL_IRQn                   = 4,        /*!< Clock failed Interrupt                           */
S    RTC_IRQn                      = 6,        /*!< Real Time Clock Interrupt                        */
S    TAMPER_IRQn                   = 7,        /*!< Tamper detection Interrupt                       */
S    WDT_IRQn                      = 8,        /*!< Watchdog Timer Interrupt                         */
S    WWDT_IRQn                     = 9,        /*!< Window Watchdog Timer Interrupt                  */
S    EINT0_IRQn                    = 10,       /*!< External Input 0 Interrupt                       */
S    EINT1_IRQn                    = 11,       /*!< External Input 1 Interrupt                       */
S    EINT2_IRQn                    = 12,       /*!< External Input 2 Interrupt                       */
S    EINT3_IRQn                    = 13,       /*!< External Input 3 Interrupt                       */
S    EINT4_IRQn                    = 14,       /*!< External Input 4 Interrupt                       */
S    EINT5_IRQn                    = 15,       /*!< External Input 5 Interrupt                       */
S    GPA_IRQn                      = 16,       /*!< GPIO Port A Interrupt                            */
S    GPB_IRQn                      = 17,       /*!< GPIO Port B Interrupt                            */
S    GPC_IRQn                      = 18,       /*!< GPIO Port C Interrupt                            */
S    GPD_IRQn                      = 19,       /*!< GPIO Port D Interrupt                            */
S    GPE_IRQn                      = 20,       /*!< GPIO Port E Interrupt                            */
S    GPF_IRQn                      = 21,       /*!< GPIO Port F Interrupt                            */
S    SPI0_IRQn                     = 22,       /*!< SPI0 Interrupt                                   */
S    SPI1_IRQn                     = 23,       /*!< SPI1 Interrupt                                   */
S    BRAKE0_IRQn                   = 24,       /*!< BRAKE0 Interrupt                                 */
S    PWM0P0_IRQn                   = 25,       /*!< PWM0P0 Interrupt                                 */
S    PWM0P1_IRQn                   = 26,       /*!< PWM0P1 Interrupt                                 */
S    PWM0P2_IRQn                   = 27,       /*!< PWM0P2 Interrupt                                 */
S    BRAKE1_IRQn                   = 28,       /*!< BRAKE1 Interrupt                                 */
S    PWM1P0_IRQn                   = 29,       /*!< PWM1P0 Interrupt                                 */
S    PWM1P1_IRQn                   = 30,       /*!< PWM1P1 Interrupt                                 */
S    PWM1P2_IRQn                   = 31,       /*!< PWM1P2 Interrupt                                 */
S    TMR0_IRQn                     = 32,       /*!< Timer 0 Interrupt                                */
S    TMR1_IRQn                     = 33,       /*!< Timer 1 Interrupt                                */
S    TMR2_IRQn                     = 34,       /*!< Timer 2 Interrupt                                */
S    TMR3_IRQn                     = 35,       /*!< Timer 3 Interrupt                                */
S    UART0_IRQn                    = 36,       /*!< UART 0 Interrupt                                 */
S    UART1_IRQn                    = 37,       /*!< UART 1 Interrupt                                 */
S    I2C0_IRQn                     = 38,       /*!< I2C 0 Interrupt                                  */
S    I2C1_IRQn                     = 39,       /*!< I2C 1 Interrupt                                  */
S    PDMA_IRQn                     = 40,       /*!< Peripheral DMA Interrupt                         */
S    DAC_IRQn                      = 41,       /*!< DAC Interrupt                                    */
S    ADC00_IRQn                    = 42,       /*!< ADC0 Source 0 Interrupt                          */
S    ADC01_IRQn                    = 43,       /*!< ADC0 Source 1 Interrupt                          */
S    ACMP01_IRQn                   = 44,       /*!< Analog Comparator 0 and 1 Interrupt              */
S    ADC02_IRQn                    = 46,       /*!< ADC0 Source 2 Interrupt                          */
S    ADC03_IRQn                    = 47,       /*!< ADC0 Source 3 Interrupt                          */
S    UART2_IRQn                    = 48,       /*!< UART2 Interrupt                                  */
S    UART3_IRQn                    = 49,       /*!< UART3 Interrupt                                  */
S    SPI2_IRQn                     = 51,       /*!< SPI2 Interrupt                                   */
S    USBD_IRQn                     = 53,       /*!< USB device Interrupt                             */
S    USBH_IRQn                     = 54,       /*!< USB host Interrupt                               */
S    USBOTG_IRQn                   = 55,       /*!< USB OTG Interrupt                                */
S    CAN0_IRQn                     = 56,       /*!< CAN0 Interrupt                                   */
S    SC0_IRQn                      = 58,       /*!< Smart Card 0 Interrupt                           */
S    TK_IRQn                       = 63        /*!< Touch Key Interrupt                              */
S} IRQn_Type;
S
S
S/*
S * ==========================================================================
S * ----------- Processor and Core Peripheral Section ------------------------
S * ==========================================================================
S */
S
S/* Configuration of the Cortex-M# Processor and Core Peripherals */
S#define __CM4_REV                 0x0201    /*!< Core Revision r2p1                               */
S#define __NVIC_PRIO_BITS          4         /*!< Number of Bits used for Priority Levels          */
S#define __Vendor_SysTickConfig    0         /*!< Set to 1 if different SysTick Config is used     */
S#define __MPU_PRESENT             1         /*!< MPU present or not                               */
S#define __FPU_PRESENT             1         /*!< FPU present or not                               */
S
S/*@}*/ /* end of group CMSIS */
S
S#include "core_cm4.h"                       /* Cortex-M4 processor and core peripherals           */
S#include "system_M451Series.h"              /* M451 System include file                           */
S#include <stdint.h>
S
S
S
S/******************************************************************************/
S/*                Device Specific Peripheral registers structures             */
S/******************************************************************************/
S
S/** @addtogroup REGISTER Control Register
S
S  @{
S
S*/
S
S
S/*---------------------- Analog Comparator Controller -------------------------*/
S/**
S    @addtogroup ACMP Analog Comparator Controller(ACMP)
S    Memory Mapped Structure for ACMP Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S/**
S * @var ACMP_T::CTL
S * Offset: 0x00  Analog Comparator 0 Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ACMPEN    |Comparator Enable Bit
S * |        |          |0 = Comparator 0 Disabled.
S * |        |          |1 = Comparator 0 Enabled.
S * |[1]     |ACMPIE    |Comparator Interrupt Enable Bit
S * |        |          |0 = Comparator 0 interrupt Disabled.
S * |        |          |1 = Comparator 0 interrupt Enabled.
S * |        |          |If WKEN (ACMP_CTL0[16]) is set to 1, the wake-up interrupt function will be enabled as well.
S * |[2]     |HYSEN     |Comparator Hysteresis Enable Bit
S * |        |          |0 = Comparator 0 hysteresis Disabled.
S * |        |          |1 = Comparator 0 hysteresis Enabled.
S * |[3]     |ACMPOINV  |Comparator Output Inverse
S * |        |          |0 = Comparator 0 output inverse Disabled.
S * |        |          |1 = Comparator 0 output inverse Enabled.
S * |[5:4]   |NEGSEL    |Comparator Negative Input Selection
S * |        |          |00 = ACMP0_N pin.
S * |        |          |01 = Internal comparator reference voltage (CRV).
S * |        |          |10 = Band-gap voltage.
S * |        |          |11 = DAC output.
S * |[7:6]   |POSSEL    |Comparator Positive Input Selection
S * |        |          |00 = Input from ACMP0_P0.
S * |        |          |01 = Input from ACMP0_P1.
S * |        |          |10 = Input from ACMP0_P2.
S * |        |          |11 = Input from ACMP0_P3.
S * |[9:8]   |INTPOL    |Interrupt Condition Polarity Selection
S * |        |          |ACMPIF0 will be set to 1 when comparator output edge condition is detected.
S * |        |          |00 = Rising edge or falling edge.
S * |        |          |01 = Rising edge.
S * |        |          |10 = Falling edge.
S * |        |          |11 = Reserved.
S * |[12]    |OUTSEL    |Comparator Output Select
S * |        |          |0 = Comparator 0 output to ACMP0_O pin is unfiltered comparator output.
S * |        |          |1 = Comparator 0 output to ACMP0_O pin is from filter output.
S * |[15:13] |FILTSEL   |Comparator Output Filter Count Selection
S * |        |          |000 = Filter function is Disabled.
S * |        |          |001 = ACMP0 output is sampled 1 consecutive PCLK.
S * |        |          |010 = ACMP0 output is sampled 2 consecutive PCLKs.
S * |        |          |011 = ACMP0 output is sampled 4 consecutive PCLKs.
S * |        |          |100 = ACMP0 output is sampled 8 consecutive PCLKs.
S * |        |          |101 = ACMP0 output is sampled 16 consecutive PCLKs.
S * |        |          |110 = ACMP0 output is sampled 32 consecutive PCLKs.
S * |        |          |111 = ACMP0 output is sampled 64 consecutive PCLKs.
S * |[16]    |WKEN      |Power Down Wake-Up Enable Bit
S * |        |          |0 = Wake-up function Disabled.
S * |        |          |1 = Wake-up function Enabled.
S * ---------------------------------------------------------------------------------------------------
S * Offset: 0x04  Analog Comparator 1 Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ACMPEN    |Comparator Enable Bit
S * |        |          |0 = Comparator 1 Disabled.
S * |        |          |1 = Comparator 1 Enabled.
S * |[1]     |ACMPIE    |Comparator Interrupt Enable Bit
S * |        |          |0 = Comparator 1 interrupt Disabled.
S * |        |          |1 = Comparator 1 interrupt Enabled.
S * |        |          |If WKEN (ACMP_CTL1[16]) is set to 1, the wake-up interrupt function will be enabled as well.
S * |[2]     |HYSEN     |Comparator Hysteresis Enable Bit
S * |        |          |0 = Comparator 1 hysteresis Disabled.
S * |        |          |1 = Comparator 1 hysteresis Enabled.
S * |[3]     |ACMPOINV  |Comparator Output Inverse Control
S * |        |          |0 = Comparator 1 output inverse Disabled.
S * |        |          |1 = Comparator 1 output inverse Enabled.
S * |[5:4]   |NEGSEL    |Comparator Negative Input Selection
S * |        |          |00 = ACMP1_N pin.
S * |        |          |01 = Internal comparator reference voltage (CRV).
S * |        |          |10 = Band-gap voltage.
S * |        |          |11 = DAC output.
S * |[7:6]   |POSSEL    |Comparator Positive Input Selection
S * |        |          |00 = Input from ACMP1_P0.
S * |        |          |01 = Input from ACMP1_P1.
S * |        |          |10 = Input from ACMP1_P2.
S * |        |          |11 = Input from ACMP1_P3.
S * |[9:8]   |INTPOL    |Interrupt Condition Polarity Selection
S * |        |          |ACMPIF1 will be set to 1 when comparator output edge condition is detected.
S * |        |          |00 = Rising edge or falling edge.
S * |        |          |01 = Rising edge.
S * |        |          |10 = Falling edge.
S * |        |          |11 = Reserved.
S * |[12]    |OUTSEL    |Comparator Output Select
S * |        |          |0 = Comparator 1 output to ACMP1_O pin is unfiltered comparator output.
S * |        |          |1 = Comparator 1 output to ACMP1_O pin is from filter output.
S * |[15:13] |FILTSEL   |Comparator Output Filter Count Selection
S * |        |          |000 = Filter function is Disabled.
S * |        |          |001 = ACMP1 output is sampled 1 consecutive PCLK.
S * |        |          |010 = ACMP1 output is sampled 2 consecutive PCLKs.
S * |        |          |011 = ACMP1 output is sampled 4 consecutive PCLKs.
S * |        |          |100 = ACMP1 output is sampled 8 consecutive PCLKs.
S * |        |          |101 = ACMP1 output is sampled 16 consecutive PCLKs.
S * |        |          |110 = ACMP1 output is sampled 32 consecutive PCLKs.
S * |        |          |111 = ACMP1 output is sampled 64 consecutive PCLKs.
S * |[16]    |WKEN      |Power Down Wakeup Enable Bit
S * |        |          |0 = Wake-up function Disabled.
S * |        |          |1 = Wake-up function Enabled.
S * @var ACMP_T::STATUS
S * Offset: 0x08  Analog Comparator Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ACMPIF0   |Comparator 0 Interrupt Flag
S * |        |          |This bit is set by hardware when the edge condition defined by INTPOL (ACMP_CTL0[9:8]) is detected on comparator 0 output.
S * |        |          |This will generate an interrupt if ACMPIE (ACMP_CTL0[1]) is set to 1.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[1]     |ACMPIF1   |Comparator 1 Interrupt Flag
S * |        |          |This bit is set by hardware when the edge condition defined by INTPOL (ACMP_CTL1[9:8]) is detected on comparator 1 output.
S * |        |          |This will cause an interrupt if ACMPIE (ACMP_CTL1[1]) is set to 1.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[4]     |ACMPO0    |Comparator 0 Output
S * |        |          |Synchronized to the PCLK to allow reading by software.
S * |        |          |Cleared when the comparator 0 is disabled, i.e. ACMPEN (ACMP_CTL0[0]) is cleared to 0.
S * |[5]     |ACMPO1    |Comparator 1 Output
S * |        |          |Synchronized to the PCLK to allow reading by software.
S * |        |          |Cleared when the comparator 1 is disabled, i.e. ACMPEN (ACMP_CTL1[0]) is cleared to 0.
S * |[8]     |WKIF0     |Comparator 0 Power Down Wake-Up Interrupt Flag
S * |        |          |This bit will be set to 1 when ACMP0 wake-up interrupt event occurs.
S * |        |          |0 = No power down wake-up occurred.
S * |        |          |1 = Power down wake-up occurred.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[9]     |WKIF1     |Comparator 1 Power Down Wake-Up Interrupt Flag
S * |        |          |This bit will be set to 1 when ACMP1 wake-up interrupt event occurs.
S * |        |          |0 = No power down wake-up occurred.
S * |        |          |1 = Power down wake-up occurred.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * @var ACMP_T::VREF
S * Offset: 0x0C  Analog Comparator Reference Voltage Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |CRVCTL    |Comparator Reference Voltage Setting
S * |        |          |CRV = CRV source voltage * (1/6+CRVCTL/24).
S * |[6]     |CRVSSEL   |CRV Source Voltage Selection
S * |        |          |0 = VDDA is selected as CRV source voltage.
S * |        |          |1 = The reference voltage defined by SYS_VREFCTL register is selected as CRV source voltage.
S */
S
S    __IO uint32_t CTL[2];        /* Offset: 0x00  Analog Comparator Control Register                                 */
S    __IO uint32_t STATUS;        /* Offset: 0x08  Analog Comparator Status Register                                  */
S    __IO uint32_t VREF;          /* Offset: 0x0C  Analog Comparator Reference Voltage Control Register               */
S
S} ACMP_T;
S
S
S
S/**
S    @addtogroup ACMP_CONST ACMP Bit Field Definition
S    Constant Definitions for ACMP Controller
S@{ */
S
S#define ACMP_CTL_ACMPEN_Pos              (0)                                               /*!< ACMP_T::CTL: ACMPEN Position             */
S#define ACMP_CTL_ACMPEN_Msk              (0x1ul << ACMP_CTL_ACMPEN_Pos)                    /*!< ACMP_T::CTL: ACMPEN Mask                 */
S
S#define ACMP_CTL_ACMPIE_Pos              (1)                                               /*!< ACMP_T::CTL: ACMPIE Position             */
S#define ACMP_CTL_ACMPIE_Msk              (0x1ul << ACMP_CTL_ACMPIE_Pos)                    /*!< ACMP_T::CTL: ACMPIE Mask                 */
S
S#define ACMP_CTL_HYSEN_Pos               (2)                                               /*!< ACMP_T::CTL: HYSEN Position              */
S#define ACMP_CTL_HYSEN_Msk               (0x1ul << ACMP_CTL_HYSEN_Pos)                     /*!< ACMP_T::CTL: HYSEN Mask                  */
S
S#define ACMP_CTL_ACMPOINV_Pos            (3)                                               /*!< ACMP_T::CTL: ACMPOINV Position           */
S#define ACMP_CTL_ACMPOINV_Msk            (0x1ul << ACMP_CTL_ACMPOINV_Pos)                  /*!< ACMP_T::CTL: ACMPOINV Mask               */
S
S#define ACMP_CTL_NEGSEL_Pos              (4)                                               /*!< ACMP_T::CTL: NEGSEL Position             */
S#define ACMP_CTL_NEGSEL_Msk              (0x3ul << ACMP_CTL_NEGSEL_Pos)                    /*!< ACMP_T::CTL: NEGSEL Mask                 */
S
S#define ACMP_CTL_POSSEL_Pos              (6)                                               /*!< ACMP_T::CTL: POSSEL Position             */
S#define ACMP_CTL_POSSEL_Msk              (0x3ul << ACMP_CTL_POSSEL_Pos)                    /*!< ACMP_T::CTL: POSSEL Mask                 */
S
S#define ACMP_CTL_INTPOL_Pos              (8)                                               /*!< ACMP_T::CTL: INTPOL Position             */
S#define ACMP_CTL_INTPOL_Msk              (0x3ul << ACMP_CTL_INTPOL_Pos)                    /*!< ACMP_T::CTL: INTPOL Mask                 */
S
S#define ACMP_CTL_OUTSEL_Pos              (12)                                              /*!< ACMP_T::CTL: OUTSEL Position             */
S#define ACMP_CTL_OUTSEL_Msk              (0x1ul << ACMP_CTL_OUTSEL_Pos)                    /*!< ACMP_T::CTL: OUTSEL Mask                 */
S
S#define ACMP_CTL_FILTSEL_Pos             (13)                                              /*!< ACMP_T::CTL: FILTSEL Position            */
S#define ACMP_CTL_FILTSEL_Msk             (0x7ul << ACMP_CTL_FILTSEL_Pos)                   /*!< ACMP_T::CTL: FILTSEL Mask                */
S
S#define ACMP_CTL_WKEN_Pos                (16)                                              /*!< ACMP_T::CTL: WKEN Position               */
S#define ACMP_CTL_WKEN_Msk                (0x1ul << ACMP_CTL_WKEN_Pos)                      /*!< ACMP_T::CTL: WKEN Mask                   */
S
S#define ACMP_STATUS_ACMPIF0_Pos          (0)                                               /*!< ACMP_T::STATUS: ACMPIF0 Position         */
S#define ACMP_STATUS_ACMPIF0_Msk          (0x1ul << ACMP_STATUS_ACMPIF0_Pos)                /*!< ACMP_T::STATUS: ACMPIF0 Mask             */
S
S#define ACMP_STATUS_ACMPIF1_Pos          (1)                                               /*!< ACMP_T::STATUS: ACMPIF1 Position         */
S#define ACMP_STATUS_ACMPIF1_Msk          (0x1ul << ACMP_STATUS_ACMPIF1_Pos)                /*!< ACMP_T::STATUS: ACMPIF1 Mask             */
S
S#define ACMP_STATUS_ACMPO0_Pos           (4)                                               /*!< ACMP_T::STATUS: ACMPO0 Position          */
S#define ACMP_STATUS_ACMPO0_Msk           (0x1ul << ACMP_STATUS_ACMPO0_Pos)                 /*!< ACMP_T::STATUS: ACMPO0 Mask              */
S
S#define ACMP_STATUS_ACMPO1_Pos           (5)                                               /*!< ACMP_T::STATUS: ACMPO1 Position          */
S#define ACMP_STATUS_ACMPO1_Msk           (0x1ul << ACMP_STATUS_ACMPO1_Pos)                 /*!< ACMP_T::STATUS: ACMPO1 Mask              */
S
S#define ACMP_STATUS_WKIF0_Pos            (8)                                               /*!< ACMP_T::STATUS: WKIF0 Position           */
S#define ACMP_STATUS_WKIF0_Msk            (0x1ul << ACMP_STATUS_WKIF0_Pos)                  /*!< ACMP_T::STATUS: WKIF0 Mask               */
S
S#define ACMP_STATUS_WKIF1_Pos            (9)                                               /*!< ACMP_T::STATUS: WKIF1 Position           */
S#define ACMP_STATUS_WKIF1_Msk            (0x1ul << ACMP_STATUS_WKIF1_Pos)                  /*!< ACMP_T::STATUS: WKIF1 Mask               */
S
S#define ACMP_VREF_CRVCTL_Pos             (0)                                               /*!< ACMP_T::VREF: CRVCTL Position            */
S#define ACMP_VREF_CRVCTL_Msk             (0xful << ACMP_VREF_CRVCTL_Pos)                   /*!< ACMP_T::VREF: CRVCTL Mask                */
S
S#define ACMP_VREF_CRVSSEL_Pos            (6)                                               /*!< ACMP_T::VREF: CRVSSEL Position           */
S#define ACMP_VREF_CRVSSEL_Msk            (0x1ul << ACMP_VREF_CRVSSEL_Pos)                  /*!< ACMP_T::VREF: CRVSSEL Mask               */
S
S/**@}*/ /* ACMP_CONST */
S/**@}*/ /* end of ACMP register group */
S
S
S/*---------------------- Enhanced Analog to Digital Converter -------------------------*/
S/**
S    @addtogroup Enhanced Analog to Digital Converter(EADC)
S    Memory Mapped Structure for EADC Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S/**
S * @var EADC_T::DAT
S * Offset: 0x00-0x48  A/D Data Register n for Sample Module n, n=0~18
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |RESULT    |A/D Conversion Result
S * |        |          |This field contains 12 bits conversion result.
S * |        |          |When DMOF (EADC_CTL[9]) is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT[11:0] and zero will be filled in RESULT[15:12].
S * |        |          |When DMOF (EADC_CTL[9]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT[11:0] and signed bits to will be filled in RESULT[15:12].
S * |[16]    |OV        |Overrun Flag
S * |        |          |If converted data in RESULT[11:0] has not been read before new conversion result is loaded to this register, OV is set to 1.
S * |        |          |0 = Data in RESULT[11:0] is recent conversion result.
S * |        |          |1 = Data in RESULT[11:0] is overwrite.
S * |        |          |Note: It is cleared by hardware after EADC_DAT register is read.
S * |[17]    |VALID     |Valid Flag
S * |        |          |This bit is set to 1 when corresponding sample module channel analog input conversion is completed and cleared by hardware after EADC_DAT register is read.
S * |        |          |0 = Data in RESULT[11:0] bits is not valid.
S * |        |          |1 = Data in RESULT[11:0] bits is valid.
S * @var EADC_T::CURDAT
S * Offset: 0x4C  EADC PDMA Current Transfer Data Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[17:0]  |CURDAT    |ADC PDMA Current Transfer Data Register
S * |        |          |This register is a shadow register of EADC_DATn (n=0~18) for PDMA support.
S * |        |          |This is a read only register.
S * @var EADC_T::CTL
S * Offset: 0x50  A/D Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ADCEN     |A/D Converter Enable Bit
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |        |          |Note: Before starting A/D conversion function, this bit should be set to 1.
S * |        |          |Clear it to 0 to disable A/D converter analog circuit power consumption.
S * |[1]     |ADCRST    |ADC A/D Converter Control Circuits Reset
S * |        |          |0 = No effect.
S * |        |          |1 = Cause ADC control circuits reset to initial state, but not change the ADC registers value.
S * |        |          |Note: ADCRST bit remains 1 during ADC reset, when ADC reset end, the ADCRST bit is automatically cleared to 0.
S * |[2]     |ADCIEN0   |Specific Sample Module A/D ADINT0 Interrupt Enable Bit
S * |        |          |The A/D converter generates a conversion end ADIF0 (EADC_STATUS2[0]) upon the end of specific sample module A/D conversion.
S * |        |          |If ADCIEN0 bit is set then conversion end interrupt request ADINT0 is generated.
S * |        |          |0 = Specific sample module A/D ADINT0 interrupt function Disabled.
S * |        |          |1 = Specific sample module A/D ADINT0 interrupt function Enabled.
S * |[3]     |ADCIEN1   |Specific Sample Module A/D ADINT1 Interrupt Enable Bit
S * |        |          |The A/D converter generates a conversion end ADIF1 (EADC_STATUS2[1]) upon the end of specific sample module A/D conversion.
S * |        |          |If ADCIEN1 bit is set then conversion end interrupt request ADINT1 is generated.
S * |        |          |0 = Specific sample module A/D ADINT1 interrupt function Disabled.
S * |        |          |1 = Specific sample module A/D ADINT1 interrupt function Enabled.
S * |[4]     |ADCIEN2   |Specific Sample Module A/D ADINT2 Interrupt Enable Bit
S * |        |          |The A/D converter generates a conversion end ADIF2 (EADC_STATUS2[2]) upon the end of specific sample module A/D conversion.
S * |        |          |If ADCIEN2 bit is set then conversion end interrupt request ADINT2 is generated.
S * |        |          |0 = Specific sample module A/D ADINT2 interrupt function Disabled.
S * |        |          |1 = Specific sample module A/D ADINT2 interrupt function Enabled.
S * |[5]     |ADCIEN3   |Specific Sample Module A/D ADINT3 Interrupt Enable Bit
S * |        |          |The A/D converter generates a conversion end ADIF3 (EADC_STATUS2[3]) upon the end of specific sample module A/D conversion.
S * |        |          |If ADCIEN3 bit is set then conversion end interrupt request ADINT3 is generated.
S * |        |          |0 = Specific sample module A/D ADINT3 interrupt function Disabled.
S * |        |          |1 = Specific sample module A/D ADINT3 interrupt function Enabled.
S * |[8]     |DIFFEN    |Differential Analog Input Mode Enable Bit
S * |        |          |0 = Single-end analog input mode.
S * |        |          |1 = Differential analog input mode.
S * |[9]     |DMOF      |ADC Differential Input Mode Output Format
S * |        |          |0 = A/D conversion result will be filled in RESULT (EADC_DATn[15:0] , n= 0 ~18) with unsigned format.
S * |        |          |1 = A/D conversion result will be filled in RESULT (EADC_DATn[15:0] , n= 0 ~18) with 2'complement format.
S * |[11]    |PDMAEN    |PDMA Transfer Enable Bit
S * |        |          |When A/D conversion is completed, the converted data is loaded into EADC_DATn (n: 0 ~ 18) register, user can enable this bit to generate a PDMA data transfer request.
S * |        |          |0 = PDMA data transfer Disabled.
S * |        |          |1 = PDMA data transfer Enabled.
S * |        |          |Note: When set this bit field to 1, user must set ADCIENn (EADC_CTL[5:2], n=0~3) = 0 to disable interrupt.
S * |[18:16] |SMPTSEL   |ADC Internal Sampling Time Selection
S * |        |          |ADC internal sampling cycle = SMPTSEL + 1.
S * |        |          |000 = 1 ADC clock sampling time.
S * |        |          |001 = 2 ADC clock sampling time.
S * |        |          |010 = 3 ADC clock sampling time.
S * |        |          |011 = 4 ADC clock sampling time.
S * |        |          |100 = 5 ADC clock sampling time.
S * |        |          |101 = 6 ADC clock sampling time.
S * |        |          |110 = 7 ADC clock sampling time.
S * |        |          |111 = 8 ADC clock sampling time.
S * @var EADC_T::SWTRG
S * Offset: 0x54  A/D Sample Module Software Start Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[18:0]  |SWTRG     |A/D Sample Module
S * |        |          |0~18 Software Force To Start ADC Conversion
S * |        |          |0 = No effect.
S * |        |          |1 = Cause an ADC conversion when the priority is given to sample module.
S * |        |          |Note: After write this register to start ADC conversion, the EADC_PENDSTS register will show which sample module will conversion.
S * |        |          |If user want to disable the conversion of the sample module, user can write EADC_PENDSTS register to clear it.
S * @var EADC_T::PENDSTS
S * Offset: 0x58  A/D Start of Conversion Pending Flag Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[18:0]  |STPF      |A/D Sample Module 0~18 Start Of Conversion Pending Flag
S * |        |          |Read:
S * |        |          |0 = There is no pending conversion for sample module.
S * |        |          |1 = Sample module ADC start of conversion is pending.
S * |        |          |Write:
S * |        |          |1 = clear pending flag and cancel the conversion for sample module.
S * |        |          |Note: This bit remains 1 during pending state, when the respective ADC conversion is end, the STPFn (n=0~18) bit is automatically cleared to 0
S * @var EADC_T::OVSTS
S * Offset: 0x5C  A/D Sample Module Start of Conversion Overrun Flag Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[18:0]  |SPOVF     |A/D SAMPLE0~18 Overrun Flag
S * |        |          |0 = No sample module event overrun.
S * |        |          |1 = Indicates a new sample module event is generated while an old one event is pending.
S * |        |          |Note: This bit is cleared by writing 1 to it.
S * @var EADC_T::SCTL
S * Offset: 0x80-0x8C  A/D Sample Module n Control Register, n=0~3
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |CHSEL     |A/D Sample Module Channel Selection
S * |        |          |00H = EADC_CH0.
S * |        |          |01H = EADC_CH1.
S * |        |          |02H = EADC_CH2.
S * |        |          |03H = EADC_CH3.
S * |        |          |04H = EADC_CH4.
S * |        |          |05H = EADC_CH5.
S * |        |          |06H = EADC_CH6.
S * |        |          |07H = EADC_CH7.
S * |        |          |08H = EADC_CH8.
S * |        |          |09H = EADC_CH9.
S * |        |          |0AH = EADC_CH10.
S * |        |          |0BH = EADC_CH11.
S * |        |          |0CH = EADC_CH12.
S * |        |          |0DH = EADC_CH13.
S * |        |          |0EH = EADC_CH14.
S * |        |          |0FH = EADC_CH15.
S * |[4]     |EXTREN    |A/D External Trigger Rising Edge Enable Bit
S * |        |          |0 = Rising edge Disabled when A/D selects STADC as trigger source.
S * |        |          |1 = Rising edge Enabled when A/D selects STADC as trigger source.
S * |[5]     |EXTFEN    |A/D External Trigger Falling Edge Enable Bit
S * |        |          |0 = Falling edge Disabled when A/D selects STADC as trigger source.
S * |        |          |1 = Falling edge Enabled when A/D selects STADC as trigger source.
S * |[7:6]   |TRGDLYDIV |A/D Sample Module Start Of Conversion Trigger Delay Clock Divider Selection
S * |        |          |Trigger delay clock frequency:
S * |        |          |00 = ADC_CLK/1.
S * |        |          |01 = ADC_CLK/2.
S * |        |          |10 = ADC_CLK/4.
S * |        |          |11 = ADC_CLK/16.
S * |[15:8]  |TRGDLYCNT |A/D Sample Module Start Of Conversion Trigger Delay Time
S * |        |          |Trigger delay time = TRGDLYCNT x ADC_CLK x n (n=1,2,4,16 from TRGDLYDIV setting).
S * |[20:16] |TRGSEL    |A/D Sample Module Start Of Conversion Trigger Source Selection
S * |        |          |0H = Disable trigger.
S * |        |          |1H = External trigger from STADC pin input.
S * |        |          |2H = ADC ADINT0 interrupt EOC (End of conversion) pulse trigger.
S * |        |          |3H = ADC ADINT1 interrupt EOC (End of conversion) pulse trigger.
S * |        |          |4H = Timer0 overflow pulse trigger.
S * |        |          |5H = Timer1 overflow pulse trigger.
S * |        |          |6H = Timer2 overflow pulse trigger.
S * |        |          |7H = Timer3 overflow pulse trigger.
S * |        |          |8H = PWM0TG0.
S * |        |          |9H = PWM0TG1.
S * |        |          |AH = PWM0TG2.
S * |        |          |BH = PWM0TG3.
S * |        |          |CH = PWM0TG4.
S * |        |          |DH = PWM0TG5.
S * |        |          |EH = PWM1TG0.
S * |        |          |FH = PWM1TG1.
S * |        |          |10H = PWM1TG2.
S * |        |          |11H = PWM1TG3.
S * |        |          |12H = PWM1TG4.
S * |        |          |13H = PWM1TG5.
S * |        |          |other = Reserved.
S * |[22]    |INTPOS    |Interrupt Flag Position Select
S * |        |          |0 = Set ADIFn (EADC_STATUS2[n], n=0~3) at A/D end of conversion.
S * |        |          |1 = Set ADIFn (EADC_STATUS2[n], n=0~3) at A/D start of conversion.
S * |[23]    |DBMEN     |Double Buffer Mode Enable Bit
S * |        |          |0 = Sample has one sample result register. (default).
S * |        |          |1 = Sample has two sample result registers.
S * |[31:24] |EXTSMPT   |ADC Sampling Time Extend
S * |        |          |When A/D converting at high conversion rate, the sampling time of analog input voltage may not enough if input channel loading is heavy, user can extend A/D sampling time after trigger source is coming to get enough sampling time.
S * |        |          |The range of start delay time is from 0~255 ADC clock.
S * @var EADC_T::SCTL
S * Offset: 0x90-0xBC  A/D Sample Module n Control Register, n=4~15
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |CHSEL     |A/D Sample Module Channel Selection
S * |        |          |00H = EADC_CH0.
S * |        |          |01H = EADC_CH1.
S * |        |          |02H = EADC_CH2.
S * |        |          |03H = EADC_CH3.
S * |        |          |04H = EADC_CH4.
S * |        |          |05H = EADC_CH5.
S * |        |          |06H = EADC_CH6.
S * |        |          |07H = EADC_CH7.
S * |        |          |08H = EADC_CH8.
S * |        |          |09H = EADC_CH9.
S * |        |          |0AH = EADC_CH10.
S * |        |          |0BH = EADC_CH11.
S * |        |          |0CH = EADC_CH12.
S * |        |          |0DH = EADC_CH13.
S * |        |          |0EH = EADC_CH14.
S * |        |          |0FH = EADC_CH15.
S * |[4]     |EXTREN    |A/D External Trigger Rising Edge Enable Bit
S * |        |          |0 = Rising edge Disabled when A/D selects STADC as trigger source.
S * |        |          |1 = Rising edge Enabled when A/D selects STADC as trigger source.
S * |[5]     |EXTFEN    |A/D External Trigger Falling Edge Enable Bit
S * |        |          |0 = Falling edge Disabled when A/D selects STADC as trigger source.
S * |        |          |1 = Falling edge Enabled when A/D selects STADC as trigger source.
S * |[7:6]   |TRGDLYDIV[1:0]|A/D Sample Module Start Of Conversion Trigger Delay Clock Divider Selection
S * |        |          |Trigger delay clock frequency:
S * |        |          |00 = ADC_CLK/1.
S * |        |          |01 = ADC_CLK/2.
S * |        |          |10 = ADC_CLK/4.
S * |        |          |11 = ADC_CLK/16.
S * |[15:8]  |TRGDLYCNT[7:0]|A/D Sample Module Start Of Conversion Trigger Delay Time
S * |        |          |Trigger delay time = TRGDLYCNT x ADC_CLK x n (n=1,2,4,16 from TRGDLYDIV setting).
S * |[20:16] |TRGSEL    |A/D Sample Module Start Of Conversion Trigger Source Selection
S * |        |          |0H = Disable trigger.
S * |        |          |1H = External trigger from STADC pin input.
S * |        |          |2H = ADC ADINT0 interrupt EOC pulse trigger.
S * |        |          |3H = ADC ADINT1 interrupt EOC pulse trigger.
S * |        |          |4H = Timer0 overflow pulse trigger.
S * |        |          |5H = Timer1 overflow pulse trigger.
S * |        |          |6H = Timer2 overflow pulse trigger.
S * |        |          |7H = Timer3 overflow pulse trigger.
S * |        |          |8H = PWM0TG0.
S * |        |          |9H = PWM0TG1.
S * |        |          |AH = PWM0TG2.
S * |        |          |BH = PWM0TG3.
S * |        |          |CH = PWM0TG4.
S * |        |          |DH = PWM0TG5.
S * |        |          |EH = PWM1TG0.
S * |        |          |FH = PWM1TG1.
S * |        |          |10H = PWM1TG2.
S * |        |          |11H = PWM1TG3.
S * |        |          |12H = PWM1TG4.
S * |        |          |13H = PWM1TG5.
S * |        |          |other = Reserved.
S * |[22]    |INTPOS    |Interrupt Flag Position Select
S * |        |          |0 = Set ADIFn (EADC_STATUS2[n], n=0~3) at A/D end of conversion.
S * |        |          |1 = Set ADIFn (EADC_STATUS2[n], n=0~3) at A/D start of conversion.
S * |[31:24] |EXTSMPT   |ADC Sampling Time Extend
S * |        |          |When A/D converting at high conversion rate, the sampling time of analog input voltage may not enough if input channel loading is heavy, SW can extend A/D sampling time after trigger source is coming to get enough sampling time.
S * |        |          |The range of start delay time is from 0~255 ADC clock.
S * @var EADC_T::SCTL
S * Offset: 0xC0~0xC8  A/D Sample Module n Control Register, n=16~18
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:24] |EXTSMPT   |ADC Sampling Time Extend
S * |        |          |When A/D converting at high conversion rate, the sampling time of analog input voltage may not enough if input channel loading is heavy, SW can extend A/D sampling time after trigger source is coming to get enough sampling time.
S * |        |          |The range of start delay time is from 0~255 ADC clock.
S * @var EADC_T::INTSRC
S * Offset: 0xDC  ADC interrupt n Source Enable Control Register, n=0~3
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |SPLIE0    |Sample Module 0 Interrupt Enable Bit
S * |        |          |0 = Sample Module 0 interrupt Disabled.
S * |        |          |1 = Sample Module 0 interrupt Enabled.
S * |[1]     |SPLIE1    |Sample Module 1 Interrupt Enable Bit
S * |        |          |0 = Sample Module 1 interrupt Disabled.
S * |        |          |1 = Sample Module 1 interrupt Enabled.
S * |[2]     |SPLIE2    |Sample Module 2 Interrupt Enable Bit
S * |        |          |0 = Sample Module 2 interrupt Disabled.
S * |        |          |1 = Sample Module 2 interrupt Enabled.
S * |[3]     |SPLIE3    |Sample Module 3 Interrupt Enable Bit
S * |        |          |0 = Sample Module 3 interrupt Disabled.
S * |        |          |1 = Sample Module 3 interrupt Enabled.
S * |[4]     |SPLIE4    |Sample Module 4 Interrupt Enable Bit
S * |        |          |0 = Sample Module 4 interrupt Disabled.
S * |        |          |1 = Sample Module 4 interrupt Enabled.
S * |[5]     |SPLIE5    |Sample Module 5 Interrupt Enable Bit
S * |        |          |0 = Sample Module 5 interrupt Disabled.
S * |        |          |1 = Sample Module 5 interrupt Enabled.
S * |[6]     |SPLIE6    |Sample Module 6 Interrupt Enable Bit
S * |        |          |0 = Sample Module 6 interrupt Disabled.
S * |        |          |1 = Sample Module 6 interrupt Enabled.
S * |[7]     |SPLIE7    |Sample Module 7 Interrupt Enable Bit
S * |        |          |0 = Sample Module 7 interrupt Disabled.
S * |        |          |1 = Sample Module 7 interrupt Enabled.
S * |[8]     |SPLIE8    |Sample Module 8 Interrupt Enable Bit
S * |        |          |0 = Sample Module 8 interrupt Disabled.
S * |        |          |1 = Sample Module 8 interrupt Enabled.
S * |[9]     |SPLIE9    |Sample Module 9 Interrupt Enable Bit
S * |        |          |0 = Sample Module 9 interrupt Disabled.
S * |        |          |1 = Sample Module 9 interrupt Enabled.
S * |[10]    |SPLIE10   |Sample Module 10 Interrupt Enable Bit
S * |        |          |0 = Sample Module 10 interrupt Disabled.
S * |        |          |1 = Sample Module 10 interrupt Enabled.
S * |[11]    |SPLIE11   |Sample Module 11 Interrupt Enable Bit
S * |        |          |0 = Sample Module 11 interrupt Disabled.
S * |        |          |1 = Sample Module 11 interrupt Enabled.
S * |[12]    |SPLIE12   |Sample Module 12 Interrupt Enable Bit
S * |        |          |0 = Sample Module 12 interrupt Disabled.
S * |        |          |1 = Sample Module 12 interrupt Enabled.
S * |[13]    |SPLIE13   |Sample Module 13 Interrupt Enable Bit
S * |        |          |0 = Sample Module 13 interrupt Disabled.
S * |        |          |1 = Sample Module 13 interrupt Enabled.
S * |[14]    |SPLIE14   |Sample Module 14 Interrupt Enable Bit
S * |        |          |0 = Sample Module 14 interrupt Disabled.
S * |        |          |1 = Sample Module 14 interrupt Enabled.
S * |[15]    |SPLIE15   |Sample Module 15 Interrupt Enable Bit
S * |        |          |0 = Sample Module 15 interrupt Disabled.
S * |        |          |1 = Sample Module 15 interrupt Enabled.
S * |[16]    |SPLIE16   |Sample Module 16 Interrupt Enable Bit
S * |        |          |0 = Sample Module 16 interrupt Disabled.
S * |        |          |1 = Sample Module 16 interrupt Enabled.
S * |[17]    |SPLIE17   |Sample Module 17 Interrupt Enable Bit
S * |        |          |0 = Sample Module 17 interrupt Disabled.
S * |        |          |1 = Sample Module 17 interrupt Enabled.
S * |[18]    |SPLIE18   |Sample Module 18 Interrupt Enable Bit
S * |        |          |0 = Sample Module 18 interrupt Disabled.
S * |        |          |1 = Sample Module 18 interrupt Enabled.
S * @var EADC_T::CMP
S * Offset: 0xEC  A/D Result Compare Register n, n=0~3
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ADCMPEN   |A/D Result Compare Enable Bit
S * |        |          |0 = Compare Disabled.
S * |        |          |1 = Compare Enabled.
S * |        |          |Set this bit to 1 to enable compare CMPDAT (EADC_CMPn[27:16], n=0~3) with specified sample module conversion result when converted data is loaded into EADC_DAT register.
S * |[1]     |ADCMPIE   |A/D Result Compare Interrupt Enable Bit
S * |        |          |0 = Compare function interrupt Disabled.
S * |        |          |1 = Compare function interrupt Enabled.
S * |        |          |If the compare function is enabled and the compare condition matches the setting of CMPCOND (EADC_CMPn[2], n=0~3) and CMPMCNT (EADC_CMPn[11:8], n=0~3), ADCMPFn (EADC_STATUS2[7:4], n=0~3) will be asserted, in the meanwhile, if ADCMPIE is set to 1, a compare interrupt request is generated.
S * |[2]     |CMPCOND   |Compare Condition
S * |        |          |0= Set the compare condition as that when a 12-bit A/D conversion result is less than the 12-bit CMPDAT (EADC_CMPn
S * |        |          |[27:16]), the internal match counter will increase one.
S * |        |          |1= Set the compare condition as that when a 12-bit A/D conversion result is greater or equal to the 12-bit CMPDAT (EADC_CMPn [27:16]), the internal match counter will increase one.
S * |        |          |Note: When the internal counter reaches the value to (CMPMCNT (EADC_CMPn[11:8], n=0~3) +1), the CMPF bit will be set.
S * |[7:3]   |CMPSPL    |Compare Sample Module Selection
S * |        |          |00000 = Sample Module 0 conversion result EADC_DAT0 is selected to be compared.
S * |        |          |00001 = Sample Module 1 conversion result EADC_DAT1 is selected to be compared.
S * |        |          |00010 = Sample Module 2 conversion result EADC_DAT2 is selected to be compared.
S * |        |          |00011 = Sample Module 3 conversion result EADC_DAT3 is selected to be compared.
S * |        |          |00100 = Sample Module 4 conversion result EADC_DAT4 is selected to be compared.
S * |        |          |00101 = Sample Module 5 conversion result EADC_DAT5 is selected to be compared.
S * |        |          |00110 = Sample Module 6 conversion result EADC_DAT6 is selected to be compared.
S * |        |          |00111 = Sample Module 7 conversion result EADC_DAT7 is selected to be compared.
S * |        |          |01000 = Sample Module 8 conversion result EADC_DAT8 is selected to be compared.
S * |        |          |01001 = Sample Module 9 conversion result EADC_DAT9 is selected to be compared.
S * |        |          |01010 = Sample Module 10 conversion result EADC_DAT10 is selected to be compared.
S * |        |          |01011 = Sample Module 11 conversion result EADC_DAT11 is selected to be compared.
S * |        |          |01100 = Sample Module 12 conversion result EADC_DAT12 is selected to be compared.
S * |        |          |01101 = Sample Module 13 conversion result EADC_DAT13 is selected to be compared.
S * |        |          |01110 = Sample Module 14 conversion result EADC_DAT14 is selected to be compared.
S * |        |          |01111 = Sample Module 15 conversion result EADC_DAT15 is selected to be compared.
S * |        |          |10000 = Sample Module 16 conversion result EADC_DAT16 is selected to be compared.
S * |        |          |10001 = Sample Module 17 conversion result EADC_DAT17 is selected to be compared.
S * |        |          |10010 = Sample Module 18 conversion result EADC_DAT18 is selected to be compared.
S * |[11:8]  |CMPMCNT   |Compare Match Count
S * |        |          |When the specified A/D sample module analog conversion result matches the compare condition defined by CMPCOND (EADC_CMPn[2], n=0~3), the internal match counter will increase 1.
S * |        |          |If the compare result does not meet the compare condition, the internal compare match counter will reset to 0.
S * |        |          |When the internal counter reaches the value to (CMPMCNT +1), the ADCMPFn (EADC_STATUS2[7:4], n=0~3) will be set.
S * |[15]    |CMPWEN    |Compare Window Mode Enable Bit
S * |        |          |0 = ADCMPF0 (EADC_STATUS2[4]) will be set when EADC_CMP0 compared condition matched.
S * |        |          |ADCMPF2 (EADC_STATUS2[6]) will be set when EADC_CMP2 compared condition matched.
S * |        |          |1 = ADCMPF0 (EADC_STATUS2[4]) will be set when both EADC_CMP0 and EADC_CMP1 compared condition matched.
S * |        |          |ADCMPF2 (EADC_STATUS2[6]) will be set when both EADC_CMP2 and EADC_CMP3 compared condition matched.
S * |        |          |Note: This bit is only present in EADC_CMP0 and EADC_CMP2 register.
S * |[27:16] |CMPDAT    |Comparison Data
S * |        |          |The 12 bits data is used to compare with conversion result of specified sample module.
S * |        |          |User can use it to monitor the external analog input pin voltage transition without imposing a load on software.
S * @var EADC_T::STATUS0
S * Offset: 0xF0  A/D Status Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |VALID     |EADC_DAT0~15 Data Valid Flag
S * |        |          |It is a mirror of VALID bit in sample module A/D result data register EADC_DATn. (n=0~18).
S * |[31:16] |OV        |EADC_DAT0~15 Overrun Flag
S * |        |          |It is a mirror to OV bit in sample module A/D result data register EADC_DATn. (n=0~18).
S * @var EADC_T::STATUS1
S * Offset: 0xF4  A/D Status Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[2:0]   |VALID     |EADC_DAT16~18 Data Valid Flag
S * |        |          |It is a mirror of VALID bit in sample module A/D result data register EADC_DATn. (n=0~18).
S * |[18:16] |OV        |EADC_DAT16~18 Overrun Flag
S * |        |          |It is a mirror to OV bit in sample module A/D result data register EADC_DATn. (n=0~18).
S * @var EADC_T::STATUS2
S * Offset: 0xF8  A/D Status Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ADIF0     |A/D ADINT0 Interrupt Flag
S * |        |          |0 = No ADINT0 interrupt pulse received.
S * |        |          |1 = ADINT0 interrupt pulse has been received.
S * |        |          |Note1: This bit is cleared by writing 1 to it.
S * |        |          |Note2:This bit indicates whether an A/D conversion of specific sample module has been completed
S * |[1]     |ADIF1     |A/D ADINT1 Interrupt Flag
S * |        |          |0 = No ADINT1 interrupt pulse received.
S * |        |          |1 = ADINT1 interrupt pulse has been received.
S * |        |          |Note1: This bit is cleared by writing 1 to it.
S * |        |          |Note2:This bit indicates whether an A/D conversion of specific sample module has been completed
S * |[2]     |ADIF2     |A/D ADINT2 Interrupt Flag
S * |        |          |0 = No ADINT2 interrupt pulse received.
S * |        |          |1 = ADINT2 interrupt pulse has been received.
S * |        |          |Note1: This bit is cleared by writing 1 to it.
S * |        |          |Note2:This bit indicates whether an A/D conversion of specific sample module has been completed
S * |[3]     |ADIF3     |A/D ADINT3 Interrupt Flag
S * |        |          |0 = No ADINT3 interrupt pulse received.
S * |        |          |1 = ADINT3 interrupt pulse has been received.
S * |        |          |Note1: This bit is cleared by writing 1 to it.
S * |        |          |Note2:This bit indicates whether an A/D conversion of specific sample module has been completed
S * |[4]     |ADCMPF0   |ADC Compare 0 Flag
S * |        |          |When the specific sample module A/D conversion result meets setting condition in EADC_CMP0 then this bit is set to 1.
S * |        |          |0 = Conversion result in EADC_DAT does not meet EADC_CMP0 register setting.
S * |        |          |1 = Conversion result in EADC_DAT meets EADC_CMP0 register setting.
S * |        |          |Note: This bit is cleared by writing 1 to it.
S * |[5]     |ADCMPF1   |ADC Compare 1 Flag
S * |        |          |When the specific sample module A/D conversion result meets setting condition in EADC_CMP1 then this bit is set to 1.
S * |        |          |0 = Conversion result in EADC_DAT does not meet EADC_CMP1 register setting.
S * |        |          |1 = Conversion result in EADC_DAT meets EADC_CMP1 register setting.
S * |        |          |Note: This bit is cleared by writing 1 to it.
S * |[6]     |ADCMPF2   |ADC Compare 2 Flag
S * |        |          |When the specific sample module A/D conversion result meets setting condition in EADC_CMP2 then this bit is set to 1.
S * |        |          |0 = Conversion result in EADC_DAT does not meet EADC_CMP2 register setting.
S * |        |          |1 = Conversion result in EADC_DAT meets EADC_CMP2 register setting.
S * |        |          |Note: This bit is cleared by writing 1 to it.
S * |[7]     |ADCMPF3   |ADC Compare 3 Flag
S * |        |          |When the specific sample module A/D conversion result meets setting condition in EADC_CMP3 then this bit is set to 1.
S * |        |          |0 = Conversion result in EADC_DAT does not meet EADC_CMP3 register setting.
S * |        |          |1 = Conversion result in EADC_DAT meets EADC_CMP3 register setting.
S * |        |          |Note: This bit is cleared by writing 1 to it.
S * |[8]     |ADOVIF0   |A/D ADINT0 Interrupt Flag Overrun
S * |        |          |0 = ADINT0 interrupt flag is not overwritten to 1.
S * |        |          |1 = ADINT0 interrupt flag is overwritten to 1.
S * |        |          |Note: This bit is cleared by writing 1 to it.
S * |[9]     |ADOVIF1   |A/D ADINT1 Interrupt Flag Overrun
S * |        |          |0 = ADINT1 interrupt flag is not overwritten to 1.
S * |        |          |1 = ADINT1 interrupt flag is overwritten to 1.
S * |        |          |Note: This bit is cleared by writing 1 to it.
S * |[10]    |ADOVIF2   |A/D ADINT2 Interrupt Flag Overrun
S * |        |          |0 = ADINT2 interrupt flag is not overwritten to 1.
S * |        |          |1 = ADINT2 interrupt flag is s overwritten to 1.
S * |        |          |Note: This bit is cleared by writing 1 to it.
S * |[11]    |ADOVIF3   |A/D ADINT3 Interrupt Flag Overrun
S * |        |          |0 = ADINT3 interrupt flag is not overwritten to 1.
S * |        |          |1 = ADINT3 interrupt flag is overwritten to 1.
S * |        |          |Note: This bit is cleared by writing 1 to it.
S * |[12]    |ADCMPO0   |ADC Compare 0 Output Status
S * |        |          |The 12 bits compare0 data CMPDAT0 (EADC_CMP0[27:16]) is used to compare with conversion result of specified sample module.
S * |        |          |User can use it to monitor the external analog input pin voltage status.
S * |        |          |0 = Conversion result in EADC_DAT less than CMPDAT0 setting.
S * |        |          |1 = Conversion result in EADC_DAT great than or equal CMPDAT0
S * |        |          |setting.
S * |[13]    |ADCMPO1   |ADC Compare 1 Output Status
S * |        |          |The 12 bits compare1 data CMPDAT1 (EADC_CMP1[27:16]) is used to compare with conversion result of specified sample module.
S * |        |          |User can use it to monitor the external analog input pin voltage status.
S * |        |          |0 = Conversion result in EADC_DAT less than CMPDAT1 setting.
S * |        |          |1 = Conversion result in EADC_DAT great than or equal CMPDAT1
S * |        |          |setting.
S * |[14]    |ADCMPO2   |ADC Compare 2 Output Status
S * |        |          |The 12 bits compare2 data CMPDAT2 (EADC_CMP2[27:16]) is used to compare with conversion result of specified sample module.
S * |        |          |User can use it to monitor the external analog input pin voltage status.
S * |        |          |0 = Conversion result in EADC_DAT less than CMPDAT2 setting.
S * |        |          |1 = Conversion result in EADC_DAT great than or equal CMPDAT2
S * |        |          |setting.
S * |[15]    |ADCMPO3   |ADC Compare 3 Output Status
S * |        |          |The 12 bits compare3 data CMPDAT3 (EADC_CMP3[27:16]) is used to compare with conversion result of specified sample module.
S * |        |          |User can use it to monitor the external analog input pin voltage status.
S * |        |          |0 = Conversion result in EADC_DAT less than CMPDAT3 setting.
S * |        |          |1 = Conversion result in EADC_DAT great than or equal CMPDAT3
S * |        |          |setting.
S * |[20:16] |CHANNEL   |Current Conversion Channel
S * |        |          |This filed reflects ADC current conversion channel when BUSY=1.
S * |        |          |It is read only.
S * |        |          |00H = EADC_CH0.
S * |        |          |01H = EADC_CH1.
S * |        |          |02H = EADC_CH2.
S * |        |          |03H = EADC_CH3.
S * |        |          |04H = EADC_CH4.
S * |        |          |05H = EADC_CH5.
S * |        |          |06H = EADC_CH6.
S * |        |          |07H = EADC_CH7.
S * |        |          |08H = EADC_CH8.
S * |        |          |09H = EADC_CH9.
S * |        |          |0AH = EADC_CH10.
S * |        |          |0BH = EADC_CH11.
S * |        |          |0CH = EADC_CH12.
S * |        |          |0DH = EADC_CH13.
S * |        |          |0EH = EADC_CH14.
S * |        |          |0FH = EADC_CH15.
S * |        |          |10H = VBG.
S * |        |          |11H = VTEMP.
S * |        |          |12H = VBAT.
S * |[23]    |BUSY      |Busy/Idle
S * |        |          |0 = EADC is in idle state.
S * |        |          |1 = EADC is busy at conversion.
S * |        |          |Note: This bit is read only.
S * |[24]    |ADOVIF    |All A/D Interrupt Flag Overrun Bits Check
S * |        |          |n=0~3.
S * |        |          |0 = None of ADINT interrupt flag ADOVIFn (EADC_STATUS2[11:8]) is overwritten to 1.
S * |        |          |1 = Any one of ADINT interrupt flag ADOVIFn (EADC_STATUS2[11:8]) is overwritten to 1.
S * |        |          |Note: This bit will keep 1 when any ADOVIFn Flag is equal to 1.
S * |[25]    |STOVF     |For All A/D Sample Module Start Of Conversion Overrun Flags Check
S * |        |          |n=0~18.
S * |        |          |0 = None of sample module event overrun flag SPOVFn (EADC_OVSTS[n]) is set to 1.
S * |        |          |1 = Any one of sample module event overrun flag SPOVFn (EADC_OVSTS[n]) is set to 1.
S * |        |          |Note: This bit will keep 1 when any SPOVFn Flag is equal to 1.
S * |[26]    |AVALID    |For All Sample Module A/D Result Data Register EADC_DAT Data Valid Flag Check
S * |        |          |n=0~18.
S * |        |          |0 = None of sample module data register valid flag VALIDn (EADC_DATn[17]) is set to 1.
S * |        |          |1 = Any one of sample module data register valid flag VALIDn (EADC_DATn[17]) is set to 1.
S * |        |          |Note: This bit will keep 1 when any VALIDn Flag is equal to 1.
S * |[27]    |AOV       |For All Sample Module A/D Result Data Register Overrun Flags Check
S * |        |          |n=0~18.
S * |        |          |0 = None of sample module data register overrun flag OVn (EADC_DATn[16]) is set to 1.
S * |        |          |1 = Any one of sample module data register overrun flag OVn (EADC_DATn[16]) is set to 1.
S * |        |          |Note: This bit will keep 1 when any OVn Flag is equal to 1.
S * @var EADC_T::STATUS3
S * Offset: 0xFC  A/D Status Register 3
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[4:0]   |CURSPL    |ADC Current Sample Module
S * |        |          |This register show the current ADC is controlled by which sample module control logic modules.
S * |        |          |If the ADC is Idle, this bit filed will set to 0x1F.
S * |        |          |This is a read only register.
S * @var EADC_T::DDAT
S * Offset: 0x100-0x10C  A/D Double Data Register n for Sample Module n, n=0~3
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |RESULT    |A/D Conversion Results
S * |        |          |This field contains 12 bits conversion results.
S * |        |          |When the DMOF (EADC_CTL[9]) is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT [11:0] and zero will be filled in RESULT [15:12].
S * |        |          |When DMOF (EADC_CTL[9]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT [11:0] and signed bits to will be filled in RESULT [15:12].
S * |[16]    |OV        |Overrun Flag
S * |        |          |0 = Data in RESULT (EADC_DATn[15:0], n=0~3) is recent conversion result.
S * |        |          |1 = Data in RESULT (EADC_DATn[15:0], n=0~3) is overwrite.
S * |        |          |If converted data in RESULT[15:0] has not been read before new conversion result is loaded to this register, OV is set to 1.
S * |        |          |It is cleared by hardware after EADC_DDAT register is read.
S * |[17]    |VALID     |Valid Flag
S * |        |          |0 = Double data in RESULT (EADC_DDATn[15:0]) is not valid.
S * |        |          |1 = Double data in RESULT (EADC_DDATn[15:0]) is valid.
S * |        |          |This bit is set to 1 when corresponding sample module channel analog input conversion is completed and cleared by hardware after EADC_DDATn register is read.
S * |        |          |(n=0~3).
S */
S
S    __I  uint32_t DAT[19];       /* Offset: 0x00-0x48  A/D Data Register n for Sample Module n, n=0~18               */
S    __I  uint32_t CURDAT;        /* Offset: 0x4C  EADC PDMA Current Transfer Data Register                           */
S    __IO uint32_t CTL;           /* Offset: 0x50  A/D Control Register                                               */
S    __O  uint32_t SWTRG;         /* Offset: 0x54  A/D Sample Module Software Start Register                          */
S    __IO uint32_t PENDSTS;       /* Offset: 0x58  A/D Start of Conversion Pending Flag Register                      */
S    __IO uint32_t OVSTS;         /* Offset: 0x5C  A/D Sample Module Start of Conversion Overrun Flag Register        */
S    __I  uint32_t RESERVE0[8];  
S    __IO uint32_t SCTL[19];      /* Offset: 0x80-0xC8  A/D Sample Module n Control Register, n=0~3                   */
S    __I  uint32_t RESERVE1[1];  
S    __IO uint32_t INTSRC[4];     /* Offset: 0xDC  ADC interrupt n Source Enable Control Register, n=0~3              */
S    __IO uint32_t CMP[4];        /* Offset: 0xEC  A/D Result Compare Register n, n=0~3                               */
S    __I  uint32_t STATUS0;       /* Offset: 0xF0  A/D Status Register 0                                              */
S    __I  uint32_t STATUS1;       /* Offset: 0xF4  A/D Status Register 1                                              */
S    __IO uint32_t STATUS2;       /* Offset: 0xF8  A/D Status Register 2                                              */
S    __I  uint32_t STATUS3;       /* Offset: 0xFC  A/D Status Register 3                                              */
S    __I  uint32_t DDAT[4];       /* Offset: 0x100-0x10C  A/D Double Data Register n for Sample Module n, n=0~3       */
S
S} EADC_T;
S
S
S
S/**
S    @addtogroup EADC_CONST EADC Bit Field Definition
S    Constant Definitions for EADC Controller
S@{ */
S#define EADC_DAT_RESULT_Pos               (0)                                               /*!< EADC_T::DAT: RESULT Position              */
S#define EADC_DAT_RESULT_Msk               (0xfffful << EADC_DAT_RESULT_Pos)                 /*!< EADC_T::DAT: RESULT Mask                  */
S
S#define EADC_DAT_OV_Pos                   (16)                                              /*!< EADC_T::DAT: OV Position                  */
S#define EADC_DAT_OV_Msk                   (0x1ul << EADC_DAT_OV_Pos)                        /*!< EADC_T::DAT: OV Mask                      */
S
S#define EADC_DAT_VALID_Pos                (17)                                              /*!< EADC_T::DAT: VALID Position               */
S#define EADC_DAT_VALID_Msk                (0x1ul << EADC_DAT_VALID_Pos)                     /*!< EADC_T::DAT: VALID Mask                   */
S
S#define EADC_CURDAT_CURDAT_Pos            (0)                                               /*!< EADC_T::CURDAT: CURDAT Position           */
S#define EADC_CURDAT_CURDAT_Msk            (0x3fffful << EADC_CURDAT_CURDAT_Pos)             /*!< EADC_T::CURDAT: CURDAT Mask               */
S
S#define EADC_CTL_ADCEN_Pos                (0)                                               /*!< EADC_T::CTL: ADCEN Position               */
S#define EADC_CTL_ADCEN_Msk                (0x1ul << EADC_CTL_ADCEN_Pos)                     /*!< EADC_T::CTL: ADCEN Mask                   */
S
S#define EADC_CTL_ADRST_Pos                (1)                                               /*!< EADC_T::CTL: ADRST Position               */
S#define EADC_CTL_ADRST_Msk                (0x1ul << EADC_CTL_ADRST_Pos)                     /*!< EADC_T::CTL: ADRST Mask                   */
S
S#define EADC_CTL_ADCIEN0_Pos              (2)                                               /*!< EADC_T::CTL: ADCIEN0 Position             */
S#define EADC_CTL_ADCIEN0_Msk              (0x1ul << EADC_CTL_ADCIEN0_Pos)                   /*!< EADC_T::CTL: ADCIEN0 Mask                 */
S
S#define EADC_CTL_ADCIEN1_Pos              (3)                                               /*!< EADC_T::CTL: ADCIEN1 Position             */
S#define EADC_CTL_ADCIEN1_Msk              (0x1ul << EADC_CTL_ADCIEN1_Pos)                   /*!< EADC_T::CTL: ADCIEN1 Mask                 */
S
S#define EADC_CTL_ADCIEN2_Pos              (4)                                               /*!< EADC_T::CTL: ADCIEN2 Position             */
S#define EADC_CTL_ADCIEN2_Msk              (0x1ul << EADC_CTL_ADCIEN2_Pos)                   /*!< EADC_T::CTL: ADCIEN2 Mask                 */
S
S#define EADC_CTL_ADCIEN3_Pos              (5)                                               /*!< EADC_T::CTL: ADCIEN3 Position             */
S#define EADC_CTL_ADCIEN3_Msk              (0x1ul << EADC_CTL_ADCIEN3_Pos)                   /*!< EADC_T::CTL: ADCIEN3 Mask                 */
S
S#define EADC_CTL_DIFFEN_Pos               (8)                                               /*!< EADC_T::CTL: DIFFEN Position              */
S#define EADC_CTL_DIFFEN_Msk               (0x1ul << EADC_CTL_DIFFEN_Pos)                    /*!< EADC_T::CTL: DIFFEN Mask                  */
S
S#define EADC_CTL_DMOF_Pos                 (9)                                               /*!< EADC_T::CTL: DMOF Position                */
S#define EADC_CTL_DMOF_Msk                 (0x1ul << EADC_CTL_DMOF_Pos)                      /*!< EADC_T::CTL: DMOF Mask                    */
S
S#define EADC_CTL_PDMAEN_Pos               (11)                                              /*!< EADC_T::CTL: PDMAEN Position              */
S#define EADC_CTL_PDMAEN_Msk               (0x1ul << EADC_CTL_PDMAEN_Pos)                    /*!< EADC_T::CTL: PDMAEN Mask                  */
S
S#define EADC_CTL_SMPTSEL_Pos              (16)                                              /*!< EADC_T::CTL: SMPTSEL Position             */
S#define EADC_CTL_SMPTSEL_Msk              (0x7ul << EADC_CTL_SMPTSEL_Pos)                   /*!< EADC_T::CTL: SMPTSEL Mask                 */
S
S#define EADC_SWTRG_SWTRG_Pos              (0)                                               /*!< EADC_T::SWTRG: SWTRG Position             */
S#define EADC_SWTRG_SWTRG_Msk              (0x7fffful << EADC_SWTRG_SWTRG_Pos)               /*!< EADC_T::SWTRG: SWTRG Mask                 */
S
S#define EADC_PENDSTS_STPF_Pos             (0)                                               /*!< EADC_T::PENDSTS: STPF Position            */
S#define EADC_PENDSTS_STPF_Msk             (0x7fffful << EADC_PENDSTS_STPF_Pos)              /*!< EADC_T::PENDSTS: STPF Mask                */
S
S#define EADC_OVSTS_SPOVF_Pos              (0)                                               /*!< EADC_T::OVSTS: SPOVF Position             */
S#define EADC_OVSTS_SPOVF_Msk              (0x7fffful << EADC_OVSTS_SPOVF_Pos)               /*!< EADC_T::OVSTS: SPOVF Mask                 */
S
S#define EADC_SCTL_CHSEL_Pos               (0)                                               /*!< EADC_T::SCTL: CHSEL Position              */
S#define EADC_SCTL_CHSEL_Msk               (0xful << EADC_SCTL_CHSEL_Pos)                    /*!< EADC_T::SCTL: CHSEL Mask                  */
S
S#define EADC_SCTL_EXTREN_Pos              (4)                                               /*!< EADC_T::SCTL: EXTREN Position             */
S#define EADC_SCTL_EXTREN_Msk              (0x1ul << EADC_SCTL_EXTREN_Pos)                   /*!< EADC_T::SCTL: EXTREN Mask                 */
S
S#define EADC_SCTL_EXTFEN_Pos              (5)                                               /*!< EADC_T::SCTL: EXTFEN Position             */
S#define EADC_SCTL_EXTFEN_Msk              (0x1ul << EADC_SCTL_EXTFEN_Pos)                   /*!< EADC_T::SCTL: EXTFEN Mask                 */
S
S#define EADC_SCTL_TRGDLYDIV_Pos           (6)                                               /*!< EADC_T::SCTL: TRGDLYDIV Position          */
S#define EADC_SCTL_TRGDLYDIV_Msk           (0x3ul << EADC_SCTL_TRGDLYDIV_Pos)                /*!< EADC_T::SCTL: TRGDLYDIV Mask              */
S
S#define EADC_SCTL_TRGDLYCNT_Pos           (8)                                               /*!< EADC_T::SCTL: TRGDLYCNT Position          */
S#define EADC_SCTL_TRGDLYCNT_Msk           (0xfful << EADC_SCTL_TRGDLYCNT_Pos)               /*!< EADC_T::SCTL: TRGDLYCNT Mask              */
S
S#define EADC_SCTL_TRGSEL_Pos              (16)                                              /*!< EADC_T::SCTL: TRGSEL Position             */
S#define EADC_SCTL_TRGSEL_Msk              (0x1ful << EADC_SCTL_TRGSEL_Pos)                  /*!< EADC_T::SCTL: TRGSEL Mask                 */
S
S#define EADC_SCTL_INTPOS_Pos              (22)                                              /*!< EADC_T::SCTL: INTPOS Position             */
S#define EADC_SCTL_INTPOS_Msk              (0x1ul << EADC_SCTL_INTPOS_Pos)                   /*!< EADC_T::SCTL: INTPOS Mask                 */
S
S#define EADC_SCTL_DBMEN_Pos               (23)                                              /*!< EADC_T::SCTL: DBMEN Position              */
S#define EADC_SCTL_DBMEN_Msk               (0x1ul << EADC_SCTL_DBMEN_Pos)                    /*!< EADC_T::SCTL: DBMEN Mask                  */
S
S#define EADC_SCTL_EXTSMPT_Pos             (24)                                              /*!< EADC_T::SCTL: EXTSMPT Position            */
S#define EADC_SCTL_EXTSMPT_Msk             (0xfful << EADC_SCTL_EXTSMPT_Pos)                 /*!< EADC_T::SCTL: EXTSMPT Mask                */
S
S#define EADC_INTSRC_SPLIE_Pos             (0)                                               /*!< EADC_T::INTSRC: SPLIE Position            */
S#define EADC_INTSRC_SPLIE_Msk             (0x7FFFFul << EADC_INTSRC_SPLIE_Pos)              /*!< EADC_T::INTSRC: SPLIE Mask                */
S
S#define EADC_CMP_ADCMPEN_Pos              (0)                                               /*!< EADC_T::CMP: ADCMPEN Position             */
S#define EADC_CMP_ADCMPEN_Msk              (0x1ul << EADC_CMP_ADCMPEN_Pos)                   /*!< EADC_T::CMP: ADCMPEN Mask                 */
S
S#define EADC_CMP_ADCMPIE_Pos              (1)                                               /*!< EADC_T::CMP: ADCMPIE Position             */
S#define EADC_CMP_ADCMPIE_Msk              (0x1ul << EADC_CMP_ADCMPIE_Pos)                   /*!< EADC_T::CMP: ADCMPIE Mask                 */
S
S#define EADC_CMP_CMPCOND_Pos              (2)                                               /*!< EADC_T::CMP: CMPCOND Position             */
S#define EADC_CMP_CMPCOND_Msk              (0x1ul << EADC_CMP_CMPCOND_Pos)                   /*!< EADC_T::CMP: CMPCOND Mask                 */
S
S#define EADC_CMP_CMPSPL_Pos               (3)                                               /*!< EADC_T::CMP: CMPSPL Position              */
S#define EADC_CMP_CMPSPL_Msk               (0x1ful << EADC_CMP_CMPSPL_Pos)                   /*!< EADC_T::CMP: CMPSPL Mask                  */
S
S#define EADC_CMP_CMPMCNT_Pos              (8)                                               /*!< EADC_T::CMP: CMPMCNT Position             */
S#define EADC_CMP_CMPMCNT_Msk              (0xful << EADC_CMP_CMPMCNT_Pos)                   /*!< EADC_T::CMP: CMPMCNT Mask                 */
S
S#define EADC_CMP_CMPWEN_Pos               (15)                                              /*!< EADC_T::CMP: CMPWEN Position              */
S#define EADC_CMP_CMPWEN_Msk               (0x1ul << EADC_CMP_CMPWEN_Pos)                    /*!< EADC_T::CMP: CMPWEN Mask                  */
S
S#define EADC_CMP_CMPDAT_Pos               (16)                                              /*!< EADC_T::CMP: CMPDAT Position              */
S#define EADC_CMP_CMPDAT_Msk               (0xffful << EADC_CMP_CMPDAT_Pos)                  /*!< EADC_T::CMP: CMPDAT Mask                  */
S
S#define EADC_STATUS0_VALID_Pos            (0)                                               /*!< EADC_T::STATUS0: VALID Position           */
S#define EADC_STATUS0_VALID_Msk            (0xfffful << EADC_STATUS0_VALID_Pos)              /*!< EADC_T::STATUS0: VALID Mask               */
S
S#define EADC_STATUS0_OV_Pos               (16)                                              /*!< EADC_T::STATUS0: OV Position              */
S#define EADC_STATUS0_OV_Msk               (0xfffful << EADC_STATUS0_OV_Pos)                 /*!< EADC_T::STATUS0: OV Mask                  */
S
S#define EADC_STATUS1_VALID_Pos            (0)                                               /*!< EADC_T::STATUS1: VALID Position           */
S#define EADC_STATUS1_VALID_Msk            (0x7ul << EADC_STATUS1_VALID_Pos)                 /*!< EADC_T::STATUS1: VALID Mask               */
S
S#define EADC_STATUS1_OV_Pos               (16)                                              /*!< EADC_T::STATUS1: OV Position              */
S#define EADC_STATUS1_OV_Msk               (0x7ul << EADC_STATUS1_OV_Pos)                    /*!< EADC_T::STATUS1: OV Mask                  */
S
S#define EADC_STATUS2_ADIF0_Pos            (0)                                               /*!< EADC_T::STATUS2: ADIF0 Position           */
S#define EADC_STATUS2_ADIF0_Msk            (0x1ul << EADC_STATUS2_ADIF0_Pos)                 /*!< EADC_T::STATUS2: ADIF0 Mask               */
S
S#define EADC_STATUS2_ADIF1_Pos            (1)                                               /*!< EADC_T::STATUS2: ADIF1 Position           */
S#define EADC_STATUS2_ADIF1_Msk            (0x1ul << EADC_STATUS2_ADIF1_Pos)                 /*!< EADC_T::STATUS2: ADIF1 Mask               */
S
S#define EADC_STATUS2_ADIF2_Pos            (2)                                               /*!< EADC_T::STATUS2: ADIF2 Position           */
S#define EADC_STATUS2_ADIF2_Msk            (0x1ul << EADC_STATUS2_ADIF2_Pos)                 /*!< EADC_T::STATUS2: ADIF2 Mask               */
S
S#define EADC_STATUS2_ADIF3_Pos            (3)                                               /*!< EADC_T::STATUS2: ADIF3 Position           */
S#define EADC_STATUS2_ADIF3_Msk            (0x1ul << EADC_STATUS2_ADIF3_Pos)                 /*!< EADC_T::STATUS2: ADIF3 Mask               */
S
S#define EADC_STATUS2_ADCMPF0_Pos          (4)                                               /*!< EADC_T::STATUS2: ADCMPF0 Position         */
S#define EADC_STATUS2_ADCMPF0_Msk          (0x1ul << EADC_STATUS2_ADCMPF0_Pos)               /*!< EADC_T::STATUS2: ADCMPF0 Mask             */
S
S#define EADC_STATUS2_ADCMPF1_Pos          (5)                                               /*!< EADC_T::STATUS2: ADCMPF1 Position         */
S#define EADC_STATUS2_ADCMPF1_Msk          (0x1ul << EADC_STATUS2_ADCMPF1_Pos)               /*!< EADC_T::STATUS2: ADCMPF1 Mask             */
S
S#define EADC_STATUS2_ADCMPF2_Pos          (6)                                               /*!< EADC_T::STATUS2: ADCMPF2 Position         */
S#define EADC_STATUS2_ADCMPF2_Msk          (0x1ul << EADC_STATUS2_ADCMPF2_Pos)               /*!< EADC_T::STATUS2: ADCMPF2 Mask             */
S
S#define EADC_STATUS2_ADCMPF3_Pos          (7)                                               /*!< EADC_T::STATUS2: ADCMPF3 Position         */
S#define EADC_STATUS2_ADCMPF3_Msk          (0x1ul << EADC_STATUS2_ADCMPF3_Pos)               /*!< EADC_T::STATUS2: ADCMPF3 Mask             */
S
S#define EADC_STATUS2_ADOVIF0_Pos          (8)                                               /*!< EADC_T::STATUS2: ADOVIF0 Position         */
S#define EADC_STATUS2_ADOVIF0_Msk          (0x1ul << EADC_STATUS2_ADOVIF0_Pos)               /*!< EADC_T::STATUS2: ADOVIF0 Mask             */
S
S#define EADC_STATUS2_ADOVIF1_Pos          (9)                                               /*!< EADC_T::STATUS2: ADOVIF1 Position         */
S#define EADC_STATUS2_ADOVIF1_Msk          (0x1ul << EADC_STATUS2_ADOVIF1_Pos)               /*!< EADC_T::STATUS2: ADOVIF1 Mask             */
S
S#define EADC_STATUS2_ADOVIF2_Pos          (10)                                              /*!< EADC_T::STATUS2: ADOVIF2 Position         */
S#define EADC_STATUS2_ADOVIF2_Msk          (0x1ul << EADC_STATUS2_ADOVIF2_Pos)               /*!< EADC_T::STATUS2: ADOVIF2 Mask             */
S
S#define EADC_STATUS2_ADOVIF3_Pos          (11)                                              /*!< EADC_T::STATUS2: ADOVIF3 Position         */
S#define EADC_STATUS2_ADOVIF3_Msk          (0x1ul << EADC_STATUS2_ADOVIF3_Pos)               /*!< EADC_T::STATUS2: ADOVIF3 Mask             */
S
S#define EADC_STATUS2_ADCMPO0_Pos          (12)                                              /*!< EADC_T::STATUS2: ADCMPO0 Position         */
S#define EADC_STATUS2_ADCMPO0_Msk          (0x1ul << EADC_STATUS2_ADCMPO0_Pos)               /*!< EADC_T::STATUS2: ADCMPO0 Mask             */
S
S#define EADC_STATUS2_ADCMPO1_Pos          (13)                                              /*!< EADC_T::STATUS2: ADCMPO1 Position         */
S#define EADC_STATUS2_ADCMPO1_Msk          (0x1ul << EADC_STATUS2_ADCMPO1_Pos)               /*!< EADC_T::STATUS2: ADCMPO1 Mask             */
S
S#define EADC_STATUS2_ADCMPO2_Pos          (14)                                              /*!< EADC_T::STATUS2: ADCMPO2 Position         */
S#define EADC_STATUS2_ADCMPO2_Msk          (0x1ul << EADC_STATUS2_ADCMPO2_Pos)               /*!< EADC_T::STATUS2: ADCMPO2 Mask             */
S
S#define EADC_STATUS2_ADCMPO3_Pos          (15)                                              /*!< EADC_T::STATUS2: ADCMPO3 Position         */
S#define EADC_STATUS2_ADCMPO3_Msk          (0x1ul << EADC_STATUS2_ADCMPO3_Pos)               /*!< EADC_T::STATUS2: ADCMPO3 Mask             */
S
S#define EADC_STATUS2_CHANNEL_Pos          (16)                                              /*!< EADC_T::STATUS2: CHANNEL Position         */
S#define EADC_STATUS2_CHANNEL_Msk          (0x1ful << EADC_STATUS2_CHANNEL_Pos)              /*!< EADC_T::STATUS2: CHANNEL Mask             */
S
S#define EADC_STATUS2_BUSY_Pos             (23)                                              /*!< EADC_T::STATUS2: BUSY Position            */
S#define EADC_STATUS2_BUSY_Msk             (0x1ul << EADC_STATUS2_BUSY_Pos)                  /*!< EADC_T::STATUS2: BUSY Mask                */
S
S#define EADC_STATUS2_ADOVIF_Pos           (24)                                              /*!< EADC_T::STATUS2: ADOVIF Position          */
S#define EADC_STATUS2_ADOVIF_Msk           (0x1ul << EADC_STATUS2_ADOVIF_Pos)                /*!< EADC_T::STATUS2: ADOVIF Mask              */
S
S#define EADC_STATUS2_STOVF_Pos            (25)                                              /*!< EADC_T::STATUS2: STOVF Position           */
S#define EADC_STATUS2_STOVF_Msk            (0x1ul << EADC_STATUS2_STOVF_Pos)                 /*!< EADC_T::STATUS2: STOVF Mask               */
S
S#define EADC_STATUS2_AVALID_Pos           (26)                                              /*!< EADC_T::STATUS2: AVALID Position          */
S#define EADC_STATUS2_AVALID_Msk           (0x1ul << EADC_STATUS2_AVALID_Pos)                /*!< EADC_T::STATUS2: AVALID Mask              */
S
S#define EADC_STATUS2_AOV_Pos              (27)                                              /*!< EADC_T::STATUS2: AOV Position             */
S#define EADC_STATUS2_AOV_Msk              (0x1ul << EADC_STATUS2_AOV_Pos)                   /*!< EADC_T::STATUS2: AOV Mask                 */
S
S#define EADC_STATUS3_CURSPL_Pos           (0)                                               /*!< EADC_T::STATUS3: CURSPL Position          */
S#define EADC_STATUS3_CURSPL_Msk           (0x1ful << EADC_STATUS3_CURSPL_Pos)               /*!< EADC_T::STATUS3: CURSPL Mask              */
S
S#define EADC_DDAT_RESULT_Pos              (0)                                               /*!< EADC_T::DDAT: RESULT Position             */
S#define EADC_DDAT_RESULT_Msk              (0xfffful << EADC_DDAT_RESULT_Pos)                /*!< EADC_T::DDAT: RESULT Mask                 */
S
S#define EADC_DDAT_OV_Pos                  (16)                                              /*!< EADC_T::DDAT: OV Position                 */
S#define EADC_DDAT_OV_Msk                  (0x1ul << EADC_DDAT_OV_Pos)                       /*!< EADC_T::DDAT: OV Mask                     */
S
S#define EADC_DDAT_VALID_Pos               (17)                                              /*!< EADC_T::DDAT: VALID Position              */
S#define EADC_DDAT_VALID_Msk               (0x1ul << EADC_DDAT_VALID_Pos)                    /*!< EADC_T::DDAT: VALID Mask                  */
S
S
S/**@}*/ /* EADC_CONST */
S/**@}*/ /* end of EADC register group */
S
S
S/*---------------------- Controller Area Network Controller -------------------------*/
S/**
S    @addtogroup CAN Controller Area Network Controller(CAN)
S    Memory Mapped Structure for CAN Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S
S/**
S * @var CAN_IF_T::CREQ
S * Offset: 0x20, 0x80  IFn (Register Map Note 2) Command Request Registers
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |MessageNumber|Message Number
S * |        |          |0x01-0x20: Valid Message Number, the Message Object in the Message
S * |        |          |RAM is selected for data transfer.
S * |        |          |0x00: Not a valid Message Number, interpreted as 0x20.
S * |        |          |0x21-0x3F: Not a valid Message Number, interpreted as 0x01-0x1F.
S * |[15]    |Busy      |Busy Flag
S * |        |          |0 = Read/write action has finished.
S * |        |          |1 = Writing to the IFn Command Request Register is in progress.
S * |        |          |This bit can only be read by the software.
S * @var CAN_IF_T::CMASK
S * Offset: 0x24, 0x84  IFn Command Mask Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |DAT_B     |Access Data Bytes [7:4]
S * |        |          |Write Operation:
S * |        |          |0 = Data Bytes [7:4] unchanged.
S * |        |          |1 = Transfer Data Bytes [7:4] to Message Object.
S * |        |          |Read Operation:
S * |        |          |0 = Data Bytes [7:4] unchanged.
S * |        |          |1 = Transfer Data Bytes [7:4] to IFn Message Buffer Register.
S * |[1]     |DAT_A     |Access Data Bytes [3:0]
S * |        |          |Write Operation:
S * |        |          |0 = Data Bytes [3:0] unchanged.
S * |        |          |1 = Transfer Data Bytes [3:0] to Message Object.
S * |        |          |Read Operation:
S * |        |          |0 = Data Bytes [3:0] unchanged.
S * |        |          |1 = Transfer Data Bytes [3:0] to IFn Message Buffer Register.
S * |[2]     |TxRqst_NewDat|Access Transmission Request Bit When Write Operation
S * |        |          |0 = TxRqst bit unchanged.
S * |        |          |1 = Set TxRqst bit.
S * |        |          |Note: If a transmission is requested by programming bit TxRqst/NewDat in the IFn Command Mask Register, bit TxRqst in the IFn Message Control Register will be ignored.
S * |        |          |Access New Data Bit when Read Operation.
S * |        |          |0 = NewDat bit remains unchanged.
S * |        |          |1 = Clear NewDat bit in the Message Object.
S * |        |          |Note: A read access to a Message Object can be combined with the reset of the control bits IntPnd and NewDat.
S * |        |          |The values of these bits transferred to the IFn Message Control Register always reflect the status before resetting these bits.
S * |[3]     |ClrIntPnd |Clear Interrupt Pending Bit
S * |        |          |Write Operation:
S * |        |          |When writing to a Message Object, this bit is ignored.
S * |        |          |Read Operation:
S * |        |          |0 = IntPnd bit (CAN_IFn_MCON[13]) remains unchanged.
S * |        |          |1 = Clear IntPnd bit in the Message Object.
S * |[4]     |Control   |Control Access Control Bits
S * |        |          |Write Operation:
S * |        |          |0 = Control Bits unchanged.
S * |        |          |1 = Transfer Control Bits to Message Object.
S * |        |          |Read Operation:
S * |        |          |0 = Control Bits unchanged.
S * |        |          |1 = Transfer Control Bits to IFn Message Buffer Register.
S * |[5]     |Arb       |Access Arbitration Bits
S * |        |          |Write Operation:
S * |        |          |0 = Arbitration bits unchanged.
S * |        |          |1 = Transfer Identifier + Dir (CAN_IFn_ARB2[13]) + Xtd (CAN_IFn_ARB2[14]) + MsgVal (CAN_IFn_APB2[15]) to Message Object.
S * |        |          |Read Operation:
S * |        |          |0 = Arbitration bits unchanged.
S * |        |          |1 = Transfer Identifier + Dir + Xtd + MsgVal to IFn Message Buffer Register.
S * |[6]     |Mask      |Access Mask Bits
S * |        |          |Write Operation:
S * |        |          |0 = Mask bits unchanged.
S * |        |          |1 = Transfer Identifier Mask + MDir + MXtd to Message Object.
S * |        |          |Read Operation:
S * |        |          |0 = Mask bits unchanged.
S * |        |          |1 = Transfer Identifier Mask + MDir + MXtd to IFn Message Buffer Register.
S * |[7]     |WR_RD     |Write / Read Mode
S * |        |          |0 = Read: Transfer data from the Message Object addressed by the Command Request Register into the selected Message Buffer Registers.
S * |        |          |1 = Write: Transfer data from the selected Message Buffer Registers to the Message Object addressed by the Command Request Register.
S * @var CAN_IF_T::MASK1
S * Offset: 0x28, 0x88  IFn Mask 1 Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |Msk[15:0] |Identifier Mask 15-0
S * |        |          |0 = The corresponding bit in the identifier of the message object cannot inhibit the match in the acceptance filtering.
S * |        |          |1 = The corresponding identifier bit is used for acceptance filtering.
S * @var CAN_IF_T::MASK2
S * Offset: 0x2C, 0x8C  IFn Mask 2 Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[12:0]  |Msk[28:16]|Identifier Mask 28-16
S * |        |          |0 = The corresponding bit in the identifier of the message object cannot inhibit the match in the acceptance filtering.
S * |        |          |1 = The corresponding identifier bit is used for acceptance filtering.
S * |[14]    |MDir      |Mask Message Direction
S * |        |          |0 = The message direction bit (Dir (CAN_IFn_ARB2[13])) has no effect on the acceptance filtering.
S * |        |          |1 = The message direction bit (Dir) is used for acceptance filtering.
S * |[15]    |MXtd      |Mask Extended Identifier
S * |        |          |0 = The extended identifier bit (IDE) has no effect on the acceptance filtering.
S * |        |          |1 = The extended identifier bit (IDE) is used for acceptance filtering.
S * |        |          |Note: When 11-bit ("standard") Identifiers are used for a Message Object, the identifiers of received Data Frames are written into bits ID28 to ID18 (CAN_IFn_ARB2[12:2]).
S * |        |          |For acceptance filtering, only these bits together with mask bits Msk28 to Msk18 (CAN_IFn_MASK2[12:2]) are considered.
S * @var CAN_IF_T::ARB1
S * Offset: 0x30, 0x90  IFn Arbitration 1 Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |ID[15:0]  |Message Identifier 15-0
S * |        |          |ID28 - ID0, 29-bit Identifier ("Extended Frame").
S * |        |          |ID28 - ID18, 11-bit Identifier ("Standard Frame")
S * @var CAN_IF_T::ARB2
S * Offset: 0x34, 0x94  IFn Arbitration 2 Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[12:0]  |ID[28:16] |Message Identifier 28-16
S * |        |          |ID28 - ID0, 29-bit Identifier ("Extended Frame").
S * |        |          |ID28 - ID18, 11-bit Identifier ("Standard Frame")
S * |[13]    |Dir       |Message Direction
S * |        |          |0 = Direction is receive.
S * |        |          |On TxRqst, a Remote Frame with the identifier of this Message Object is transmitted.
S * |        |          |On reception of a Data Frame with matching identifier, that message is stored in this Message Object.
S * |        |          |1 = Direction is transmit.
S * |        |          |On TxRqst, the respective Message Object is transmitted as a Data Frame.
S * |        |          |On reception of a Remote Frame with matching identifier, the TxRqst bit (CAN_IFn_CMASK[2]) of this Message Object is set (if RmtEn (CAN_IFn_MCON[9]) = one).
S * |[14]    |Xtd       |Extended Identifier
S * |        |          |0 = The 11-bit ("standard") Identifier will be used for this Message Object.
S * |        |          |1 = The 29-bit ("extended") Identifier will be used for this Message Object.
S * |[15]    |MsgVal    |Message Valid
S * |        |          |0 = The Message Object is ignored by the Message Handler.
S * |        |          |1 = The Message Object is configured and should be considered by the Message Handler.
S * |        |          |Note: The application software must reset the MsgVal bit of all unused Messages Objects during the initialization before it resets bit Init (CAN_CON[0]).
S * |        |          |This bit must also be reset before the identifier Id28-0 (CAN_IFn_ARB1/2), the control bits Xtd (CAN_IFn_ARB2[14]), Dir (CAN_IFn_APB2[13]), or the Data Length Code DLC3-0 (CAN_IFn_MCON[3:0]) are modified, or if the Messages Object is no longer required.
S * @var CAN_IF_T::MCON
S * Offset: 0x38, 0x98  IFn Message Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |DLC       |Data Length Code
S * |        |          |0-8: Data Frame has 0-8 data bytes.
S * |        |          |9-15: Data Frame has 8 data bytes
S * |        |          |Note: The Data Length Code of a Message Object must be defined the same as in all the corresponding objects with the same identifier at other nodes.
S * |        |          |When the Message Handler stores a data frame, it will write the DLC to the value given by the received message.
S * |        |          |Data 0: 1st data byte of a CAN Data Frame
S * |        |          |Data 1: 2nd data byte of a CAN Data Frame
S * |        |          |Data 2: 3rd data byte of a CAN Data Frame
S * |        |          |Data 3: 4th data byte of a CAN Data Frame
S * |        |          |Data 4: 5th data byte of a CAN Data Frame
S * |        |          |Data 5: 6th data byte of a CAN Data Frame
S * |        |          |Data 6: 7th data byte of a CAN Data Frame
S * |        |          |Data 7 : 8th data byte of a CAN Data Frame
S * |        |          |Note: The Data 0 Byte is the first data byte shifted into the shift register of the CAN Core during a reception while the Data 7 byte is the last.
S * |        |          |When the Message Handler stores a Data Frame, it will write all the eight data bytes into a Message Object.
S * |        |          |If the Data Length Code is less than 8, the remaining bytes of the Message Object will be overwritten by unspecified values.
S * |[7]     |EoB       |End Of Buffer
S * |        |          |0 = Message Object belongs to a FIFO Buffer and is not the last Message Object of that FIFO Buffer.
S * |        |          |1 = Single Message Object or last Message Object of a FIFO Buffer.
S * |        |          |Note: This bit is used to concatenate two or more Message Objects (up to 32) to build a FIFO Buffer.
S * |        |          |For single Message Objects (not belonging to a FIFO Buffer), this bit must always be set to one.
S * |[8]     |TxRqst    |Transmit Request
S * |        |          |0 = This Message Object is not waiting for transmission.
S * |        |          |1 = The transmission of this Message Object is requested and is not yet done.
S * |[9]     |RmtEn     |Remote Enable Control
S * |        |          |0 = At the reception of a Remote Frame, TxRqst (CAN_IFn_MCON[8]) is left unchanged.
S * |        |          |1 = At the reception of a Remote Frame, TxRqst is set.
S * |[10]    |RxIE      |Receive Interrupt Enable Control
S * |        |          |0 = IntPnd (CAN_IFn_MCON[13]) will be left unchanged after a successful reception of a frame.
S * |        |          |1 = IntPnd will be set after a successful reception of a frame.
S * |[11]    |TxIE      |Transmit Interrupt Enable Control
S * |        |          |0 = IntPnd (CAN_IFn_MCON[13]) will be left unchanged after the successful transmission of a frame.
S * |        |          |1 = IntPnd will be set after a successful transmission of a frame.
S * |[12]    |UMask     |Use Acceptance Mask
S * |        |          |0 = Mask ignored.
S * |        |          |1 = Use Mask (Msk28-0, MXtd, and MDir) for acceptance filtering.
S * |        |          |Note: If the UMask bit is set to one, the Message Object's mask bits have to be programmed during initialization of the Message Object before MsgVal bit (CAN_IFn_APB2[15]) is set to one.
S * |[13]    |IntPnd    |Interrupt Pending
S * |        |          |0 = This message object is not the source of an interrupt.
S * |        |          |1 = This message object is the source of an interrupt.
S * |        |          |The Interrupt Identifier in the Interrupt Register will point to this message object if there is no other interrupt source with higher priority.
S * |[14]    |MsgLst    |Message Lost (only valid for Message Objects with direction = receive).
S * |        |          |0 = No message lost since last time this bit was reset by the CPU.
S * |        |          |1 = The Message Handler stored a new message into this object when NewDat was still set, the CPU has lost a message.
S * |[15]    |NewDat    |New Data
S * |        |          |0 = No new data has been written into the data portion of this Message Object by the Message Handler since last time this flag was cleared by the application software.
S * |        |          |1 = The Message Handler or the application software has written new data into the data portion of this Message Object.
S * @var CAN_IF_T::DAT_A1
S * Offset: 0x3C, 0x9C  IFn Data A1 Register (Register Map Note 3)
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |Data0     |Data Byte 0
S * |        |          |1st data byte of a CAN Data Frame
S * |[15:8]  |Data1     |Data Byte 1
S * |        |          |2nd data byte of a CAN Data Frame
S * @var CAN_IF_T::DAT_A2
S * Offset: 0x40, 0xA0  IFn Data A2 Register (Register Map Note 3)
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |Data2     |Data Byte 2
S * |        |          |3rd data byte of CAN Data Frame
S * |[15:8]  |Data3     |Data Byte 3
S * |        |          |4th data byte of CAN Data Frame
S * @var CAN_IF_T::DAT_B1
S * Offset: 0x44, 0xA4  IFn Data B1 Register (Register Map Note 3)
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |Data4     |Data Byte 4
S * |        |          |5th data byte of CAN Data Frame
S * |[15:8]  |Data5     |Data Byte 5
S * |        |          |6th data byte of CAN Data Frame
S * @var CAN_IF_T::DAT_B2
S * Offset: 0x48, 0xA8  IFn Data B2 Register (Register Map Note 3)
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |Data6     |Data Byte 6
S * |        |          |7th data byte of CAN Data Frame.
S * |[15:8]  |Data7     |Data Byte 7
S * |        |          |8th data byte of CAN Data Frame.
S */
S
S    __IO uint32_t CREQ;          /* Offset: 0x20, 0x80  IFn (Register Map Note 2) Command Request Registers          */
S    __IO uint32_t CMASK;         /* Offset: 0x24, 0x84  IFn Command Mask Register                                    */
S    __IO uint32_t MASK1;         /* Offset: 0x28, 0x88  IFn Mask 1 Register                                          */
S    __IO uint32_t MASK2;         /* Offset: 0x2C, 0x8C  IFn Mask 2 Register                                          */
S    __IO uint32_t ARB1;          /* Offset: 0x30, 0x90  IFn Arbitration 1 Register                                   */
S    __IO uint32_t ARB2;          /* Offset: 0x34, 0x94  IFn Arbitration 2 Register                                   */
S    __IO uint32_t MCON;          /* Offset: 0x38, 0x98  IFn Message Control Register                                 */
S    __IO uint32_t DAT_A1;        /* Offset: 0x3C, 0x9C  IFn Data A1 Register (Register Map Note 3)                   */
S    __IO uint32_t DAT_A2;        /* Offset: 0x40, 0xA0  IFn Data A2 Register (Register Map Note 3)                   */
S    __IO uint32_t DAT_B1;        /* Offset: 0x44, 0xA4  IFn Data B1 Register (Register Map Note 3)                   */
S    __IO uint32_t DAT_B2;        /* Offset: 0x48, 0xA8  IFn Data B2 Register (Register Map Note 3)                   */
S    __I  uint32_t RESERVE0[13];
S
S} CAN_IF_T;
S
S
S
S
Stypedef struct
S{
S
S
S
S/**
S * @var CAN_T::CON
S * Offset: 0x00  Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |Init      |Init Initialization
S * |        |          |0 = Normal Operation.
S * |        |          |1 = Initialization is started.
S * |[1]     |IE        |Module Interrupt Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[2]     |SIE       |Status Change Interrupt Enable Control
S * |        |          |0 = Disabled - No Status Change Interrupt will be generated.
S * |        |          |1 = Enabled - An interrupt will be generated when a message transfer is successfully completed or a CAN bus error is detected.
S * |[3]     |EIE       |Error Interrupt Enable Control
S * |        |          |0 = Disabled - No Error Status Interrupt will be generated.
S * |        |          |1 = Enabled - A change in the bits BOff (CAN_STATUS[7]) or EWarn (CAN_STATUS[6]) in the Status Register will generate an interrupt.
S * |[5]     |DAR       |Automatic Re-Transmission Disable Control
S * |        |          |0 = Automatic Retransmission of disturbed messages enabled.
S * |        |          |1 = Automatic Retransmission disabled.
S * |[6]     |CCE       |Configuration Change Enable Control
S * |        |          |0 = No write access to the Bit Timing Register.
S * |        |          |1 = Write access to the Bit Timing Register (CAN_BTIME) allowed. (while Init bit (CAN_CON[0]) = 1).
S * |[7]     |Test      |Test Mode Enable Control
S * |        |          |0 = Normal Operation.
S * |        |          |1 = Test Mode.
S * @var CAN_T::STATUS
S * Offset: 0x04  Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[2:0]   |LEC       |Last Error Code (Type Of The Last Error To Occur On The CAN Bus)
S * |        |          |The LEC field holds a code, which indicates the type of the last error to occur on the CAN bus.
S * |        |          |This field will be cleared to '0' when a message has been transferred (reception or transmission) without error.
S * |        |          |The unused code '7' may be written by the CPU to check for updates.
S * |        |          |The following table describes the error code.
S * |[3]     |TxOK      |Transmitted A Message Successfully
S * |        |          |0 = Since this bit was reset by the CPU, no message has been successfully transmitted.
S * |        |          |This bit is never reset by the CAN Core.
S * |        |          |1 = Since this bit was last reset by the CPU, a message has been successfully (error free and acknowledged by at least one other node) transmitted.
S * |[4]     |RxOK      |Received A Message Successfully
S * |        |          |0 = No message has been successfully received since this bit was last reset by the CPU.
S * |        |          |This bit is never reset by the CAN Core.
S * |        |          |1 = A message has been successfully received since this bit was last reset by the CPU (independent of the result of acceptance filtering).
S * |[5]     |EPass     |Error Passive (Read Only)
S * |        |          |0 = The CAN Core is error active.
S * |        |          |1 = The CAN Core is in the error passive state as defined in the CAN Specification.
S * |[6]     |EWarn     |Error Warning Status (Read Only)
S * |        |          |0 = Both error counters are below the error warning limit of 96.
S * |        |          |1 = At least one of the error counters in the EML has reached the error warning limit of 96.
S * |[7]     |BOff      |Bus-Off Status (Read Only)
S * |        |          |0 = The CAN module is not in bus-off state.
S * |        |          |1 = The CAN module is in bus-off state.
S * @var CAN_T::ERR
S * Offset: 0x08  Error Counter Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |TEC       |Transmit Error Counter
S * |        |          |Actual state of the Transmit Error Counter. Values between 0 and 255.
S * |[14:8]  |REC       |Receive Error Counter
S * |        |          |Actual state of the Receive Error Counter. Values between 0 and 127.
S * |[15]    |RP        |Receive Error Passive
S * |        |          |0 = The Receive Error Counter is below the error passive level.
S * |        |          |1 = The Receive Error Counter has reached the error passive level as defined in the CAN Specification.
S * @var CAN_T::BTIME
S * Offset: 0x0C  Bit Timing Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |BRP       |Baud Rate Prescaler
S * |        |          |0x01-0x3F: The value by which the oscillator frequency is divided for generating the bit time quanta.
S * |        |          |The bit time is built up from a multiple of this quanta.
S * |        |          |Valid values for the Baud Rate Prescaler are [ 0 ... 63 ].
S * |        |          |The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.
S * |[7:6]   |SJW       |(Re)Synchronization Jump Width
S * |        |          |0x0-0x3: Valid programmed values are [0 ... 3].
S * |        |          |The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.
S * |[11:8]  |TSeg1     |Time Segment Before The Sample Point Minus Sync_Seg
S * |        |          |0x01-0x0F: valid values for TSeg1 are [1 ... 15].
S * |        |          |The actual interpretation by the hardware of this value is such that one more than the value programmed is used.
S * |[14:12] |TSeg2     |Time Segment After Sample Point
S * |        |          |0x0-0x7: Valid values for TSeg2 are [0 ... 7].
S * |        |          |The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.
S * @var CAN_T::IIDR
S * Offset: 0x10  Interrupt Identifier Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |IntId     |Interrupt Identifier (Indicates The Source Of The Interrupt)
S * |        |          |If several interrupts are pending, the CAN Interrupt Register will point to the pending interrupt with the highest priority, disregarding their chronological order.
S * |        |          |An interrupt remains pending until the application software has cleared it.
S * |        |          |If IntId is different from 0x0000 and IE (CAN_IFn_MCON[1]) is set, the IRQ interrupt signal to the EIC is active.
S * |        |          |The interrupt remains active until IntId is back to value 0x0000 (the cause of the interrupt is reset) or until IE is reset.
S * |        |          |The Status Interrupt has the highest priority.
S * |        |          |Among the message interrupts, the Message Object' s interrupt priority decreases with increasing message number.
S * |        |          |A message interrupt is cleared by clearing the Message Object's IntPnd bit (CAN_IFn_MCON[13]).
S * |        |          |The Status Interrupt is cleared by reading the Status Register.
S * @var CAN_T::TEST
S * Offset: 0x14  Test Register (Register Map Note 1)
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |Res       |Reserved
S * |        |          |There are reserved bits.
S * |        |          |These bits are always read as '0' and must always be written with '0'.
S * |[2]     |Basic     |Basic Mode
S * |        |          |0 = Basic Mode disabled.
S * |        |          |1= IF1 Registers used as Tx Buffer, IF2 Registers used as Rx Buffer.
S * |[3]     |Silent    |Silent Mode
S * |        |          |0 = Normal operation.
S * |        |          |1 = The module is in Silent Mode.
S * |[4]     |LBack     |Loop Back Mode Enable Control
S * |        |          |0 = Loop Back Mode is disabled.
S * |        |          |1 = Loop Back Mode is enabled.
S * |[6:5]   |Tx10      |Tx[1:0]: Control Of CAN_TX Pin
S * |        |          |00 = Reset value, CAN_TX pin is controlled by the CAN Core.
S * |        |          |01 = Sample Point can be monitored at CAN_TX pin.
S * |        |          |10 = CAN_TX pin drives a dominant ('0') value.
S * |        |          |11 = CAN_TX pin drives a recessive ('1') value.
S * |[7]     |Rx        |Monitors The Actual Value Of CAN_RX Pin (Read Only)
S * |        |          |0 = The CAN bus is dominant (CAN_RX = '0').
S * |        |          |1 = The CAN bus is recessive (CAN_RX = '1').
S * @var CAN_T::BRPE
S * Offset: 0x18  Baud Rate Prescaler Extension Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |BRPE      |BRPE: Baud Rate Prescaler Extension
S * |        |          |0x00-0x0F: By programming BRPE, the Baud Rate Prescaler can be extended to values up to 1023.
S * |        |          |The actual interpretation by the hardware is that one more than the value programmed by BRPE (MSBs) and BTIME (LSBs) is used.
S * @var CAN_T::IF
S * Offset: 0x20~0xFC  CAN Interface Registers
S * ---------------------------------------------------------------------------------------------------
S * CAN interface structure. Refer to \ref CAN_IF_T for detail information.
S     *
S * @var CAN_T::TXREQ1
S * Offset: 0x100  Transmission Request Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |TxRqst[16:1]|Transmission Request Bits 16-1 (Of All Message Objects)
S * |        |          |0 = This Message Object is not waiting for transmission.
S * |        |          |1 = The transmission of this Message Object is requested and is not yet done.
S * |        |          |These bits are read only.
S * @var CAN_T::TXREQ2
S * Offset: 0x104  Transmission Request Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |TxRqst[32:17]|Transmission Request Bits 32-17 (Of All Message Objects)
S * |        |          |0 = This Message Object is not waiting for transmission.
S * |        |          |1 = The transmission of this Message Object is requested and is not yet done.
S * |        |          |These bits are read only.
S * @var CAN_T::NDAT1
S * Offset: 0x120  New Data Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |NewData[16:1]|New Data Bits 16-1 (Of All Message Objects)
S * |        |          |0 = No new data has been written into the data portion of this Message Object by the Message Handler since the last time this flag was cleared by the application software.
S * |        |          |1 = The Message Handler or the application software has written new data into the data portion of this Message Object.
S * @var CAN_T::NDAT2
S * Offset: 0x124  New Data Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |NewData[32:17]|New Data Bits 32-17 (Of All Message Objects)
S * |        |          |0 = No new data has been written into the data portion of this Message Object by the Message Handler since the last time this flag was cleared by the application software.
S * |        |          |1 = The Message Handler or the application software has written new data into the data portion of this Message Object.
S * @var CAN_T::IPND1
S * Offset: 0x140  Interrupt Pending Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |IntPnd[16:1]|Interrupt Pending Bits 16-1 (Of All Message Objects)
S * |        |          |0 = This message object is not the source of an interrupt.
S * |        |          |1 = This message object is the source of an interrupt.
S * @var CAN_T::IPND2
S * Offset: 0x144  Interrupt Pending Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |IntPnd[32:17]|Interrupt Pending Bits 32-17(Of All Message Objects)
S * |        |          |0 = This message object is not the source of an interrupt.
S * |        |          |1 = This message object is the source of an interrupt.
S * @var CAN_T::MVLD1
S * Offset: 0x160  Message Valid Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |MsgVal[16:1]|Message Valid Bits 16-1 (Of All Message Objects) (Read Only)
S * |        |          |0 = This Message Object is ignored by the Message Handler.
S * |        |          |1 = This Message Object is configured and should be considered by the Message Handler.
S * |        |          |Ex.
S * |        |          |CAN_MVLD1[0] means Message object No.1 is valid or not.
S * |        |          |If CAN_MVLD1[0] is set, message object No.1 is configured.
S * @var CAN_T::MVLD2
S * Offset: 0x164  Message Valid Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |MsgVal[32:17]|Message Valid Bits 32-17 (Of All Message Objects) (Read Only)
S * |        |          |0 = This Message Object is ignored by the Message Handler.
S * |        |          |1 = This Message Object is configured and should be considered by the Message Handler.
S * |        |          |Ex.CAN_MVLD2[15] means Message object No.32 is valid or not.
S * |        |          |If CAN_MVLD2[15] is set, message object No.32 is configured.
S * @var CAN_T::WU_EN
S * Offset: 0x168  Wake-up Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |WAKUP_EN  |Wake-Up Enable Control
S * |        |          |0 = The wake-up function Disabled.
S * |        |          |1 = The wake-up function Enabled.
S * |        |          |Note: User can wake-up system when there is a falling edge in the CAN_Rx pin.
S * @var CAN_T::WU_STATUS
S * Offset: 0x16C  Wake-up Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |WAKUP_STS |Wake-Up Status
S * |        |          |0 = No wake-up event occurred.
S * |        |          |1 = Wake-up event occurred.
S * |        |          |Note: This bit can be cleared by writing '0'.
S */
S
S    __IO uint32_t CON;           /* Offset: 0x00  Control Register                                                   */
S    __IO uint32_t STATUS;        /* Offset: 0x04  Status Register                                                    */
S    __I  uint32_t ERR;           /* Offset: 0x08  Error Counter Register                                             */
S    __IO uint32_t BTIME;         /* Offset: 0x0C  Bit Timing Register                                                */
S    __I  uint32_t IIDR;          /* Offset: 0x10  Interrupt Identifier Register                                      */
S    __IO uint32_t TEST;          /* Offset: 0x14  Test Register (Register Map Note 1)                                */
S    __IO uint32_t BRPE;          /* Offset: 0x18  Baud Rate Prescaler Extension Register                             */
S    __I  uint32_t RESERVE0[1];  
S    __IO CAN_IF_T IF[2];         /* Offset: 0x20~0xFC  CAN Interface Registers                                       */
S    __I  uint32_t RESERVE1[8];  
S    __I  uint32_t TXREQ1;        /* Offset: 0x100  Transmission Request Register 1                                   */
S    __I  uint32_t TXREQ2;        /* Offset: 0x104  Transmission Request Register 2                                   */
S    __I  uint32_t RESERVE3[6];  
S    __I  uint32_t NDAT1;         /* Offset: 0x120  New Data Register 1                                               */
S    __I  uint32_t NDAT2;         /* Offset: 0x124  New Data Register 2                                               */
S    __I  uint32_t RESERVE4[6];  
S    __I  uint32_t IPND1;         /* Offset: 0x140  Interrupt Pending Register 1                                      */
S    __I  uint32_t IPND2;         /* Offset: 0x144  Interrupt Pending Register 2                                      */
S    __I  uint32_t RESERVE5[6];  
S    __I  uint32_t MVLD1;         /* Offset: 0x160  Message Valid Register 1                                          */
S    __I  uint32_t MVLD2;         /* Offset: 0x164  Message Valid Register 2                                          */
S    __IO uint32_t WU_EN;         /* Offset: 0x168  Wake-up Enable Register                                           */
S    __IO uint32_t WU_STATUS;     /* Offset: 0x16C  Wake-up Status Register                                           */
S
S} CAN_T;
S
S
S
S/**
S    @addtogroup CAN_CONST CAN Bit Field Definition
S    Constant Definitions for CAN Controller
S@{ */
S/* CAN CON Bit Field Definitions */
S#define CAN_CON_TEST_Pos           7                                    /*!< CAN_T::CON: TEST Position */
S#define CAN_CON_TEST_Msk           (0x1ul << CAN_CON_TEST_Pos)          /*!< CAN_T::CON: TEST Mask     */
S                                                                                
S#define CAN_CON_CCE_Pos            6                                    /*!< CAN_T::CON: CCE Position  */
S#define CAN_CON_CCE_Msk            (0x1ul << CAN_CON_CCE_Pos)           /*!< CAN_T::CON: CCE Mask      */
S                                                             
S#define CAN_CON_DAR_Pos            5                                    /*!< CAN_T::CON: DAR Position  */
S#define CAN_CON_DAR_Msk            (0x1ul << CAN_CON_DAR_Pos)           /*!< CAN_T::CON: DAR Mask      */
S                                                             
S#define CAN_CON_EIE_Pos            3                                    /*!< CAN_T::CON: EIE Position  */
S#define CAN_CON_EIE_Msk            (0x1ul << CAN_CON_EIE_Pos)           /*!< CAN_T::CON: EIE Mask      */
S                                                             
S#define CAN_CON_SIE_Pos            2                                    /*!< CAN_T::CON: SIE Position  */
S#define CAN_CON_SIE_Msk            (0x1ul << CAN_CON_SIE_Pos)           /*!< CAN_T::CON: SIE Mask      */
S                                                             
S#define CAN_CON_IE_Pos             1                                    /*!< CAN_T::CON: IE Position   */
S#define CAN_CON_IE_Msk             (0x1ul << CAN_CON_IE_Pos)            /*!< CAN_T::CON: IE Mask       */
S                                                             
S#define CAN_CON_INIT_Pos           0                                    /*!< CAN_T::CON: INIT Position */
S#define CAN_CON_INIT_Msk           (0x1ul << CAN_CON_INIT_Pos)          /*!< CAN_T::CON: INIT Mask     */
S
S/* CAN STATUS Bit Field Definitions */
S#define CAN_STATUS_BOFF_Pos        7                                    /*!< CAN_T::STATUS: BOFF Position  */
S#define CAN_STATUS_BOFF_Msk        (0x1ul << CAN_STATUS_BOFF_Pos)       /*!< CAN_T::STATUS: BOFF Mask      */
S
S#define CAN_STATUS_EWARN_Pos       6                                    /*!< CAN_T::STATUS: EWARN Position */
S#define CAN_STATUS_EWARN_Msk       (0x1ul << CAN_STATUS_EWARN_Pos)      /*!< CAN_T::STATUS: EWARN Mask     */
S
S#define CAN_STATUS_EPASS_Pos       5                                    /*!< CAN_T::STATUS: EPASS Position */
S#define CAN_STATUS_EPASS_Msk       (0x1ul << CAN_STATUS_EPASS_Pos)      /*!< CAN_T::STATUS: EPASS Mask     */
S
S#define CAN_STATUS_RXOK_Pos        4                                    /*!< CAN_T::STATUS: RXOK Position  */
S#define CAN_STATUS_RXOK_Msk        (0x1ul << CAN_STATUS_RXOK_Pos)       /*!< CAN_T::STATUS: RXOK Mask      */
S
S#define CAN_STATUS_TXOK_Pos        3                                    /*!< CAN_T::STATUS: TXOK Position  */
S#define CAN_STATUS_TXOK_Msk        (0x1ul << CAN_STATUS_TXOK_Pos)       /*!< CAN_T::STATUS: TXOK Mask      */
S
S#define CAN_STATUS_LEC_Pos         0                                    /*!< CAN_T::STATUS: LEC Position   */
S#define CAN_STATUS_LEC_Msk         (0x7ul << CAN_STATUS_LEC_Pos)        /*!< CAN_T::STATUS: LEC Mask       */
S
S/* CAN ERR Bit Field Definitions */                                             
S#define CAN_ERR_RP_Pos             15                                   /*!< CAN_T::ERR: RP Position       */
S#define CAN_ERR_RP_Msk             (0x1ul << CAN_ERR_RP_Pos)            /*!< CAN_T::ERR: RP Mask           */
S
S#define CAN_ERR_REC_Pos            8                                    /*!< CAN_T::ERR: REC Position      */
S#define CAN_ERR_REC_Msk            (0x7Ful << CAN_ERR_REC_Pos)          /*!< CAN_T::ERR: REC Mask          */
S
S#define CAN_ERR_TEC_Pos            0                                    /*!< CAN_T::ERR: TEC Position      */
S#define CAN_ERR_TEC_Msk            (0xFFul << CAN_ERR_TEC_Pos)          /*!< CAN_T::ERR: TEC Mask          */
S
S/* CAN BTIME Bit Field Definitions */                                           
S#define CAN_BTIME_TSEG2_Pos        12                                   /*!< CAN_T::BTIME: TSEG2 Position  */
S#define CAN_BTIME_TSEG2_Msk        (0x7ul << CAN_BTIME_TSEG2_Pos)       /*!< CAN_T::BTIME: TSEG2 Mask      */
S
S#define CAN_BTIME_TSEG1_Pos        8                                    /*!< CAN_T::BTIME: TSEG1 Position  */
S#define CAN_BTIME_TSEG1_Msk        (0xFul << CAN_BTIME_TSEG1_Pos)       /*!< CAN_T::BTIME: TSEG1 Mask      */
S
S#define CAN_BTIME_SJW_Pos          6                                    /*!< CAN_T::BTIME: SJW Position    */
S#define CAN_BTIME_SJW_Msk          (0x3ul << CAN_BTIME_SJW_Pos)         /*!< CAN_T::BTIME: SJW Mask        */
S
S#define CAN_BTIME_BRP_Pos          0                                    /*!< CAN_T::BTIME: BRP Position    */
S#define CAN_BTIME_BRP_Msk          (0x3Ful << CAN_BTIME_BRP_Pos)        /*!< CAN_T::BTIME: BRP Mask        */
S
S/* CAN IIDR Bit Field Definitions */                                            
S#define CAN_IIDR_INTID_Pos         0                                    /*!< CAN_T::IIDR: INTID Position   */
S#define CAN_IIDR_INTID_Msk         (0xFFFFul << CAN_IIDR_INTID_Pos)     /*!< CAN_T::IIDR: INTID Mask       */
S
S/* CAN TEST Bit Field Definitions */                                            
S#define CAN_TEST_RX_Pos            7                                    /*!< CAN_T::TEST: RX Position      */
S#define CAN_TEST_RX_Msk            (0x1ul << CAN_TEST_RX_Pos)           /*!< CAN_T::TEST: RX Mask          */
S
S#define CAN_TEST_TX_Pos            5                                    /*!< CAN_T::TEST: TX Position      */
S#define CAN_TEST_TX_Msk            (0x3ul << CAN_TEST_TX_Pos)           /*!< CAN_T::TEST: TX Mask          */
S
S#define CAN_TEST_LBACK_Pos         4                                    /*!< CAN_T::TEST: LBACK Position   */
S#define CAN_TEST_LBACK_Msk         (0x1ul << CAN_TEST_LBACK_Pos)        /*!< CAN_T::TEST: LBACK Mask       */
S
S#define CAN_TEST_SILENT_Pos        3                                    /*!< CAN_T::TEST: Silent Position  */
S#define CAN_TEST_SILENT_Msk        (0x1ul << CAN_TEST_SILENT_Pos)       /*!< CAN_T::TEST: Silent Mask      */
S
S#define CAN_TEST_BASIC_Pos         2                                    /*!< CAN_T::TEST: Basic Position   */
S#define CAN_TEST_BASIC_Msk         (0x1ul << CAN_TEST_BASIC_Pos)        /*!< CAN_T::TEST: Basic Mask       */
S
S/* CAN BPRE Bit Field Definitions */                                           
S#define CAN_BRPE_BRPE_Pos          0                                    /*!< CAN_T::BRPE: BRPE Position    */
S#define CAN_BRPE_BRPE_Msk          (0xFul << CAN_BRPE_BRPE_Pos)         /*!< CAN_T::BRPE: BRPE Mask        */
S
S/* CAN IFn_CREQ Bit Field Definitions */
S#define CAN_IF_CREQ_BUSY_Pos       15                                     /*!< CAN_IF_T::CREQ: BUSY Position */
S#define CAN_IF_CREQ_BUSY_Msk       (0x1ul << CAN_IF_CREQ_BUSY_Pos)        /*!< CAN_IF_T::CREQ: BUSY Mask     */
S                                                                                  
S#define CAN_IF_CREQ_MSGNUM_Pos     0                                      /*!< CAN_IF_T::CREQ: MSGNUM Position */
S#define CAN_IF_CREQ_MSGNUM_Msk     (0x3Ful << CAN_IF_CREQ_MSGNUM_Pos)     /*!< CAN_IF_T::CREQ: MSGNUM Mask     */
S                                                                                  
S/* CAN IFn_CMASK Bit Field Definitions */                                         
S#define CAN_IF_CMASK_WRRD_Pos      7                                      /*!< CAN_IF_T::CMASK: WRRD Position */
S#define CAN_IF_CMASK_WRRD_Msk      (0x1ul << CAN_IF_CMASK_WRRD_Pos)       /*!< CAN_IF_T::CMASK: WRRD Mask     */
S                                                                                  
S#define CAN_IF_CMASK_MASK_Pos      6                                      /*!< CAN_IF_T::CMASK: MASK Position */
S#define CAN_IF_CMASK_MASK_Msk      (0x1ul << CAN_IF_CMASK_MASK_Pos)       /*!< CAN_IF_T::CMASK: MASK Mask     */
S                                                                                  
S#define CAN_IF_CMASK_ARB_Pos       5                                      /*!< CAN_IF_T::CMASK: ARB Position  */
S#define CAN_IF_CMASK_ARB_Msk       (0x1ul << CAN_IF_CMASK_ARB_Pos)        /*!< CAN_IF_T::CMASK: ARB Mask      */
S
S#define CAN_IF_CMASK_CONTROL_Pos   4                                     /*!< CAN_IF_T::CMASK: CONTROL Position */
S#define CAN_IF_CMASK_CONTROL_Msk   (0x1ul << CAN_IF_CMASK_CONTROL_Pos)   /*!< CAN_IF_T::CMASK: CONTROL Mask */
S
S#define CAN_IF_CMASK_CLRINTPND_Pos 3                                       /*!< CAN_IF_T::CMASK: CLRINTPND Position */
S#define CAN_IF_CMASK_CLRINTPND_Msk (0x1ul << CAN_IF_CMASK_CLRINTPND_Pos)   /*!< CAN_IF_T::CMASK: CLRINTPND Mask */
S
S#define CAN_IF_CMASK_TXRQSTNEWDAT_Pos 2                                         /*!< CAN_IF_T::CMASK: TXRQSTNEWDAT Position */
S#define CAN_IF_CMASK_TXRQSTNEWDAT_Msk (0x1ul << CAN_IF_CMASK_TXRQSTNEWDAT_Pos)  /*!< CAN_IF_T::CMASK: TXRQSTNEWDAT Mask     */
S
S#define CAN_IF_CMASK_DATAA_Pos     1                                    /*!< CAN_IF_T::CMASK: DATAA Position */
S#define CAN_IF_CMASK_DATAA_Msk     (0x1ul << CAN_IF_CMASK_DATAA_Pos)    /*!< CAN_IF_T::CMASK: DATAA Mask     */
S
S#define CAN_IF_CMASK_DATAB_Pos     0                                    /*!< CAN_IF_T::CMASK: DATAB Position */
S#define CAN_IF_CMASK_DATAB_Msk     (0x1ul << CAN_IF_CMASK_DATAB_Pos)    /*!< CAN_IF_T::CMASK: DATAB Mask     */
S
S/* CAN IFn_MASK1 Bit Field Definitions */
S#define CAN_IF_MASK1_MSK_Pos       0                                    /*!< CAN_IF_T::MASK1: MSK Position   */
S#define CAN_IF_MASK1_MSK_Msk       (0xFFul << CAN_IF_MASK1_MSK_Pos)     /*!< CAN_IF_T::MASK1: MSK Mask       */
S
S/* CAN IFn_MASK2 Bit Field Definitions */                                       
S#define CAN_IF_MASK2_MXTD_Pos      15                                   /*!< CAN_IF_T::MASK2: MXTD Position */
S#define CAN_IF_MASK2_MXTD_Msk      (0x1ul << CAN_IF_MASK2_MXTD_Pos)     /*!< CAN_IF_T::MASK2: MXTD Mask     */
S
S#define CAN_IF_MASK2_MDIR_Pos      14                                   /*!< CAN_IF_T::MASK2: MDIR Position */
S#define CAN_IF_MASK2_MDIR_Msk      (0x1ul << CAN_IF_MASK2_MDIR_Pos)     /*!< CAN_IF_T::MASK2: MDIR Mask     */
S
S#define CAN_IF_MASK2_MSK_Pos       0                                    /*!< CAN_IF_T::MASK2: MSK Position */
S#define CAN_IF_MASK2_MSK_Msk       (0x1FFul << CAN_IF_MASK2_MSK_Pos)    /*!< CAN_IF_T::MASK2: MSK Mask     */
S
S/* CAN IFn_ARB1 Bit Field Definitions */                                        
S#define CAN_IF_ARB1_ID_Pos         0                                    /*!< CAN_IF_T::ARB1: ID Position   */
S#define CAN_IF_ARB1_ID_Msk         (0xFFFFul << CAN_IF_ARB1_ID_Pos)     /*!< CAN_IF_T::ARB1: ID Mask       */
S
S/* CAN IFn_ARB2 Bit Field Definitions */                                        
S#define CAN_IF_ARB2_MSGVAL_Pos     15                                   /*!< CAN_IF_T::ARB2: MSGVAL Position */
S#define CAN_IF_ARB2_MSGVAL_Msk     (0x1ul << CAN_IF_ARB2_MSGVAL_Pos)    /*!< CAN_IF_T::ARB2: MSGVAL Mask     */
S
S#define CAN_IF_ARB2_XTD_Pos        14                                   /*!< CAN_IF_T::ARB2: XTD Position    */
S#define CAN_IF_ARB2_XTD_Msk        (0x1ul << CAN_IF_ARB2_XTD_Pos)       /*!< CAN_IF_T::ARB2: XTD Mask        */
S
S#define CAN_IF_ARB2_DIR_Pos        13                                   /*!< CAN_IF_T::ARB2: DIR Position    */
S#define CAN_IF_ARB2_DIR_Msk        (0x1ul << CAN_IF_ARB2_DIR_Pos)       /*!< CAN_IF_T::ARB2: DIR Mask        */
S
S#define CAN_IF_ARB2_ID_Pos         0                                    /*!< CAN_IF_T::ARB2: ID Position     */
S#define CAN_IF_ARB2_ID_Msk         (0x1FFFul << CAN_IF_ARB2_ID_Pos)     /*!< CAN_IF_T::ARB2: ID Mask         */
S
S/* CAN IFn_MCON Bit Field Definitions */                                        
S#define CAN_IF_MCON_NEWDAT_Pos     15                                   /*!< CAN_IF_T::MCON: NEWDAT Position */
S#define CAN_IF_MCON_NEWDAT_Msk     (0x1ul << CAN_IF_MCON_NEWDAT_Pos)    /*!< CAN_IF_T::MCON: NEWDAT Mask     */
S
S#define CAN_IF_MCON_MSGLST_Pos     14                                   /*!< CAN_IF_T::MCON: MSGLST Position */
S#define CAN_IF_MCON_MSGLST_Msk     (0x1ul << CAN_IF_MCON_MSGLST_Pos)    /*!< CAN_IF_T::MCON: MSGLST Mask     */
S
S#define CAN_IF_MCON_INTPND_Pos     13                                   /*!< CAN_IF_T::MCON: INTPND Position */
S#define CAN_IF_MCON_INTPND_Msk     (0x1ul << CAN_IF_MCON_INTPND_Pos)    /*!< CAN_IF_T::MCON: INTPND Mask     */
S
S#define CAN_IF_MCON_UMASK_Pos      12                                   /*!< CAN_IF_T::MCON: UMASK Position  */
S#define CAN_IF_MCON_UMASK_Msk      (0x1ul << CAN_IF_MCON_UMASK_Pos)     /*!< CAN_IF_T::MCON: UMASK Mask      */
S
S#define CAN_IF_MCON_TXIE_Pos       11                                   /*!< CAN_IF_T::MCON: TXIE Position   */
S#define CAN_IF_MCON_TXIE_Msk       (0x1ul << CAN_IF_MCON_TXIE_Pos)      /*!< CAN_IF_T::MCON: TXIE Mask       */
S
S#define CAN_IF_MCON_RXIE_Pos       10                                   /*!< CAN_IF_T::MCON: RXIE Position   */
S#define CAN_IF_MCON_RXIE_Msk       (0x1ul << CAN_IF_MCON_RXIE_Pos)      /*!< CAN_IF_T::MCON: RXIE Mask       */
S
S#define CAN_IF_MCON_RMTEN_Pos      9                                    /*!< CAN_IF_T::MCON: RMTEN Position  */
S#define CAN_IF_MCON_RMTEN_Msk      (0x1ul << CAN_IF_MCON_RMTEN_Pos)     /*!< CAN_IF_T::MCON: RMTEN Mask      */
S
S#define CAN_IF_MCON_TXRQST_Pos     8                                    /*!< CAN_IF_T::MCON: TXRQST Position */
S#define CAN_IF_MCON_TXRQST_Msk     (0x1ul << CAN_IF_MCON_TXRQST_Pos)    /*!< CAN_IF_T::MCON: TXRQST Mask     */
S
S#define CAN_IF_MCON_EOB_Pos        7                                    /*!< CAN_IF_T::MCON: EOB Position    */
S#define CAN_IF_MCON_EOB_Msk        (0x1ul << CAN_IF_MCON_EOB_Pos)       /*!< CAN_IF_T::MCON: EOB Mask        */
S
S#define CAN_IF_MCON_DLC_Pos        0                                    /*!< CAN_IF_T::MCON: DLC Position    */
S#define CAN_IF_MCON_DLC_Msk        (0xFul << CAN_IF_MCON_DLC_Pos)       /*!< CAN_IF_T::MCON: DLC Mask        */
S
S/* CAN IFn_DATA_A1 Bit Field Definitions */                                     
S#define CAN_IF_DAT_A1_DATA1_Pos    8                                    /*!< CAN_IF_T::DATAA1: DATA1 Position */
S#define CAN_IF_DAT_A1_DATA1_Msk    (0xFFul << CAN_IF_DAT_A1_DATA1_Pos)  /*!< CAN_IF_T::DATAA1: DATA1 Mask     */
S
S#define CAN_IF_DAT_A1_DATA0_Pos    0                                    /*!< CAN_IF_T::DATAA1: DATA0 Position */
S#define CAN_IF_DAT_A1_DATA0_Msk    (0xFFul << CAN_IF_DAT_A1_DATA0_Pos)  /*!< CAN_IF_T::DATAA1: DATA0 Mask     */
S
S/* CAN IFn_DATA_A2 Bit Field Definitions */                                     
S#define CAN_IF_DAT_A2_DATA3_Pos    8                                    /*!< CAN_IF_T::DATAA1: DATA3 Position */
S#define CAN_IF_DAT_A2_DATA3_Msk    (0xFFul << CAN_IF_DAT_A2_DATA3_Pos)  /*!< CAN_IF_T::DATAA1: DATA3 Mask     */
S
S#define CAN_IF_DAT_A2_DATA2_Pos    0                                    /*!< CAN_IF_T::DATAA1: DATA2 Position */
S#define CAN_IF_DAT_A2_DATA2_Msk    (0xFFul << CAN_IF_DAT_A2_DATA2_Pos)  /*!< CAN_IF_T::DATAA1: DATA2 Mask     */
S
S/* CAN IFn_DATA_B1 Bit Field Definitions */                                     
S#define CAN_IF_DAT_B1_DATA5_Pos    8                                    /*!< CAN_IF_T::DATAB1: DATA5 Position */
S#define CAN_IF_DAT_B1_DATA5_Msk    (0xFFul << CAN_IF_DAT_B1_DATA5_Pos)  /*!< CAN_IF_T::DATAB1: DATA5 Mask */
S
S#define CAN_IF_DAT_B1_DATA4_Pos    0                                    /*!< CAN_IF_T::DATAB1: DATA4 Position */
S#define CAN_IF_DAT_B1_DATA4_Msk    (0xFFul << CAN_IF_DAT_B1_DATA4_Pos)  /*!< CAN_IF_T::DATAB1: DATA4 Mask */
S
S/* CAN IFn_DATA_B2 Bit Field Definitions */                                     
S#define CAN_IF_DAT_B2_DATA7_Pos    8                                    /*!< CAN_IF_T::DATAB2: DATA7 Position */
S#define CAN_IF_DAT_B2_DATA7_Msk    (0xFFul << CAN_IF_DAT_B2_DATA7_Pos)  /*!< CAN_IF_T::DATAB2: DATA7 Mask     */
S
S#define CAN_IF_DAT_B2_DATA6_Pos    0                                    /*!< CAN_IF_T::DATAB2: DATA6 Position */
S#define CAN_IF_DAT_B2_DATA6_Msk    (0xFFul << CAN_IF_DAT_B2_DATA6_Pos)  /*!< CAN_IF_T::DATAB2: DATA6 Mask     */
S
S/* CAN IFn_TXRQST1 Bit Field Definitions */
S#define CAN_TXRQST1_TXRQST_Pos  0                                        /*!< CAN_T::TXRQST1: TXRQST Position */
S#define CAN_TXRQST1_TXRQST_Msk  (0xFFFFul << CAN_TXRQST1_TXRQST_Pos)  /*!< CAN_T::TXRQST1: TXRQST Mask     */
S
S/* CAN IFn_TXRQST2 Bit Field Definitions */                                         
S#define CAN_TXRQST2_TXRQST_Pos  0                                        /*!< CAN_T::TXRQST2: TXRQST Position  */
S#define CAN_TXRQST2_TXRQST_Msk  (0xFFFFul << CAN_TXRQST2_TXRQST_Pos)  /*!< CAN_T::TXRQST2: TXRQST Mask      */
S
S/* CAN IFn_NDAT1 Bit Field Definitions */                                           
S#define CAN_NDAT1_NEWDATA_Pos   0                                        /*!< CAN_T::NDAT1: NEWDATA Position */
S#define CAN_NDAT1_NEWDATA_Msk   (0xFFFFul << CAN_NDAT1_NEWDATA_Pos)   /*!< CAN_T::NDAT1: NEWDATA Mask     */
S
S/* CAN IFn_NDAT2 Bit Field Definitions */                                          
S#define CAN_NDAT2_NEWDATA_Pos   0                                        /*!< CAN_T::NDAT2: NEWDATA Position */
S#define CAN_NDAT2_NEWDATA_Msk   (0xFFFFul << CAN_NDAT2_NEWDATA_Pos)   /*!< CAN_T::NDAT2: NEWDATA Mask     */
S
S/* CAN IFn_IPND1 Bit Field Definitions */                                          
S#define CAN_IPND1_INTPND_Pos   0                                         /*!< CAN_T::IPND1: INTPND Position */
S#define CAN_IPND1_INTPND_Msk   (0xFFFFul << CAN_IPND1_INTPND_Pos)     /*!< CAN_T::IPND1: INTPND Mask     */
S
S/* CAN IFn_IPND2 Bit Field Definitions */                                          
S#define CAN_IPND2_INTPND_Pos   0                                         /*!< CAN_T::IPND2: INTPND Position */
S#define CAN_IPND2_INTPND_Msk   (0xFFFFul << CAN_IPND2_INTPND_Pos)     /*!< CAN_T::IPND2: INTPND Mask     */
S
S/* CAN IFn_MVLD1 Bit Field Definitions */                                          
S#define CAN_MVLD1_MSGVAL_Pos   0                                         /*!< CAN_T::MVLD1: MSGVAL Position */
S#define CAN_MVLD1_MSGVAL_Msk   (0xFFFFul << CAN_MVLD1_MSGVAL_Pos)     /*!< CAN_T::MVLD1: MSGVAL Mask     */
S
S/* CAN IFn_MVLD2 Bit Field Definitions */                                           
S#define CAN_MVLD2_MSGVAL_Pos   0                                         /*!< CAN_T::MVLD2: MSGVAL Position */
S#define CAN_MVLD2_MSGVAL_Msk   (0xFFFFul << CAN_MVLD2_MSGVAL_Pos)     /*!< CAN_T::MVLD2: MSGVAL Mask     */
S
S/* CAN WUEN Bit Field Definitions */                                                
S#define CAN_WUEN_WAKUP_EN_Pos     0                                         /*!< CAN_T::WU_EN: WAKUP_EN Position */
S#define CAN_WUEN_WAKUP_EN_Msk    (0x1ul << CAN_WUEN_WAKUP_EN_Pos)           /*!< CAN_T::WU_EN: WAKUP_EN Mask     */
S
S/* CAN WUSTATUS Bit Field Definitions */
S#define CAN_WUSTATUS_WAKUP_STS_Pos     0                                      /*!< CAN_T::WU_STATUS: WAKUP_STS Position */
S#define CAN_WUSTATUS_WAKUP_STS_Msk    (0x1ul << CAN_WUSTATUS_WAKUP_STS_Pos)   /*!< CAN_T::WU_STATUS: WAKUP_STS Mask     */
S
S
S/**@}*/ /* CAN_CONST */
S/**@}*/ /* end of CAN register group */
S
S
S/*---------------------- System Clock Controller -------------------------*/
S/**
S    @addtogroup CLK System Clock Controller(CLK)
S    Memory Mapped Structure for CLK Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S
S
S/**
S * @var CLK_T::PWRCTL
S * Offset: 0x00  System Power-down Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |HXTEN     |External 4~24 MHz High-Speed Crystal Enable Bit (Write Protect)
S * |        |          |The bit default value is set by flash controller user configuration register CONFIG0 [26:24].
S * |        |          |When the default clock source is from external 4~24 MHz high-speed crystal, this bit is set to 1 automatically.
S * |        |          |0 = External 4 ~ 24 MHz high speed crystal oscillator (HXT) Disabled.
S * |        |          |1 = External 4 MH~ 24 z high speed crystal oscillator (HXT) Enabled.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[1]     |LXTEN     |External 32.768 KHz Low-Speed Crystal Enable Bit (Write Protect)
S * |        |          |0 = External 32.768 kHz low-speed crystal oscillator (LXT) Disabled.
S * |        |          |1 = External 32.768 kHz low-speed crystal oscillator (LXT) Enabled.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[2]     |HIRCEN    |Internal 22.1184 MHz High-Speed Oscillator Enable Bit (Write Protect)
S * |        |          |0 = Internal 22.1184 MHz high-speed RC oscillator (HIRC) Disabled.
S * |        |          |1 = Internal 22.1184 MHz high-speed RC oscillator (HIRC) Enabled.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[3]     |LIRCEN    |Internal 10 KHz Low-Speed Oscillator Enable Bit (Write Protect)
S * |        |          |0 = Internal 10 kHz low speed RC oscillator (LIRC) Disabled.
S * |        |          |1 = Internal 10 kHz low speed RC oscillator (LIRC) Enabled.
S * |[4]     |PDWKDLY   |Enable The Wake-Up Delay Counter (Write Protect)
S * |        |          |When the chip wakes up from Power-down mode, the clock control will delay certain clock cycles to wait system clock stable.
S * |        |          |The delayed clock cycle is 4096 clock cycles when chip work at external 4~24 MHz high-speed crystal, and 256 clock cycles when chip work at internal 22.1184 MHz high-speed oscillator.
S * |        |          |0 = Clock cycles delay Disabled.
S * |        |          |1 = Clock cycles delay Enabled.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[5]     |PDWKIEN   |Power-Down Mode Wake-Up Interrupt Enable Bit (Write Protect)
S * |        |          |0 = Power-down Mode Wake-up Interrupt Disabled.
S * |        |          |1 = Power-down Mode Wake-up Interrupt Enabled.
S * |        |          |Note1: The interrupt will occur when both PDWKIF and PDWKIEN are high.
S * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[6]     |PDWKIF    |Power-Down Mode Wake-Up Interrupt Status
S * |        |          |Set by "Power-down wake-up event", it indicates that resume from Power-down mode
S * |        |          |The flag is set if the EINT0~5, GPIO, USBH, USBD, OTG, UART0~3, WDT, CAN0, ACMP01, BOD, RTC, TMR0~3, I2C0~1 or TK wake-up occurred.
S * |        |          |Note1: Write 1 to clear the bit to 0.
S * |        |          |Note2: This bit works only if PDWKIEN (CLK_PWRCTL[5]) set to 1.
S * |[7]     |PDEN      |System Power-Down Enable (Write Protect)
S * |        |          |When this bit is set to 1, Power-down mode is enabled and chip Power-down behavior will depend on the PDWTCPU bit.
S * |        |          |(a) If the PDWTCPU is 0, then the chip enters Power-down mode immediately after the PDEN bit set.(default)
S * |        |          |(b) if the PDWTCPU is 1, then the chip keeps active till the CPU sleep mode is also active and then the chip enters Power-down mode.
S * |        |          |When chip wakes up from Power-down mode, this bit is auto cleared.
S * |        |          |Users need to set this bit again for next Power-down.
S * |        |          |In Power-down mode, external 4~24 MHz high-speed crystal and the internal 22.1184 MHz high-speed oscillator will be disabled in this mode, but the external 32.768 kHz low-speed crystal and internal 10 kHz low-speed oscillator are not controlled by Power-down mode.
S * |        |          |In Power-down mode, the PLL and system clock are disabled, and ignored the clock source selection.
S * |        |          |The clocks of peripheral are not controlled by Power-down mode, if the peripheral clock source is from external 32.768 kHz low-speed crystal or the internal 10 kHz low-speed oscillator.
S * |        |          |0 = Chip operating normally or chip in idle mode because of WFI command.
S * |        |          |1 = Chip enters Power-down mode instant or wait CPU sleep command WFI.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[8]     |PDWTCPU   |This Bit Control The Power-Down Entry Condition (Write Protect)
S * |        |          |0 = Chip enters Power-down mode when the PDEN bit is set to 1.
S * |        |          |1 = Chip enters Power-down mode when the both PDWTCPU and PDEN bits are set to 1 and CPU run WFI instruction.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[11:10] |HXTGAIN   |4~24 MHz High-Speed Crystal Gain Control Bit
S * |        |          |(Write Protect)
S * |        |          |This is a protected register. Please refer to open lock sequence to program it.
S * |        |          |Gain control is used to enlarge the gain of crystal to make sure crystal work normally.
S * |        |          |If gain control is enabled, crystal will consume more power than gain control off.
S * |        |          |00 = HXT frequency is lower than from 8 MHz.
S * |        |          |01 = HXT frequency is from 8 MHz to 12 MHz.
S * |        |          |10 = HXT frequency is from 12 MHz to 16 MHz.
S * |        |          |11 = HXT frequency is higher than 16 MHz.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[12]    |HXTSELTYP |4~24 MHz High-Speed Crystal Type Select Bit (Write Protect)
S * |        |          |This is a protected register. Please refer to open lock sequence to program it.
S * |        |          |0 = Select INV type.
S * |        |          |1 = Select GM type.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * @var CLK_T::AHBCLK
S * Offset: 0x04  AHB Devices Clock Enable Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1]     |PDMACKEN  |PDMA Controller Clock Enable Bit
S * |        |          |0 = PDMA peripheral clock Disabled.
S * |        |          |1 = PDMA peripheral clock Enabled.
S * |[2]     |ISPCKEN   |Flash ISP Controller Clock Enable Bit
S * |        |          |0 = Flash ISP peripheral clock Disabled.
S * |        |          |1 = Flash ISP peripheral clock Enabled.
S * |[3]     |EBICKEN   |EBI Controller Clock Enable Bit
S * |        |          |0 = EBI peripheral clock Disabled.
S * |        |          |1 = EBI peripheral clock Enabled.
S * |[4]     |USBHCKEN  |USB HOST Controller Clock Enable Bit
S * |        |          |0 = USB HOST peripheral clock Disabled.
S * |        |          |1 = USB HOST peripheral clock Enabled.
S * |[7]     |CRCCKEN   |CRC Generator Controller Clock Enable Bit
S * |        |          |0 = CRC peripheral clock Disabled.
S * |        |          |1 = CRC peripheral clock Enabled.
S * |[15]    |FMCIDLE   |Flash Memory Controller Clock Enable Bit In IDLE Mode
S * |        |          |0 = FMC peripheral clock Disabled when chip operating at IDLE mode.
S * |        |          |1 = FMC peripheral clock Enabled when chip operating at IDLE mode.
S * @var CLK_T::APBCLK0
S * Offset: 0x08  APB Devices Clock Enable Control Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |WDTCKEN   |Watchdog Timer Clock Enable Bit (Write Protect)
S * |        |          |0 = Watchdog Timer Clock Disabled.
S * |        |          |1 = Watchdog Timer Clock Enabled.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[1]     |RTCCKEN   |Real-Time-Clock APB Interface Clock Enable Bit
S * |        |          |This bit is used to control the RTC APB clock only.
S * |        |          |The RTC peripheral clock source is selected from RTCSEL(CLK_CLKSEL3[8]).
S * |        |          |It can be selected to external 32.768 kHz low speed crystal or internal 10 kHz low speed oscillator.
S * |        |          |0 = RTC Clock Disabled.
S * |        |          |1 = RTC Clock Enabled.
S * |[2]     |TMR0CKEN  |Timer0 Clock Enable Bit
S * |        |          |0 = Timer0 Clock Disabled.
S * |        |          |1 = Timer0 Clock Enabled.
S * |[3]     |TMR1CKEN  |Timer1 Clock Enable Bit
S * |        |          |0 = Timer1 Clock Disabled.
S * |        |          |1 = Timer1 Clock Enabled.
S * |[4]     |TMR2CKEN  |Timer2 Clock Enable Bit
S * |        |          |0 = Timer2 Clock Disabled.
S * |        |          |1 = Timer2 Clock Enabled.
S * |[5]     |TMR3CKEN  |Timer3 Clock Enable Bit
S * |        |          |0 = Timer3 Clock Disabled.
S * |        |          |1 = Timer3 Clock Enabled.
S * |[6]     |CLKOCKEN  |CLKO Clock Enable Bit
S * |        |          |0 = CLKO Clock Disabled.
S * |        |          |1 = CLKO Clock Enabled.
S * |[7]     |ACMP01CKEN|Analog Comparator 0/1 Clock Enable Bit
S * |        |          |0 = Analog Comparator 0/1 Clock Disabled.
S * |        |          |1 = Analog Comparator 0/1 Clock Enabled.
S * |[8]     |I2C0CKEN  |I2C0 Clock Enable Bit
S * |        |          |0 = I2C0 Clock Disabled.
S * |        |          |1 = I2C0 Clock Enabled.
S * |[9]     |I2C1CKEN  |I2C1 Clock Enable Bit
S * |        |          |0 = I2C1 Clock Disabled.
S * |        |          |1 = I2C1 Clock Enabled.
S * |[12]    |SPI0CKEN  |SPI0 Clock Enable Bit
S * |        |          |0 = SPI0 Clock Disabled.
S * |        |          |1 = SPI0 Clock Enabled.
S * |[13]    |SPI1CKEN  |SPI1 Clock Enable Bit
S * |        |          |0 = SPI1 Clock Disabled.
S * |        |          |1 = SPI1 Clock Enabled.
S * |[14]    |SPI2CKEN  |SPI2 Clock Enable Bit
S * |        |          |0 = SPI2 Clock Disabled.
S * |        |          |1 = SPI2 Clock Enabled.
S * |[16]    |UART0CKEN |UART0 Clock Enable Bit
S * |        |          |0 = UART0 clock Disabled.
S * |        |          |1 = UART0 clock Enabled.
S * |[17]    |UART1CKEN |UART1 Clock Enable Bit
S * |        |          |0 = UART1 clock Disabled.
S * |        |          |1 = UART1 clock Enabled.
S * |[18]    |UART2CKEN |UART2 Clock Enable Bit
S * |        |          |0 = UART2 clock Disabled.
S * |        |          |1 = UART2 clock Enabled.
S * |[19]    |UART3CKEN |UART3 Clock Enable Bit
S * |        |          |0 = UART3 clock Disabled.
S * |        |          |1 = UART3 clock Enabled.
S * |[24]    |CAN0CKEN  |CAN0 Clock Enable Bit
S * |        |          |0 = CAN0 clock Disabled.
S * |        |          |1 = CAN0 clock Enabled.
S * |[26]    |OTGCKEN   |USB OTG Clock Enable Bit
S * |        |          |0 = USB OTG clock Disabled.
S * |        |          |1 = USB OTG clock Enabled.
S * |[27]    |USBDCKEN  |USB Device Clock Enable Bit
S * |        |          |0 = USB Device clock Disabled.
S * |        |          |1 = USB Device clock Enabled.
S * |[28]    |EADCCKEN  |Enhanced Analog-Digital-Converter (EADC) Clock Enable Bit
S * |        |          |0 = EADC clock Disabled.
S * |        |          |1 = EADC clock Enabled.
S * @var CLK_T::APBCLK1
S * Offset: 0x0C  APB Devices Clock Enable Control Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |SC0CKEN   |SC0 Clock Enable Bit
S * |        |          |0 = SC0 Clock Disabled.
S * |        |          |1 = SC0 Clock Enabled.
S * |[12]    |DACCKEN   |DAC Clock Enable Bit
S * |        |          |0 = DAC Clock Disabled.
S * |        |          |1 = DAC Clock Enabled.
S * |[16]    |PWM0CKEN  |PWM0 Clock Enable Bit
S * |        |          |0 = PWM0 Clock Disabled.
S * |        |          |1 = PWM0 Clock Enabled.
S * |[17]    |PWM1CKEN  |PWM1 Clock Enable Bit
S * |        |          |0 = PWM1 Clock Disabled.
S * |        |          |1 = PWM1 Clock Enabled.
S * |[25]    |TKCKEN    |Touch Key Clock Enable Bit
S * |        |          |0 = Touch Key Clock Disabled.
S * |        |          |1 = Touch key Clock Enabled.
S * @var CLK_T::CLKSEL0
S * Offset: 0x10  Clock Source Select Control Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[2:0]   |HCLKSEL   |HCLK Clock Source Selection (Write Protect)
S * |        |          |Before clock switching, the related clock sources (both pre-select and new-select) must be turned on.
S * |        |          |The default value is reloaded from the value of CFOSC (CONFIG0[26:24]) in user configuration register of Flash controller by any reset.
S * |        |          |Therefore the default value is either 000b or 111b.
S * |        |          |000 = Clock source from external 4~24 MHz high-speed crystal clock.
S * |        |          |001 = Clock source from external 32.768 kHz low-speed crystal clock.
S * |        |          |010 = Clock source from PLL clock.
S * |        |          |011 = Clock source from internal 10 kHz low-speed oscillator clock.
S * |        |          |111= Clock source from internal 22.1184 MHz high-speed oscillator clock.
S * |        |          |Other = Reserved.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[5:3]   |STCLKSEL  |Cortex-M4 SysTick Clock Source Selection (Write Protect)
S * |        |          |If SYST_CTRL[2]=0, SysTick uses listed clock source below.
S * |        |          |000 = Clock source from external 4~24 MHz high-speed crystal clock.
S * |        |          |001 = Clock source from external 32.768 kHz low-speed crystal clock.
S * |        |          |010 = Clock source from external 4~24 MHz high-speed crystal clock/2.
S * |        |          |011 = Clock source from HCLK/2.
S * |        |          |111 = Clock source from internal 22.1184 MHz high-speed oscillator clock/2.
S * |        |          |Note: if SysTick clock source is not from HCLK (i.e.
S * |        |          |SYST_CTRL[2] = 0), SysTick clock source must less than or equal to HCLK/2.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[6]     |PCLK0SEL  |PCLK0 Clock Source Selection (Write Protect)
S * |        |          |0 = APB0 BUS clock source from HCLK.
S * |        |          |1 = APB0 BUS clock source from HCLK/2.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[7]     |PCLK1SEL  |PCLK1 Clock Source Selection (Write Protect)
S * |        |          |0 = APB1 BUS clock source from HCLK.
S * |        |          |1 = APB1 BUS clock source from HCLK/2.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * @var CLK_T::CLKSEL1
S * Offset: 0x14  Clock Source Select Control Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |WDTSEL    |Watchdog Timer Clock Source Selection (Write Protect)
S * |        |          |00 = Reserved.
S * |        |          |01 = Clock source from external 32.768 kHz low-speed crystal clock.
S * |        |          |10 = Clock source from PCLK0/2048 clock.
S * |        |          |11 = Clock source from internal 10 kHz low-speed oscillator clock.
S * |[10:8]  |TMR0SEL   |TIMER0 Clock Source Selection
S * |        |          |000 = Clock source from external 4~24 MHz high-speed crystal clock.
S * |        |          |001 = Clock source from external 32.768 kHz low-speed crystal clock.
S * |        |          |010 = Clock source from PCLK0.
S * |        |          |011 = Clock source from external clock T0 pin
S * |        |          |101 = Clock source from internal 10 kHz low-speed oscillator clock.
S * |        |          |111 = Clock source from internal 22.1184 MHz high-speed oscillator clock.
S * |        |          |Others = Reserved.
S * |[14:12] |TMR1SEL   |TIMER1 Clock Source Selection
S * |        |          |000 = Clock source from external 4~24 MHz high-speed crystal clock.
S * |        |          |001 = Clock source from external 32.768 kHz low-speed crystal clock.
S * |        |          |010 = Clock source from PCLK0.
S * |        |          |011 = Clock source from external clock T1 pin
S * |        |          |101 = Clock source from internal 10 kHz low-speed oscillator clock.
S * |        |          |111 = Clock source from internal 22.1184 MHz high-speed oscillator clock.
S * |        |          |Others = Reserved.
S * |[18:16] |TMR2SEL   |TIMER2 Clock Source Selection
S * |        |          |000 = Clock source from external 4~24 MHz high-speed crystal clock.
S * |        |          |001 = Clock source from external 32.768 kHz low-speed crystal clock.
S * |        |          |010 = Clock source from PCLK1.
S * |        |          |011 = Clock source from external clock T2 pin
S * |        |          |101 = Clock source from internal 10 kHz low-speed oscillator clock.
S * |        |          |111 = Clock source from internal 22.1184 MHz high-speed oscillator clock.
S * |        |          |Others = Reserved.
S * |[22:20] |TMR3SEL   |TIMER3 Clock Source Selection
S * |        |          |000 = Clock source from external 4~24 MHz high-speed crystal clock.
S * |        |          |001 = Clock source from external 32.768 kHz low-speed crystal clock.
S * |        |          |010 = Clock source from PCLK1.
S * |        |          |011 = Clock source from external clock T3 pin.
S * |        |          |101 = Clock source from internal 10 kHz low-speed oscillator clock.
S * |        |          |111 = Clock source from internal 22.1184 MHz high-speed oscillator clock.
S * |        |          |Others = Reserved.
S * |[25:24] |UARTSEL   |UART Clock Source Selection
S * |        |          |00 = Clock source from external 4~24 MHz high-speed crystal clock (HXT).
S * |        |          |01 = Clock source from PLL clock.
S * |        |          |10 = Clock source from 32.768 kHz external low speed crystal oscillator (LXT).
S * |        |          |11 = Clock source from internal 22.1184 MHz high-speed oscillator clock (HIRC).
S * |[29:28] |CLKOSEL   |Clock Divider Clock Source Selection
S * |        |          |00 = Clock source from external 4~24 MHz high-speed crystal clock.
S * |        |          |01 = Clock source from external 32.768 kHz low-speed crystal clock.
S * |        |          |10 = Clock source from HCLK.
S * |        |          |11 = Clock source from internal 22.1184 MHz high-speed oscillator clock.
S * |[31:30] |WWDTSEL   |Window Watchdog Timer Clock Source Selection
S * |        |          |10 = Clock source from PCLK0/2048 clock.
S * |        |          |11 = Clock source from internal 10 kHz low-speed oscillator clock.
S * |        |          |Others = Reserved.
S * @var CLK_T::CLKSEL2
S * Offset: 0x18  Clock Source Select Control Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |PWM0SEL   |PWM0 Clock Source Selection
S * |        |          |The peripheral clock source of PWM0 is defined by PWM0SEL.
S * |        |          |0 = Clock source from PLL clock.
S * |        |          |1 = Clock source from PCLK0.
S * |[1]     |PWM1SEL   |PWM1 Clock Source Selection
S * |        |          |The peripheral clock source of PWM1 is defined by PWM1SEL.
S * |        |          |0 = Clock source from PLL clock.
S * |        |          |1 = Clock source from PCLK1.
S * |[3:2]   |SPI0SEL   |SPI0 Clock Source Selection
S * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
S * |        |          |01 = Clock source from PLL clock.
S * |        |          |10 = Clock source from PCLK0.
S * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S * |[5:4]   |SPI1SEL   |SPI1 Clock Source Selection
S * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
S * |        |          |01 = Clock source from PLL clock.
S * |        |          |10 = Clock source from PCLK1.
S * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S * |[7:6]   |SPI2SEL   |SPI2 Clock Source Selection
S * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
S * |        |          |01 = Clock source from PLL clock.
S * |        |          |10 = Clock source from PCLK0.
S * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S * @var CLK_T::CLKSEL3
S * Offset: 0x1C  Clock Source Select Control Register 3
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |SC0SEL    |SC0 Clock Source Selection
S * |        |          |00 = Clock source from external 4~24 MHz high-speed crystal clock.
S * |        |          |01 = Clock source from PLL clock.
S * |        |          |10 = Clock source from PCLK0.
S * |        |          |11 = Clock source from internal 22.1184 MHz high-speed oscillator clock.
S * |[8]     |RTCSEL    |RTC Clock Source Selection
S * |        |          |0 = Clock source from external 32.768 kHz low-speed oscillator.
S * |        |          |1 = Clock source from internal 10 kHz low speed RC oscillator.
S * @var CLK_T::CLKDIV0
S * Offset: 0x20  Clock Divider Number Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |HCLKDIV   |HCLK Clock Divide Number From HCLK Clock Source
S * |        |          |HCLK clock frequency = (HCLK clock source frequency) / (HCLKDIV + 1).
S * |[7:4]   |USBDIV    |USB Clock Divide Number From PLL Clock
S * |        |          |USB clock frequency = (PLL frequency) / (USBDIV + 1).
S * |[11:8]  |UARTDIV   |UART Clock Divide Number From UART Clock Source
S * |        |          |UART clock frequency = (UART clock source frequency) / (UARTDIV + 1).
S * |[23:16] |EADCDIV   |EADC Clock Divide Number From EADC Clock Source
S * |        |          |EADC clock frequency = (EADC clock source frequency) / (EADCDIV + 1).
S * @var CLK_T::CLKDIV1
S * Offset: 0x24  Clock Divider Number Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |SC0DIV    |SC0 Clock Divide Number From SC0 Clock Source
S * |        |          |SC0 clock frequency = (SC0 clock source frequency ) / (SC0DIV + 1).
S * @var CLK_T::PLLCTL
S * Offset: 0x40  PLL Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[8:0]   |FBDIV     |PLL Feedback Divider Control Pins (Write Protect)
S * |        |          |Refer to the formulas below the table.
S * |[13:9]  |INDIV     |PLL Input Divider Control Pins (Write Protect)
S * |        |          |Refer to the formulas below the table.
S * |[15:14] |OUTDIV    |PLL Output Divider Control Pins (Write Protect)
S * |        |          |Refer to the formulas below the table.
S * |[16]    |PD        |Power-Down Mode (Write Protect)
S * |        |          |If set the PDEN bit to 1 in CLK_PWRCTL register, the PLL will enter Power-down mode, too.
S * |        |          |0 = PLL is in normal mode.
S * |        |          |1 = PLL is in Power-down mode (default).
S * |[17]    |BP        |PLL Bypass Control (Write Protect)
S * |        |          |0 = PLL is in normal mode (default).
S * |        |          |1 = PLL clock output is same as PLL input clock FIN.
S * |[18]    |OE        |PLL OE (FOUT Enable) Pin Control (Write Protect)
S * |        |          |0 = PLL FOUT Enabled.
S * |        |          |1 = PLL FOUT is fixed low.
S * |[19]    |PLLSRC    |PLL Source Clock Selection (Write Protect)
S * |        |          |0 = PLL source clock from external 4~24 MHz high-speed crystal (HXT).
S * |        |          |1 = PLL source clock from internal 22.1184 MHz high-speed oscillator (HIRC).
S * |[23]    |STBSEL    |PLL Stable Counter Selection (Write Protect)
S * |        |          |0 = PLL stable time is 6144 PLL source clock (suitable for source clock is equal to or less than 12MHz).
S * |        |          |1 = PLL stable time is 12288 PLL source clock (suitable for source clock is larger than 12MHz).
S * @var CLK_T::STATUS
S * Offset: 0x50  Clock Status Monitor Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |HXTSTB    |External 4~24 MHz High-Speed Crystal Clock Source Stable Flag (Read Only)
S * |        |          |0 = External 4~24 MHz high-speed crystal clock is not stable or disabled.
S * |        |          |1 = External 4~24 MHz high-speed crystal clock is stable and enabled.
S * |[1]     |LXTSTB    |External 32.768 kHz Low-Speed Crystal Clock Source Stable Flag (Read Only)
S * |        |          |0 = External 32.768 kHz low-speed crystal clock is not stable or disabled.
S * |        |          |1 = External 32.768 kHz low-speed crystal clock is stabled and enabled.
S * |[2]     |PLLSTB    |Internal PLL Clock Source Stable Flag (Read Only)
S * |        |          |0 = Internal PLL clock is not stable or disabled.
S * |        |          |1 = Internal PLL clock is stable and enabled.
S * |[3]     |LIRCSTB   |Internal 10 KHz Low-Speed Oscillator Clock Source Stable Flag (Read Only)
S * |        |          |0 = Internal 10 kHz low-speed oscillator clock is not stable or disabled.
S * |        |          |1 = Internal 10 kHz low-speed oscillator clock is stable and enabled.
S * |[4]     |HIRCSTB   |Internal 22.1184 MHz High-Speed Oscillator Clock Source Stable Flag (Read Only)
S * |        |          |0 = Internal 22.1184 MHz high-speed oscillator clock is not stable or disabled.
S * |        |          |1 = Internal 22.1184 MHz high-speed oscillator clock is stable and enabled.
S * |[7]     |CLKSFAIL  |Clock Switching Fail Flag (Read Only)
S * |        |          |This bit is updated when software switches system clock source.
S * |        |          |If switch target clock is stable, this bit will be set to 0.
S * |        |          |If switch target clock is not stable, this bit will be set to 1.
S * |        |          |0 = Clock switching success.
S * |        |          |1 = Clock switching failure.
S * |        |          |Note: Write 1 to clear the bit to 0.
S * @var CLK_T::CLKOCTL
S * Offset: 0x60  Clock Output Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |FREQSEL   |Clock Output Frequency Selection
S * |        |          |The formula of output frequency is
S * |        |          |Fout = Fin/2(N+1).
S * |        |          |Fin is the input clock frequency.
S * |        |          |Fout is the frequency of divider output clock.
S * |        |          |N is the 4-bit value of FREQSEL[3:0].
S * |[4]     |CLKOEN    |Clock Output Enable Bit
S * |        |          |0 =Clock Output function Disabled.
S * |        |          |1 = Clock Output function Enabled.
S * |[5]     |DIV1EN    |Clock Output Divide One Enable Bit
S * |        |          |0 = Clock Output will output clock with source frequency divided by FREQSEL.
S * |        |          |1 = Clock Output will output clock with source frequency.
S * |[6]     |CLK1HZEN  |Clock Output 1Hz Enable Bit
S * |        |          |0 = 1 Hz clock output for 32.768kHz frequency compensation Disabled.
S * |        |          |1 = 1 Hz clock output for 332.768kHz frequency compensation Enabled.
S * @var CLK_T::CLKDCTL
S * Offset: 0x70  Clock Fail Detector Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[4]     |HXTFDEN   |HXT Clock Fail Detector Enable Bit
S * |        |          |0 = HXT clock Fail detector Disabled.
S * |        |          |1 = HXT clock Fail detector Enabled.
S * |[5]     |HXTFIEN   |HXT Clock Fail Interrupt Enable Bit
S * |        |          |0 = HXT clock Fail interrupt Disabled.
S * |        |          |1 = HXT clock Fail interrupt Enabled.
S * |[12]    |LXTFDEN   |LXT Clock Fail Detector Enable Bit
S * |        |          |0 = LXT clock Fail detector Disabled.
S * |        |          |1 = LXT clock Fail detector Enabled.
S * |[13]    |LXTFIEN   |LXT Clock Fail Interrupt Enable Bit
S * |        |          |0 = LXT clock Fail interrupt Disabled.
S * |        |          |1 = LXT clock Fail interrupt Enabled.
S * |[16]    |HXTFQDEN  |HXT Clock Frequency Monitor Enable Bit
S * |        |          |0 = HXT clock frequency monitor Disabled.
S * |        |          |1 = HXT clock frequency monitor Enabled.
S * |[17]    |HXTFQIEN  |HXT Clock Frequency Monitor Interrupt Enable Bit
S * |        |          |0 = HXT clock frequency monitor fail interrupt Disabled.
S * |        |          |1 = HXT clock frequency monitor fail interrupt Enabled.
S * @var CLK_T::CLKDSTS
S * Offset: 0x74  Clock Fail Detector Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |HXTFIF    |HXT Clock Fail Interrupt Flag
S * |        |          |0 = HXT clock normal.
S * |        |          |1 = HXT clock stop
S * |        |          |Note: Write 1 to clear the bit to 0.
S * |[1]     |LXTFIF    |LXT Clock Fail Interrupt Flag
S * |        |          |0 = LXT clock normal.
S * |        |          |1 = LXT stop
S * |        |          |Note: Write 1 to clear the bit to 0.
S * |[8]     |HXTFQIF   |HXT Clock Frequency Monitor Interrupt Flag
S * |        |          |0 = HXT clock normal.
S * |        |          |1 = HXT clock frequency abnormal
S * |        |          |Note: Write 1 to clear the bit to 0.
S * @var CLK_T::CDUPB
S * Offset: 0x78  Clock Frequency Detector Upper Boundary Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[9:0]   |UPERBD    |HXT Clock Frequency Detector Upper Boundary
S * |        |          |The bits define the high value of frequency monitor window.
S * |        |          |When HXT frequency monitor value higher than this register, the HXT frequency detect fail interrupt flag will set to 1.
S * @var CLK_T::CDLOWB
S * Offset: 0x7C  Clock Frequency Detector Low Boundary Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[9:0]   |LOWERBD   |HXT Clock Frequency Detector Low Boundary
S * |        |          |The bits define the low value of frequency monitor window.
S * |        |          |When HXT frequency monitor value lower than this register, the HXT frequency detect fail interrupt flag will set to 1.
S */
S
S    __IO uint32_t PWRCTL;        /* Offset: 0x00  System Power-down Control Register                                 */
S    __IO uint32_t AHBCLK;        /* Offset: 0x04  AHB Devices Clock Enable Control Register                          */
S    __IO uint32_t APBCLK0;       /* Offset: 0x08  APB Devices Clock Enable Control Register 0                        */
S    __IO uint32_t APBCLK1;       /* Offset: 0x0C  APB Devices Clock Enable Control Register 1                        */
S    __IO uint32_t CLKSEL0;       /* Offset: 0x10  Clock Source Select Control Register 0                             */
S    __IO uint32_t CLKSEL1;       /* Offset: 0x14  Clock Source Select Control Register 1                             */
S    __IO uint32_t CLKSEL2;       /* Offset: 0x18  Clock Source Select Control Register 2                             */
S    __IO uint32_t CLKSEL3;       /* Offset: 0x1C  Clock Source Select Control Register 3                             */
S    __IO uint32_t CLKDIV0;       /* Offset: 0x20  Clock Divider Number Register 0                                    */
S    __IO uint32_t CLKDIV1;       /* Offset: 0x24  Clock Divider Number Register 1                                    */
S    __I  uint32_t RESERVE0[6];  
S    __IO uint32_t PLLCTL;        /* Offset: 0x40  PLL Control Register                                               */
S    __I  uint32_t RESERVE1[3];  
S    __I  uint32_t STATUS;        /* Offset: 0x50  Clock Status Monitor Register                                      */
S    __I  uint32_t RESERVE2[3];  
S    __IO uint32_t CLKOCTL;       /* Offset: 0x60  Clock Output Control Register                                      */
S    __I  uint32_t RESERVE3[3];  
S    __IO uint32_t CLKDCTL;       /* Offset: 0x70  Clock Fail Detector Control Register                               */
S    __IO uint32_t CLKDSTS;       /* Offset: 0x74  Clock Fail Detector Status Register                                */
S    __IO uint32_t CDUPB;         /* Offset: 0x78  Clock Frequency Detector Upper Boundary Register                   */
S    __IO uint32_t CDLOWB;        /* Offset: 0x7C  Clock Frequency Detector Low Boundary Register                     */
S
S} CLK_T;
S
S
S
S/**
S    @addtogroup CLK_CONST CLK Bit Field Definition
S    Constant Definitions for CLK Controller
S@{ */
S
S#define CLK_PWRCTL_HXTEN_Pos             (0)                                               /*!< CLK_T::PWRCTL: HXTEN Position             */
S#define CLK_PWRCTL_HXTEN_Msk             (0x1ul << CLK_PWRCTL_HXTEN_Pos)                   /*!< CLK_T::PWRCTL: HXTEN Mask                 */
S
S#define CLK_PWRCTL_LXTEN_Pos             (1)                                               /*!< CLK_T::PWRCTL: LXTEN Position             */
S#define CLK_PWRCTL_LXTEN_Msk             (0x1ul << CLK_PWRCTL_LXTEN_Pos)                   /*!< CLK_T::PWRCTL: LXTEN Mask                 */
S
S#define CLK_PWRCTL_HIRCEN_Pos            (2)                                               /*!< CLK_T::PWRCTL: HIRCEN Position            */
S#define CLK_PWRCTL_HIRCEN_Msk            (0x1ul << CLK_PWRCTL_HIRCEN_Pos)                  /*!< CLK_T::PWRCTL: HIRCEN Mask                */
S
S#define CLK_PWRCTL_LIRCEN_Pos            (3)                                               /*!< CLK_T::PWRCTL: LIRCEN Position            */
S#define CLK_PWRCTL_LIRCEN_Msk            (0x1ul << CLK_PWRCTL_LIRCEN_Pos)                  /*!< CLK_T::PWRCTL: LIRCEN Mask                */
S
S#define CLK_PWRCTL_PDWKDLY_Pos           (4)                                               /*!< CLK_T::PWRCTL: PDWKDLY Position           */
S#define CLK_PWRCTL_PDWKDLY_Msk           (0x1ul << CLK_PWRCTL_PDWKDLY_Pos)                 /*!< CLK_T::PWRCTL: PDWKDLY Mask               */
S
S#define CLK_PWRCTL_PDWKIEN_Pos           (5)                                               /*!< CLK_T::PWRCTL: PDWKIEN Position           */
S#define CLK_PWRCTL_PDWKIEN_Msk           (0x1ul << CLK_PWRCTL_PDWKIEN_Pos)                 /*!< CLK_T::PWRCTL: PDWKIEN Mask               */
S
S#define CLK_PWRCTL_PDWKIF_Pos            (6)                                               /*!< CLK_T::PWRCTL: PDWKIF Position            */
S#define CLK_PWRCTL_PDWKIF_Msk            (0x1ul << CLK_PWRCTL_PDWKIF_Pos)                  /*!< CLK_T::PWRCTL: PDWKIF Mask                */
S
S#define CLK_PWRCTL_PDEN_Pos              (7)                                               /*!< CLK_T::PWRCTL: PDEN Position              */
S#define CLK_PWRCTL_PDEN_Msk              (0x1ul << CLK_PWRCTL_PDEN_Pos)                    /*!< CLK_T::PWRCTL: PDEN Mask                  */
S
S#define CLK_PWRCTL_PDWTCPU_Pos           (8)                                               /*!< CLK_T::PWRCTL: PDWTCPU Position           */
S#define CLK_PWRCTL_PDWTCPU_Msk           (0x1ul << CLK_PWRCTL_PDWTCPU_Pos)                 /*!< CLK_T::PWRCTL: PDWTCPU Mask               */
S
S#define CLK_PWRCTL_HXTGAIN_Pos           (10)                                              /*!< CLK_T::PWRCTL: HXTGAIN Position           */
S#define CLK_PWRCTL_HXTGAIN_Msk           (0x3ul << CLK_PWRCTL_HXTGAIN_Pos)                 /*!< CLK_T::PWRCTL: HXTGAIN Mask               */
S
S#define CLK_PWRCTL_HXTSELTYP_Pos         (12)                                              /*!< CLK_T::PWRCTL: HXTSELTYP Position         */
S#define CLK_PWRCTL_HXTSELTYP_Msk         (0x1ul << CLK_PWRCTL_HXTSELTYP_Pos)               /*!< CLK_T::PWRCTL: HXTSELTYP Mask             */
S
S#define CLK_AHBCLK_PDMACKEN_Pos          (1)                                               /*!< CLK_T::AHBCLK: PDMACKEN Position          */
S#define CLK_AHBCLK_PDMACKEN_Msk          (0x1ul << CLK_AHBCLK_PDMACKEN_Pos)                /*!< CLK_T::AHBCLK: PDMACKEN Mask              */
S
S#define CLK_AHBCLK_ISPCKEN_Pos           (2)                                               /*!< CLK_T::AHBCLK: ISPCKEN Position           */
S#define CLK_AHBCLK_ISPCKEN_Msk           (0x1ul << CLK_AHBCLK_ISPCKEN_Pos)                 /*!< CLK_T::AHBCLK: ISPCKEN Mask               */
S
S#define CLK_AHBCLK_EBICKEN_Pos           (3)                                               /*!< CLK_T::AHBCLK: EBICKEN Position           */
S#define CLK_AHBCLK_EBICKEN_Msk           (0x1ul << CLK_AHBCLK_EBICKEN_Pos)                 /*!< CLK_T::AHBCLK: EBICKEN Mask               */
S
S#define CLK_AHBCLK_USBHCKEN_Pos          (4)                                               /*!< CLK_T::AHBCLK: USBHCKEN Position          */
S#define CLK_AHBCLK_USBHCKEN_Msk          (0x1ul << CLK_AHBCLK_USBHCKEN_Pos)                /*!< CLK_T::AHBCLK: USBHCKEN Mask              */
S
S#define CLK_AHBCLK_CRCCKEN_Pos           (7)                                               /*!< CLK_T::AHBCLK: CRCCKEN Position           */
S#define CLK_AHBCLK_CRCCKEN_Msk           (0x1ul << CLK_AHBCLK_CRCCKEN_Pos)                 /*!< CLK_T::AHBCLK: CRCCKEN Mask               */
S
S#define CLK_AHBCLK_FMCIDLE_Pos           (15)                                              /*!< CLK_T::AHBCLK: FMCIDLE Position           */
S#define CLK_AHBCLK_FMCIDLE_Msk           (0x1ul << CLK_AHBCLK_FMCIDLE_Pos)                 /*!< CLK_T::AHBCLK: FMCIDLE Mask               */
S
S#define CLK_APBCLK0_WDTCKEN_Pos          (0)                                               /*!< CLK_T::APBCLK0: WDTCKEN Position          */
S#define CLK_APBCLK0_WDTCKEN_Msk          (0x1ul << CLK_APBCLK0_WDTCKEN_Pos)                /*!< CLK_T::APBCLK0: WDTCKEN Mask              */
S
S#define CLK_APBCLK0_RTCCKEN_Pos          (1)                                               /*!< CLK_T::APBCLK0: RTCCKEN Position          */
S#define CLK_APBCLK0_RTCCKEN_Msk          (0x1ul << CLK_APBCLK0_RTCCKEN_Pos)                /*!< CLK_T::APBCLK0: RTCCKEN Mask              */
S
S#define CLK_APBCLK0_TMR0CKEN_Pos         (2)                                               /*!< CLK_T::APBCLK0: TMR0CKEN Position         */
S#define CLK_APBCLK0_TMR0CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR0CKEN_Pos)               /*!< CLK_T::APBCLK0: TMR0CKEN Mask             */
S
S#define CLK_APBCLK0_TMR1CKEN_Pos         (3)                                               /*!< CLK_T::APBCLK0: TMR1CKEN Position         */
S#define CLK_APBCLK0_TMR1CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR1CKEN_Pos)               /*!< CLK_T::APBCLK0: TMR1CKEN Mask             */
S
S#define CLK_APBCLK0_TMR2CKEN_Pos         (4)                                               /*!< CLK_T::APBCLK0: TMR2CKEN Position         */
S#define CLK_APBCLK0_TMR2CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR2CKEN_Pos)               /*!< CLK_T::APBCLK0: TMR2CKEN Mask             */
S
S#define CLK_APBCLK0_TMR3CKEN_Pos         (5)                                               /*!< CLK_T::APBCLK0: TMR3CKEN Position         */
S#define CLK_APBCLK0_TMR3CKEN_Msk         (0x1ul << CLK_APBCLK0_TMR3CKEN_Pos)               /*!< CLK_T::APBCLK0: TMR3CKEN Mask             */
S
S#define CLK_APBCLK0_CLKOCKEN_Pos         (6)                                               /*!< CLK_T::APBCLK0: CLKOCKEN Position         */
S#define CLK_APBCLK0_CLKOCKEN_Msk         (0x1ul << CLK_APBCLK0_CLKOCKEN_Pos)               /*!< CLK_T::APBCLK0: CLKOCKEN Mask             */
S
S#define CLK_APBCLK0_ACMP01CKEN_Pos       (7)                                               /*!< CLK_T::APBCLK0: ACMP01CKEN Position       */
S#define CLK_APBCLK0_ACMP01CKEN_Msk       (0x1ul << CLK_APBCLK0_ACMP01CKEN_Pos)             /*!< CLK_T::APBCLK0: ACMP01CKEN Mask           */
S
S#define CLK_APBCLK0_I2C0CKEN_Pos         (8)                                               /*!< CLK_T::APBCLK0: I2C0CKEN Position         */
S#define CLK_APBCLK0_I2C0CKEN_Msk         (0x1ul << CLK_APBCLK0_I2C0CKEN_Pos)               /*!< CLK_T::APBCLK0: I2C0CKEN Mask             */
S
S#define CLK_APBCLK0_I2C1CKEN_Pos         (9)                                               /*!< CLK_T::APBCLK0: I2C1CKEN Position         */
S#define CLK_APBCLK0_I2C1CKEN_Msk         (0x1ul << CLK_APBCLK0_I2C1CKEN_Pos)               /*!< CLK_T::APBCLK0: I2C1CKEN Mask             */
S
S#define CLK_APBCLK0_SPI0CKEN_Pos         (12)                                              /*!< CLK_T::APBCLK0: SPI0CKEN Position         */
S#define CLK_APBCLK0_SPI0CKEN_Msk         (0x1ul << CLK_APBCLK0_SPI0CKEN_Pos)               /*!< CLK_T::APBCLK0: SPI0CKEN Mask             */
S
S#define CLK_APBCLK0_SPI1CKEN_Pos         (13)                                              /*!< CLK_T::APBCLK0: SPI1CKEN Position         */
S#define CLK_APBCLK0_SPI1CKEN_Msk         (0x1ul << CLK_APBCLK0_SPI1CKEN_Pos)               /*!< CLK_T::APBCLK0: SPI1CKEN Mask             */
S
S#define CLK_APBCLK0_SPI2CKEN_Pos         (14)                                              /*!< CLK_T::APBCLK0: SPI2CKEN Position         */
S#define CLK_APBCLK0_SPI2CKEN_Msk         (0x1ul << CLK_APBCLK0_SPI2CKEN_Pos)               /*!< CLK_T::APBCLK0: SPI2CKEN Mask             */
S
S#define CLK_APBCLK0_UART0CKEN_Pos        (16)                                              /*!< CLK_T::APBCLK0: UART0CKEN Position        */
S#define CLK_APBCLK0_UART0CKEN_Msk        (0x1ul << CLK_APBCLK0_UART0CKEN_Pos)              /*!< CLK_T::APBCLK0: UART0CKEN Mask            */
S
S#define CLK_APBCLK0_UART1CKEN_Pos        (17)                                              /*!< CLK_T::APBCLK0: UART1CKEN Position        */
S#define CLK_APBCLK0_UART1CKEN_Msk        (0x1ul << CLK_APBCLK0_UART1CKEN_Pos)              /*!< CLK_T::APBCLK0: UART1CKEN Mask            */
S
S#define CLK_APBCLK0_UART2CKEN_Pos        (18)                                              /*!< CLK_T::APBCLK0: UART2CKEN Position        */
S#define CLK_APBCLK0_UART2CKEN_Msk        (0x1ul << CLK_APBCLK0_UART2CKEN_Pos)              /*!< CLK_T::APBCLK0: UART2CKEN Mask            */
S
S#define CLK_APBCLK0_UART3CKEN_Pos        (19)                                              /*!< CLK_T::APBCLK0: UART3CKEN Position        */
S#define CLK_APBCLK0_UART3CKEN_Msk        (0x1ul << CLK_APBCLK0_UART3CKEN_Pos)              /*!< CLK_T::APBCLK0: UART3CKEN Mask            */
S
S#define CLK_APBCLK0_CAN0CKEN_Pos         (24)                                              /*!< CLK_T::APBCLK0: CAN0CKEN Position         */
S#define CLK_APBCLK0_CAN0CKEN_Msk         (0x1ul << CLK_APBCLK0_CAN0CKEN_Pos)               /*!< CLK_T::APBCLK0: CAN0CKEN Mask             */
S
S#define CLK_APBCLK0_OTGCKEN_Pos          (26)                                              /*!< CLK_T::APBCLK0: OTGCKEN Position          */
S#define CLK_APBCLK0_OTGCKEN_Msk          (0x1ul << CLK_APBCLK0_OTGCKEN_Pos)                /*!< CLK_T::APBCLK0: OTGCKEN Mask              */
S
S#define CLK_APBCLK0_USBDCKEN_Pos         (27)                                              /*!< CLK_T::APBCLK0: USBDCKEN Position         */
S#define CLK_APBCLK0_USBDCKEN_Msk         (0x1ul << CLK_APBCLK0_USBDCKEN_Pos)               /*!< CLK_T::APBCLK0: USBDCKEN Mask             */
S
S#define CLK_APBCLK0_EADCCKEN_Pos         (28)                                              /*!< CLK_T::APBCLK0: EADCCKEN Position         */
S#define CLK_APBCLK0_EADCCKEN_Msk         (0x1ul << CLK_APBCLK0_EADCCKEN_Pos)               /*!< CLK_T::APBCLK0: EADCCKEN Mask             */
S
S#define CLK_APBCLK1_SC0CKEN_Pos          (0)                                               /*!< CLK_T::APBCLK1: SC0CKEN Position          */
S#define CLK_APBCLK1_SC0CKEN_Msk          (0x1ul << CLK_APBCLK1_SC0CKEN_Pos)                /*!< CLK_T::APBCLK1: SC0CKEN Mask              */
S
S#define CLK_APBCLK1_DACCKEN_Pos          (12)                                              /*!< CLK_T::APBCLK1: DACCKEN Position          */
S#define CLK_APBCLK1_DACCKEN_Msk          (0x1ul << CLK_APBCLK1_DACCKEN_Pos)                /*!< CLK_T::APBCLK1: DACCKEN Mask              */
S
S#define CLK_APBCLK1_PWM0CKEN_Pos         (16)                                              /*!< CLK_T::APBCLK1: PWM0CKEN Position         */
S#define CLK_APBCLK1_PWM0CKEN_Msk         (0x1ul << CLK_APBCLK1_PWM0CKEN_Pos)               /*!< CLK_T::APBCLK1: PWM0CKEN Mask             */
S
S#define CLK_APBCLK1_PWM1CKEN_Pos         (17)                                              /*!< CLK_T::APBCLK1: PWM1CKEN Position         */
S#define CLK_APBCLK1_PWM1CKEN_Msk         (0x1ul << CLK_APBCLK1_PWM1CKEN_Pos)               /*!< CLK_T::APBCLK1: PWM1CKEN Mask             */
S
S#define CLK_APBCLK1_TKCKEN_Pos           (25)                                              /*!< CLK_T::APBCLK1: TKCKEN Position           */
S#define CLK_APBCLK1_TKCKEN_Msk           (0x1ul << CLK_APBCLK1_TKCKEN_Pos)                 /*!< CLK_T::APBCLK1: TKCKEN Mask               */
S
S#define CLK_CLKSEL0_HCLKSEL_Pos          (0)                                               /*!< CLK_T::CLKSEL0: HCLKSEL Position          */
S#define CLK_CLKSEL0_HCLKSEL_Msk          (0x7ul << CLK_CLKSEL0_HCLKSEL_Pos)                /*!< CLK_T::CLKSEL0: HCLKSEL Mask              */
S
S#define CLK_CLKSEL0_STCLKSEL_Pos         (3)                                               /*!< CLK_T::CLKSEL0: STCLKSEL Position         */
S#define CLK_CLKSEL0_STCLKSEL_Msk         (0x7ul << CLK_CLKSEL0_STCLKSEL_Pos)               /*!< CLK_T::CLKSEL0: STCLKSEL Mask             */
S
S#define CLK_CLKSEL0_PCLK0SEL_Pos         (6)                                               /*!< CLK_T::CLKSEL0: PCLK0SEL Position         */
S#define CLK_CLKSEL0_PCLK0SEL_Msk         (0x1ul << CLK_CLKSEL0_PCLK0SEL_Pos)               /*!< CLK_T::CLKSEL0: PCLK0SEL Mask             */
S
S#define CLK_CLKSEL0_PCLK1SEL_Pos         (7)                                               /*!< CLK_T::CLKSEL0: PCLK1SEL Position         */
S#define CLK_CLKSEL0_PCLK1SEL_Msk         (0x1ul << CLK_CLKSEL0_PCLK1SEL_Pos)               /*!< CLK_T::CLKSEL0: PCLK1SEL Mask             */
S
S#define CLK_CLKSEL1_WDTSEL_Pos           (0)                                               /*!< CLK_T::CLKSEL1: WDTSEL Position           */
S#define CLK_CLKSEL1_WDTSEL_Msk           (0x3ul << CLK_CLKSEL1_WDTSEL_Pos)                 /*!< CLK_T::CLKSEL1: WDTSEL Mask               */
S
S#define CLK_CLKSEL1_TMR0SEL_Pos          (8)                                               /*!< CLK_T::CLKSEL1: TMR0SEL Position          */
S#define CLK_CLKSEL1_TMR0SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR0SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR0SEL Mask              */
S
S#define CLK_CLKSEL1_TMR1SEL_Pos          (12)                                              /*!< CLK_T::CLKSEL1: TMR1SEL Position          */
S#define CLK_CLKSEL1_TMR1SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR1SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR1SEL Mask              */
S
S#define CLK_CLKSEL1_TMR2SEL_Pos          (16)                                              /*!< CLK_T::CLKSEL1: TMR2SEL Position          */
S#define CLK_CLKSEL1_TMR2SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR2SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR2SEL Mask              */
S
S#define CLK_CLKSEL1_TMR3SEL_Pos          (20)                                              /*!< CLK_T::CLKSEL1: TMR3SEL Position          */
S#define CLK_CLKSEL1_TMR3SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR3SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR3SEL Mask              */
S
S#define CLK_CLKSEL1_UARTSEL_Pos          (24)                                              /*!< CLK_T::CLKSEL1: UARTSEL Position          */
S#define CLK_CLKSEL1_UARTSEL_Msk          (0x3ul << CLK_CLKSEL1_UARTSEL_Pos)                /*!< CLK_T::CLKSEL1: UARTSEL Mask              */
S
S#define CLK_CLKSEL1_CLKOSEL_Pos          (28)                                              /*!< CLK_T::CLKSEL1: CLKOSEL Position          */
S#define CLK_CLKSEL1_CLKOSEL_Msk          (0x3ul << CLK_CLKSEL1_CLKOSEL_Pos)                /*!< CLK_T::CLKSEL1: CLKOSEL Mask              */
S
S#define CLK_CLKSEL1_WWDTSEL_Pos          (30)                                              /*!< CLK_T::CLKSEL1: WWDTSEL Position          */
S#define CLK_CLKSEL1_WWDTSEL_Msk          (0x3ul << CLK_CLKSEL1_WWDTSEL_Pos)                /*!< CLK_T::CLKSEL1: WWDTSEL Mask              */
S
S#define CLK_CLKSEL2_PWM0SEL_Pos          (0)                                               /*!< CLK_T::CLKSEL2: PWM0SEL Position          */
S#define CLK_CLKSEL2_PWM0SEL_Msk          (0x1ul << CLK_CLKSEL2_PWM0SEL_Pos)                /*!< CLK_T::CLKSEL2: PWM0SEL Mask              */
S
S#define CLK_CLKSEL2_PWM1SEL_Pos          (1)                                               /*!< CLK_T::CLKSEL2: PWM1SEL Position          */
S#define CLK_CLKSEL2_PWM1SEL_Msk          (0x1ul << CLK_CLKSEL2_PWM1SEL_Pos)                /*!< CLK_T::CLKSEL2: PWM1SEL Mask              */
S
S#define CLK_CLKSEL2_SPI0SEL_Pos          (2)                                               /*!< CLK_T::CLKSEL2: SPI0SEL Position          */
S#define CLK_CLKSEL2_SPI0SEL_Msk          (0x3ul << CLK_CLKSEL2_SPI0SEL_Pos)                /*!< CLK_T::CLKSEL2: SPI0SEL Mask              */
S
S#define CLK_CLKSEL2_SPI1SEL_Pos          (4)                                               /*!< CLK_T::CLKSEL2: SPI1SEL Position          */
S#define CLK_CLKSEL2_SPI1SEL_Msk          (0x3ul << CLK_CLKSEL2_SPI1SEL_Pos)                /*!< CLK_T::CLKSEL2: SPI1SEL Mask              */
S
S#define CLK_CLKSEL2_SPI2SEL_Pos          (6)                                               /*!< CLK_T::CLKSEL2: SPI2SEL Position          */
S#define CLK_CLKSEL2_SPI2SEL_Msk          (0x3ul << CLK_CLKSEL2_SPI2SEL_Pos)                /*!< CLK_T::CLKSEL2: SPI2SEL Mask              */
S
S#define CLK_CLKSEL3_SC0SEL_Pos           (0)                                               /*!< CLK_T::CLKSEL3: SC0SEL Position           */
S#define CLK_CLKSEL3_SC0SEL_Msk           (0x3ul << CLK_CLKSEL3_SC0SEL_Pos)                 /*!< CLK_T::CLKSEL3: SC0SEL Mask               */
S
S#define CLK_CLKSEL3_RTCSEL_Pos           (8)                                               /*!< CLK_T::CLKSEL3: RTCSEL Position           */
S#define CLK_CLKSEL3_RTCSEL_Msk           (0x1ul << CLK_CLKSEL3_RTCSEL_Pos)                 /*!< CLK_T::CLKSEL3: RTCSEL Mask               */
S
S#define CLK_CLKDIV0_HCLKDIV_Pos          (0)                                               /*!< CLK_T::CLKDIV0: HCLKDIV Position          */
S#define CLK_CLKDIV0_HCLKDIV_Msk          (0xful << CLK_CLKDIV0_HCLKDIV_Pos)                /*!< CLK_T::CLKDIV0: HCLKDIV Mask              */
S
S#define CLK_CLKDIV0_USBDIV_Pos           (4)                                               /*!< CLK_T::CLKDIV0: USBDIV Position           */
S#define CLK_CLKDIV0_USBDIV_Msk           (0xful << CLK_CLKDIV0_USBDIV_Pos)                 /*!< CLK_T::CLKDIV0: USBDIV Mask               */
S
S#define CLK_CLKDIV0_UARTDIV_Pos          (8)                                               /*!< CLK_T::CLKDIV0: UARTDIV Position          */
S#define CLK_CLKDIV0_UARTDIV_Msk          (0xful << CLK_CLKDIV0_UARTDIV_Pos)                /*!< CLK_T::CLKDIV0: UARTDIV Mask              */
S
S#define CLK_CLKDIV0_EADCDIV_Pos          (16)                                              /*!< CLK_T::CLKDIV0: EADCDIV Position          */
S#define CLK_CLKDIV0_EADCDIV_Msk          (0xfful << CLK_CLKDIV0_EADCDIV_Pos)               /*!< CLK_T::CLKDIV0: EADCDIV Mask              */
S
S#define CLK_CLKDIV1_SC0DIV_Pos           (0)                                               /*!< CLK_T::CLKDIV1: SC0DIV Position           */
S#define CLK_CLKDIV1_SC0DIV_Msk           (0xfful << CLK_CLKDIV1_SC0DIV_Pos)                /*!< CLK_T::CLKDIV1: SC0DIV Mask               */
S
S#define CLK_PLLCTL_FBDIV_Pos             (0)                                               /*!< CLK_T::PLLCTL: FBDIV Position             */
S#define CLK_PLLCTL_FBDIV_Msk             (0x1fful << CLK_PLLCTL_FBDIV_Pos)                 /*!< CLK_T::PLLCTL: FBDIV Mask                 */
S
S#define CLK_PLLCTL_INDIV_Pos             (9)                                               /*!< CLK_T::PLLCTL: INDIV Position             */
S#define CLK_PLLCTL_INDIV_Msk             (0x1ful << CLK_PLLCTL_INDIV_Pos)                  /*!< CLK_T::PLLCTL: INDIV Mask                 */
S
S#define CLK_PLLCTL_OUTDIV_Pos            (14)                                              /*!< CLK_T::PLLCTL: OUTDIV Position            */
S#define CLK_PLLCTL_OUTDIV_Msk            (0x3ul << CLK_PLLCTL_OUTDIV_Pos)                  /*!< CLK_T::PLLCTL: OUTDIV Mask                */
S
S#define CLK_PLLCTL_PD_Pos                (16)                                              /*!< CLK_T::PLLCTL: PD Position                */
S#define CLK_PLLCTL_PD_Msk                (0x1ul << CLK_PLLCTL_PD_Pos)                      /*!< CLK_T::PLLCTL: PD Mask                    */
S
S#define CLK_PLLCTL_BP_Pos                (17)                                              /*!< CLK_T::PLLCTL: BP Position                */
S#define CLK_PLLCTL_BP_Msk                (0x1ul << CLK_PLLCTL_BP_Pos)                      /*!< CLK_T::PLLCTL: BP Mask                    */
S
S#define CLK_PLLCTL_OE_Pos                (18)                                              /*!< CLK_T::PLLCTL: OE Position                */
S#define CLK_PLLCTL_OE_Msk                (0x1ul << CLK_PLLCTL_OE_Pos)                      /*!< CLK_T::PLLCTL: OE Mask                    */
S
S#define CLK_PLLCTL_PLLSRC_Pos            (19)                                              /*!< CLK_T::PLLCTL: PLLSRC Position            */
S#define CLK_PLLCTL_PLLSRC_Msk            (0x1ul << CLK_PLLCTL_PLLSRC_Pos)                  /*!< CLK_T::PLLCTL: PLLSRC Mask                */
S
S#define CLK_PLLCTL_STBSEL_Pos            (23)                                              /*!< CLK_T::PLLCTL: STBSEL Position            */
S#define CLK_PLLCTL_STBSEL_Msk            (0x1ul << CLK_PLLCTL_STBSEL_Pos)                  /*!< CLK_T::PLLCTL: STBSEL Mask                */
S
S#define CLK_STATUS_HXTSTB_Pos            (0)                                               /*!< CLK_T::STATUS: HXTSTB Position            */
S#define CLK_STATUS_HXTSTB_Msk            (0x1ul << CLK_STATUS_HXTSTB_Pos)                  /*!< CLK_T::STATUS: HXTSTB Mask                */
S
S#define CLK_STATUS_LXTSTB_Pos            (1)                                               /*!< CLK_T::STATUS: LXTSTB Position            */
S#define CLK_STATUS_LXTSTB_Msk            (0x1ul << CLK_STATUS_LXTSTB_Pos)                  /*!< CLK_T::STATUS: LXTSTB Mask                */
S
S#define CLK_STATUS_PLLSTB_Pos            (2)                                               /*!< CLK_T::STATUS: PLLSTB Position            */
S#define CLK_STATUS_PLLSTB_Msk            (0x1ul << CLK_STATUS_PLLSTB_Pos)                  /*!< CLK_T::STATUS: PLLSTB Mask                */
S
S#define CLK_STATUS_LIRCSTB_Pos           (3)                                               /*!< CLK_T::STATUS: LIRCSTB Position           */
S#define CLK_STATUS_LIRCSTB_Msk           (0x1ul << CLK_STATUS_LIRCSTB_Pos)                 /*!< CLK_T::STATUS: LIRCSTB Mask               */
S
S#define CLK_STATUS_HIRCSTB_Pos           (4)                                               /*!< CLK_T::STATUS: HIRCSTB Position           */
S#define CLK_STATUS_HIRCSTB_Msk           (0x1ul << CLK_STATUS_HIRCSTB_Pos)                 /*!< CLK_T::STATUS: HIRCSTB Mask               */
S
S#define CLK_STATUS_CLKSFAIL_Pos          (7)                                               /*!< CLK_T::STATUS: CLKSFAIL Position          */
S#define CLK_STATUS_CLKSFAIL_Msk          (0x1ul << CLK_STATUS_CLKSFAIL_Pos)                /*!< CLK_T::STATUS: CLKSFAIL Mask              */
S
S#define CLK_CLKOCTL_FREQSEL_Pos          (0)                                               /*!< CLK_T::CLKOCTL: FREQSEL Position          */
S#define CLK_CLKOCTL_FREQSEL_Msk          (0xful << CLK_CLKOCTL_FREQSEL_Pos)                /*!< CLK_T::CLKOCTL: FREQSEL Mask              */
S
S#define CLK_CLKOCTL_CLKOEN_Pos           (4)                                               /*!< CLK_T::CLKOCTL: CLKOEN Position           */
S#define CLK_CLKOCTL_CLKOEN_Msk           (0x1ul << CLK_CLKOCTL_CLKOEN_Pos)                 /*!< CLK_T::CLKOCTL: CLKOEN Mask               */
S
S#define CLK_CLKOCTL_DIV1EN_Pos           (5)                                               /*!< CLK_T::CLKOCTL: DIV1EN Position           */
S#define CLK_CLKOCTL_DIV1EN_Msk           (0x1ul << CLK_CLKOCTL_DIV1EN_Pos)                 /*!< CLK_T::CLKOCTL: DIV1EN Mask               */
S
S#define CLK_CLKOCTL_CLK1HZEN_Pos         (6)                                               /*!< CLK_T::CLKOCTL: CLK1HZEN Position         */
S#define CLK_CLKOCTL_CLK1HZEN_Msk         (0x1ul << CLK_CLKOCTL_CLK1HZEN_Pos)               /*!< CLK_T::CLKOCTL: CLK1HZEN Mask             */
S
S#define CLK_CLKDCTL_HXTFDEN_Pos          (4)                                               /*!< CLK_T::CLKDCTL: HXTFDEN Position          */
S#define CLK_CLKDCTL_HXTFDEN_Msk          (0x1ul << CLK_CLKDCTL_HXTFDEN_Pos)                /*!< CLK_T::CLKDCTL: HXTFDEN Mask              */
S
S#define CLK_CLKDCTL_HXTFIEN_Pos          (5)                                               /*!< CLK_T::CLKDCTL: HXTFIEN Position          */
S#define CLK_CLKDCTL_HXTFIEN_Msk          (0x1ul << CLK_CLKDCTL_HXTFIEN_Pos)                /*!< CLK_T::CLKDCTL: HXTFIEN Mask              */
S
S#define CLK_CLKDCTL_LXTFDEN_Pos          (12)                                              /*!< CLK_T::CLKDCTL: LXTFDEN Position          */
S#define CLK_CLKDCTL_LXTFDEN_Msk          (0x1ul << CLK_CLKDCTL_LXTFDEN_Pos)                /*!< CLK_T::CLKDCTL: LXTFDEN Mask              */
S
S#define CLK_CLKDCTL_LXTFIEN_Pos          (13)                                              /*!< CLK_T::CLKDCTL: LXTFIEN Position          */
S#define CLK_CLKDCTL_LXTFIEN_Msk          (0x1ul << CLK_CLKDCTL_LXTFIEN_Pos)                /*!< CLK_T::CLKDCTL: LXTFIEN Mask              */
S
S#define CLK_CLKDCTL_HXTFQDEN_Pos         (16)                                              /*!< CLK_T::CLKDCTL: HXTFQDEN Position         */
S#define CLK_CLKDCTL_HXTFQDEN_Msk         (0x1ul << CLK_CLKDCTL_HXTFQDEN_Pos)               /*!< CLK_T::CLKDCTL: HXTFQDEN Mask             */
S
S#define CLK_CLKDCTL_HXTFQIEN_Pos         (17)                                              /*!< CLK_T::CLKDCTL: HXTFQIEN Position         */
S#define CLK_CLKDCTL_HXTFQIEN_Msk         (0x1ul << CLK_CLKDCTL_HXTFQIEN_Pos)               /*!< CLK_T::CLKDCTL: HXTFQIEN Mask             */
S
S#define CLK_CLKDSTS_HXTFIF_Pos           (0)                                               /*!< CLK_T::CLKDSTS: HXTFIF Position           */
S#define CLK_CLKDSTS_HXTFIF_Msk           (0x1ul << CLK_CLKDSTS_HXTFIF_Pos)                 /*!< CLK_T::CLKDSTS: HXTFIF Mask               */
S
S#define CLK_CLKDSTS_LXTFIF_Pos           (1)                                               /*!< CLK_T::CLKDSTS: LXTFIF Position           */
S#define CLK_CLKDSTS_LXTFIF_Msk           (0x1ul << CLK_CLKDSTS_LXTFIF_Pos)                 /*!< CLK_T::CLKDSTS: LXTFIF Mask               */
S
S#define CLK_CLKDSTS_HXTFQIF_Pos          (8)                                               /*!< CLK_T::CLKDSTS: HXTFQIF Position          */
S#define CLK_CLKDSTS_HXTFQIF_Msk          (0x1ul << CLK_CLKDSTS_HXTFQIF_Pos)                /*!< CLK_T::CLKDSTS: HXTFQIF Mask              */
S
S#define CLK_CDUPB_UPERBD_Pos             (0)                                               /*!< CLK_T::CDUPB: UPERBD Position             */
S#define CLK_CDUPB_UPERBD_Msk             (0x3fful << CLK_CDUPB_UPERBD_Pos)                 /*!< CLK_T::CDUPB: UPERBD Mask                 */
S
S#define CLK_CDLOWB_LOWERBD_Pos           (0)                                               /*!< CLK_T::CDLOWB: LOWERBD Position           */
S#define CLK_CDLOWB_LOWERBD_Msk           (0x3fful << CLK_CDLOWB_LOWERBD_Pos)               /*!< CLK_T::CDLOWB: LOWERBD Mask               */
S
S
S/**@}*/ /* CLK_CONST */
S/**@}*/ /* end of CLK register group */
S
S
S
S/*---------------------- Cyclic Redundancy Check Controller -------------------------*/
S/**
S    @addtogroup CRC Cyclic Redundancy Check Controller(CRC)
S    Memory Mapped Structure for CRC Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S
S
S/**
S * @var CRC_T::CTL
S * Offset: 0x00  CRC Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |CRCEN     |CRC Channel Enable Bit
S * |        |          |0 = No effect.
S * |        |          |1 = CRC operation Enabled.
S * |[1]     |CRCRST    |CRC Engine Reset
S * |        |          |0 = No effect.
S * |        |          |1 = Reset the internal CRC state machine and internal buffer.
S * |        |          |The others contents of CRC_CTL register will not be cleared.
S * |        |          |Note1: This bit will be cleared automatically.
S * |        |          |Note2: Setting this bit will reload the initial seed value (CRC_SEED register).
S * |[24]    |DATREV    |Write Data Bit Order Reverse
S * |        |          |This bit is used to enable the bit order reverse function for write data value in CRC_DAT register.
S * |        |          |0 = Bit order reversed for CRC write data in Disabled.
S * |        |          |1 = Bit order reversed for CRC write data in Enabled (per byte).
S * |        |          |Note: If the write data is 0xAABBCCDD, the bit order reverse for CRC write data in is 0x55DD33BB.
S * |[25]    |CHKSREV   |Checksum Bit Order Reverse
S * |        |          |This bit is used to enable the bit order reverse function for write data value in CRC_CHECKSUM register.
S * |        |          |0 = Bit order reverse for CRC checksum Disabled.
S * |        |          |1 = Bit order reverse for CRC checksum Enabled.
S * |        |          |Note: If the checksum result is 0xDD7B0F2E, the bit order reverse for CRC checksum is 0x74F0DEBB.
S * |[26]    |DATFMT    |Write Data 1's Complement
S * |        |          |This bit is used to enable the 1's complement function for write data value in CRC_DAT register.
S * |        |          |0 = 1's complement for CRC writes data in Disabled.
S * |        |          |1 = 1's complement for CRC writes data in Enabled.
S * |[27]    |CHKSFMT   |Checksum 1's Complement
S * |        |          |This bit is used to enable the 1's complement function for checksum result in CRC_CHECKSUM register.
S * |        |          |0 = 1's complement for CRC checksum Disabled.
S * |        |          |1 = 1's complement for CRC checksum Enabled.
S * |[29:28] |DATLEN    |CPU Write Data Length
S * |        |          |This field indicates the write data length.
S * |        |          |00 = Data length is 8-bit mode.
S * |        |          |01 = Data length is 16-bit mode.
S * |        |          |1x = Data length is 32-bit mode.
S * |        |          |Note: When the write data length is 8-bit mode, the valid data in CRC_DAT register is only DATA[7:0] bits; if the write data length is 16-bit mode, the valid data in CRC_DAT register is only DATA[15:0]
S * |[31:30] |CRCMODE   |CRC Polynomial Mode
S * |        |          |This field indicates the CRC operation polynomial mode.
S * |        |          |00 = CRC-CCITT Polynomial mode.
S * |        |          |01 = CRC-8 Polynomial mode.
S * |        |          |10 = CRC-16 Polynomial mode.
S * |        |          |11 = CRC-32 Polynomial mode.
S * @var CRC_T::DAT
S * Offset: 0x04  CRC Write Data Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |DATA      |CRC Write Data Bits
S * |        |          |User can write data directly by CPU mode or use PDMA function to write data to this field to perform CRC operation.
S * |        |          |Note: When the write data length is 8-bit mode, the valid data in CRC_DAT register is only DATA[7:0] bits; if the write data length is 16-bit mode, the valid data in CRC_DAT register is only DATA[15:0].
S * @var CRC_T::SEED
S * Offset: 0x08  CRC Seed Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |SEED      |CRC Seed Value
S * |        |          |This field indicates the CRC seed value.
S * @var CRC_T::CHECKSUM
S * Offset: 0x0C  CRC Checksum Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |CHECKSUM  |CRC Checksum Results
S * |        |          |This field indicates the CRC checksum result.
S */
S
S    __IO uint32_t CTL;           /* Offset: 0x00  CRC Control Register                                               */
S    __IO uint32_t DAT;           /* Offset: 0x04  CRC Write Data Register                                            */
S    __IO uint32_t SEED;          /* Offset: 0x08  CRC Seed Register                                                  */
S    __I  uint32_t CHECKSUM;      /* Offset: 0x0C  CRC Checksum Register                                              */
S
S} CRC_T;
S
S
S
S/**
S    @addtogroup CRC_CONST CRC Bit Field Definition
S    Constant Definitions for CRC Controller
S@{ */
S
S#define CRC_CTL_CRCEN_Pos                (0)                                               /*!< CRC_T::CTL: CRCEN Position                */
S#define CRC_CTL_CRCEN_Msk                (0x1ul << CRC_CTL_CRCEN_Pos)                      /*!< CRC_T::CTL: CRCEN Mask                    */
S
S#define CRC_CTL_CRCRST_Pos               (1)                                               /*!< CRC_T::CTL: CRCRST Position               */
S#define CRC_CTL_CRCRST_Msk               (0x1ul << CRC_CTL_CRCRST_Pos)                     /*!< CRC_T::CTL: CRCRST Mask                   */
S
S#define CRC_CTL_DATREV_Pos               (24)                                              /*!< CRC_T::CTL: DATREV Position               */
S#define CRC_CTL_DATREV_Msk               (0x1ul << CRC_CTL_DATREV_Pos)                     /*!< CRC_T::CTL: DATREV Mask                   */
S
S#define CRC_CTL_CHKSREV_Pos              (25)                                              /*!< CRC_T::CTL: CHKSREV Position              */
S#define CRC_CTL_CHKSREV_Msk              (0x1ul << CRC_CTL_CHKSREV_Pos)                    /*!< CRC_T::CTL: CHKSREV Mask                  */
S
S#define CRC_CTL_DATFMT_Pos               (26)                                              /*!< CRC_T::CTL: DATFMT Position               */
S#define CRC_CTL_DATFMT_Msk               (0x1ul << CRC_CTL_DATFMT_Pos)                     /*!< CRC_T::CTL: DATFMT Mask                   */
S
S#define CRC_CTL_CHKSFMT_Pos              (27)                                              /*!< CRC_T::CTL: CHKSFMT Position              */
S#define CRC_CTL_CHKSFMT_Msk              (0x1ul << CRC_CTL_CHKSFMT_Pos)                    /*!< CRC_T::CTL: CHKSFMT Mask                  */
S
S#define CRC_CTL_DATLEN_Pos               (28)                                              /*!< CRC_T::CTL: DATLEN Position               */
S#define CRC_CTL_DATLEN_Msk               (0x3ul << CRC_CTL_DATLEN_Pos)                     /*!< CRC_T::CTL: DATLEN Mask                   */
S
S#define CRC_CTL_CRCMODE_Pos              (30)                                              /*!< CRC_T::CTL: CRCMODE Position              */
S#define CRC_CTL_CRCMODE_Msk              (0x3ul << CRC_CTL_CRCMODE_Pos)                    /*!< CRC_T::CTL: CRCMODE Mask                  */
S
S#define CRC_DAT_DATA_Pos                 (0)                                               /*!< CRC_T::DAT: DATA Position                 */
S#define CRC_DAT_DATA_Msk                 (0xfffffffful << CRC_DAT_DATA_Pos)                /*!< CRC_T::DAT: DATA Mask                     */
S
S#define CRC_SEED_SEED_Pos                (0)                                               /*!< CRC_T::SEED: SEED Position                */
S#define CRC_SEED_SEED_Msk                (0xfffffffful << CRC_SEED_SEED_Pos)               /*!< CRC_T::SEED: SEED Mask                    */
S
S#define CRC_CHECKSUM_CHECKSUM_Pos        (0)                                               /*!< CRC_T::CHECKSUM: CHECKSUM Position        */
S#define CRC_CHECKSUM_CHECKSUM_Msk        (0xfffffffful << CRC_CHECKSUM_CHECKSUM_Pos)       /*!< CRC_T::CHECKSUM: CHECKSUM Mask            */
S
S/**@}*/ /* CRC_CONST */
S/**@}*/ /* end of CRC register group */
S
S
S/*---------------------- Digital to Analog Converter -------------------------*/
S/**
S    @addtogroup DAC Digital to Analog Converter(DAC)
S    Memory Mapped Structure for DAC Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S
S/**
S * @var DAC_T::CTL
S * Offset: 0x00  DAC Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |DACEN     |DAC Enable Bit
S * |        |          |0 = DAC is Disabled.
S * |        |          |1 = DAC is Enabled.
S * |[1]     |DACIEN    |DAC Interrupt Enable Bit
S * |        |          |0 = Interrupt is Disabled.
S * |        |          |1 = Interrupt is Enabled.
S * |[2]     |DMAEN     |DMA Mode Enable Bit
S * |        |          |0 = DMA mode Disabled.
S * |        |          |1 = DMA mode Enabled.
S * |[3]     |DMAURIEN  |DMA Under-Run Interrupt Enable Bit
S * |        |          |0 = DMA under run interrupt Disabled.
S * |        |          |1 = DMA under run interrupt Enabled.
S * |[4]     |TRGEN     |Trigger Mode Enable Bit
S * |        |          |0 = DAC event trigger mode Disabled.
S * |        |          |1 = DAC event trigger mode Enabled.
S * |[7:5]   |TRGSEL    |Trigger Source Selection
S * |        |          |000 = Software trigger.
S * |        |          |001 = External pin STDAC trigger.
S * |        |          |010 = Timer 0 trigger.
S * |        |          |011 = Timer 1 trigger.
S * |        |          |100 = Timer 2 trigger.
S * |        |          |101 = Timer 3 trigger.
S * |        |          |110 = PWM0 trigger.
S * |        |          |111 = PWM1 trigger.
S * |[8]     |BYPASS    |Bypass Buffer Mode
S * |        |          |0 = Output voltage buffer Enabled.
S * |        |          |1 = Output voltage buffer Disabled.
S * |[10]    |LALIGN    |DAC Data Left-Aligned Enabled Control
S * |        |          |0 = Right alignment.
S * |        |          |1 = Left alignment.
S * |[13:12] |ETRGSEL   |External Pin Trigger Selection
S * |        |          |00 = Low level trigger.
S * |        |          |01 = High level trigger.
S * |        |          |10 = Falling edge trigger.
S * |        |          |11 = Rising edge trigger.
S * @var DAC_T::SWTRG
S * Offset: 0x04  DAC Software Trigger Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |SWTRG     |Software Trigger
S * |        |          |0 = Software trigger Disabled.
S * |        |          |1 = Software trigger Enabled.
S * |        |          |User writes this bit to generate one shot pulse and it is cleared to 0 by hardware automatically; Reading this bit will always get 0.
S * @var DAC_T::DAT
S * Offset: 0x08  DAC Data Holding Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |DAC_DAT   |DAC 12-Bit Holding Data
S * |        |          |These bits are written by user software which specifies 12-bit conversion data for DAC output.
S * |        |          |The unused bits (DAC_DAT[3:0] in left-alignment mode and DAC_DAT[15:12] in right alignment mode) are ignored by DAC controller hardware.
S * |        |          |12 bit left alignment: user has to load data into DAC_DAT[15:4] bits.
S * |        |          |12 bit right alignment: user has to load data into DAC_DAT[11:0] bits.
S * @var DAC_T::DATOUT
S * Offset: 0x0C  DAC Data Output Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[11:0]  |DATOUT    |DAC 12-Bit Output Data
S * |        |          |These bits are current digital data for DAC output conversion.
S * |        |          |It is loaded from DAC_DAT register and user cannot write it directly.
S * @var DAC_T::STATUS
S * Offset: 0x10  DAC Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |FINISH    |DAC Conversion Complete Finish Flag
S * |        |          |0 = DAC is in conversion state.
S * |        |          |1 = DAC conversion finish.
S * |        |          |This bit set to 1 when conversion time counter counts to SETTLET.
S * |        |          |It is cleared to 0 when DAC starts a new conversion.
S * |        |          |User writes 1 to clear this bit to 0.
S * |[1]     |DMAUDR    |DMA Under Run Interrupt Flag
S * |        |          |0 = No DMA under-run error condition occurred.
S * |        |          |1 = DMA under-run error condition occurred.
S * |        |          |User writes 1 to clear this bit.
S * |[8]     |BUSY      |DAC Busy Flag (Read Only)
S * |        |          |0 = DAC is ready for next conversion.
S * |        |          |1 = DAC is busy in conversion.
S * |        |          |This is read only bit.
S * @var DAC_T::TCTL
S * Offset: 0x14  DAC Timing Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[9:0]   |SETTLET   |DAC Output Settling Time
S * |        |          |User software needs to write appropriate value to these bits to meet DAC conversion settling time base on PCLK (APB clock) speed.
S * |        |          |For example, DAC controller clock speed is 72MHz and DAC conversion setting time is 1 us, SETTLET value must be greater than 0x48.
S */
S
S    __IO uint32_t CTL;           /* Offset: 0x00  DAC Control Register                                               */
S    __IO uint32_t SWTRG;         /* Offset: 0x04  DAC Software Trigger Control Register                              */
S    __IO uint32_t DAT;           /* Offset: 0x08  DAC Data Holding Register                                          */
S    __I  uint32_t DATOUT;        /* Offset: 0x0C  DAC Data Output Register                                           */
S    __IO uint32_t STATUS;        /* Offset: 0x10  DAC Status Register                                                */
S    __IO uint32_t TCTL;          /* Offset: 0x14  DAC Timing Control Register                                        */
S
S} DAC_T;
S
S
S
S/**
S    @addtogroup DAC_CONST DAC Bit Field Definition
S    Constant Definitions for DAC Controller
S@{ */
S
S#define DAC_CTL_DACEN_Pos                (0)                                               /*!< DAC_T::CTL: DACEN Position                */
S#define DAC_CTL_DACEN_Msk                (0x1ul << DAC_CTL_DACEN_Pos)                      /*!< DAC_T::CTL: DACEN Mask                    */
S
S#define DAC_CTL_DACIEN_Pos               (1)                                               /*!< DAC_T::CTL: DACIEN Position               */
S#define DAC_CTL_DACIEN_Msk               (0x1ul << DAC_CTL_DACIEN_Pos)                     /*!< DAC_T::CTL: DACIEN Mask                   */
S
S#define DAC_CTL_DMAEN_Pos                (2)                                               /*!< DAC_T::CTL: DMAEN Position                */
S#define DAC_CTL_DMAEN_Msk                (0x1ul << DAC_CTL_DMAEN_Pos)                      /*!< DAC_T::CTL: DMAEN Mask                    */
S
S#define DAC_CTL_DMAURIEN_Pos             (3)                                               /*!< DAC_T::CTL: DMAURIEN Position             */
S#define DAC_CTL_DMAURIEN_Msk             (0x1ul << DAC_CTL_DMAURIEN_Pos)                   /*!< DAC_T::CTL: DMAURIEN Mask                 */
S
S#define DAC_CTL_TRGEN_Pos                (4)                                               /*!< DAC_T::CTL: TRGEN Position                */
S#define DAC_CTL_TRGEN_Msk                (0x1ul << DAC_CTL_TRGEN_Pos)                      /*!< DAC_T::CTL: TRGEN Mask                    */
S
S#define DAC_CTL_TRGSEL_Pos               (5)                                               /*!< DAC_T::CTL: TRGSEL Position               */
S#define DAC_CTL_TRGSEL_Msk               (0x7ul << DAC_CTL_TRGSEL_Pos)                     /*!< DAC_T::CTL: TRGSEL Mask                   */
S
S#define DAC_CTL_BYPASS_Pos               (8)                                               /*!< DAC_T::CTL: BYPASS Position               */
S#define DAC_CTL_BYPASS_Msk               (0x1ul << DAC_CTL_BYPASS_Pos)                     /*!< DAC_T::CTL: BYPASS Mask                   */
S
S#define DAC_CTL_LALIGN_Pos               (10)                                              /*!< DAC_T::CTL: LALIGN Position               */
S#define DAC_CTL_LALIGN_Msk               (0x1ul << DAC_CTL_LALIGN_Pos)                     /*!< DAC_T::CTL: LALIGN Mask                   */
S
S#define DAC_CTL_ETRGSEL_Pos              (12)                                              /*!< DAC_T::CTL: ETRGSEL Position              */
S#define DAC_CTL_ETRGSEL_Msk              (0x3ul << DAC_CTL_ETRGSEL_Pos)                    /*!< DAC_T::CTL: ETRGSEL Mask                  */
S
S#define DAC_SWTRG_SWTRG_Pos              (0)                                               /*!< DAC_T::SWTRG: SWTRG Position              */
S#define DAC_SWTRG_SWTRG_Msk              (0x1ul << DAC_SWTRG_SWTRG_Pos)                    /*!< DAC_T::SWTRG: SWTRG Mask                  */
S
S#define DAC_DAT_DAC_DAT_Pos              (0)                                               /*!< DAC_T::DAT: DAC_DAT Position              */
S#define DAC_DAT_DAC_DAT_Msk              (0xfffful << DAC_DAT_DAC_DAT_Pos)                 /*!< DAC_T::DAT: DAC_DAT Mask                  */
S
S#define DAC_DATOUT_DATOUT_Pos            (0)                                               /*!< DAC_T::DATOUT: DATOUT Position            */
S#define DAC_DATOUT_DATOUT_Msk            (0xffful << DAC_DATOUT_DATOUT_Pos)                /*!< DAC_T::DATOUT: DATOUT Mask                */
S
S#define DAC_STATUS_FINISH_Pos            (0)                                               /*!< DAC_T::STATUS: FINISH Position            */
S#define DAC_STATUS_FINISH_Msk            (0x1ul << DAC_STATUS_FINISH_Pos)                  /*!< DAC_T::STATUS: FINISH Mask                */
S
S#define DAC_STATUS_DMAUDR_Pos            (1)                                               /*!< DAC_T::STATUS: DMAUDR Position            */
S#define DAC_STATUS_DMAUDR_Msk            (0x1ul << DAC_STATUS_DMAUDR_Pos)                  /*!< DAC_T::STATUS: DMAUDR Mask                */
S
S#define DAC_STATUS_BUSY_Pos              (8)                                               /*!< DAC_T::STATUS: BUSY Position              */
S#define DAC_STATUS_BUSY_Msk              (0x1ul << DAC_STATUS_BUSY_Pos)                    /*!< DAC_T::STATUS: BUSY Mask                  */
S
S#define DAC_TCTL_SETTLET_Pos             (0)                                               /*!< DAC_T::TCTL: SETTLET Position             */
S#define DAC_TCTL_SETTLET_Msk             (0x3fful << DAC_TCTL_SETTLET_Pos)                 /*!< DAC_T::TCTL: SETTLET Mask                 */
S
S/**@}*/ /* DAC_CONST */
S/**@}*/ /* end of DAC register group */
S
S
S/*---------------------- External Bus Interface Controller -------------------------*/
S/**
S    @addtogroup EBI External Bus Interface Controller(EBI)
S    Memory Mapped Structure for EBI Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S
S
S/**
S * @var EBI_T::CTL0
S * Offset: 0x00  External Bus Interface Bank0 Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |EN        |EBI Enable Bit
S * |        |          |This bit is the functional enable bit for EBI.
S * |        |          |0 = EBI function Disabled.
S * |        |          |1 = EBI function Enabled.
S * |[1]     |DW16      |EBI Data Width 16-Bit Select
S * |        |          |This bit defines if the EBI data width is 8-bit or 16-bit.
S * |        |          |0 = EBI data width is 8-bit.
S * |        |          |1 = EBI data width is 16-bit.
S * |[2]     |CSPOLINV  |Chip Select Pin Polar Inverse
S * |        |          |This bit defines the active level of EBI chip select pin (EBI_nCS).
S * |        |          |0 = Chip select pin (EBI_nCS) is active low.
S * |        |          |1 = Chip select pin (EBI_nCS) is active high.
S * |[10:8]  |MCLKDIV   |External Output Clock Divider
S * |        |          |The frequency of EBI output clock (MCLK) is controlled by MCLKDIV as follow:
S * |        |          |000 = HCLK/1.
S * |        |          |001 = HCLK/2.
S * |        |          |010 = HCLK/4.
S * |        |          |011 = HCLK/8.
S * |        |          |100 = HCLK/16.
S * |        |          |101 = HCLK/32.
S * |        |          |110 = Reserved.
S * |        |          |111 = Reserved.
S * |[18:16] |TALE      |Extend Time Of ALE
S * |        |          |The EBI_ALE high pulse period (tALE) to latch the address can be controlled by TALE.
S * |        |          |tALE = (TALE+1)*EBI_MCLK.
S * |        |          |Note: This field only available in EBI_CTL0 register
S * |[24]    |WBUFEN    |EBI Write Buffer Enable Bit
S * |        |          |0 = EBI write buffer Disabled.
S * |        |          |1 = EBI write buffer Enabled.
S * |        |          |Note: This bit only available in EBI_CTL0 register
S * @var EBI_T::TCTL0
S * Offset: 0x04  External Bus Interface Bank0 Timing Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:3]   |TACC      |EBI Data Access Time
S * |        |          |TACC define data access time (tACC).
S * |        |          |tACC = (TACC +1) * EBI_MCLK.
S * |[10:8]  |TAHD      |EBI Data Access Hold Time
S * |        |          |TAHD define data access hold time (tAHD).
S * |        |          |tAHD = (TAHD +1) * EBI_MCLK.
S * |[15:12] |W2X       |Idle Cycle After Write
S * |        |          |This field defines the number of W2X idle cycle.
S * |        |          |W2X idle cycle = (W2X * EBI_MCLK).
S * |        |          |When write action is finish, W2X idle cycle is inserted and EBI_nCS return to idle state.
S * |[22]    |RAHDOFF   |Access Hold Time Disable Control When Read
S * |        |          |0 = The Data Access Hold Time (tAHD) during EBI reading is Enabled.
S * |        |          |1 = The Data Access Hold Time (tAHD) during EBI reading is Disabled.
S * |[23]    |WAHDOFF   |Access Hold Time Disable Control When Write
S * |        |          |0 = The Data Access Hold Time (tAHD) during EBI writing is Enabled.
S * |        |          |1 = The Data Access Hold Time (tAHD) during EBI writing is Disabled.
S * |[27:24] |R2R       |Idle Cycle Between Read-To-Read
S * |        |          |This field defines the number of R2R idle cycle.
S * |        |          |R2R idle cycle = (R2R * EBI_MCLK).
S * |        |          |When read action is finish and next action is going to read, R2R idle cycle is inserted and EBI_nCS return to idle state.
S * @var EBI_T::CTL1
S * Offset: 0x10  External Bus Interface Bank1 Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |EN        |EBI Enable Bit
S * |        |          |This bit is the functional enable bit for EBI.
S * |        |          |0 = EBI function Disabled.
S * |        |          |1 = EBI function Enabled.
S * |[1]     |DW16      |EBI Data Width 16-Bit Select
S * |        |          |This bit defines if the EBI data width is 8-bit or 16-bit.
S * |        |          |0 = EBI data width is 8-bit.
S * |        |          |1 = EBI data width is 16-bit.
S * |[2]     |CSPOLINV  |Chip Select Pin Polar Inverse
S * |        |          |This bit defines the active level of EBI chip select pin (EBI_nCS).
S * |        |          |0 = Chip select pin (EBI_nCS) is active low.
S * |        |          |1 = Chip select pin (EBI_nCS) is active high.
S * |[10:8]  |MCLKDIV   |External Output Clock Divider
S * |        |          |The frequency of EBI output clock (MCLK) is controlled by MCLKDIV as follow:
S * |        |          |000 = HCLK/1.
S * |        |          |001 = HCLK/2.
S * |        |          |010 = HCLK/4.
S * |        |          |011 = HCLK/8.
S * |        |          |100 = HCLK/16.
S * |        |          |101 = HCLK/32.
S * |        |          |110 = Reserved.
S * |        |          |111 = Reserved.
S * |[18:16] |TALE      |Extend Time Of ALE
S * |        |          |The EBI_ALE high pulse period (tALE) to latch the address can be controlled by TALE.
S * |        |          |tALE = (TALE+1)*EBI_MCLK.
S * |        |          |Note: This field only available in EBI_CTL0 register
S * |[24]    |WBUFEN    |EBI Write Buffer Enable Bit
S * |        |          |0 = EBI write buffer Disabled.
S * |        |          |1 = EBI write buffer Enabled.
S * |        |          |Note: This bit only available in EBI_CTL0 register
S * @var EBI_T::TCTL1
S * Offset: 0x14  External Bus Interface Bank1 Timing Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:3]   |TACC      |EBI Data Access Time
S * |        |          |TACC define data access time (tACC).
S * |        |          |tACC = (TACC +1) * EBI_MCLK.
S * |[10:8]  |TAHD      |EBI Data Access Hold Time
S * |        |          |TAHD define data access hold time (tAHD).
S * |        |          |tAHD = (TAHD +1) * EBI_MCLK.
S * |[15:12] |W2X       |Idle Cycle After Write
S * |        |          |This field defines the number of W2X idle cycle.
S * |        |          |W2X idle cycle = (W2X * EBI_MCLK).
S * |        |          |When write action is finish, W2X idle cycle is inserted and EBI_nCS return to idle state.
S * |[22]    |RAHDOFF   |Access Hold Time Disable Control When Read
S * |        |          |0 = The Data Access Hold Time (tAHD) during EBI reading is Enabled.
S * |        |          |1 = The Data Access Hold Time (tAHD) during EBI reading is Disabled.
S * |[23]    |WAHDOFF   |Access Hold Time Disable Control When Write
S * |        |          |0 = The Data Access Hold Time (tAHD) during EBI writing is Enabled.
S * |        |          |1 = The Data Access Hold Time (tAHD) during EBI writing is Disabled.
S * |[27:24] |R2R       |Idle Cycle Between Read-To-Read
S * |        |          |This field defines the number of R2R idle cycle.
S * |        |          |R2R idle cycle = (R2R * EBI_MCLK).
S * |        |          |When read action is finish and next action is going to read, R2R idle cycle is inserted and EBI_nCS return to idle state.
S */
S
S    __IO uint32_t CTL0;          /* Offset: 0x00  External Bus Interface Bank0 Control Register                      */
S    __IO uint32_t TCTL0;         /* Offset: 0x04  External Bus Interface Bank0 Timing Control Register               */
S    __I  uint32_t RESERVE0[2];  
S    __IO uint32_t CTL1;          /* Offset: 0x10  External Bus Interface Bank1 Control Register                      */
S    __IO uint32_t TCTL1;         /* Offset: 0x14  External Bus Interface Bank1 Timing Control Register               */
S
S} EBI_T;
S
S
S
S/**
S    @addtogroup EBI_CONST EBI Bit Field Definition
S    Constant Definitions for EBI Controller
S@{ */
S
S#define EBI_CTL0_EN_Pos                  (0)                                               /*!< EBI_T::CTL0: EN Position                  */
S#define EBI_CTL0_EN_Msk                  (0x1ul << EBI_CTL0_EN_Pos)                        /*!< EBI_T::CTL0: EN Mask                      */
S
S#define EBI_CTL0_DW16_Pos                (1)                                               /*!< EBI_T::CTL0: DW16 Position                */
S#define EBI_CTL0_DW16_Msk                (0x1ul << EBI_CTL0_DW16_Pos)                      /*!< EBI_T::CTL0: DW16 Mask                    */
S
S#define EBI_CTL0_CSPOLINV_Pos            (2)                                               /*!< EBI_T::CTL0: CSPOLINV Position            */
S#define EBI_CTL0_CSPOLINV_Msk            (0x1ul << EBI_CTL0_CSPOLINV_Pos)                  /*!< EBI_T::CTL0: CSPOLINV Mask                */
S
S#define EBI_CTL0_MCLKDIV_Pos             (8)                                               /*!< EBI_T::CTL0: MCLKDIV Position             */
S#define EBI_CTL0_MCLKDIV_Msk             (0x7ul << EBI_CTL0_MCLKDIV_Pos)                   /*!< EBI_T::CTL0: MCLKDIV Mask                 */
S
S#define EBI_CTL0_TALE_Pos                (16)                                              /*!< EBI_T::CTL0: TALE Position                */
S#define EBI_CTL0_TALE_Msk                (0x7ul << EBI_CTL0_TALE_Pos)                      /*!< EBI_T::CTL0: TALE Mask                    */
S
S#define EBI_CTL0_WBUFEN_Pos              (24)                                              /*!< EBI_T::CTL0: WBUFEN Position              */
S#define EBI_CTL0_WBUFEN_Msk              (0x1ul << EBI_CTL0_WBUFEN_Pos)                    /*!< EBI_T::CTL0: WBUFEN Mask                  */
S
S#define EBI_TCTL0_TACC_Pos               (3)                                               /*!< EBI_T::TCTL0: TACC Position               */
S#define EBI_TCTL0_TACC_Msk               (0x1ful << EBI_TCTL0_TACC_Pos)                    /*!< EBI_T::TCTL0: TACC Mask                   */
S
S#define EBI_TCTL0_TAHD_Pos               (8)                                               /*!< EBI_T::TCTL0: TAHD Position               */
S#define EBI_TCTL0_TAHD_Msk               (0x7ul << EBI_TCTL0_TAHD_Pos)                     /*!< EBI_T::TCTL0: TAHD Mask                   */
S
S#define EBI_TCTL0_W2X_Pos                (12)                                              /*!< EBI_T::TCTL0: W2X Position                */
S#define EBI_TCTL0_W2X_Msk                (0xful << EBI_TCTL0_W2X_Pos)                      /*!< EBI_T::TCTL0: W2X Mask                    */
S
S#define EBI_TCTL0_RAHDOFF_Pos            (22)                                              /*!< EBI_T::TCTL0: RAHDOFF Position            */
S#define EBI_TCTL0_RAHDOFF_Msk            (0x1ul << EBI_TCTL0_RAHDOFF_Pos)                  /*!< EBI_T::TCTL0: RAHDOFF Mask                */
S
S#define EBI_TCTL0_WAHDOFF_Pos            (23)                                              /*!< EBI_T::TCTL0: WAHDOFF Position            */
S#define EBI_TCTL0_WAHDOFF_Msk            (0x1ul << EBI_TCTL0_WAHDOFF_Pos)                  /*!< EBI_T::TCTL0: WAHDOFF Mask                */
S
S#define EBI_TCTL0_R2R_Pos                (24)                                              /*!< EBI_T::TCTL0: R2R Position                */
S#define EBI_TCTL0_R2R_Msk                (0xful << EBI_TCTL0_R2R_Pos)                      /*!< EBI_T::TCTL0: R2R Mask                    */
S
S#define EBI_CTL1_EN_Pos                  (0)                                               /*!< EBI_T::CTL1: EN Position                  */
S#define EBI_CTL1_EN_Msk                  (0x1ul << EBI_CTL1_EN_Pos)                        /*!< EBI_T::CTL1: EN Mask                      */
S
S#define EBI_CTL1_DW16_Pos                (1)                                               /*!< EBI_T::CTL1: DW16 Position                */
S#define EBI_CTL1_DW16_Msk                (0x1ul << EBI_CTL1_DW16_Pos)                      /*!< EBI_T::CTL1: DW16 Mask                    */
S
S#define EBI_CTL1_CSPOLINV_Pos            (2)                                               /*!< EBI_T::CTL1: CSPOLINV Position            */
S#define EBI_CTL1_CSPOLINV_Msk            (0x1ul << EBI_CTL1_CSPOLINV_Pos)                  /*!< EBI_T::CTL1: CSPOLINV Mask                */
S
S#define EBI_CTL1_MCLKDIV_Pos             (8)                                               /*!< EBI_T::CTL1: MCLKDIV Position             */
S#define EBI_CTL1_MCLKDIV_Msk             (0x7ul << EBI_CTL1_MCLKDIV_Pos)                   /*!< EBI_T::CTL1: MCLKDIV Mask                 */
S
S#define EBI_CTL1_TALE_Pos                (16)                                              /*!< EBI_T::CTL1: TALE Position                */
S#define EBI_CTL1_TALE_Msk                (0x7ul << EBI_CTL1_TALE_Pos)                      /*!< EBI_T::CTL1: TALE Mask                    */
S
S#define EBI_CTL1_WBUFEN_Pos              (24)                                              /*!< EBI_T::CTL1: WBUFEN Position              */
S#define EBI_CTL1_WBUFEN_Msk              (0x1ul << EBI_CTL1_WBUFEN_Pos)                    /*!< EBI_T::CTL1: WBUFEN Mask                  */
S
S#define EBI_TCTL1_TACC_Pos               (3)                                               /*!< EBI_T::TCTL1: TACC Position               */
S#define EBI_TCTL1_TACC_Msk               (0x1ful << EBI_TCTL1_TACC_Pos)                    /*!< EBI_T::TCTL1: TACC Mask                   */
S
S#define EBI_TCTL1_TAHD_Pos               (8)                                               /*!< EBI_T::TCTL1: TAHD Position               */
S#define EBI_TCTL1_TAHD_Msk               (0x7ul << EBI_TCTL1_TAHD_Pos)                     /*!< EBI_T::TCTL1: TAHD Mask                   */
S
S#define EBI_TCTL1_W2X_Pos                (12)                                              /*!< EBI_T::TCTL1: W2X Position                */
S#define EBI_TCTL1_W2X_Msk                (0xful << EBI_TCTL1_W2X_Pos)                      /*!< EBI_T::TCTL1: W2X Mask                    */
S
S#define EBI_TCTL1_RAHDOFF_Pos            (22)                                              /*!< EBI_T::TCTL1: RAHDOFF Position            */
S#define EBI_TCTL1_RAHDOFF_Msk            (0x1ul << EBI_TCTL1_RAHDOFF_Pos)                  /*!< EBI_T::TCTL1: RAHDOFF Mask                */
S
S#define EBI_TCTL1_WAHDOFF_Pos            (23)                                              /*!< EBI_T::TCTL1: WAHDOFF Position            */
S#define EBI_TCTL1_WAHDOFF_Msk            (0x1ul << EBI_TCTL1_WAHDOFF_Pos)                  /*!< EBI_T::TCTL1: WAHDOFF Mask                */
S
S#define EBI_TCTL1_R2R_Pos                (24)                                              /*!< EBI_T::TCTL1: R2R Position                */
S#define EBI_TCTL1_R2R_Msk                (0xful << EBI_TCTL1_R2R_Pos)                      /*!< EBI_T::TCTL1: R2R Mask                    */
S
S/**@}*/ /* EBI_CONST */
S/**@}*/ /* end of EBI register group */
S
S
S/*---------------------- Flash Memory Controller -------------------------*/
S/**
S    @addtogroup FMC Flash Memory Controller(FMC)
S    Memory Mapped Structure for FMC Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S
S
S/**
S * @var FMC_T::ISPCTL
S * Offset: 0x00  ISP Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ISPEN     |ISP Enable Bit (Write Protect)
S * |        |          |ISP function enable bit. Set this bit to enable ISP function.
S * |        |          |0 = ISP function Disabled.
S * |        |          |1 = ISP function Enabled.
S * |[1]     |BS        |Boot Select (Write Protect)
S * |        |          |When MBS in CONFIG0 is 1, set/clear this bit to select next booting from LDROM/APROM, respectively.
S * |        |          |This bit also functions as chip booting status flag, which can be used to check where chip booted from.
S * |        |          |This bit is initiated with the inverted value of CBS[1] (CONFIG0[7]) after any reset is happened except CPU reset (CPU is 1) or system reset (SYS) is happened.
S * |        |          |0 = Booting from APROM when MBS (CONFIG0[5]) is 1.
S * |        |          |1 = Booting from LDROM when MBS (CONFIG0[5]) is 1.
S * |[3]     |APUEN     |APROM Update Enable Bit (Write Protect)
S * |        |          |0 = APROM cannot be updated when the chip runs in APROM.
S * |        |          |1 = APROM can be updated when the chip runs in APROM.
S * |[4]     |CFGUEN    |CONFIG Update Enable Bit (Write Protect)
S * |        |          |0 = CONFIG cannot be updated.
S * |        |          |1 = CONFIG can be updated.
S * |[5]     |LDUEN     |LDROM Update Enable Bit (Write Protect)
S * |        |          |LDROM update enable bit.
S * |        |          |0 = LDROM cannot be updated.
S * |        |          |1 = LDROM can be updated.
S * |[6]     |ISPFF     |ISP Fail Flag (Write Protect)
S * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
S * |        |          |This bit needs to be cleared by writing 1 to it.
S * |        |          |(1) APROM writes to itself if APUEN is set to 0.
S * |        |          |(2) LDROM writes to itself if LDUEN is set to 0.
S * |        |          |(3) CONFIG is erased/programmed if CFGUEN is set to 0.
S * |        |          |(4) SPROM is erased/programmed if SPUEN is set to 0
S * |        |          |(5) SPROM is programmed at SPROM secured mode.
S * |        |          |(6) Page Erase command at LOCK mode with ICE connection
S * |        |          |(7) Erase or Program command at brown-out detected
S * |        |          |(8) Destination address is illegal, such as over an available range.
S * |        |          |(9) Invalid ISP commands
S * |[16]    |BL        |Boot Loader Booting (Write Protect)
S * |        |          |This bit is initiated with the inverted value of MBS (CONFIG0[5]).
S * |        |          |Any reset, except CPU reset (CPU is 1) or system reset (SYS), BL will be reloaded.
S * |        |          |This bit is used to check chip boot from Boot Loader or not.
S * |        |          |User should keep original value of this bit when updating FMC_ISPCTL register.
S * |        |          |0 = Booting from APROM or LDROM.
S * |        |          |1 = Booting from Boot Loader.
S * @var FMC_T::ISPADDR
S * Offset: 0x04  ISP Address Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |ISPADDR   |ISP Address
S * |        |          |The NuMicro M451 series is equipped with embedded flash.
S * |        |          |ISPADDR[1:0] must be kept 00 for ISP 32-bit operation.
S * |        |          |ISPADDR[2:0] must be kept 000 for ISP 64-bit operation.
S * |        |          |For Checksum Calculation command, this field is the flash starting address for checksum calculation, 2 Kbytes alignment is necessary for checksum calculation.
S * @var FMC_T::ISPDAT
S * Offset: 0x08  ISP Data Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |ISPDAT    |ISP Data
S * |        |          |Write data to this register before ISP program operation.
S * |        |          |Read data from this register after ISP read operation.
S * |        |          |For Run Checksum Calculation command, ISPDAT is the memory size (byte) and 2 Kbytes alignment.
S * |        |          |For ISP Read Checksum command, ISPDAT is the checksum result.
S * |        |          |If ISPDAT = 0x0000_0000, it means that (1) the checksum calculation is in progress, (2) the memory range for checksum calculation is incorrect, or (3) all of data are 0.
S * @var FMC_T::ISPCMD
S * Offset: 0x0C  ISP CMD Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[6:0]   |CMD       |ISP CMD
S * |        |          |ISP command table is shown below:
S * |        |          |0x00= FLASH Read.
S * |        |          |0x04= Read Unique ID.
S * |        |          |0x0B= Read Company ID.
S * |        |          |0x0C= Read Device ID.
S * |        |          |0x0D= Read Checksum.
S * |        |          |0x21= FLASH 32-bit Program.
S * |        |          |0x22= FLASH Page Erase.
S * |        |          |0x27= FLASH Multi-Word Program.
S * |        |          |0x2D= Run Checksum Calculation.
S * |        |          |0x2E= Vector Remap.
S * |        |          |0x61= FLASH 64-bit Program.
S * |        |          |The other commands are invalid.
S * @var FMC_T::ISPTRG
S * Offset: 0x10  ISP Trigger Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ISPGO     |ISP Start Trigger (Write Protect)
S * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.
S * |        |          |0 = ISP operation is finished.
S * |        |          |1 = ISP is progressed.
S * @var FMC_T::DFBA
S * Offset: 0x14  Data Flash Base Address
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |DFBA      |Data Flash Base Address
S * |        |          |This register indicates Data Flash start address. It is a read only register.
S * |        |          |The Data Flash is shared with APROM. the content of this register is loaded from CONFIG1
S * |        |          |This register is valid when DFEN (CONFIG0[0]) =0 .
S * @var FMC_T::FTCTL
S * Offset: 0x18  Flash Access Time Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[6:4]   |FOM       |Frequency Optimization Mode (Write Protect)
S * |        |          |The NuMicro M451 series support adjustable flash access timing to optimize the flash access cycles in different working frequency.
S * |        |          |001 = Frequency <= 12MHz.
S * |        |          |010 = Frequency <= 36MHz.
S * |        |          |100 = Frequency <= 60MHz.
S * |        |          |Others = Frequency <= 72MHz.
S * @var FMC_T::ISPSTS
S * Offset: 0x40  ISP Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ISPBUSY   |ISP Busy Flag (Read Only)
S * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.
S * |        |          |This bit is the mirror of ISPGO(FMC_ISPTRG[0]).
S * |        |          |0 = ISP operation is finished.
S * |        |          |1 = ISP is progressed.
S * |[2:1]   |CBS       |Boot Selection Of CONFIG (Read Only)
S * |        |          |This bit is initiated with the CBS (CONFIG0[7:6]) after any reset is happened except CPU reset (CPU is 1) or system reset (SYS) is happened.
S * |        |          |The following function is valid when MBS (FMC_ISPSTS[3])= 1.
S * |        |          |00 = LDROM with IAP mode.
S * |        |          |01 = LDROM without IAP mode.
S * |        |          |10 = APROM with IAP mode.
S * |        |          |11 = APROM without IAP mode.
S * |[3]     |MBS       |Boot From Boot Loader Selection Flag (Read Only)
S * |        |          |This bit is initiated with the MBS (CONFIG0[5]) after any reset is happened except CPU reset (CPU is 1) or system reset (SYS) is happened
S * |        |          |0 = Booting from Boot Loader.
S * |        |          |1 = Booting
S * |        |          |from LDROM/APROM.(see CBS bit setting)
S * |[5]     |PGFF      |Flash Program With Fast Verification Flag (Read Only)
S * |        |          |This bit is set if data is mismatched at ISP programming verification.
S * |        |          |This bit is clear by performing ISP flash erase or ISP read CID operation.
S * |        |          |0 = Flash Program is success.
S * |        |          |1 = Flash Program is fail. Program data is different with data in the flash memory
S * |[6]     |ISPFF     |ISP Fail Flag (Write Protect)
S * |        |          |This bit is the mirror of ISPFF (FMC_ISPCTL[6]), it needs to be cleared by writing 1 to FMC_ISPCTL[6] or FMC_ISPSTS[6].
S * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
S * |        |          |(1) APROM writes to itself if APUEN is set to 0.
S * |        |          |(2) LDROM writes to itself if LDUEN is set to 0.
S * |        |          |(3) CONFIG is erased/programmed if CFGUEN is set to 0.
S * |        |          |(4) SPROM is erased/programmed if SPUEN is set to 0
S * |        |          |(5) SPROM is programmed at SPROM secured mode.
S * |        |          |(6) Page Erase command at LOCK mode with ICE connection
S * |        |          |(7) Erase or Program command at brown-out detected
S * |        |          |(8) Destination address is illegal, such as over an available range.
S * |        |          |(9) Invalid ISP commands
S * |[23:9]  |VECMAP    |Vector Page Mapping Address (Read Only)
S * |        |          |All access to 0x0000_0000~0x0000_01FF is remapped to the flash memory address {VECMAP[14:0], 9'h000} ~ {VECMAP[14:0], 9'h1FF}
S * @var FMC_T::MPDAT0
S * Offset: 0x80  ISP Data0 Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |ISPDAT0   |ISP Data 0
S * |        |          |This register is the first 32-bit data for 32-bit/64-bit/multi-word programming, and it is also the mirror of FMC_ISPDAT, both registers keep the same data
S * @var FMC_T::MPDAT1
S * Offset: 0x84  ISP Data1 Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |ISPDAT1   |ISP Data 1
S * |        |          |This register is the second 32-bit data for 64-bit/multi-word programming.
S * @var FMC_T::MPDAT2
S * Offset: 0x88  ISP Data2 Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |ISPDAT2   |ISP Data 2
S * |        |          |This register is the third 32-bit data for multi-word programming.
S * @var FMC_T::MPDAT3
S * Offset: 0x8C  ISP Data3 Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |ISPDAT3   |ISP Data 3
S * |        |          |This register is the fourth 32-bit data for multi-word programming.
S * @var FMC_T::MPSTS
S * Offset: 0xC0  ISP Multi-Program Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |MPBUSY    |ISP Multi-Word Program Busy Flag (Read Only)
S * |        |          |Write 1 to start ISP Multi-Word program operation and this bit will be cleared to 0 by hardware automatically when ISP Multi-Word program operation is finished.
S * |        |          |This bit is the mirror of ISPGO(FMC_ISPTRG[0]).
S * |        |          |0 = ISP Multi-Word program operation is finished.
S * |        |          |1 = ISP Multi-Word program operation
S * |        |          |is progressed.
S * |[1]     |PPGO      |ISP Multi-Program Status (Read Only)
S * |        |          |0 = ISP multi-word program operation is not active.
S * |        |          |1 = ISP multi-word program operation is in progress.
S * |[2]     |ISPFF     |ISP Fail Flag (Read Only)
S * |        |          |This bit is the mirror of ISPFF (FMC_ISPCTL[6]), it needs to be cleared by writing 1 to FMC_ISPCTL[6] or FMC_ISPSTS[6].
S * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
S * |        |          |(1) APROM writes to itself if APUEN is set to 0.
S * |        |          |(2) LDROM writes to itself if LDUEN is set to 0.
S * |        |          |(3) CONFIG is erased/programmed if CFGUEN is set to 0.
S * |        |          |(4) SPROM is erased/programmed if SPUEN is set to 0
S * |        |          |(5) SPROM is programmed at SPROM secured mode.
S * |        |          |(6) Page Erase command at LOCK mode with ICE connection
S * |        |          |(7) Erase or Program command at brown-out detected
S * |        |          |(8) Destination address is illegal, such as over an available range.
S * |        |          |(9) Invalid ISP commands
S * |[4]     |D0        |ISP DATA 0 Flag (Read Only)
S * |        |          |This bit is set when FMC_MPDAT0 is written and auto-clear to 0 when the FMC_MPDAT0 data is programmed to flash complete.
S * |        |          |0 = FMC_MPDAT0 register is empty, or program to flash complete.
S * |        |          |1 = FMC_MPDAT0 register has been written, and not program to flash complete.
S * |[5]     |D1        |ISP DATA 1 Flag (Read Only)
S * |        |          |This bit is set when FMC_MPDAT1 is written and auto-clear to 0 when the FMC_MPDAT1 data is programmed to flash complete.
S * |        |          |0 = FMC_MPDAT1 register is empty, or program to flash complete.
S * |        |          |1 = FMC_MPDAT1 register has been written, and not program to flash complete.
S * |[6]     |D2        |ISP DATA 2 Flag (Read Only)
S * |        |          |This bit is set when FMC_MPDAT2 is written and auto-clear to 0 when the FMC_MPDAT2 data is programmed to flash complete.
S * |        |          |0 = FMC_MPDAT2 register is empty, or program to flash complete.
S * |        |          |1 = FMC_MPDAT2 register has been written, and not program to flash complete.
S * |[7]     |D3        |ISP DATA 3 Flag (Read Only)
S * |        |          |This bit is set when FMC_MPDAT3 is written and auto-clear to 0 when the FMC_MPDAT3 data is programmed to flash complete.
S * |        |          |0 = FMC_MPDAT3 register is empty, or program to flash complete.
S * |        |          |1 = FMC_MPDAT3 register has been written, and not program to flash complete.
S * @var FMC_T::MPADDR
S * Offset: 0xC4  ISP Multi-Program Address Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |MPADDR    |ISP Multi-Word Program Address
S * |        |          |MPADDR is the address of ISP multi-word program operation when ISPGO flag is 1.
S * |        |          |MPADDR will keep the final ISP address when ISP multi-word program is complete.
S    */
S
S    __IO uint32_t ISPCTL;        /* Offset: 0x00  ISP Control Register                                               */
S    __IO uint32_t ISPADDR;       /* Offset: 0x04  ISP Address Register                                               */
S    __IO uint32_t ISPDAT;        /* Offset: 0x08  ISP Data Register                                                  */
S    __IO uint32_t ISPCMD;        /* Offset: 0x0C  ISP CMD Register                                                   */
S    __IO uint32_t ISPTRG;        /* Offset: 0x10  ISP Trigger Control Register                                       */
S    __I  uint32_t DFBA;          /* Offset: 0x14  Data Flash Base Address                                            */
S    __IO uint32_t FTCTL;         /* Offset: 0x18  Flash Access Time Control Register                                 */
S    __I  uint32_t RESERVE0[9];  
S    __I  uint32_t ISPSTS;        /* Offset: 0x40  ISP Status Register                                                */
S    __I  uint32_t RESERVE1[15]; 
S    __IO uint32_t MPDAT0;        /* Offset: 0x80  ISP Data0 Register                                                 */
S    __IO uint32_t MPDAT1;        /* Offset: 0x84  ISP Data1 Register                                                 */
S    __IO uint32_t MPDAT2;        /* Offset: 0x88  ISP Data2 Register                                                 */
S    __IO uint32_t MPDAT3;        /* Offset: 0x8C  ISP Data3 Register                                                 */
S    __I  uint32_t RESERVE2[12]; 
S    __I  uint32_t MPSTS;         /* Offset: 0xC0  ISP Multi-Program Status Register                                  */
S    __I  uint32_t MPADDR;        /* Offset: 0xC4  ISP Multi-Program Address Register                                 */
S
S} FMC_T;
S
S
S
S
S/**
S    @addtogroup FMC_CONST FMC Bit Field Definition
S    Constant Definitions for FMC Controller
S@{ */
S
S#define FMC_ISPCTL_ISPEN_Pos             (0)                                               /*!< FMC_T::ISPCTL: ISPEN Position             */
S#define FMC_ISPCTL_ISPEN_Msk             (0x1ul << FMC_ISPCTL_ISPEN_Pos)                   /*!< FMC_T::ISPCTL: ISPEN Mask                 */
S
S#define FMC_ISPCTL_BS_Pos                (1)                                               /*!< FMC_T::ISPCTL: BS Position                */
S#define FMC_ISPCTL_BS_Msk                (0x1ul << FMC_ISPCTL_BS_Pos)                      /*!< FMC_T::ISPCTL: BS Mask                    */
S
S#define FMC_ISPCTL_APUEN_Pos             (3)                                               /*!< FMC_T::ISPCTL: APUEN Position             */
S#define FMC_ISPCTL_APUEN_Msk             (0x1ul << FMC_ISPCTL_APUEN_Pos)                   /*!< FMC_T::ISPCTL: APUEN Mask                 */
S
S#define FMC_ISPCTL_CFGUEN_Pos            (4)                                               /*!< FMC_T::ISPCTL: CFGUEN Position            */
S#define FMC_ISPCTL_CFGUEN_Msk            (0x1ul << FMC_ISPCTL_CFGUEN_Pos)                  /*!< FMC_T::ISPCTL: CFGUEN Mask                */
S
S#define FMC_ISPCTL_LDUEN_Pos             (5)                                               /*!< FMC_T::ISPCTL: LDUEN Position             */
S#define FMC_ISPCTL_LDUEN_Msk             (0x1ul << FMC_ISPCTL_LDUEN_Pos)                   /*!< FMC_T::ISPCTL: LDUEN Mask                 */
S
S#define FMC_ISPCTL_ISPFF_Pos             (6)                                               /*!< FMC_T::ISPCTL: ISPFF Position             */
S#define FMC_ISPCTL_ISPFF_Msk             (0x1ul << FMC_ISPCTL_ISPFF_Pos)                   /*!< FMC_T::ISPCTL: ISPFF Mask                 */
S
S#define FMC_ISPCTL_BL_Pos                (16)                                              /*!< FMC_T::ISPCTL: BL Position                */
S#define FMC_ISPCTL_BL_Msk                (0x1ul << FMC_ISPCTL_BL_Pos)                      /*!< FMC_T::ISPCTL: BL Mask                    */
S
S#define FMC_ISPADDR_ISPADDR_Pos          (0)                                               /*!< FMC_T::ISPADDR: ISPADDR Position          */
S#define FMC_ISPADDR_ISPADDR_Msk          (0xfffffffful << FMC_ISPADDR_ISPADDR_Pos)         /*!< FMC_T::ISPADDR: ISPADDR Mask              */
S
S#define FMC_ISPDAT_ISPDAT_Pos            (0)                                               /*!< FMC_T::ISPDAT: ISPDAT Position            */
S#define FMC_ISPDAT_ISPDAT_Msk            (0xfffffffful << FMC_ISPDAT_ISPDAT_Pos)           /*!< FMC_T::ISPDAT: ISPDAT Mask                */
S
S#define FMC_ISPCMD_CMD_Pos               (0)                                               /*!< FMC_T::ISPCMD: CMD Position               */
S#define FMC_ISPCMD_CMD_Msk               (0x7ful << FMC_ISPCMD_CMD_Pos)                    /*!< FMC_T::ISPCMD: CMD Mask                   */
S
S#define FMC_ISPTRG_ISPGO_Pos             (0)                                               /*!< FMC_T::ISPTRG: ISPGO Position             */
S#define FMC_ISPTRG_ISPGO_Msk             (0x1ul << FMC_ISPTRG_ISPGO_Pos)                   /*!< FMC_T::ISPTRG: ISPGO Mask                 */
S
S#define FMC_DFBA_DFBA_Pos                (0)                                               /*!< FMC_T::DFBA: DFBA Position                */
S#define FMC_DFBA_DFBA_Msk                (0xfffffffful << FMC_DFBA_DFBA_Pos)               /*!< FMC_T::DFBA: DFBA Mask                    */
S
S#define FMC_FTCTL_FOM_Pos                (4)                                               /*!< FMC_T::FTCTL: FOM Position                */
S#define FMC_FTCTL_FOM_Msk                (0x7ul << FMC_FTCTL_FOM_Pos)                      /*!< FMC_T::FTCTL: FOM Mask                    */
S
S#define FMC_ISPSTS_ISPBUSY_Pos           (0)                                               /*!< FMC_T::ISPSTS: ISPBUSY Position           */
S#define FMC_ISPSTS_ISPBUSY_Msk           (0x1ul << FMC_ISPSTS_ISPBUSY_Pos)                 /*!< FMC_T::ISPSTS: ISPBUSY Mask               */
S
S#define FMC_ISPSTS_CBS_Pos               (1)                                               /*!< FMC_T::ISPSTS: CBS Position               */
S#define FMC_ISPSTS_CBS_Msk               (0x3ul << FMC_ISPSTS_CBS_Pos)                     /*!< FMC_T::ISPSTS: CBS Mask                   */
S
S#define FMC_ISPSTS_MBS_Pos               (3)                                               /*!< FMC_T::ISPSTS: MBS Position               */
S#define FMC_ISPSTS_MBS_Msk               (0x1ul << FMC_ISPSTS_MBS_Pos)                     /*!< FMC_T::ISPSTS: MBS Mask                   */
S
S#define FMC_ISPSTS_PGFF_Pos              (5)                                               /*!< FMC_T::ISPSTS: PGFF Position              */
S#define FMC_ISPSTS_PGFF_Msk              (0x1ul << FMC_ISPSTS_PGFF_Pos)                    /*!< FMC_T::ISPSTS: PGFF Mask                  */
S
S#define FMC_ISPSTS_ISPFF_Pos             (6)                                               /*!< FMC_T::ISPSTS: ISPFF Position             */
S#define FMC_ISPSTS_ISPFF_Msk             (0x1ul << FMC_ISPSTS_ISPFF_Pos)                   /*!< FMC_T::ISPSTS: ISPFF Mask                 */
S
S#define FMC_ISPSTS_VECMAP_Pos            (9)                                               /*!< FMC_T::ISPSTS: VECMAP Position            */
S#define FMC_ISPSTS_VECMAP_Msk            (0x7ffful << FMC_ISPSTS_VECMAP_Pos)               /*!< FMC_T::ISPSTS: VECMAP Mask                */
S
S#define FMC_MPDAT0_ISPDAT0_Pos           (0)                                               /*!< FMC_T::MPDAT0: ISPDAT0 Position           */
S#define FMC_MPDAT0_ISPDAT0_Msk           (0xfffffffful << FMC_MPDAT0_ISPDAT0_Pos)          /*!< FMC_T::MPDAT0: ISPDAT0 Mask               */
S
S#define FMC_MPDAT1_ISPDAT1_Pos           (0)                                               /*!< FMC_T::MPDAT1: ISPDAT1 Position           */
S#define FMC_MPDAT1_ISPDAT1_Msk           (0xfffffffful << FMC_MPDAT1_ISPDAT1_Pos)          /*!< FMC_T::MPDAT1: ISPDAT1 Mask               */
S
S#define FMC_MPDAT2_ISPDAT2_Pos           (0)                                               /*!< FMC_T::MPDAT2: ISPDAT2 Position           */
S#define FMC_MPDAT2_ISPDAT2_Msk           (0xfffffffful << FMC_MPDAT2_ISPDAT2_Pos)          /*!< FMC_T::MPDAT2: ISPDAT2 Mask               */
S
S#define FMC_MPDAT3_ISPDAT3_Pos           (0)                                               /*!< FMC_T::MPDAT3: ISPDAT3 Position           */
S#define FMC_MPDAT3_ISPDAT3_Msk           (0xfffffffful << FMC_MPDAT3_ISPDAT3_Pos)          /*!< FMC_T::MPDAT3: ISPDAT3 Mask               */
S
S#define FMC_MPSTS_MPBUSY_Pos             (0)                                               /*!< FMC_T::MPSTS: MPBUSY Position             */
S#define FMC_MPSTS_MPBUSY_Msk             (0x1ul << FMC_MPSTS_MPBUSY_Pos)                   /*!< FMC_T::MPSTS: MPBUSY Mask                 */
S
S#define FMC_MPSTS_PPGO_Pos               (1)                                               /*!< FMC_T::MPSTS: PPGO Position               */
S#define FMC_MPSTS_PPGO_Msk               (0x1ul << FMC_MPSTS_PPGO_Pos)                     /*!< FMC_T::MPSTS: PPGO Mask                   */
S
S#define FMC_MPSTS_ISPFF_Pos              (2)                                               /*!< FMC_T::MPSTS: ISPFF Position              */
S#define FMC_MPSTS_ISPFF_Msk              (0x1ul << FMC_MPSTS_ISPFF_Pos)                    /*!< FMC_T::MPSTS: ISPFF Mask                  */
S
S#define FMC_MPSTS_D0_Pos                 (4)                                               /*!< FMC_T::MPSTS: D0 Position                 */
S#define FMC_MPSTS_D0_Msk                 (0x1ul << FMC_MPSTS_D0_Pos)                       /*!< FMC_T::MPSTS: D0 Mask                     */
S
S#define FMC_MPSTS_D1_Pos                 (5)                                               /*!< FMC_T::MPSTS: D1 Position                 */
S#define FMC_MPSTS_D1_Msk                 (0x1ul << FMC_MPSTS_D1_Pos)                       /*!< FMC_T::MPSTS: D1 Mask                     */
S
S#define FMC_MPSTS_D2_Pos                 (6)                                               /*!< FMC_T::MPSTS: D2 Position                 */
S#define FMC_MPSTS_D2_Msk                 (0x1ul << FMC_MPSTS_D2_Pos)                       /*!< FMC_T::MPSTS: D2 Mask                     */
S
S#define FMC_MPSTS_D3_Pos                 (7)                                               /*!< FMC_T::MPSTS: D3 Position                 */
S#define FMC_MPSTS_D3_Msk                 (0x1ul << FMC_MPSTS_D3_Pos)                       /*!< FMC_T::MPSTS: D3 Mask                     */
S
S#define FMC_MPADDR_MPADDR_Pos            (0)                                               /*!< FMC_T::MPADDR: MPADDR Position            */
S#define FMC_MPADDR_MPADDR_Msk            (0xfffffffful << FMC_MPADDR_MPADDR_Pos)           /*!< FMC_T::MPADDR: MPADDR Mask                */
S
S/**@}*/ /* FMC_CONST */
S/**@}*/ /* end of FMC register group */
S
S
S/*---------------------- General Purpose Input/Output Controller -------------------------*/
S/**
S    @addtogroup GPIO General Purpose Input/Output Controller(GPIO)
S    Memory Mapped Structure for GPIO Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S
S/**
S * @var GPIO_T::MODE
S * Offset: 0x00/0x40/0x80/0xC0/0x100/0x140  Port A-F I/O Mode Control
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[2n+1:2n]|MODEn    |Port A-F I/O Pin[n] Mode Control
S * |        |          |Determine each I/O mode of Px.n pins.
S * |        |          |00 = Px.n is in Input mode.
S * |        |          |01 = Px.n is in Push-pull Output mode.
S * |        |          |10 = Px.n is in Open-drain Output mode.
S * |        |          |11 = Px.n is in Quasi-bidirectional mode.
S * |        |          |Note1: The initial value of this field is defined by CIOINI (CONFIG0 [10]).
S * |        |          |If CIOINI is set to 0, the default value is 0xFFFF_FFFF and all pins will be quasi-bidirectional mode after chip powered on.
S * |        |          |If CIOINI is set to 1, the default value is 0x0000_0000 and all pins will be
S * |        |          |input mode after chip powered on.
S * |        |          |Note2:
S * |        |          |n=0~15 for port A/B/C/D.
S * |        |          |n=0~14 for port E.
S * |        |          |n=0~7 for port F.
S * @var GPIO_T::DINOFF
S * Offset: 0x04/0x44/0x84/0xC4/0x104/0x144  Port A-F Digital Input Path Disable Control
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[n+16]  |DINOFFn   |Port A-F Pin[n] Digital Input Path Disable Control
S * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled.
S * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
S * |        |          |0 = Px.n digital input path Enabled.
S * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
S * |        |          |Note:
S * |        |          |n=0~15 for port A/B/C/D.
S * |        |          |n=0~14 for port E.
S * |        |          |n=0~7 for port F.
S * @var GPIO_T::DOUT
S * Offset: 0x08/0x48/0x88/0xC8/0x108/0x148  Port A-F Data Output Value
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[n]     |DOUTn     |Port A-F Pin[n] Output Value
S * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
S * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
S * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
S * |        |          |Note:
S * |        |          |n=0~15 for port A/B/C/D.
S * |        |          |n=0~14 for port E.
S * |        |          |n=0~7 for port F.
S * @var GPIO_T::DATMSK
S * Offset: 0x0C/0x4C/0x8C/0xCC/0x10C/0x14C  Port A-F Data Output Write Mask
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[n]     |DMASKn    |Port A-F Pin[n] Data Output Write Mask
S * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit.
S * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected.
S * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
S * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
S * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
S * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
S * |        |          |Note2:
S * |        |          |n=0~15 for port A/B/C/D.
S * |        |          |n=0~14 for port E.
S * |        |          |n=0~7 for port F.
S * @var GPIO_T::PIN
S * Offset: 0x10/0x50/0x90/0xD0/0x110/0x150  Port A-F Pin Value
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[n]     |PINn      |Port A-F Pin[n] Pin Value
S * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin.
S * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
S * |        |          |Note:
S * |        |          |n=0~15 for port A/B/C/D.
S * |        |          |n=0~14 for port E.
S * |        |          |n=0~7 for port F.
S * @var GPIO_T::DBEN
S * Offset: 0x14/0x54/0x94/0xD4/0x114/0x154  Port A-F De-Bounce Enable Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[n]     |DBENn     |Port A-F Pin[n] Input Signal De-Bounce Enable Bit
S * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit.
S * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt.
S * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
S * |        |          |0 = Px.n de-bounce function Disabled.
S * |        |          |1 = Px.n de-bounce function Enabled.
S * |        |          |The de-bounce function is valid only for edge triggered interrupt.
S * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
S * |        |          |Note:
S * |        |          |n=0~15 for port A/B/C/D.
S * |        |          |n=0~14 for port E.
S * |        |          |n=0~7 for port F.
S * @var GPIO_T::INTTYPE
S * Offset: 0x18/0x58/0x98/0xD8/0x118/0x158  Port A-F Interrupt Trigger Type Control
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[n]     |TYPEn     |Port A-F Pin[n] Edge Or Level Detection Interrupt Trigger Type Control
S * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger.
S * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
S * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
S * |        |          |0 = Edge trigger interrupt.
S * |        |          |1 = Level trigger interrupt.
S * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]).
S * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
S * |        |          |The de-bounce function is valid only for edge triggered interrupt.
S * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
S * |        |          |Note:
S * |        |          |n=0~15 for port A/B/C/D.
S * |        |          |n=0~14 for port E.
S * |        |          |n=0~7 for port F.
S * @var GPIO_T::INTEN
S * Offset: 0x1C/0x5C/0x9C/0xDC/0x11C/0x15C  Port A-F Interrupt Enable Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[n]     |FLIENn    |Port A-F Pin[n] Falling Edge or Low Level Interrupt Trigger Type Enable Bit
S * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.
S * |        |          |Set bit to 1 also enable the pin wake-up function.
S * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1 :
S * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
S * |        |          |If the interrupt is edge trigger(TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
S * |        |          |0 = Px.n level low or high to low interrupt Disabled.
S * |        |          |1 = Px.n level low or high to low interrupt Enabled.
S * |        |          |Note:
S * |        |          |n=0~15 for port A/B/C/D.
S * |        |          |n=0~14 for port E.
S * |        |          |n=0~7 for port F.
S * @var GPIO_T::INTSRC
S * Offset: 0x20/0x60/0xA0/0xE0/0x120/0x160  Port A-F Interrupt Source Flag
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[n]     |INTSRCn   |Port A-F Pin[n] Interrupt Source Flag
S * |        |          |Write Operation :
S * |        |          |0 = No action.
S * |        |          |1 = Clear the corresponding pending interrupt.
S * |        |          |Read Operation :
S * |        |          |0 = No interrupt at Px.n.
S * |        |          |1 = Px.n generates an interrupt.
S * |        |          |Note:
S * |        |          |n=0~15 for port A/B/C/D.
S * |        |          |n=0~14 for port E.
S * |        |          |n=0~7 for port F.
S * @var GPIO_T::SMTEN
S * Offset: 0x24/0x64/0xA4/0xE4/0x124/0x164  Port A-F Input Schmitt Trigger Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[n]     |SMTENn    |Port A-F Pin[n] Input Schmitt Trigger Enable Bit
S * |        |          |0 = Px.n input Schmitt trigger function Disabled.
S * |        |          |1 = Px.n input Schmitt trigger function Enabled.
S * |        |          |Note:
S * |        |          |n=0~15 for port A/B/C/D.
S * |        |          |n=0~14 for port E.
S * |        |          |n=0~7 for port F.
S * @var GPIO_T::SLEWCTL
S * Offset: 0x28/0x68/0xA8/0xE8/0x128/0x168  Port A-F High Slew Rate Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[n]     |HSRENn    |Port A-F Pin[n] High Slew Rate Control
S * |        |          |0 = Px.n output with basic slew rate.
S * |        |          |1 = Px.n output with higher slew rate.
S * |        |          |Note:
S * |        |          |n=0~15 for port A/B/C/D.
S * |        |          |n=0~14 for port E.
S * |        |          |n=0~7 for port F.
S * @var GPIO_T::DRVCTL
S * Offset: 0x2C  Port E High Drive Strength Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[n]     |HDRVENn   |Port E Pin[n] Driving Strength Control
S * |        |          |0 = Px.n output with basic driving strength.
S * |        |          |1 = Px.n output with high driving strength.
S * |        |          |Note:
S * |        |          |n=8,9..13 for port E.
S */
S
S    __IO uint32_t MODE;          /* Offset: 0x00/0x40/0x80/0xC0/0x100/0x140  Port A-F I/O Mode Control                       */
S    __IO uint32_t DINOFF;        /* Offset: 0x04/0x44/0x84/0xC4/0x104/0x144  Port A-F Digital Input Path Disable Control     */
S    __IO uint32_t DOUT;          /* Offset: 0x08/0x48/0x88/0xC8/0x108/0x148  Port A-F Data Output Value                      */
S    __IO uint32_t DATMSK;        /* Offset: 0x0C/0x4C/0x8C/0xCC/0x10C/0x14C  Port A-F Data Output Write Mask                 */
S    __I  uint32_t PIN;           /* Offset: 0x10/0x50/0x90/0xD0/0x110/0x150  Port A-F Pin Value                              */
S    __IO uint32_t DBEN;          /* Offset: 0x14/0x54/0x94/0xD4/0x114/0x154  Port A-F De-Bounce Enable Control Register      */
S    __IO uint32_t INTTYPE;       /* Offset: 0x18/0x58/0x98/0xD8/0x118/0x158  Port A-F Interrupt Trigger Type Control         */
S    __IO uint32_t INTEN;         /* Offset: 0x1C/0x5C/0x9C/0xDC/0x11C/0x15C  Port A-F Interrupt Enable Control Register      */
S    __IO uint32_t INTSRC;        /* Offset: 0x20/0x60/0xA0/0xE0/0x120/0x160  Port A-F Interrupt Source Flag                  */
S    __IO uint32_t SMTEN;         /* Offset: 0x24/0x64/0xA4/0xE4/0x124/0x164  Port A-F Input Schmitt Trigger Enable Register  */
S    __IO uint32_t SLEWCTL;       /* Offset: 0x28/0x68/0xA8/0xE8/0x128/0x168  Port A-F High Slew Rate Control Register        */
S    __IO uint32_t DRVCTL;        /* Offset: 0x12C  Port E High Drive Strength Control Register                               */
S
S} GPIO_T;
S
S
S
S
Stypedef struct
S{
S
S
S
S/**
S * @var GPIO_DBCTL_T::DBCTL
S * Offset: 0x440  Interrupt De-bounce Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |DBCLKSEL  |De-Bounce Sampling Cycle Selection
S * |        |          |0000 = Sample interrupt input once per 1 clocks.
S * |        |          |0001 = Sample interrupt input once per 2 clocks.
S * |        |          |0010 = Sample interrupt input once per 4 clocks.
S * |        |          |0011 = Sample interrupt input once per 8 clocks.
S * |        |          |0100 = Sample interrupt input once per 16 clocks.
S * |        |          |0101 = Sample interrupt input once per 32 clocks.
S * |        |          |0110 = Sample interrupt input once per 64 clocks.
S * |        |          |0111 = Sample interrupt input once per 128 clocks.
S * |        |          |1000 = Sample interrupt input once per 256 clocks.
S * |        |          |1001 = Sample interrupt input once per 2*256 clocks.
S * |        |          |1010 = Sample interrupt input once per 4*256 clocks.
S * |        |          |1011 = Sample interrupt input once per 8*256 clocks.
S * |        |          |1100 = Sample interrupt input once per 16*256 clocks.
S * |        |          |1101 = Sample interrupt input once per 32*256 clocks.
S * |        |          |1110 = Sample interrupt input once per 64*256 clocks.
S * |        |          |1111 = Sample interrupt input once per 128*256 clocks.
S * |[4]     |DBCLKSRC  |De-Bounce Counter Clock Source Selection
S * |        |          |0 = De-bounce counter clock source is the HCLK.
S * |        |          |1 = De-bounce counter clock source is the internal 10 kHz internal low speed oscillator.
S * |[5]     |ICLKON    |Interrupt Clock On Mode
S * |        |          |0 = Edge detection circuit is active only if I/O pin corresponding RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]) bit is set to 1.
S * |        |          |1 = All I/O pins edge detection circuit is always active after reset.
S * |        |          |Note: It is recommended to disable this bit to save system power if no special application concern.
S */
S
S    __IO uint32_t DBCTL;         /* Offset: 0x440  Interrupt De-bounce Control Register                              */
S
S} GPIO_DBCTL_T;
S
S
S
S
S/**
S    @addtogroup GPIO_CONST GPIO Bit Field Definition
S    Constant Definitions for GPIO Controller
S@{ */
S
S#define GPIO_MODE_MODE0_Pos              (0)                                               /*!< GPIO_T::MODE: MODE0 Position              */
S#define GPIO_MODE_MODE0_Msk              (0x3ul << GPIO_MODE_MODE0_Pos)                    /*!< GPIO_T::MODE: MODE0 Mask                  */
S
S#define GPIO_MODE_MODE1_Pos              (2)                                               /*!< GPIO_T::MODE: MODE1 Position              */
S#define GPIO_MODE_MODE1_Msk              (0x3ul << GPIO_MODE_MODE1_Pos)                    /*!< GPIO_T::MODE: MODE1 Mask                  */
S
S#define GPIO_MODE_MODE2_Pos              (4)                                               /*!< GPIO_T::MODE: MODE2 Position              */
S#define GPIO_MODE_MODE2_Msk              (0x3ul << GPIO_MODE_MODE2_Pos)                    /*!< GPIO_T::MODE: MODE2 Mask                  */
S
S#define GPIO_MODE_MODE3_Pos              (6)                                               /*!< GPIO_T::MODE: MODE3 Position              */
S#define GPIO_MODE_MODE3_Msk              (0x3ul << GPIO_MODE_MODE3_Pos)                    /*!< GPIO_T::MODE: MODE3 Mask                  */
S
S#define GPIO_MODE_MODE4_Pos              (8)                                               /*!< GPIO_T::MODE: MODE4 Position              */
S#define GPIO_MODE_MODE4_Msk              (0x3ul << GPIO_MODE_MODE4_Pos)                    /*!< GPIO_T::MODE: MODE4 Mask                  */
S
S#define GPIO_MODE_MODE5_Pos              (10)                                              /*!< GPIO_T::MODE: MODE5 Position              */
S#define GPIO_MODE_MODE5_Msk              (0x3ul << GPIO_MODE_MODE5_Pos)                    /*!< GPIO_T::MODE: MODE5 Mask                  */
S
S#define GPIO_MODE_MODE6_Pos              (12)                                              /*!< GPIO_T::MODE: MODE6 Position              */
S#define GPIO_MODE_MODE6_Msk              (0x3ul << GPIO_MODE_MODE6_Pos)                    /*!< GPIO_T::MODE: MODE6 Mask                  */
S
S#define GPIO_MODE_MODE7_Pos              (14)                                              /*!< GPIO_T::MODE: MODE7 Position              */
S#define GPIO_MODE_MODE7_Msk              (0x3ul << GPIO_MODE_MODE7_Pos)                    /*!< GPIO_T::MODE: MODE7 Mask                  */
S
S#define GPIO_MODE_MODE8_Pos              (16)                                              /*!< GPIO_T::MODE: MODE8 Position              */
S#define GPIO_MODE_MODE8_Msk              (0x3ul << GPIO_MODE_MODE8_Pos)                    /*!< GPIO_T::MODE: MODE8 Mask                  */
S
S#define GPIO_MODE_MODE9_Pos              (18)                                              /*!< GPIO_T::MODE: MODE9 Position              */
S#define GPIO_MODE_MODE9_Msk              (0x3ul << GPIO_MODE_MODE9_Pos)                    /*!< GPIO_T::MODE: MODE9 Mask                  */
S
S#define GPIO_MODE_MODE10_Pos             (20)                                              /*!< GPIO_T::MODE: MODE10 Position             */
S#define GPIO_MODE_MODE10_Msk             (0x3ul << GPIO_MODE_MODE10_Pos)                   /*!< GPIO_T::MODE: MODE10 Mask                 */
S
S#define GPIO_MODE_MODE11_Pos             (22)                                              /*!< GPIO_T::MODE: MODE11 Position             */
S#define GPIO_MODE_MODE11_Msk             (0x3ul << GPIO_MODE_MODE11_Pos)                   /*!< GPIO_T::MODE: MODE11 Mask                 */
S
S#define GPIO_MODE_MODE12_Pos             (24)                                              /*!< GPIO_T::MODE: MODE12 Position             */
S#define GPIO_MODE_MODE12_Msk             (0x3ul << GPIO_MODE_MODE12_Pos)                   /*!< GPIO_T::MODE: MODE12 Mask                 */
S
S#define GPIO_MODE_MODE13_Pos             (26)                                              /*!< GPIO_T::MODE: MODE13 Position             */
S#define GPIO_MODE_MODE13_Msk             (0x3ul << GPIO_MODE_MODE13_Pos)                   /*!< GPIO_T::MODE: MODE13 Mask                 */
S
S#define GPIO_MODE_MODE14_Pos             (28)                                              /*!< GPIO_T::MODE: MODE14 Position             */
S#define GPIO_MODE_MODE14_Msk             (0x3ul << GPIO_MODE_MODE14_Pos)                   /*!< GPIO_T::MODE: MODE14 Mask                 */
S
S#define GPIO_MODE_MODE15_Pos             (30)                                              /*!< GPIO_T::MODE: MODE15 Position             */
S#define GPIO_MODE_MODE15_Msk             (0x3ul << GPIO_MODE_MODE15_Pos)                   /*!< GPIO_T::MODE: MODE15 Mask                 */
S
S#define GPIO_DINOFF_DINOFF0_Pos          (16)                                              /*!< GPIO_T::DINOFF: DINOFF0 Position          */
S#define GPIO_DINOFF_DINOFF0_Msk          (0x1ul << GPIO_DINOFF_DINOFF0_Pos)                /*!< GPIO_T::DINOFF: DINOFF0 Mask              */
S
S#define GPIO_DINOFF_DINOFF1_Pos          (17)                                              /*!< GPIO_T::DINOFF: DINOFF1 Position          */
S#define GPIO_DINOFF_DINOFF1_Msk          (0x1ul << GPIO_DINOFF_DINOFF1_Pos)                /*!< GPIO_T::DINOFF: DINOFF1 Mask              */
S
S#define GPIO_DINOFF_DINOFF2_Pos          (18)                                              /*!< GPIO_T::DINOFF: DINOFF2 Position          */
S#define GPIO_DINOFF_DINOFF2_Msk          (0x1ul << GPIO_DINOFF_DINOFF2_Pos)                /*!< GPIO_T::DINOFF: DINOFF2 Mask              */
S
S#define GPIO_DINOFF_DINOFF3_Pos          (19)                                              /*!< GPIO_T::DINOFF: DINOFF3 Position          */
S#define GPIO_DINOFF_DINOFF3_Msk          (0x1ul << GPIO_DINOFF_DINOFF3_Pos)                /*!< GPIO_T::DINOFF: DINOFF3 Mask              */
S
S#define GPIO_DINOFF_DINOFF4_Pos          (20)                                              /*!< GPIO_T::DINOFF: DINOFF4 Position          */
S#define GPIO_DINOFF_DINOFF4_Msk          (0x1ul << GPIO_DINOFF_DINOFF4_Pos)                /*!< GPIO_T::DINOFF: DINOFF4 Mask              */
S
S#define GPIO_DINOFF_DINOFF5_Pos          (21)                                              /*!< GPIO_T::DINOFF: DINOFF5 Position          */
S#define GPIO_DINOFF_DINOFF5_Msk          (0x1ul << GPIO_DINOFF_DINOFF5_Pos)                /*!< GPIO_T::DINOFF: DINOFF5 Mask              */
S
S#define GPIO_DINOFF_DINOFF6_Pos          (22)                                              /*!< GPIO_T::DINOFF: DINOFF6 Position          */
S#define GPIO_DINOFF_DINOFF6_Msk          (0x1ul << GPIO_DINOFF_DINOFF6_Pos)                /*!< GPIO_T::DINOFF: DINOFF6 Mask              */
S
S#define GPIO_DINOFF_DINOFF7_Pos          (23)                                              /*!< GPIO_T::DINOFF: DINOFF7 Position          */
S#define GPIO_DINOFF_DINOFF7_Msk          (0x1ul << GPIO_DINOFF_DINOFF7_Pos)                /*!< GPIO_T::DINOFF: DINOFF7 Mask              */
S
S#define GPIO_DINOFF_DINOFF8_Pos          (24)                                              /*!< GPIO_T::DINOFF: DINOFF8 Position          */
S#define GPIO_DINOFF_DINOFF8_Msk          (0x1ul << GPIO_DINOFF_DINOFF8_Pos)                /*!< GPIO_T::DINOFF: DINOFF8 Mask              */
S
S#define GPIO_DINOFF_DINOFF9_Pos          (25)                                              /*!< GPIO_T::DINOFF: DINOFF9 Position          */
S#define GPIO_DINOFF_DINOFF9_Msk          (0x1ul << GPIO_DINOFF_DINOFF9_Pos)                /*!< GPIO_T::DINOFF: DINOFF9 Mask              */
S
S#define GPIO_DINOFF_DINOFF10_Pos         (26)                                              /*!< GPIO_T::DINOFF: DINOFF10 Position         */
S#define GPIO_DINOFF_DINOFF10_Msk         (0x1ul << GPIO_DINOFF_DINOFF10_Pos)               /*!< GPIO_T::DINOFF: DINOFF10 Mask             */
S
S#define GPIO_DINOFF_DINOFF11_Pos         (27)                                              /*!< GPIO_T::DINOFF: DINOFF11 Position         */
S#define GPIO_DINOFF_DINOFF11_Msk         (0x1ul << GPIO_DINOFF_DINOFF11_Pos)               /*!< GPIO_T::DINOFF: DINOFF11 Mask             */
S
S#define GPIO_DINOFF_DINOFF12_Pos         (28)                                              /*!< GPIO_T::DINOFF: DINOFF12 Position         */
S#define GPIO_DINOFF_DINOFF12_Msk         (0x1ul << GPIO_DINOFF_DINOFF12_Pos)               /*!< GPIO_T::DINOFF: DINOFF12 Mask             */
S
S#define GPIO_DINOFF_DINOFF13_Pos         (29)                                              /*!< GPIO_T::DINOFF: DINOFF13 Position         */
S#define GPIO_DINOFF_DINOFF13_Msk         (0x1ul << GPIO_DINOFF_DINOFF13_Pos)               /*!< GPIO_T::DINOFF: DINOFF13 Mask             */
S
S#define GPIO_DINOFF_DINOFF14_Pos         (30)                                              /*!< GPIO_T::DINOFF: DINOFF14 Position         */
S#define GPIO_DINOFF_DINOFF14_Msk         (0x1ul << GPIO_DINOFF_DINOFF14_Pos)               /*!< GPIO_T::DINOFF: DINOFF14 Mask             */
S
S#define GPIO_DINOFF_DINOFF15_Pos         (31)                                              /*!< GPIO_T::DINOFF: DINOFF15 Position         */
S#define GPIO_DINOFF_DINOFF15_Msk         (0x1ul << GPIO_DINOFF_DINOFF15_Pos)               /*!< GPIO_T::DINOFF: DINOFF15 Mask             */
S
S#define GPIO_DOUT_DOUT0_Pos              (0)                                               /*!< GPIO_T::DOUT: DOUT0 Position              */
S#define GPIO_DOUT_DOUT0_Msk              (0x1ul << GPIO_DOUT_DOUT0_Pos)                    /*!< GPIO_T::DOUT: DOUT0 Mask                  */
S
S#define GPIO_DOUT_DOUT1_Pos              (1)                                               /*!< GPIO_T::DOUT: DOUT1 Position              */
S#define GPIO_DOUT_DOUT1_Msk              (0x1ul << GPIO_DOUT_DOUT1_Pos)                    /*!< GPIO_T::DOUT: DOUT1 Mask                  */
S
S#define GPIO_DOUT_DOUT2_Pos              (2)                                               /*!< GPIO_T::DOUT: DOUT2 Position              */
S#define GPIO_DOUT_DOUT2_Msk              (0x1ul << GPIO_DOUT_DOUT2_Pos)                    /*!< GPIO_T::DOUT: DOUT2 Mask                  */
S
S#define GPIO_DOUT_DOUT3_Pos              (3)                                               /*!< GPIO_T::DOUT: DOUT3 Position              */
S#define GPIO_DOUT_DOUT3_Msk              (0x1ul << GPIO_DOUT_DOUT3_Pos)                    /*!< GPIO_T::DOUT: DOUT3 Mask                  */
S
S#define GPIO_DOUT_DOUT4_Pos              (4)                                               /*!< GPIO_T::DOUT: DOUT4 Position              */
S#define GPIO_DOUT_DOUT4_Msk              (0x1ul << GPIO_DOUT_DOUT4_Pos)                    /*!< GPIO_T::DOUT: DOUT4 Mask                  */
S
S#define GPIO_DOUT_DOUT5_Pos              (5)                                               /*!< GPIO_T::DOUT: DOUT5 Position              */
S#define GPIO_DOUT_DOUT5_Msk              (0x1ul << GPIO_DOUT_DOUT5_Pos)                    /*!< GPIO_T::DOUT: DOUT5 Mask                  */
S
S#define GPIO_DOUT_DOUT6_Pos              (6)                                               /*!< GPIO_T::DOUT: DOUT6 Position              */
S#define GPIO_DOUT_DOUT6_Msk              (0x1ul << GPIO_DOUT_DOUT6_Pos)                    /*!< GPIO_T::DOUT: DOUT6 Mask                  */
S
S#define GPIO_DOUT_DOUT7_Pos              (7)                                               /*!< GPIO_T::DOUT: DOUT7 Position              */
S#define GPIO_DOUT_DOUT7_Msk              (0x1ul << GPIO_DOUT_DOUT7_Pos)                    /*!< GPIO_T::DOUT: DOUT7 Mask                  */
S
S#define GPIO_DOUT_DOUT8_Pos              (8)                                               /*!< GPIO_T::DOUT: DOUT8 Position              */
S#define GPIO_DOUT_DOUT8_Msk              (0x1ul << GPIO_DOUT_DOUT8_Pos)                    /*!< GPIO_T::DOUT: DOUT8 Mask                  */
S
S#define GPIO_DOUT_DOUT9_Pos              (9)                                               /*!< GPIO_T::DOUT: DOUT9 Position              */
S#define GPIO_DOUT_DOUT9_Msk              (0x1ul << GPIO_DOUT_DOUT9_Pos)                    /*!< GPIO_T::DOUT: DOUT9 Mask                  */
S
S#define GPIO_DOUT_DOUT10_Pos             (10)                                              /*!< GPIO_T::DOUT: DOUT10 Position             */
S#define GPIO_DOUT_DOUT10_Msk             (0x1ul << GPIO_DOUT_DOUT10_Pos)                   /*!< GPIO_T::DOUT: DOUT10 Mask                 */
S
S#define GPIO_DOUT_DOUT11_Pos             (11)                                              /*!< GPIO_T::DOUT: DOUT11 Position             */
S#define GPIO_DOUT_DOUT11_Msk             (0x1ul << GPIO_DOUT_DOUT11_Pos)                   /*!< GPIO_T::DOUT: DOUT11 Mask                 */
S
S#define GPIO_DOUT_DOUT12_Pos             (12)                                              /*!< GPIO_T::DOUT: DOUT12 Position             */
S#define GPIO_DOUT_DOUT12_Msk             (0x1ul << GPIO_DOUT_DOUT12_Pos)                   /*!< GPIO_T::DOUT: DOUT12 Mask                 */
S
S#define GPIO_DOUT_DOUT13_Pos             (13)                                              /*!< GPIO_T::DOUT: DOUT13 Position             */
S#define GPIO_DOUT_DOUT13_Msk             (0x1ul << GPIO_DOUT_DOUT13_Pos)                   /*!< GPIO_T::DOUT: DOUT13 Mask                 */
S
S#define GPIO_DOUT_DOUT14_Pos             (14)                                              /*!< GPIO_T::DOUT: DOUT14 Position             */
S#define GPIO_DOUT_DOUT14_Msk             (0x1ul << GPIO_DOUT_DOUT14_Pos)                   /*!< GPIO_T::DOUT: DOUT14 Mask                 */
S
S#define GPIO_DOUT_DOUT15_Pos             (15)                                              /*!< GPIO_T::DOUT: DOUT15 Position             */
S#define GPIO_DOUT_DOUT15_Msk             (0x1ul << GPIO_DOUT_DOUT15_Pos)                   /*!< GPIO_T::DOUT: DOUT15 Mask                 */
S
S#define GPIO_DATMSK_DMASK0_Pos           (0)                                               /*!< GPIO_T::DATMSK: DMASK0 Position           */
S#define GPIO_DATMSK_DMASK0_Msk           (0x1ul << GPIO_DATMSK_DMASK0_Pos)                 /*!< GPIO_T::DATMSK: DMASK0 Mask               */
S
S#define GPIO_DATMSK_DMASK1_Pos           (1)                                               /*!< GPIO_T::DATMSK: DMASK1 Position           */
S#define GPIO_DATMSK_DMASK1_Msk           (0x1ul << GPIO_DATMSK_DMASK1_Pos)                 /*!< GPIO_T::DATMSK: DMASK1 Mask               */
S
S#define GPIO_DATMSK_DMASK2_Pos           (2)                                               /*!< GPIO_T::DATMSK: DMASK2 Position           */
S#define GPIO_DATMSK_DMASK2_Msk           (0x1ul << GPIO_DATMSK_DMASK2_Pos)                 /*!< GPIO_T::DATMSK: DMASK2 Mask               */
S
S#define GPIO_DATMSK_DMASK3_Pos           (3)                                               /*!< GPIO_T::DATMSK: DMASK3 Position           */
S#define GPIO_DATMSK_DMASK3_Msk           (0x1ul << GPIO_DATMSK_DMASK3_Pos)                 /*!< GPIO_T::DATMSK: DMASK3 Mask               */
S
S#define GPIO_DATMSK_DMASK4_Pos           (4)                                               /*!< GPIO_T::DATMSK: DMASK4 Position           */
S#define GPIO_DATMSK_DMASK4_Msk           (0x1ul << GPIO_DATMSK_DMASK4_Pos)                 /*!< GPIO_T::DATMSK: DMASK4 Mask               */
S
S#define GPIO_DATMSK_DMASK5_Pos           (5)                                               /*!< GPIO_T::DATMSK: DMASK5 Position           */
S#define GPIO_DATMSK_DMASK5_Msk           (0x1ul << GPIO_DATMSK_DMASK5_Pos)                 /*!< GPIO_T::DATMSK: DMASK5 Mask               */
S
S#define GPIO_DATMSK_DMASK6_Pos           (6)                                               /*!< GPIO_T::DATMSK: DMASK6 Position           */
S#define GPIO_DATMSK_DMASK6_Msk           (0x1ul << GPIO_DATMSK_DMASK6_Pos)                 /*!< GPIO_T::DATMSK: DMASK6 Mask               */
S
S#define GPIO_DATMSK_DMASK7_Pos           (7)                                               /*!< GPIO_T::DATMSK: DMASK7 Position           */
S#define GPIO_DATMSK_DMASK7_Msk           (0x1ul << GPIO_DATMSK_DMASK7_Pos)                 /*!< GPIO_T::DATMSK: DMASK7 Mask               */
S
S#define GPIO_DATMSK_DMASK8_Pos           (8)                                               /*!< GPIO_T::DATMSK: DMASK8 Position           */
S#define GPIO_DATMSK_DMASK8_Msk           (0x1ul << GPIO_DATMSK_DMASK8_Pos)                 /*!< GPIO_T::DATMSK: DMASK8 Mask               */
S
S#define GPIO_DATMSK_DMASK9_Pos           (9)                                               /*!< GPIO_T::DATMSK: DMASK9 Position           */
S#define GPIO_DATMSK_DMASK9_Msk           (0x1ul << GPIO_DATMSK_DMASK9_Pos)                 /*!< GPIO_T::DATMSK: DMASK9 Mask               */
S
S#define GPIO_DATMSK_DMASK10_Pos          (10)                                              /*!< GPIO_T::DATMSK: DMASK10 Position          */
S#define GPIO_DATMSK_DMASK10_Msk          (0x1ul << GPIO_DATMSK_DMASK10_Pos)                /*!< GPIO_T::DATMSK: DMASK10 Mask              */
S
S#define GPIO_DATMSK_DMASK11_Pos          (11)                                              /*!< GPIO_T::DATMSK: DMASK11 Position          */
S#define GPIO_DATMSK_DMASK11_Msk          (0x1ul << GPIO_DATMSK_DMASK11_Pos)                /*!< GPIO_T::DATMSK: DMASK11 Mask              */
S
S#define GPIO_DATMSK_DMASK12_Pos          (12)                                              /*!< GPIO_T::DATMSK: DMASK12 Position          */
S#define GPIO_DATMSK_DMASK12_Msk          (0x1ul << GPIO_DATMSK_DMASK12_Pos)                /*!< GPIO_T::DATMSK: DMASK12 Mask              */
S
S#define GPIO_DATMSK_DMASK13_Pos          (13)                                              /*!< GPIO_T::DATMSK: DMASK13 Position          */
S#define GPIO_DATMSK_DMASK13_Msk          (0x1ul << GPIO_DATMSK_DMASK13_Pos)                /*!< GPIO_T::DATMSK: DMASK13 Mask              */
S
S#define GPIO_DATMSK_DMASK14_Pos          (14)                                              /*!< GPIO_T::DATMSK: DMASK14 Position          */
S#define GPIO_DATMSK_DMASK14_Msk          (0x1ul << GPIO_DATMSK_DMASK14_Pos)                /*!< GPIO_T::DATMSK: DMASK14 Mask              */
S
S#define GPIO_DATMSK_DMASK15_Pos          (15)                                              /*!< GPIO_T::DATMSK: DMASK15 Position          */
S#define GPIO_DATMSK_DMASK15_Msk          (0x1ul << GPIO_DATMSK_DMASK15_Pos)                /*!< GPIO_T::DATMSK: DMASK15 Mask              */
S
S#define GPIO_PIN_PIN0_Pos                (0)                                               /*!< GPIO_T::PIN: PIN0 Position                */
S#define GPIO_PIN_PIN0_Msk                (0x1ul << GPIO_PIN_PIN0_Pos)                      /*!< GPIO_T::PIN: PIN0 Mask                    */
S
S#define GPIO_PIN_PIN1_Pos                (1)                                               /*!< GPIO_T::PIN: PIN1 Position                */
S#define GPIO_PIN_PIN1_Msk                (0x1ul << GPIO_PIN_PIN1_Pos)                      /*!< GPIO_T::PIN: PIN1 Mask                    */
S
S#define GPIO_PIN_PIN2_Pos                (2)                                               /*!< GPIO_T::PIN: PIN2 Position                */
S#define GPIO_PIN_PIN2_Msk                (0x1ul << GPIO_PIN_PIN2_Pos)                      /*!< GPIO_T::PIN: PIN2 Mask                    */
S
S#define GPIO_PIN_PIN3_Pos                (3)                                               /*!< GPIO_T::PIN: PIN3 Position                */
S#define GPIO_PIN_PIN3_Msk                (0x1ul << GPIO_PIN_PIN3_Pos)                      /*!< GPIO_T::PIN: PIN3 Mask                    */
S
S#define GPIO_PIN_PIN4_Pos                (4)                                               /*!< GPIO_T::PIN: PIN4 Position                */
S#define GPIO_PIN_PIN4_Msk                (0x1ul << GPIO_PIN_PIN4_Pos)                      /*!< GPIO_T::PIN: PIN4 Mask                    */
S
S#define GPIO_PIN_PIN5_Pos                (5)                                               /*!< GPIO_T::PIN: PIN5 Position                */
S#define GPIO_PIN_PIN5_Msk                (0x1ul << GPIO_PIN_PIN5_Pos)                      /*!< GPIO_T::PIN: PIN5 Mask                    */
S
S#define GPIO_PIN_PIN6_Pos                (6)                                               /*!< GPIO_T::PIN: PIN6 Position                */
S#define GPIO_PIN_PIN6_Msk                (0x1ul << GPIO_PIN_PIN6_Pos)                      /*!< GPIO_T::PIN: PIN6 Mask                    */
S
S#define GPIO_PIN_PIN7_Pos                (7)                                               /*!< GPIO_T::PIN: PIN7 Position                */
S#define GPIO_PIN_PIN7_Msk                (0x1ul << GPIO_PIN_PIN7_Pos)                      /*!< GPIO_T::PIN: PIN7 Mask                    */
S
S#define GPIO_PIN_PIN8_Pos                (8)                                               /*!< GPIO_T::PIN: PIN8 Position                */
S#define GPIO_PIN_PIN8_Msk                (0x1ul << GPIO_PIN_PIN8_Pos)                      /*!< GPIO_T::PIN: PIN8 Mask                    */
S
S#define GPIO_PIN_PIN9_Pos                (9)                                               /*!< GPIO_T::PIN: PIN9 Position                */
S#define GPIO_PIN_PIN9_Msk                (0x1ul << GPIO_PIN_PIN9_Pos)                      /*!< GPIO_T::PIN: PIN9 Mask                    */
S
S#define GPIO_PIN_PIN10_Pos               (10)                                              /*!< GPIO_T::PIN: PIN10 Position               */
S#define GPIO_PIN_PIN10_Msk               (0x1ul << GPIO_PIN_PIN10_Pos)                     /*!< GPIO_T::PIN: PIN10 Mask                   */
S
S#define GPIO_PIN_PIN11_Pos               (11)                                              /*!< GPIO_T::PIN: PIN11 Position               */
S#define GPIO_PIN_PIN11_Msk               (0x1ul << GPIO_PIN_PIN11_Pos)                     /*!< GPIO_T::PIN: PIN11 Mask                   */
S
S#define GPIO_PIN_PIN12_Pos               (12)                                              /*!< GPIO_T::PIN: PIN12 Position               */
S#define GPIO_PIN_PIN12_Msk               (0x1ul << GPIO_PIN_PIN12_Pos)                     /*!< GPIO_T::PIN: PIN12 Mask                   */
S
S#define GPIO_PIN_PIN13_Pos               (13)                                              /*!< GPIO_T::PIN: PIN13 Position               */
S#define GPIO_PIN_PIN13_Msk               (0x1ul << GPIO_PIN_PIN13_Pos)                     /*!< GPIO_T::PIN: PIN13 Mask                   */
S
S#define GPIO_PIN_PIN14_Pos               (14)                                              /*!< GPIO_T::PIN: PIN14 Position               */
S#define GPIO_PIN_PIN14_Msk               (0x1ul << GPIO_PIN_PIN14_Pos)                     /*!< GPIO_T::PIN: PIN14 Mask                   */
S
S#define GPIO_PIN_PIN15_Pos               (15)                                              /*!< GPIO_T::PIN: PIN15 Position               */
S#define GPIO_PIN_PIN15_Msk               (0x1ul << GPIO_PIN_PIN15_Pos)                     /*!< GPIO_T::PIN: PIN15 Mask                   */
S
S#define GPIO_DBEN_DBEN0_Pos              (0)                                               /*!< GPIO_T::DBEN: DBEN0 Position              */
S#define GPIO_DBEN_DBEN0_Msk              (0x1ul << GPIO_DBEN_DBEN0_Pos)                    /*!< GPIO_T::DBEN: DBEN0 Mask                  */
S
S#define GPIO_DBEN_DBEN1_Pos              (1)                                               /*!< GPIO_T::DBEN: DBEN1 Position              */
S#define GPIO_DBEN_DBEN1_Msk              (0x1ul << GPIO_DBEN_DBEN1_Pos)                    /*!< GPIO_T::DBEN: DBEN1 Mask                  */
S
S#define GPIO_DBEN_DBEN2_Pos              (2)                                               /*!< GPIO_T::DBEN: DBEN2 Position              */
S#define GPIO_DBEN_DBEN2_Msk              (0x1ul << GPIO_DBEN_DBEN2_Pos)                    /*!< GPIO_T::DBEN: DBEN2 Mask                  */
S
S#define GPIO_DBEN_DBEN3_Pos              (3)                                               /*!< GPIO_T::DBEN: DBEN3 Position              */
S#define GPIO_DBEN_DBEN3_Msk              (0x1ul << GPIO_DBEN_DBEN3_Pos)                    /*!< GPIO_T::DBEN: DBEN3 Mask                  */
S
S#define GPIO_DBEN_DBEN4_Pos              (4)                                               /*!< GPIO_T::DBEN: DBEN4 Position              */
S#define GPIO_DBEN_DBEN4_Msk              (0x1ul << GPIO_DBEN_DBEN4_Pos)                    /*!< GPIO_T::DBEN: DBEN4 Mask                  */
S
S#define GPIO_DBEN_DBEN5_Pos              (5)                                               /*!< GPIO_T::DBEN: DBEN5 Position              */
S#define GPIO_DBEN_DBEN5_Msk              (0x1ul << GPIO_DBEN_DBEN5_Pos)                    /*!< GPIO_T::DBEN: DBEN5 Mask                  */
S
S#define GPIO_DBEN_DBEN6_Pos              (6)                                               /*!< GPIO_T::DBEN: DBEN6 Position              */
S#define GPIO_DBEN_DBEN6_Msk              (0x1ul << GPIO_DBEN_DBEN6_Pos)                    /*!< GPIO_T::DBEN: DBEN6 Mask                  */
S
S#define GPIO_DBEN_DBEN7_Pos              (7)                                               /*!< GPIO_T::DBEN: DBEN7 Position              */
S#define GPIO_DBEN_DBEN7_Msk              (0x1ul << GPIO_DBEN_DBEN7_Pos)                    /*!< GPIO_T::DBEN: DBEN7 Mask                  */
S
S#define GPIO_DBEN_DBEN8_Pos              (8)                                               /*!< GPIO_T::DBEN: DBEN8 Position              */
S#define GPIO_DBEN_DBEN8_Msk              (0x1ul << GPIO_DBEN_DBEN8_Pos)                    /*!< GPIO_T::DBEN: DBEN8 Mask                  */
S
S#define GPIO_DBEN_DBEN9_Pos              (9)                                               /*!< GPIO_T::DBEN: DBEN9 Position              */
S#define GPIO_DBEN_DBEN9_Msk              (0x1ul << GPIO_DBEN_DBEN9_Pos)                    /*!< GPIO_T::DBEN: DBEN9 Mask                  */
S
S#define GPIO_DBEN_DBEN10_Pos             (10)                                              /*!< GPIO_T::DBEN: DBEN10 Position             */
S#define GPIO_DBEN_DBEN10_Msk             (0x1ul << GPIO_DBEN_DBEN10_Pos)                   /*!< GPIO_T::DBEN: DBEN10 Mask                 */
S
S#define GPIO_DBEN_DBEN11_Pos             (11)                                              /*!< GPIO_T::DBEN: DBEN11 Position             */
S#define GPIO_DBEN_DBEN11_Msk             (0x1ul << GPIO_DBEN_DBEN11_Pos)                   /*!< GPIO_T::DBEN: DBEN11 Mask                 */
S
S#define GPIO_DBEN_DBEN12_Pos             (12)                                              /*!< GPIO_T::DBEN: DBEN12 Position             */
S#define GPIO_DBEN_DBEN12_Msk             (0x1ul << GPIO_DBEN_DBEN12_Pos)                   /*!< GPIO_T::DBEN: DBEN12 Mask                 */
S
S#define GPIO_DBEN_DBEN13_Pos             (13)                                              /*!< GPIO_T::DBEN: DBEN13 Position             */
S#define GPIO_DBEN_DBEN13_Msk             (0x1ul << GPIO_DBEN_DBEN13_Pos)                   /*!< GPIO_T::DBEN: DBEN13 Mask                 */
S
S#define GPIO_DBEN_DBEN14_Pos             (14)                                              /*!< GPIO_T::DBEN: DBEN14 Position             */
S#define GPIO_DBEN_DBEN14_Msk             (0x1ul << GPIO_DBEN_DBEN14_Pos)                   /*!< GPIO_T::DBEN: DBEN14 Mask                 */
S
S#define GPIO_DBEN_DBEN15_Pos             (15)                                              /*!< GPIO_T::DBEN: DBEN15 Position             */
S#define GPIO_DBEN_DBEN15_Msk             (0x1ul << GPIO_DBEN_DBEN15_Pos)                   /*!< GPIO_T::DBEN: DBEN15 Mask                 */
S
S#define GPIO_INTTYPE_TYPE0_Pos           (0)                                               /*!< GPIO_T::INTTYPE: TYPE0 Position           */
S#define GPIO_INTTYPE_TYPE0_Msk           (0x1ul << GPIO_INTTYPE_TYPE0_Pos)                 /*!< GPIO_T::INTTYPE: TYPE0 Mask               */
S
S#define GPIO_INTTYPE_TYPE1_Pos           (1)                                               /*!< GPIO_T::INTTYPE: TYPE1 Position           */
S#define GPIO_INTTYPE_TYPE1_Msk           (0x1ul << GPIO_INTTYPE_TYPE1_Pos)                 /*!< GPIO_T::INTTYPE: TYPE1 Mask               */
S
S#define GPIO_INTTYPE_TYPE2_Pos           (2)                                               /*!< GPIO_T::INTTYPE: TYPE2 Position           */
S#define GPIO_INTTYPE_TYPE2_Msk           (0x1ul << GPIO_INTTYPE_TYPE2_Pos)                 /*!< GPIO_T::INTTYPE: TYPE2 Mask               */
S
S#define GPIO_INTTYPE_TYPE3_Pos           (3)                                               /*!< GPIO_T::INTTYPE: TYPE3 Position           */
S#define GPIO_INTTYPE_TYPE3_Msk           (0x1ul << GPIO_INTTYPE_TYPE3_Pos)                 /*!< GPIO_T::INTTYPE: TYPE3 Mask               */
S
S#define GPIO_INTTYPE_TYPE4_Pos           (4)                                               /*!< GPIO_T::INTTYPE: TYPE4 Position           */
S#define GPIO_INTTYPE_TYPE4_Msk           (0x1ul << GPIO_INTTYPE_TYPE4_Pos)                 /*!< GPIO_T::INTTYPE: TYPE4 Mask               */
S
S#define GPIO_INTTYPE_TYPE5_Pos           (5)                                               /*!< GPIO_T::INTTYPE: TYPE5 Position           */
S#define GPIO_INTTYPE_TYPE5_Msk           (0x1ul << GPIO_INTTYPE_TYPE5_Pos)                 /*!< GPIO_T::INTTYPE: TYPE5 Mask               */
S
S#define GPIO_INTTYPE_TYPE6_Pos           (6)                                               /*!< GPIO_T::INTTYPE: TYPE6 Position           */
S#define GPIO_INTTYPE_TYPE6_Msk           (0x1ul << GPIO_INTTYPE_TYPE6_Pos)                 /*!< GPIO_T::INTTYPE: TYPE6 Mask               */
S
S#define GPIO_INTTYPE_TYPE7_Pos           (7)                                               /*!< GPIO_T::INTTYPE: TYPE7 Position           */
S#define GPIO_INTTYPE_TYPE7_Msk           (0x1ul << GPIO_INTTYPE_TYPE7_Pos)                 /*!< GPIO_T::INTTYPE: TYPE7 Mask               */
S
S#define GPIO_INTTYPE_TYPE8_Pos           (8)                                               /*!< GPIO_T::INTTYPE: TYPE8 Position           */
S#define GPIO_INTTYPE_TYPE8_Msk           (0x1ul << GPIO_INTTYPE_TYPE8_Pos)                 /*!< GPIO_T::INTTYPE: TYPE8 Mask               */
S
S#define GPIO_INTTYPE_TYPE9_Pos           (9)                                               /*!< GPIO_T::INTTYPE: TYPE9 Position           */
S#define GPIO_INTTYPE_TYPE9_Msk           (0x1ul << GPIO_INTTYPE_TYPE9_Pos)                 /*!< GPIO_T::INTTYPE: TYPE9 Mask               */
S
S#define GPIO_INTTYPE_TYPE10_Pos          (10)                                              /*!< GPIO_T::INTTYPE: TYPE10 Position          */
S#define GPIO_INTTYPE_TYPE10_Msk          (0x1ul << GPIO_INTTYPE_TYPE10_Pos)                /*!< GPIO_T::INTTYPE: TYPE10 Mask              */
S
S#define GPIO_INTTYPE_TYPE11_Pos          (11)                                              /*!< GPIO_T::INTTYPE: TYPE11 Position          */
S#define GPIO_INTTYPE_TYPE11_Msk          (0x1ul << GPIO_INTTYPE_TYPE11_Pos)                /*!< GPIO_T::INTTYPE: TYPE11 Mask              */
S
S#define GPIO_INTTYPE_TYPE12_Pos          (12)                                              /*!< GPIO_T::INTTYPE: TYPE12 Position          */
S#define GPIO_INTTYPE_TYPE12_Msk          (0x1ul << GPIO_INTTYPE_TYPE12_Pos)                /*!< GPIO_T::INTTYPE: TYPE12 Mask              */
S
S#define GPIO_INTTYPE_TYPE13_Pos          (13)                                              /*!< GPIO_T::INTTYPE: TYPE13 Position          */
S#define GPIO_INTTYPE_TYPE13_Msk          (0x1ul << GPIO_INTTYPE_TYPE13_Pos)                /*!< GPIO_T::INTTYPE: TYPE13 Mask              */
S
S#define GPIO_INTTYPE_TYPE14_Pos          (14)                                              /*!< GPIO_T::INTTYPE: TYPE14 Position          */
S#define GPIO_INTTYPE_TYPE14_Msk          (0x1ul << GPIO_INTTYPE_TYPE14_Pos)                /*!< GPIO_T::INTTYPE: TYPE14 Mask              */
S
S#define GPIO_INTTYPE_TYPE15_Pos          (15)                                              /*!< GPIO_T::INTTYPE: TYPE15 Position          */
S#define GPIO_INTTYPE_TYPE15_Msk          (0x1ul << GPIO_INTTYPE_TYPE15_Pos)                /*!< GPIO_T::INTTYPE: TYPE15 Mask              */
S
S#define GPIO_INTEN_FLIEN0_Pos            (0)                                               /*!< GPIO_T::INTEN: FLIEN0 Position            */
S#define GPIO_INTEN_FLIEN0_Msk            (0x1ul << GPIO_INTEN_FLIEN0_Pos)                  /*!< GPIO_T::INTEN: FLIEN0 Mask                */
S
S#define GPIO_INTEN_FLIEN1_Pos            (1)                                               /*!< GPIO_T::INTEN: FLIEN1 Position            */
S#define GPIO_INTEN_FLIEN1_Msk            (0x1ul << GPIO_INTEN_FLIEN1_Pos)                  /*!< GPIO_T::INTEN: FLIEN1 Mask                */
S
S#define GPIO_INTEN_FLIEN2_Pos            (2)                                               /*!< GPIO_T::INTEN: FLIEN2 Position            */
S#define GPIO_INTEN_FLIEN2_Msk            (0x1ul << GPIO_INTEN_FLIEN2_Pos)                  /*!< GPIO_T::INTEN: FLIEN2 Mask                */
S
S#define GPIO_INTEN_FLIEN3_Pos            (3)                                               /*!< GPIO_T::INTEN: FLIEN3 Position            */
S#define GPIO_INTEN_FLIEN3_Msk            (0x1ul << GPIO_INTEN_FLIEN3_Pos)                  /*!< GPIO_T::INTEN: FLIEN3 Mask                */
S
S#define GPIO_INTEN_FLIEN4_Pos            (4)                                               /*!< GPIO_T::INTEN: FLIEN4 Position            */
S#define GPIO_INTEN_FLIEN4_Msk            (0x1ul << GPIO_INTEN_FLIEN4_Pos)                  /*!< GPIO_T::INTEN: FLIEN4 Mask                */
S
S#define GPIO_INTEN_FLIEN5_Pos            (5)                                               /*!< GPIO_T::INTEN: FLIEN5 Position            */
S#define GPIO_INTEN_FLIEN5_Msk            (0x1ul << GPIO_INTEN_FLIEN5_Pos)                  /*!< GPIO_T::INTEN: FLIEN5 Mask                */
S
S#define GPIO_INTEN_FLIEN6_Pos            (6)                                               /*!< GPIO_T::INTEN: FLIEN6 Position            */
S#define GPIO_INTEN_FLIEN6_Msk            (0x1ul << GPIO_INTEN_FLIEN6_Pos)                  /*!< GPIO_T::INTEN: FLIEN6 Mask                */
S
S#define GPIO_INTEN_FLIEN7_Pos            (7)                                               /*!< GPIO_T::INTEN: FLIEN7 Position            */
S#define GPIO_INTEN_FLIEN7_Msk            (0x1ul << GPIO_INTEN_FLIEN7_Pos)                  /*!< GPIO_T::INTEN: FLIEN7 Mask                */
S
S#define GPIO_INTEN_FLIEN8_Pos            (8)                                               /*!< GPIO_T::INTEN: FLIEN8 Position            */
S#define GPIO_INTEN_FLIEN8_Msk            (0x1ul << GPIO_INTEN_FLIEN8_Pos)                  /*!< GPIO_T::INTEN: FLIEN8 Mask                */
S
S#define GPIO_INTEN_FLIEN9_Pos            (9)                                               /*!< GPIO_T::INTEN: FLIEN9 Position            */
S#define GPIO_INTEN_FLIEN9_Msk            (0x1ul << GPIO_INTEN_FLIEN9_Pos)                  /*!< GPIO_T::INTEN: FLIEN9 Mask                */
S
S#define GPIO_INTEN_FLIEN10_Pos           (10)                                              /*!< GPIO_T::INTEN: FLIEN10 Position           */
S#define GPIO_INTEN_FLIEN10_Msk           (0x1ul << GPIO_INTEN_FLIEN10_Pos)                 /*!< GPIO_T::INTEN: FLIEN10 Mask               */
S
S#define GPIO_INTEN_FLIEN11_Pos           (11)                                              /*!< GPIO_T::INTEN: FLIEN11 Position           */
S#define GPIO_INTEN_FLIEN11_Msk           (0x1ul << GPIO_INTEN_FLIEN11_Pos)                 /*!< GPIO_T::INTEN: FLIEN11 Mask               */
S
S#define GPIO_INTEN_FLIEN12_Pos           (12)                                              /*!< GPIO_T::INTEN: FLIEN12 Position           */
S#define GPIO_INTEN_FLIEN12_Msk           (0x1ul << GPIO_INTEN_FLIEN12_Pos)                 /*!< GPIO_T::INTEN: FLIEN12 Mask               */
S
S#define GPIO_INTEN_FLIEN13_Pos           (13)                                              /*!< GPIO_T::INTEN: FLIEN13 Position           */
S#define GPIO_INTEN_FLIEN13_Msk           (0x1ul << GPIO_INTEN_FLIEN13_Pos)                 /*!< GPIO_T::INTEN: FLIEN13 Mask               */
S
S#define GPIO_INTEN_FLIEN14_Pos           (14)                                              /*!< GPIO_T::INTEN: FLIEN14 Position           */
S#define GPIO_INTEN_FLIEN14_Msk           (0x1ul << GPIO_INTEN_FLIEN14_Pos)                 /*!< GPIO_T::INTEN: FLIEN14 Mask               */
S
S#define GPIO_INTEN_FLIEN15_Pos           (15)                                              /*!< GPIO_T::INTEN: FLIEN15 Position           */
S#define GPIO_INTEN_FLIEN15_Msk           (0x1ul << GPIO_INTEN_FLIEN15_Pos)                 /*!< GPIO_T::INTEN: FLIEN15 Mask               */
S
S#define GPIO_INTEN_RHIEN0_Pos            (16)                                              /*!< GPIO_T::INTEN: RHIEN0 Position            */
S#define GPIO_INTEN_RHIEN0_Msk            (0x1ul << GPIO_INTEN_RHIEN0_Pos)                  /*!< GPIO_T::INTEN: RHIEN0 Mask                */
S
S#define GPIO_INTEN_RHIEN1_Pos            (17)                                              /*!< GPIO_T::INTEN: RHIEN1 Position            */
S#define GPIO_INTEN_RHIEN1_Msk            (0x1ul << GPIO_INTEN_RHIEN1_Pos)                  /*!< GPIO_T::INTEN: RHIEN1 Mask                */
S
S#define GPIO_INTEN_RHIEN2_Pos            (18)                                              /*!< GPIO_T::INTEN: RHIEN2 Position            */
S#define GPIO_INTEN_RHIEN2_Msk            (0x1ul << GPIO_INTEN_RHIEN2_Pos)                  /*!< GPIO_T::INTEN: RHIEN2 Mask                */
S
S#define GPIO_INTEN_RHIEN3_Pos            (19)                                              /*!< GPIO_T::INTEN: RHIEN3 Position            */
S#define GPIO_INTEN_RHIEN3_Msk            (0x1ul << GPIO_INTEN_RHIEN3_Pos)                  /*!< GPIO_T::INTEN: RHIEN3 Mask                */
S
S#define GPIO_INTEN_RHIEN4_Pos            (20)                                              /*!< GPIO_T::INTEN: RHIEN4 Position            */
S#define GPIO_INTEN_RHIEN4_Msk            (0x1ul << GPIO_INTEN_RHIEN4_Pos)                  /*!< GPIO_T::INTEN: RHIEN4 Mask                */
S
S#define GPIO_INTEN_RHIEN5_Pos            (21)                                              /*!< GPIO_T::INTEN: RHIEN5 Position            */
S#define GPIO_INTEN_RHIEN5_Msk            (0x1ul << GPIO_INTEN_RHIEN5_Pos)                  /*!< GPIO_T::INTEN: RHIEN5 Mask                */
S
S#define GPIO_INTEN_RHIEN6_Pos            (22)                                              /*!< GPIO_T::INTEN: RHIEN6 Position            */
S#define GPIO_INTEN_RHIEN6_Msk            (0x1ul << GPIO_INTEN_RHIEN6_Pos)                  /*!< GPIO_T::INTEN: RHIEN6 Mask                */
S
S#define GPIO_INTEN_RHIEN7_Pos            (23)                                              /*!< GPIO_T::INTEN: RHIEN7 Position            */
S#define GPIO_INTEN_RHIEN7_Msk            (0x1ul << GPIO_INTEN_RHIEN7_Pos)                  /*!< GPIO_T::INTEN: RHIEN7 Mask                */
S
S#define GPIO_INTEN_RHIEN8_Pos            (24)                                              /*!< GPIO_T::INTEN: RHIEN8 Position            */
S#define GPIO_INTEN_RHIEN8_Msk            (0x1ul << GPIO_INTEN_RHIEN8_Pos)                  /*!< GPIO_T::INTEN: RHIEN8 Mask                */
S
S#define GPIO_INTEN_RHIEN9_Pos            (25)                                              /*!< GPIO_T::INTEN: RHIEN9 Position            */
S#define GPIO_INTEN_RHIEN9_Msk            (0x1ul << GPIO_INTEN_RHIEN9_Pos)                  /*!< GPIO_T::INTEN: RHIEN9 Mask                */
S
S#define GPIO_INTEN_RHIEN10_Pos           (26)                                              /*!< GPIO_T::INTEN: RHIEN10 Position           */
S#define GPIO_INTEN_RHIEN10_Msk           (0x1ul << GPIO_INTEN_RHIEN10_Pos)                 /*!< GPIO_T::INTEN: RHIEN10 Mask               */
S
S#define GPIO_INTEN_RHIEN11_Pos           (27)                                              /*!< GPIO_T::INTEN: RHIEN11 Position           */
S#define GPIO_INTEN_RHIEN11_Msk           (0x1ul << GPIO_INTEN_RHIEN11_Pos)                 /*!< GPIO_T::INTEN: RHIEN11 Mask               */
S
S#define GPIO_INTEN_RHIEN12_Pos           (28)                                              /*!< GPIO_T::INTEN: RHIEN12 Position           */
S#define GPIO_INTEN_RHIEN12_Msk           (0x1ul << GPIO_INTEN_RHIEN12_Pos)                 /*!< GPIO_T::INTEN: RHIEN12 Mask               */
S
S#define GPIO_INTEN_RHIEN13_Pos           (29)                                              /*!< GPIO_T::INTEN: RHIEN13 Position           */
S#define GPIO_INTEN_RHIEN13_Msk           (0x1ul << GPIO_INTEN_RHIEN13_Pos)                 /*!< GPIO_T::INTEN: RHIEN13 Mask               */
S
S#define GPIO_INTEN_RHIEN14_Pos           (30)                                              /*!< GPIO_T::INTEN: RHIEN14 Position           */
S#define GPIO_INTEN_RHIEN14_Msk           (0x1ul << GPIO_INTEN_RHIEN14_Pos)                 /*!< GPIO_T::INTEN: RHIEN14 Mask               */
S
S#define GPIO_INTEN_RHIEN15_Pos           (31)                                              /*!< GPIO_T::INTEN: RHIEN15 Position           */
S#define GPIO_INTEN_RHIEN15_Msk           (0x1ul << GPIO_INTEN_RHIEN15_Pos)                 /*!< GPIO_T::INTEN: RHIEN15 Mask               */
S
S#define GPIO_INTSRC_INTSRC0_Pos          (0)                                               /*!< GPIO_T::INTSRC: INTSRC0 Position          */
S#define GPIO_INTSRC_INTSRC0_Msk          (0x1ul << GPIO_INTSRC_INTSRC0_Pos)                /*!< GPIO_T::INTSRC: INTSRC0 Mask              */
S
S#define GPIO_INTSRC_INTSRC1_Pos          (1)                                               /*!< GPIO_T::INTSRC: INTSRC1 Position          */
S#define GPIO_INTSRC_INTSRC1_Msk          (0x1ul << GPIO_INTSRC_INTSRC1_Pos)                /*!< GPIO_T::INTSRC: INTSRC1 Mask              */
S
S#define GPIO_INTSRC_INTSRC2_Pos          (2)                                               /*!< GPIO_T::INTSRC: INTSRC2 Position          */
S#define GPIO_INTSRC_INTSRC2_Msk          (0x1ul << GPIO_INTSRC_INTSRC2_Pos)                /*!< GPIO_T::INTSRC: INTSRC2 Mask              */
S
S#define GPIO_INTSRC_INTSRC3_Pos          (3)                                               /*!< GPIO_T::INTSRC: INTSRC3 Position          */
S#define GPIO_INTSRC_INTSRC3_Msk          (0x1ul << GPIO_INTSRC_INTSRC3_Pos)                /*!< GPIO_T::INTSRC: INTSRC3 Mask              */
S
S#define GPIO_INTSRC_INTSRC4_Pos          (4)                                               /*!< GPIO_T::INTSRC: INTSRC4 Position          */
S#define GPIO_INTSRC_INTSRC4_Msk          (0x1ul << GPIO_INTSRC_INTSRC4_Pos)                /*!< GPIO_T::INTSRC: INTSRC4 Mask              */
S
S#define GPIO_INTSRC_INTSRC5_Pos          (5)                                               /*!< GPIO_T::INTSRC: INTSRC5 Position          */
S#define GPIO_INTSRC_INTSRC5_Msk          (0x1ul << GPIO_INTSRC_INTSRC5_Pos)                /*!< GPIO_T::INTSRC: INTSRC5 Mask              */
S
S#define GPIO_INTSRC_INTSRC6_Pos          (6)                                               /*!< GPIO_T::INTSRC: INTSRC6 Position          */
S#define GPIO_INTSRC_INTSRC6_Msk          (0x1ul << GPIO_INTSRC_INTSRC6_Pos)                /*!< GPIO_T::INTSRC: INTSRC6 Mask              */
S
S#define GPIO_INTSRC_INTSRC7_Pos          (7)                                               /*!< GPIO_T::INTSRC: INTSRC7 Position          */
S#define GPIO_INTSRC_INTSRC7_Msk          (0x1ul << GPIO_INTSRC_INTSRC7_Pos)                /*!< GPIO_T::INTSRC: INTSRC7 Mask              */
S
S#define GPIO_INTSRC_INTSRC8_Pos          (8)                                               /*!< GPIO_T::INTSRC: INTSRC8 Position          */
S#define GPIO_INTSRC_INTSRC8_Msk          (0x1ul << GPIO_INTSRC_INTSRC8_Pos)                /*!< GPIO_T::INTSRC: INTSRC8 Mask              */
S
S#define GPIO_INTSRC_INTSRC9_Pos          (9)                                               /*!< GPIO_T::INTSRC: INTSRC9 Position          */
S#define GPIO_INTSRC_INTSRC9_Msk          (0x1ul << GPIO_INTSRC_INTSRC9_Pos)                /*!< GPIO_T::INTSRC: INTSRC9 Mask              */
S
S#define GPIO_INTSRC_INTSRC10_Pos         (10)                                              /*!< GPIO_T::INTSRC: INTSRC10 Position         */
S#define GPIO_INTSRC_INTSRC10_Msk         (0x1ul << GPIO_INTSRC_INTSRC10_Pos)               /*!< GPIO_T::INTSRC: INTSRC10 Mask             */
S
S#define GPIO_INTSRC_INTSRC11_Pos         (11)                                              /*!< GPIO_T::INTSRC: INTSRC11 Position         */
S#define GPIO_INTSRC_INTSRC11_Msk         (0x1ul << GPIO_INTSRC_INTSRC11_Pos)               /*!< GPIO_T::INTSRC: INTSRC11 Mask             */
S
S#define GPIO_INTSRC_INTSRC12_Pos         (12)                                              /*!< GPIO_T::INTSRC: INTSRC12 Position         */
S#define GPIO_INTSRC_INTSRC12_Msk         (0x1ul << GPIO_INTSRC_INTSRC12_Pos)               /*!< GPIO_T::INTSRC: INTSRC12 Mask             */
S
S#define GPIO_INTSRC_INTSRC13_Pos         (13)                                              /*!< GPIO_T::INTSRC: INTSRC13 Position         */
S#define GPIO_INTSRC_INTSRC13_Msk         (0x1ul << GPIO_INTSRC_INTSRC13_Pos)               /*!< GPIO_T::INTSRC: INTSRC13 Mask             */
S
S#define GPIO_INTSRC_INTSRC14_Pos         (14)                                              /*!< GPIO_T::INTSRC: INTSRC14 Position         */
S#define GPIO_INTSRC_INTSRC14_Msk         (0x1ul << GPIO_INTSRC_INTSRC14_Pos)               /*!< GPIO_T::INTSRC: INTSRC14 Mask             */
S
S#define GPIO_INTSRC_INTSRC15_Pos         (15)                                              /*!< GPIO_T::INTSRC: INTSRC15 Position         */
S#define GPIO_INTSRC_INTSRC15_Msk         (0x1ul << GPIO_INTSRC_INTSRC15_Pos)               /*!< GPIO_T::INTSRC: INTSRC15 Mask             */
S
S#define GPIO_SMTEN_SMTEN0_Pos            (0)                                               /*!< GPIO_T::SMTEN: SMTEN0 Position            */
S#define GPIO_SMTEN_SMTEN0_Msk            (0x1ul << GPIO_SMTEN_SMTEN0_Pos)                  /*!< GPIO_T::SMTEN: SMTEN0 Mask                */
S
S#define GPIO_SMTEN_SMTEN1_Pos            (1)                                               /*!< GPIO_T::SMTEN: SMTEN1 Position            */
S#define GPIO_SMTEN_SMTEN1_Msk            (0x1ul << GPIO_SMTEN_SMTEN1_Pos)                  /*!< GPIO_T::SMTEN: SMTEN1 Mask                */
S
S#define GPIO_SMTEN_SMTEN2_Pos            (2)                                               /*!< GPIO_T::SMTEN: SMTEN2 Position            */
S#define GPIO_SMTEN_SMTEN2_Msk            (0x1ul << GPIO_SMTEN_SMTEN2_Pos)                  /*!< GPIO_T::SMTEN: SMTEN2 Mask                */
S
S#define GPIO_SMTEN_SMTEN3_Pos            (3)                                               /*!< GPIO_T::SMTEN: SMTEN3 Position            */
S#define GPIO_SMTEN_SMTEN3_Msk            (0x1ul << GPIO_SMTEN_SMTEN3_Pos)                  /*!< GPIO_T::SMTEN: SMTEN3 Mask                */
S
S#define GPIO_SMTEN_SMTEN4_Pos            (4)                                               /*!< GPIO_T::SMTEN: SMTEN4 Position            */
S#define GPIO_SMTEN_SMTEN4_Msk            (0x1ul << GPIO_SMTEN_SMTEN4_Pos)                  /*!< GPIO_T::SMTEN: SMTEN4 Mask                */
S
S#define GPIO_SMTEN_SMTEN5_Pos            (5)                                               /*!< GPIO_T::SMTEN: SMTEN5 Position            */
S#define GPIO_SMTEN_SMTEN5_Msk            (0x1ul << GPIO_SMTEN_SMTEN5_Pos)                  /*!< GPIO_T::SMTEN: SMTEN5 Mask                */
S
S#define GPIO_SMTEN_SMTEN6_Pos            (6)                                               /*!< GPIO_T::SMTEN: SMTEN6 Position            */
S#define GPIO_SMTEN_SMTEN6_Msk            (0x1ul << GPIO_SMTEN_SMTEN6_Pos)                  /*!< GPIO_T::SMTEN: SMTEN6 Mask                */
S
S#define GPIO_SMTEN_SMTEN7_Pos            (7)                                               /*!< GPIO_T::SMTEN: SMTEN7 Position            */
S#define GPIO_SMTEN_SMTEN7_Msk            (0x1ul << GPIO_SMTEN_SMTEN7_Pos)                  /*!< GPIO_T::SMTEN: SMTEN7 Mask                */
S
S#define GPIO_SMTEN_SMTEN8_Pos            (8)                                               /*!< GPIO_T::SMTEN: SMTEN8 Position            */
S#define GPIO_SMTEN_SMTEN8_Msk            (0x1ul << GPIO_SMTEN_SMTEN8_Pos)                  /*!< GPIO_T::SMTEN: SMTEN8 Mask                */
S
S#define GPIO_SMTEN_SMTEN9_Pos            (9)                                               /*!< GPIO_T::SMTEN: SMTEN9 Position            */
S#define GPIO_SMTEN_SMTEN9_Msk            (0x1ul << GPIO_SMTEN_SMTEN9_Pos)                  /*!< GPIO_T::SMTEN: SMTEN9 Mask                */
S
S#define GPIO_SMTEN_SMTEN10_Pos           (10)                                              /*!< GPIO_T::SMTEN: SMTEN10 Position           */
S#define GPIO_SMTEN_SMTEN10_Msk           (0x1ul << GPIO_SMTEN_SMTEN10_Pos)                 /*!< GPIO_T::SMTEN: SMTEN10 Mask               */
S
S#define GPIO_SMTEN_SMTEN11_Pos           (11)                                              /*!< GPIO_T::SMTEN: SMTEN11 Position           */
S#define GPIO_SMTEN_SMTEN11_Msk           (0x1ul << GPIO_SMTEN_SMTEN11_Pos)                 /*!< GPIO_T::SMTEN: SMTEN11 Mask               */
S
S#define GPIO_SMTEN_SMTEN12_Pos           (12)                                              /*!< GPIO_T::SMTEN: SMTEN12 Position           */
S#define GPIO_SMTEN_SMTEN12_Msk           (0x1ul << GPIO_SMTEN_SMTEN12_Pos)                 /*!< GPIO_T::SMTEN: SMTEN12 Mask               */
S
S#define GPIO_SMTEN_SMTEN13_Pos           (13)                                              /*!< GPIO_T::SMTEN: SMTEN13 Position           */
S#define GPIO_SMTEN_SMTEN13_Msk           (0x1ul << GPIO_SMTEN_SMTEN13_Pos)                 /*!< GPIO_T::SMTEN: SMTEN13 Mask               */
S
S#define GPIO_SMTEN_SMTEN14_Pos           (14)                                              /*!< GPIO_T::SMTEN: SMTEN14 Position           */
S#define GPIO_SMTEN_SMTEN14_Msk           (0x1ul << GPIO_SMTEN_SMTEN14_Pos)                 /*!< GPIO_T::SMTEN: SMTEN14 Mask               */
S
S#define GPIO_SMTEN_SMTEN15_Pos           (15)                                              /*!< GPIO_T::SMTEN: SMTEN15 Position           */
S#define GPIO_SMTEN_SMTEN15_Msk           (0x1ul << GPIO_SMTEN_SMTEN15_Pos)                 /*!< GPIO_T::SMTEN: SMTEN15 Mask               */
S
S#define GPIO_SLEWCTL_HSREN0_Pos          (0)                                               /*!< GPIO_T::SLEWCTL: HSREN0 Position          */
S#define GPIO_SLEWCTL_HSREN0_Msk          (0x1ul << GPIO_SLEWCTL_HSREN0_Pos)                /*!< GPIO_T::SLEWCTL: HSREN0 Mask              */
S
S#define GPIO_SLEWCTL_HSREN1_Pos          (1)                                               /*!< GPIO_T::SLEWCTL: HSREN1 Position          */
S#define GPIO_SLEWCTL_HSREN1_Msk          (0x1ul << GPIO_SLEWCTL_HSREN1_Pos)                /*!< GPIO_T::SLEWCTL: HSREN1 Mask              */
S
S#define GPIO_SLEWCTL_HSREN2_Pos          (2)                                               /*!< GPIO_T::SLEWCTL: HSREN2 Position          */
S#define GPIO_SLEWCTL_HSREN2_Msk          (0x1ul << GPIO_SLEWCTL_HSREN2_Pos)                /*!< GPIO_T::SLEWCTL: HSREN2 Mask              */
S
S#define GPIO_SLEWCTL_HSREN3_Pos          (3)                                               /*!< GPIO_T::SLEWCTL: HSREN3 Position          */
S#define GPIO_SLEWCTL_HSREN3_Msk          (0x1ul << GPIO_SLEWCTL_HSREN3_Pos)                /*!< GPIO_T::SLEWCTL: HSREN3 Mask              */
S
S#define GPIO_SLEWCTL_HSREN4_Pos          (4)                                               /*!< GPIO_T::SLEWCTL: HSREN4 Position          */
S#define GPIO_SLEWCTL_HSREN4_Msk          (0x1ul << GPIO_SLEWCTL_HSREN4_Pos)                /*!< GPIO_T::SLEWCTL: HSREN4 Mask              */
S
S#define GPIO_SLEWCTL_HSREN5_Pos          (5)                                               /*!< GPIO_T::SLEWCTL: HSREN5 Position          */
S#define GPIO_SLEWCTL_HSREN5_Msk          (0x1ul << GPIO_SLEWCTL_HSREN5_Pos)                /*!< GPIO_T::SLEWCTL: HSREN5 Mask              */
S
S#define GPIO_SLEWCTL_HSREN6_Pos          (6)                                               /*!< GPIO_T::SLEWCTL: HSREN6 Position          */
S#define GPIO_SLEWCTL_HSREN6_Msk          (0x1ul << GPIO_SLEWCTL_HSREN6_Pos)                /*!< GPIO_T::SLEWCTL: HSREN6 Mask              */
S
S#define GPIO_SLEWCTL_HSREN7_Pos          (7)                                               /*!< GPIO_T::SLEWCTL: HSREN7 Position          */
S#define GPIO_SLEWCTL_HSREN7_Msk          (0x1ul << GPIO_SLEWCTL_HSREN7_Pos)                /*!< GPIO_T::SLEWCTL: HSREN7 Mask              */
S
S#define GPIO_SLEWCTL_HSREN8_Pos          (8)                                               /*!< GPIO_T::SLEWCTL: HSREN8 Position          */
S#define GPIO_SLEWCTL_HSREN8_Msk          (0x1ul << GPIO_SLEWCTL_HSREN8_Pos)                /*!< GPIO_T::SLEWCTL: HSREN8 Mask              */
S
S#define GPIO_SLEWCTL_HSREN9_Pos          (9)                                               /*!< GPIO_T::SLEWCTL: HSREN9 Position          */
S#define GPIO_SLEWCTL_HSREN9_Msk          (0x1ul << GPIO_SLEWCTL_HSREN9_Pos)                /*!< GPIO_T::SLEWCTL: HSREN9 Mask              */
S
S#define GPIO_SLEWCTL_HSREN10_Pos         (10)                                              /*!< GPIO_T::SLEWCTL: HSREN10 Position         */
S#define GPIO_SLEWCTL_HSREN10_Msk         (0x1ul << GPIO_SLEWCTL_HSREN10_Pos)               /*!< GPIO_T::SLEWCTL: HSREN10 Mask             */
S
S#define GPIO_SLEWCTL_HSREN11_Pos         (11)                                              /*!< GPIO_T::SLEWCTL: HSREN11 Position         */
S#define GPIO_SLEWCTL_HSREN11_Msk         (0x1ul << GPIO_SLEWCTL_HSREN11_Pos)               /*!< GPIO_T::SLEWCTL: HSREN11 Mask             */
S
S#define GPIO_SLEWCTL_HSREN12_Pos         (12)                                              /*!< GPIO_T::SLEWCTL: HSREN12 Position         */
S#define GPIO_SLEWCTL_HSREN12_Msk         (0x1ul << GPIO_SLEWCTL_HSREN12_Pos)               /*!< GPIO_T::SLEWCTL: HSREN12 Mask             */
S
S#define GPIO_SLEWCTL_HSREN13_Pos         (13)                                              /*!< GPIO_T::SLEWCTL: HSREN13 Position         */
S#define GPIO_SLEWCTL_HSREN13_Msk         (0x1ul << GPIO_SLEWCTL_HSREN13_Pos)               /*!< GPIO_T::SLEWCTL: HSREN13 Mask             */
S
S#define GPIO_SLEWCTL_HSREN14_Pos         (14)                                              /*!< GPIO_T::SLEWCTL: HSREN14 Position         */
S#define GPIO_SLEWCTL_HSREN14_Msk         (0x1ul << GPIO_SLEWCTL_HSREN14_Pos)               /*!< GPIO_T::SLEWCTL: HSREN14 Mask             */
S
S#define GPIO_SLEWCTL_HSREN15_Pos         (15)                                              /*!< GPIO_T::SLEWCTL: HSREN15 Position         */
S#define GPIO_SLEWCTL_HSREN15_Msk         (0x1ul << GPIO_SLEWCTL_HSREN15_Pos)               /*!< GPIO_T::SLEWCTL: HSREN15 Mask             */
S
S#define GPIO_DRVCTL_HDRVEN8_Pos          (8)                                               /*!< GPIO_T::DRVCTL: HDRVEN8 Position          */
S#define GPIO_DRVCTL_HDRVEN8_Msk          (0x1ul << GPIO_DRVCTL_HDRVEN8_Pos)                /*!< GPIO_T::DRVCTL: HDRVEN8 Mask              */
S
S#define GPIO_DRVCTL_HDRVEN9_Pos          (9)                                               /*!< GPIO_T::DRVCTL: HDRVEN9 Position          */
S#define GPIO_DRVCTL_HDRVEN9_Msk          (0x1ul << GPIO_DRVCTL_HDRVEN9_Pos)                /*!< GPIO_T::DRVCTL: HDRVEN9 Mask              */
S
S#define GPIO_DRVCTL_HDRVEN10_Pos         (10)                                              /*!< GPIO_T::DRVCTL: HDRVEN10 Position         */
S#define GPIO_DRVCTL_HDRVEN10_Msk         (0x1ul << GPIO_DRVCTL_HDRVEN10_Pos)               /*!< GPIO_T::DRVCTL: HDRVEN10 Mask             */
S
S#define GPIO_DRVCTL_HDRVEN11_Pos         (11)                                              /*!< GPIO_T::DRVCTL: HDRVEN11 Position         */
S#define GPIO_DRVCTL_HDRVEN11_Msk         (0x1ul << GPIO_DRVCTL_HDRVEN11_Pos)               /*!< GPIO_T::DRVCTL: HDRVEN11 Mask             */
S
S#define GPIO_DRVCTL_HDRVEN12_Pos         (12)                                              /*!< GPIO_T::DRVCTL: HDRVEN12 Position         */
S#define GPIO_DRVCTL_HDRVEN12_Msk         (0x1ul << GPIO_DRVCTL_HDRVEN12_Pos)               /*!< GPIO_T::DRVCTL: HDRVEN12 Mask             */
S
S#define GPIO_DRVCTL_HDRVEN13_Pos         (13)                                              /*!< GPIO_T::DRVCTL: HDRVEN13 Position         */
S#define GPIO_DRVCTL_HDRVEN13_Msk         (0x1ul << GPIO_DRVCTL_HDRVEN13_Pos)               /*!< GPIO_T::DRVCTL: HDRVEN13 Mask             */
S
S#define GPIO_DBCTL_DBCLKSEL_Pos          (0)                                               /*!< GPIO_T::DBCTL: DBCLKSEL Position          */
S#define GPIO_DBCTL_DBCLKSEL_Msk          (0xFul << GPIO_DBCTL_DBCLKSEL_Pos)                /*!< GPIO_T::DBCTL: DBCLKSEL Mask              */
S
S#define GPIO_DBCTL_DBCLKSRC_Pos          (4)                                               /*!< GPIO_T::DBCTL: DBCLKSRC Position          */
S#define GPIO_DBCTL_DBCLKSRC_Msk          (1ul << GPIO_DBCTL_DBCLKSRC_Pos)                  /*!< GPIO_T::DBCTL: DBCLKSRC Mask              */
S
S#define GPIO_DBCTL_ICLKON_Pos            (5)                                               /*!< GPIO_T::DBCTL: ICLKON Position            */
S#define GPIO_DBCTL_ICLKON_Msk            (1ul << GPIO_DBCTL_ICLKON_Pos)                    /*!< GPIO_T::DBCTL: ICLKON Mask                */
S
S
S/**@}*/ /* GPIO_CONST */
S/**@}*/ /* end of GPIO register group */
S
S
S/*---------------------- Inter-IC Bus Controller -------------------------*/
S/**
S    @addtogroup I2C Inter-IC Bus Controller(I2C)
S    Memory Mapped Structure for I2C Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S
S
S/**
S * @var I2C_T::CTL
S * Offset: 0x00  I2C Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[2]     |AA        |Assert Acknowledge Control
S * |        |          |When AA =1 prior to address or data is received, 
S * |        |          |an acknowledged (low level to SDA) will be returned during the acknowledge clock pulse on the SCL line when 
S * |        |          |1. A slave is acknowledging the address sent from master. 
S * |        |          |2. The receiver devices are acknowledging the data sent by transmitter.
S * |        |          |When AA=0 prior to address or data received, 
S * |        |          |a Not acknowledged (high level to SDA) will be returned during the acknowledge clock pulse on the SCL line.
S * |[3]     |SI        |I2C Interrupt Flag
S * |        |          |When a new I2C state is present in the I2C_STATUS register, the SI flag is set by hardware.
S * |        |          |If bit INTEN (I2C_CTL [7]) is set, the I2C interrupt is requested.
S * |        |          |SI must be cleared by software.
S * |        |          |Clear SI by writing 1 to this bit.
S * |        |          |For ACKMEN is set in slave read mode, the SI flag is set in 8th clock period for user to confirm the acknowledge bit and 9th clock period for user to read the data in the data buffer.
S * |[4]     |STO       |I2C STOP Control
S * |        |          |In Master mode, setting STO to transmit a STOP condition to bus then I2C controller will check the bus condition if a STOP condition is detected.
S * |        |          |This bit will be cleared by hardware automatically.
S * |[5]     |STA       |I2C START Control
S * |        |          |Setting STA to logic 1 to enter Master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.
S * |[6]     |I2CEN     |I2C Controller Enable Bit
S * |        |          |Set to enable I2C serial function controller.
S * |        |          |When I2CEN=1 the I2C serial function enable.
S * |        |          |The multi-function pin function must set to SDA, and SCL of I2C function first.
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[7]     |INTEN     |Enable Interrupt
S * |        |          |0 = I2C interrupt Disabled.
S * |        |          |1 = I2C interrupt Enabled.
S * @var I2C_T::ADDR0
S * Offset: 0x04  I2C Slave Address Register0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |GC        |General Call Function
S * |        |          |0 = General Call Function Disabled.
S * |        |          |1 = General Call Function Enabled.
S * |[7:1]   |ADDR      |I2C Address
S * |        |          |The content of this register is irrelevant when I2C is in Master mode.
S * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
S * |        |          |The I2C hardware will react if either of the address is matched.
S * @var I2C_T::DAT
S * Offset: 0x08  I2C Data Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |DAT       |I2C Data
S * |        |          |Bit [7:0] is located with the 8-bit transferred/received data of I2C serial port.
S * @var I2C_T::STATUS
S * Offset: 0x0C  I2C Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |STATUS    |I2C Status
S * |        |          |The three least significant bits are always 0.
S * |        |          |The five most significant bits contain the status code.
S * |        |          |There are 28 possible status codes.
S * |        |          |When the content of I2C_STATUS is F8H, no serial interrupt is requested.
S * |        |          |Others I2C_STATUS values correspond to defined I2C states.
S * |        |          |When each of these states is entered, a status interrupt is requested (SI = 1).
S * |        |          |A valid status code is present in I2C_STATUS one cycle after SI is set by hardware and is still present one cycle after SI has been reset by software.
S * |        |          |In addition, states 00H stands for a Bus Error.
S * |        |          |A Bus Error occurs when a START or STOP condition is present at an illegal position in the formation frame.
S * |        |          |Example of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit.
S * |        |          |Note:
S * |        |          |1.
S * |        |          |If the BUSEN and ACKMEN are enabled in slave received mode, there is SI interrupt in the 8th clock.
S * |        |          |The user can read the I2C_STATUS = 0xf0 for the function condition has done.
S * |        |          |2.
S * |        |          |If the BUSEN and PECEN are enabled, the status of PECERR, I2C_BUSSTS[3], is used to substitute for I2C_STATUS to check the ACK status in the last frame when the byte count done interrupt has active and the PEC frame has been transformed.
S * @var I2C_T::CLKDIV
S * Offset: 0x10  I2C Clock Divided Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |DIVIDER   |I2C Clock Divided
S * |        |          |Indicates the I2C clock rate: Data Baud Rate of I2C = (system clock) / (4x (I2C_CLKDIV+1)).
S * |        |          |Note: The minimum value of I2C_CLKDIV is 4.
S * @var I2C_T::TOCTL
S * Offset: 0x14  I2C Time-out Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |TOIF      |Time-Out Flag
S * |        |          |This bit is set by hardware when I2C time-out happened and it can interrupt CPU if I2C interrupt enable bit (INTEN) is set to 1.
S * |        |          |Note: Software can write 1 to clear this bit.
S * |[1]     |TOCDIV4   |Time-Out Counter Input Clock Divided By 4
S * |        |          |When Enabled, The time-out period is extend 4 times.
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[2]     |TOCEN     |Time-Out Counter Enable Bit
S * |        |          |When Enabled, the 14-bit time-out counter will start counting when SI is clear.
S * |        |          |Setting flag SI to '1' will reset counter and re-start up counting after SI is cleared.
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * @var I2C_T::ADDR1
S * Offset: 0x18  I2C Slave Address Register1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |GC        |General Call Function
S * |        |          |0 = General Call Function Disabled.
S * |        |          |1 = General Call Function Enabled.
S * |[7:1]   |ADDR      |I2C Address
S * |        |          |The content of this register is irrelevant when I2C is in Master mode.
S * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
S * |        |          |The I2C hardware will react if either of the address is matched.
S * @var I2C_T::ADDR2
S * Offset: 0x1C  I2C Slave Address Register2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |GC        |General Call Function
S * |        |          |0 = General Call Function Disabled.
S * |        |          |1 = General Call Function Enabled.
S * |[7:1]   |ADDR      |I2C Address
S * |        |          |The content of this register is irrelevant when I2C is in Master mode.
S * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
S * |        |          |The I2C hardware will react if either of the address is matched.
S * @var I2C_T::ADDR3
S * Offset: 0x20  I2C Slave Address Register3
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |GC        |General Call Function
S * |        |          |0 = General Call Function Disabled.
S * |        |          |1 = General Call Function Enabled.
S * |[7:1]   |ADDR      |I2C Address
S * |        |          |The content of this register is irrelevant when I2C is in Master mode.
S * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
S * |        |          |The I2C hardware will react if either of the address is matched.
S * @var I2C_T::ADDRMSK0
S * Offset: 0x24  I2C Slave Address Mask Register0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:1]   |ADDRMSK   |I2C Address Mask
S * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
S * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
S * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
S * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
S * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
S * @var I2C_T::ADDRMSK1
S * Offset: 0x28  I2C Slave Address Mask Register1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:1]   |ADDRMSK   |I2C Address Mask
S * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
S * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
S * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
S * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
S * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
S * @var I2C_T::ADDRMSK2
S * Offset: 0x2C  I2C Slave Address Mask Register2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:1]   |ADDRMSK   |I2C Address Mask
S * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
S * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
S * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
S * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
S * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
S * @var I2C_T::ADDRMSK3
S * Offset: 0x30  I2C Slave Address Mask Register3
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:1]   |ADDRMSK   |I2C Address Mask
S * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
S * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
S * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
S * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
S * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
S * @var I2C_T::WKCTL
S * Offset: 0x3C  I2C Wake-up Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |WKEN      |I2C Wake-Up Enable Bit
S * |        |          |0 = I2C wake-up function Disabled.
S * |        |          |1= I2C wake-up function Enabled.
S * @var I2C_T::WKSTS
S * Offset: 0x40  I2C Wake-up Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |WKIF      |I2C Wake-Up Flag
S * |        |          |When chip is woken up from Power-down mode by I2C, this bit is set to 1.
S * |        |          |Software can write 1 to clear this bit.
S * @var I2C_T::BUSCTL
S * Offset: 0x44  I2C Bus Management Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ACKMEN    |Acknowledge Control By Manual
S * |        |          |In order to allow ACK control in slave reception including the command and data, slave byte control mode must be enabled by setting the ACKMEN bit.
S * |        |          |0 = Slave byte control Disabled.
S * |        |          |1 = Slave byte control Enabled.
S * |        |          |The 9th bit can response the ACK or NACK according the received data by user.
S * |        |          |When the byte is received, stretching the SCLK signal low between the 8th and 9th SCLK pulse.
S * |        |          |Note: If the BMDEN =1 and this bit is enabled, the information of I2C_STATUS will be fixed as 0xF0 in slave receive condition.
S * |[1]     |PECEN     |Packet Error Checking Calculation Enable Bit
S * |        |          |0 = Packet Error Checking Calculation Disabled.
S * |        |          |1 = Packet Error Checking Calculation Enabled.
S * |[2]     |BMDEN     |Bus Management Device Default Address Enable Bit
S * |        |          |0 = Device default address Disable.
S * |        |          |When the address 0'b1100001x coming and the both of BMDEN and ACKMEN are enabled, the device responses NACKed.
S * |        |          |1 = Device default address Enabled.
S * |        |          |When the address 0'b1100001x coming and the both of BMDEN and ACKMEN are enabled, the device responses ACKed.
S * |[3]     |BMHEN     |Bus Management Host Enable Bit
S * |        |          |0 = Host function Disabled.
S * |        |          |1 = Host function Enabled and the SUSCON will be used as CONTROL function.
S * |[4]     |ALERTEN   |Bus Management Alert Enable Bit
S * |        |          |Device Mode (BMHEN =0).
S * |        |          |0 = Release the BM_ALERT pin high and Alert Response Header disabled: 0001100x followed by NACK if both of BMDEN and ACKMEN are enabled.
S * |        |          |1 = Drive BM_ALERT pin low and Alert Response Address Header enables: 0001100x followed by ACK if both of BMDEN and ACKMEN are enabled.
S * |        |          |Host Mode (BMHEN =1).
S * |        |          |0 = BM_ALERT pin not supported.
S * |        |          |1 = BM_ALERT pin supported.
S * |[5]     |SCTLOSTS  |Suspend/Control Data Output Status
S * |        |          |0 = The output of SUSCON pin is low.
S * |        |          |1 = The output of SUSCON pin is high.
S * |[6]     |SCTLOEN   |Suspend Or Control Pin Output Enable Bit
S * |        |          |0 = The SUSCON pin in input.
S * |        |          |1 = The output enable is active on the SUSCON pin.
S * |[7]     |BUSEN     |BUS Enable Bit
S * |        |          |0 = The system management function is Disabled.
S * |        |          |1 = The system management function is Enable.
S * |        |          |Note: When the bit is enabled, the internal 14-bit counter is used to calculate the time out event of clock low condition.
S * |[8]     |PECTXEN   |Packet Error Checking Byte Transmission/Reception
S * |        |          |This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address Matched is received
S * |        |          |0 = No PEC transfer.
S * |        |          |1 = PEC transmission/reception is requested.
S * |        |          |Note: 1.This bit has no effect in slave mode when ACKMEN =0.
S * |[9]     |TIDLE     |Timer Check In Idle State
S * |        |          |The BUSTOUT is used to calculate the time-out of clock low in bus active and the idle period in bus Idle.
S * |        |          |This bit is used to define which condition is enabled.
S * |        |          |0 = The BUSTOUT is used to calculate the clock low period in bus active.
S * |        |          |1 = The BUSTOUT is used to calculate the IDLE period in bus Idle.
S * |        |          |Note: The BUSY (I2C_BUSSTS[0]) indicate the current bus state.
S * |[10]    |PECCLR    |PEC Clear At Repeat Start
S * |        |          |The calculation of PEC starts when PECEN is set to 1 and it is clear when the STA or STO bit is detected.
S * |        |          |This PECCLR bit is used to enable the condition of REPEAT START can clear the PEC calculation.
S * |        |          |0 = The PEC calculation is cleared by "Repeat Start" function is Disabled.
S * |        |          |1 = The PEC calculation is cleared by "Repeat Start" function is Enabled.
S * |[11]    |ACKM9SI   |Acknowledge Manual Enable Extra SI Interrupt
S * |        |          |0 = There is no SI interrupt in the 9th clock cycle when the BUSEN =1 and ACKMEN =1.
S * |        |          |1 = There is SI interrupt in the 9th clock cycle when the BUSEN =1 and ACKMEN =1.
S * @var I2C_T::BUSTCTL
S * Offset: 0x48  I2C Bus Management Timer Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |BUSTOEN   |Bus Time Out Enable Bit
S * |        |          |0 = Indicates the bus clock low time-out detection is Disabled.
S * |        |          |1 = Indicates the bus clock low time-out detection is Enabled 
S * |        |          |bus clock is low for more than Time-out (in BIDLE=0) or high more than Time-out(in BIDLE =1),
S * |[1]     |CLKTOEN   |Cumulative Clock Low Time Out Enable Bit
S * |        |          |0 = Indicates the cumulative clock low time-out detection is Disabled.
S * |        |          |1 = Indicates the cumulative clock low time-out detection is Enabled.
S * |        |          |For Master, it calculates the period from START to ACK
S * |        |          |For Slave, it calculates the period from START to STOP
S * |[2]     |BUSTOIEN  |Time-Out Interrupt Enable Bit
S * |        |          |BUSY =1.
S * |        |          |0 = Indicates the SCLK low time-out interrupt is Disabled.
S * |        |          |1 = Indicates the SCLK low time-out interrupt is Enabled.
S * |        |          |BUSY =0.
S * |        |          |0 = Indicates the bus IDLE time-out interrupt is Disabled.
S * |        |          |1 = Indicates the bus IDLE time-out interrupt is Enabled.
S * |[3]     |CLKTOIEN  |Extended Clock Time Out Interrupt Enable Bit
S * |        |          |0 = Indicates the time extended interrupt is Disabled.
S * |        |          |1 = Indicates the time extended interrupt is Enabled.
S * |[4]     |TORSTEN   |Time Out Reset Enable Bit
S * |        |          |0 = Indicates the I2C state machine reset is Disable.
S * |        |          |1 = Indicates the I2C state machine reset is Enable. (The clock and data bus will be released to high)
S * |[5]     |PECIEN    |Packet Error Checking Byte Count Done Interrupt Enable Bit
S * |        |          |0 = Indicates the byte count done interrupt is Disabled.
S * |        |          |1 = Indicates the byte count done interrupt is Enabled.
S * |        |          |Note: This bit is used in PECEN =1.
S * @var I2C_T::BUSSTS
S * Offset: 0x4C  I2C Bus Management Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |BUSY      |Bus Busy
S * |        |          |Indicates that a communication is in progress on the bus.
S * |        |          |It is set by hardware when a START condition is detected.
S * |        |          |It is cleared by hardware when a STOP condition is detected.
S * |        |          |0 = The bus is IDLE (both SCLK and SDA High).
S * |        |          |1 = The bus is busy.
S * |[1]     |BCDONE    |Byte Count Transmission/Receive Done
S * |        |          |0 = Indicates the transmission/ receive is not finished when the PECEN is set.
S * |        |          |1 = Indicates the transmission/ receive is finished when the PECEN is set.
S * |        |          |Note: Software can write 1 to clear this bit.
S * |[2]     |PECERR    |PEC Error In Reception
S * |        |          |0 = Indicates the PEC value equal the received PEC data packet.
S * |        |          |1 = Indicates the PEC value doesn't match the receive PEC data packet.
S * |        |          |Note: Software can write 1 to clear this bit.
S * |[3]     |ALERT     |SMBus Alert Status
S * |        |          |Device Mode (BMHEN =0).
S * |        |          |0 = Indicates SMALERT pin state is low.
S * |        |          |1 = Indicates SMALERT pin state is high
S * |        |          |Host Mode (BMHEN =1).
S * |        |          |0 = No SMBALERT event.
S * |        |          |1 = Indicates there is SMBALERT event (falling edge) is detected in SMALERT pin when the BMHEN = 1 (SMBus host configuration) and the ALERTEN = 1.
S * |        |          |Note: 1.
S * |        |          |The SMALERT pin is an open-drain pin, the pull-high resistor is must in the system.
S * |        |          |2.
S * |        |          |Software can write 1 to clear this bit.
S * |[4]     |SCTLDIN   |Bus Suspend Or Control Signal Input Status
S * |        |          |0 = The input status of SUSCON pin is 0.
S * |        |          |1 = The input status of SUSCON pin is 1.
S * |[5]     |BUSTO     |Bus Time-out Status
S * |        |          |0 = Indicates that there is no any time-out or external clock time-out.
S * |        |          |1 = Indicates that a time-out or external clock time-out occurred.
S * |        |          |In bus busy, the bit indicates the total clock low time-out event occurred otherwise, it indicates the bus idle time-out event occurred.
S * |        |          |Note: Software can write 1 to clear this bit.
S * |[6]     |CLKTO     |Clock Low Cumulate Time-out Status
S * |        |          |0 = Indicates that the cumulative clock low is no any time-out.
S * |        |          |1 = Indicates that the cumulative clock low time-out occurred.
S * |        |          |Note: Software can write 1 to clear this bit.
S * @var I2C_T::PKTSIZE
S * Offset: 0x50  I2C Packet Error Checking Byte Number Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |PLDSIZE   |Transfer Byte Number
S * |        |          |The transmission or receive byte number in one transaction when the PECEN is set.
S * |        |          |The maximum transaction or receive byte is 255 Bytes.
S * @var I2C_T::PKTCRC
S * Offset: 0x54  I2C Packet Error Checking Byte Value Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |PECCRC    |Packet Error Checking Byte Value
S * |        |          |This byte indicates the packet error checking content after transmission or receive byte count by using the C(x) = X8 + X2 + X + 1.
S * |        |          |I t is read only.
S * @var I2C_T::BUSTOUT
S * Offset: 0x58  I2C Bus Management Timer Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |BUSTO     |Bus Management Time-out Value
S * |        |          |Indicate the bus time-out value in bus is IDLE or SCLK low.
S * |        |          |Note: If the user wants to revise the value of BUSTOUT, the TORSTEN (I2C_BUSTCTL[4]) bit shall be set to 1 and clear to 0 first in the BUSEN(I2C_BUSCTL[7]) is set.
S * @var I2C_T::CLKTOUT
S * Offset: 0x5C  I2C Bus Management Clock Low Timer Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |CLKTO     |Bus Clock Low Timer
S * |        |          |The field is used to configure the cumulative clock extension time-out.
S * |        |          |Note: If the user wants to revise the value of CLKLTOUT, the TORSTEN bit shall be set to 1 and d clear to 0 first in the BUSEN is set.
S    */
S
S    __IO uint32_t CTL;           /* Offset: 0x00  I2C Control Register                                               */
S    __IO uint32_t ADDR0;         /* Offset: 0x04  I2C Slave Address Register0                                        */
S    __IO uint32_t DAT;           /* Offset: 0x08  I2C Data Register                                                  */
S    __I  uint32_t STATUS;        /* Offset: 0x0C  I2C Status Register                                                */
S    __IO uint32_t CLKDIV;        /* Offset: 0x10  I2C Clock Divided Register                                         */
S    __IO uint32_t TOCTL;         /* Offset: 0x14  I2C Time-out Control Register                                      */
S    __IO uint32_t ADDR1;         /* Offset: 0x18  I2C Slave Address Register1                                        */
S    __IO uint32_t ADDR2;         /* Offset: 0x1C  I2C Slave Address Register2                                        */
S    __IO uint32_t ADDR3;         /* Offset: 0x20  I2C Slave Address Register3                                        */
S    __IO uint32_t ADDRMSK0;      /* Offset: 0x24  I2C Slave Address Mask Register0                                   */
S    __IO uint32_t ADDRMSK1;      /* Offset: 0x28  I2C Slave Address Mask Register1                                   */
S    __IO uint32_t ADDRMSK2;      /* Offset: 0x2C  I2C Slave Address Mask Register2                                   */
S    __IO uint32_t ADDRMSK3;      /* Offset: 0x30  I2C Slave Address Mask Register3                                   */
S    __I  uint32_t RESERVE0[2];  
S    __IO uint32_t WKCTL;         /* Offset: 0x3C  I2C Wake-up Control Register                                       */
S    __IO uint32_t WKSTS;         /* Offset: 0x40  I2C Wake-up Status Register                                        */
S    __IO uint32_t BUSCTL;        /* Offset: 0x44  I2C Bus Management Control Register                                */
S    __IO uint32_t BUSTCTL;       /* Offset: 0x48  I2C Bus Management Timer Control Register                          */
S    __IO uint32_t BUSSTS;        /* Offset: 0x4C  I2C Bus Management Status Register                                 */
S    __IO uint32_t PKTSIZE;       /* Offset: 0x50  I2C Packet Error Checking Byte Number Register                     */
S    __I  uint32_t PKTCRC;        /* Offset: 0x54  I2C Packet Error Checking Byte Value Register                      */
S    __IO uint32_t BUSTOUT;       /* Offset: 0x58  I2C Bus Management Timer Register                                  */
S    __IO uint32_t CLKTOUT;       /* Offset: 0x5C  I2C Bus Management Clock Low Timer Register                        */
S
S} I2C_T;
S
S
S
S/**
S    @addtogroup I2C_CONST I2C Bit Field Definition
S    Constant Definitions for I2C Controller
S@{ */
S
S#define I2C_CTL_AA_Pos                   (2)                                               /*!< I2C_T::CTL: AA Position                   */
S#define I2C_CTL_AA_Msk                   (0x1ul << I2C_CTL_AA_Pos)                         /*!< I2C_T::CTL: AA Mask                       */
S
S#define I2C_CTL_SI_Pos                   (3)                                               /*!< I2C_T::CTL: SI Position                   */
S#define I2C_CTL_SI_Msk                   (0x1ul << I2C_CTL_SI_Pos)                         /*!< I2C_T::CTL: SI Mask                       */
S
S#define I2C_CTL_STO_Pos                  (4)                                               /*!< I2C_T::CTL: STO Position                  */
S#define I2C_CTL_STO_Msk                  (0x1ul << I2C_CTL_STO_Pos)                        /*!< I2C_T::CTL: STO Mask                      */
S
S#define I2C_CTL_STA_Pos                  (5)                                               /*!< I2C_T::CTL: STA Position                  */
S#define I2C_CTL_STA_Msk                  (0x1ul << I2C_CTL_STA_Pos)                        /*!< I2C_T::CTL: STA Mask                      */
S
S#define I2C_CTL_I2CEN_Pos                (6)                                               /*!< I2C_T::CTL: I2CEN Position                */
S#define I2C_CTL_I2CEN_Msk                (0x1ul << I2C_CTL_I2CEN_Pos)                      /*!< I2C_T::CTL: I2CEN Mask                    */
S
S#define I2C_CTL_INTEN_Pos                (7)                                               /*!< I2C_T::CTL: INTEN Position                */
S#define I2C_CTL_INTEN_Msk                (0x1ul << I2C_CTL_INTEN_Pos)                      /*!< I2C_T::CTL: INTEN Mask                    */
S
S#define I2C_ADDR0_GC_Pos                 (0)                                               /*!< I2C_T::ADDR0: GC Position                 */
S#define I2C_ADDR0_GC_Msk                 (0x1ul << I2C_ADDR0_GC_Pos)                       /*!< I2C_T::ADDR0: GC Mask                     */
S
S#define I2C_ADDR0_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR0: ADDR Position               */
S#define I2C_ADDR0_ADDR_Msk               (0x7ful << I2C_ADDR0_ADDR_Pos)                    /*!< I2C_T::ADDR0: ADDR Mask                   */
S
S#define I2C_DAT_DAT_Pos                  (0)                                               /*!< I2C_T::DAT: DAT Position                  */
S#define I2C_DAT_DAT_Msk                  (0xfful << I2C_DAT_DAT_Pos)                       /*!< I2C_T::DAT: DAT Mask                      */
S
S#define I2C_STATUS_STATUS_Pos            (0)                                               /*!< I2C_T::STATUS: STATUS Position            */
S#define I2C_STATUS_STATUS_Msk            (0xfful << I2C_STATUS_STATUS_Pos)                 /*!< I2C_T::STATUS: STATUS Mask                */
S
S#define I2C_CLKDIV_DIVIDER_Pos           (0)                                               /*!< I2C_T::CLKDIV: DIVIDER Position           */
S#define I2C_CLKDIV_DIVIDER_Msk           (0xfful << I2C_CLKDIV_DIVIDER_Pos)                /*!< I2C_T::CLKDIV: DIVIDER Mask               */
S
S#define I2C_TOCTL_TOIF_Pos               (0)                                               /*!< I2C_T::TOCTL: TOIF Position               */
S#define I2C_TOCTL_TOIF_Msk               (0x1ul << I2C_TOCTL_TOIF_Pos)                     /*!< I2C_T::TOCTL: TOIF Mask                   */
S
S#define I2C_TOCTL_TOCDIV4_Pos            (1)                                               /*!< I2C_T::TOCTL: TOCDIV4 Position            */
S#define I2C_TOCTL_TOCDIV4_Msk            (0x1ul << I2C_TOCTL_TOCDIV4_Pos)                  /*!< I2C_T::TOCTL: TOCDIV4 Mask                */
S
S#define I2C_TOCTL_TOCEN_Pos              (2)                                               /*!< I2C_T::TOCTL: TOCEN Position              */
S#define I2C_TOCTL_TOCEN_Msk              (0x1ul << I2C_TOCTL_TOCEN_Pos)                    /*!< I2C_T::TOCTL: TOCEN Mask                  */
S
S#define I2C_ADDR1_GC_Pos                 (0)                                               /*!< I2C_T::ADDR1: GC Position                 */
S#define I2C_ADDR1_GC_Msk                 (0x1ul << I2C_ADDR1_GC_Pos)                       /*!< I2C_T::ADDR1: GC Mask                     */
S
S#define I2C_ADDR1_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR1: ADDR Position               */
S#define I2C_ADDR1_ADDR_Msk               (0x7ful << I2C_ADDR1_ADDR_Pos)                    /*!< I2C_T::ADDR1: ADDR Mask                   */
S
S#define I2C_ADDR2_GC_Pos                 (0)                                               /*!< I2C_T::ADDR2: GC Position                 */
S#define I2C_ADDR2_GC_Msk                 (0x1ul << I2C_ADDR2_GC_Pos)                       /*!< I2C_T::ADDR2: GC Mask                     */
S
S#define I2C_ADDR2_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR2: ADDR Position               */
S#define I2C_ADDR2_ADDR_Msk               (0x7ful << I2C_ADDR2_ADDR_Pos)                    /*!< I2C_T::ADDR2: ADDR Mask                   */
S
S#define I2C_ADDR3_GC_Pos                 (0)                                               /*!< I2C_T::ADDR3: GC Position                 */
S#define I2C_ADDR3_GC_Msk                 (0x1ul << I2C_ADDR3_GC_Pos)                       /*!< I2C_T::ADDR3: GC Mask                     */
S
S#define I2C_ADDR3_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR3: ADDR Position               */
S#define I2C_ADDR3_ADDR_Msk               (0x7ful << I2C_ADDR3_ADDR_Pos)                    /*!< I2C_T::ADDR3: ADDR Mask                   */
S
S#define I2C_ADDRMSK0_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK0: ADDRMSK Position         */
S#define I2C_ADDRMSK0_ADDRMSK_Msk         (0x7ful << I2C_ADDRMSK0_ADDRMSK_Pos)              /*!< I2C_T::ADDRMSK0: ADDRMSK Mask             */
S
S#define I2C_ADDRMSK1_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK1: ADDRMSK Position         */
S#define I2C_ADDRMSK1_ADDRMSK_Msk         (0x7ful << I2C_ADDRMSK1_ADDRMSK_Pos)              /*!< I2C_T::ADDRMSK1: ADDRMSK Mask             */
S
S#define I2C_ADDRMSK2_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK2: ADDRMSK Position         */
S#define I2C_ADDRMSK2_ADDRMSK_Msk         (0x7ful << I2C_ADDRMSK2_ADDRMSK_Pos)              /*!< I2C_T::ADDRMSK2: ADDRMSK Mask             */
S
S#define I2C_ADDRMSK3_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK3: ADDRMSK Position         */
S#define I2C_ADDRMSK3_ADDRMSK_Msk         (0x7ful << I2C_ADDRMSK3_ADDRMSK_Pos)              /*!< I2C_T::ADDRMSK3: ADDRMSK Mask             */
S
S#define I2C_WKCTL_WKEN_Pos               (0)                                               /*!< I2C_T::WKCTL: WKEN Position               */
S#define I2C_WKCTL_WKEN_Msk               (0x1ul << I2C_WKCTL_WKEN_Pos)                     /*!< I2C_T::WKCTL: WKEN Mask                   */
S
S#define I2C_WKSTS_WKIF_Pos               (0)                                               /*!< I2C_T::WKSTS: WKIF Position               */
S#define I2C_WKSTS_WKIF_Msk               (0x1ul << I2C_WKSTS_WKIF_Pos)                     /*!< I2C_T::WKSTS: WKIF Mask                   */
S
S#define I2C_BUSCTL_ACKMEN_Pos            (0)                                               /*!< I2C_T::BUSCTL: ACKMEN Position            */
S#define I2C_BUSCTL_ACKMEN_Msk            (0x1ul << I2C_BUSCTL_ACKMEN_Pos)                  /*!< I2C_T::BUSCTL: ACKMEN Mask                */
S
S#define I2C_BUSCTL_PECEN_Pos             (1)                                               /*!< I2C_T::BUSCTL: PECEN Position             */
S#define I2C_BUSCTL_PECEN_Msk             (0x1ul << I2C_BUSCTL_PECEN_Pos)                   /*!< I2C_T::BUSCTL: PECEN Mask                 */
S
S#define I2C_BUSCTL_BMDEN_Pos             (2)                                               /*!< I2C_T::BUSCTL: BMDEN Position             */
S#define I2C_BUSCTL_BMDEN_Msk             (0x1ul << I2C_BUSCTL_BMDEN_Pos)                   /*!< I2C_T::BUSCTL: BMDEN Mask                 */
S
S#define I2C_BUSCTL_BMHEN_Pos             (3)                                               /*!< I2C_T::BUSCTL: BMHEN Position             */
S#define I2C_BUSCTL_BMHEN_Msk             (0x1ul << I2C_BUSCTL_BMHEN_Pos)                   /*!< I2C_T::BUSCTL: BMHEN Mask                 */
S
S#define I2C_BUSCTL_ALERTEN_Pos           (4)                                               /*!< I2C_T::BUSCTL: ALERTEN Position           */
S#define I2C_BUSCTL_ALERTEN_Msk           (0x1ul << I2C_BUSCTL_ALERTEN_Pos)                 /*!< I2C_T::BUSCTL: ALERTEN Mask               */
S
S#define I2C_BUSCTL_SCTLOSTS_Pos          (5)                                               /*!< I2C_T::BUSCTL: SCTLOSTS Position          */
S#define I2C_BUSCTL_SCTLOSTS_Msk          (0x1ul << I2C_BUSCTL_SCTLOSTS_Pos)                /*!< I2C_T::BUSCTL: SCTLOSTS Mask              */
S
S#define I2C_BUSCTL_SCTLOEN_Pos           (6)                                               /*!< I2C_T::BUSCTL: SCTLOEN Position           */
S#define I2C_BUSCTL_SCTLOEN_Msk           (0x1ul << I2C_BUSCTL_SCTLOEN_Pos)                 /*!< I2C_T::BUSCTL: SCTLOEN Mask               */
S
S#define I2C_BUSCTL_BUSEN_Pos             (7)                                               /*!< I2C_T::BUSCTL: BUSEN Position             */
S#define I2C_BUSCTL_BUSEN_Msk             (0x1ul << I2C_BUSCTL_BUSEN_Pos)                   /*!< I2C_T::BUSCTL: BUSEN Mask                 */
S
S#define I2C_BUSCTL_PECTXEN_Pos           (8)                                               /*!< I2C_T::BUSCTL: PECTXEN Position           */
S#define I2C_BUSCTL_PECTXEN_Msk           (0x1ul << I2C_BUSCTL_PECTXEN_Pos)                 /*!< I2C_T::BUSCTL: PECTXEN Mask               */
S
S#define I2C_BUSCTL_TIDLE_Pos             (9)                                               /*!< I2C_T::BUSCTL: TIDLE Position             */
S#define I2C_BUSCTL_TIDLE_Msk             (0x1ul << I2C_BUSCTL_TIDLE_Pos)                   /*!< I2C_T::BUSCTL: TIDLE Mask                 */
S
S#define I2C_BUSCTL_PECCLR_Pos            (10)                                              /*!< I2C_T::BUSCTL: PECCLR Position            */
S#define I2C_BUSCTL_PECCLR_Msk            (0x1ul << I2C_BUSCTL_PECCLR_Pos)                  /*!< I2C_T::BUSCTL: PECCLR Mask                */
S
S#define I2C_BUSCTL_ACKM9SI_Pos           (11)                                              /*!< I2C_T::BUSCTL: ACKM9SI Position           */
S#define I2C_BUSCTL_ACKM9SI_Msk           (0x1ul << I2C_BUSCTL_ACKM9SI_Pos)                 /*!< I2C_T::BUSCTL: ACKM9SI Mask               */
S
S#define I2C_BUSTCTL_BUSTOEN_Pos          (0)                                               /*!< I2C_T::BUSTCTL: BUSTOEN Position          */
S#define I2C_BUSTCTL_BUSTOEN_Msk          (0x1ul << I2C_BUSTCTL_BUSTOEN_Pos)                /*!< I2C_T::BUSTCTL: BUSTOEN Mask              */
S
S#define I2C_BUSTCTL_CLKTOEN_Pos          (1)                                               /*!< I2C_T::BUSTCTL: CLKTOEN Position          */
S#define I2C_BUSTCTL_CLKTOEN_Msk          (0x1ul << I2C_BUSTCTL_CLKTOEN_Pos)                /*!< I2C_T::BUSTCTL: CLKTOEN Mask              */
S
S#define I2C_BUSTCTL_BUSTOIEN_Pos         (2)                                               /*!< I2C_T::BUSTCTL: BUSTOIEN Position         */
S#define I2C_BUSTCTL_BUSTOIEN_Msk         (0x1ul << I2C_BUSTCTL_BUSTOIEN_Pos)               /*!< I2C_T::BUSTCTL: BUSTOIEN Mask             */
S
S#define I2C_BUSTCTL_CLKTOIEN_Pos         (3)                                               /*!< I2C_T::BUSTCTL: CLKTOIEN Position         */
S#define I2C_BUSTCTL_CLKTOIEN_Msk         (0x1ul << I2C_BUSTCTL_CLKTOIEN_Pos)               /*!< I2C_T::BUSTCTL: CLKTOIEN Mask             */
S
S#define I2C_BUSTCTL_TORSTEN_Pos          (4)                                               /*!< I2C_T::BUSTCTL: TORSTEN Position          */
S#define I2C_BUSTCTL_TORSTEN_Msk          (0x1ul << I2C_BUSTCTL_TORSTEN_Pos)                /*!< I2C_T::BUSTCTL: TORSTEN Mask              */
S
S#define I2C_BUSTCTL_PECIEN_Pos           (5)                                               /*!< I2C_T::BUSTCTL: PECIEN Position           */
S#define I2C_BUSTCTL_PECIEN_Msk           (0x1ul << I2C_BUSTCTL_PECIEN_Pos)                 /*!< I2C_T::BUSTCTL: PECIEN Mask               */
S
S#define I2C_BUSSTS_BUSY_Pos              (0)                                               /*!< I2C_T::BUSSTS: BUSY Position              */
S#define I2C_BUSSTS_BUSY_Msk              (0x1ul << I2C_BUSSTS_BUSY_Pos)                    /*!< I2C_T::BUSSTS: BUSY Mask                  */
S
S#define I2C_BUSSTS_BCDONE_Pos            (1)                                               /*!< I2C_T::BUSSTS: BCDONE Position            */
S#define I2C_BUSSTS_BCDONE_Msk            (0x1ul << I2C_BUSSTS_BCDONE_Pos)                  /*!< I2C_T::BUSSTS: BCDONE Mask                */
S
S#define I2C_BUSSTS_PECERR_Pos            (2)                                               /*!< I2C_T::BUSSTS: PECERR Position            */
S#define I2C_BUSSTS_PECERR_Msk            (0x1ul << I2C_BUSSTS_PECERR_Pos)                  /*!< I2C_T::BUSSTS: PECERR Mask                */
S
S#define I2C_BUSSTS_ALERT_Pos             (3)                                               /*!< I2C_T::BUSSTS: ALERT Position             */
S#define I2C_BUSSTS_ALERT_Msk             (0x1ul << I2C_BUSSTS_ALERT_Pos)                   /*!< I2C_T::BUSSTS: ALERT Mask                 */
S
S#define I2C_BUSSTS_SCTLDIN_Pos           (4)                                               /*!< I2C_T::BUSSTS: SCTLDIN Position           */
S#define I2C_BUSSTS_SCTLDIN_Msk           (0x1ul << I2C_BUSSTS_SCTLDIN_Pos)                 /*!< I2C_T::BUSSTS: SCTLDIN Mask               */
S
S#define I2C_BUSSTS_BUSTO_Pos             (5)                                               /*!< I2C_T::BUSSTS: BUSTO Position             */
S#define I2C_BUSSTS_BUSTO_Msk             (0x1ul << I2C_BUSSTS_BUSTO_Pos)                   /*!< I2C_T::BUSSTS: BUSTO Mask                 */
S
S#define I2C_BUSSTS_CLKTO_Pos             (6)                                               /*!< I2C_T::BUSSTS: CLKTO Position             */
S#define I2C_BUSSTS_CLKTO_Msk             (0x1ul << I2C_BUSSTS_CLKTO_Pos)                   /*!< I2C_T::BUSSTS: CLKTO Mask                 */
S
S#define I2C_PKTSIZE_PLDSIZE_Pos          (0)                                               /*!< I2C_T::PKTSIZE: PLDSIZE Position          */
S#define I2C_PKTSIZE_PLDSIZE_Msk          (0xfful << I2C_PKTSIZE_PLDSIZE_Pos)               /*!< I2C_T::PKTSIZE: PLDSIZE Mask              */
S
S#define I2C_PKTCRC_PECCRC_Pos            (0)                                               /*!< I2C_T::PKTCRC: PECCRC Position            */
S#define I2C_PKTCRC_PECCRC_Msk            (0xfful << I2C_PKTCRC_PECCRC_Pos)                 /*!< I2C_T::PKTCRC: PECCRC Mask                */
S
S#define I2C_BUSTOUT_BUSTO_Pos            (0)                                               /*!< I2C_T::BUSTOUT: BUSTO Position            */
S#define I2C_BUSTOUT_BUSTO_Msk            (0xfful << I2C_BUSTOUT_BUSTO_Pos)                 /*!< I2C_T::BUSTOUT: BUSTO Mask                */
S
S#define I2C_CLKTOUT_CLKTO_Pos            (0)                                               /*!< I2C_T::CLKTOUT: CLKTO Position            */
S#define I2C_CLKTOUT_CLKTO_Msk            (0xfful << I2C_CLKTOUT_CLKTO_Pos)                 /*!< I2C_T::CLKTOUT: CLKTO Mask                */
S
S
S/**@}*/ /* I2C_CONST */
S/**@}*/ /* end of I2C register group */
S
S/*---------------------- USB On-The-Go Controller -------------------------*/
S/**
S    @addtogroup OTG USB On-The-Go Controller(OTG)
S    Memory Mapped Structure for OTG Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S/**
S * @var OTG_T::CTL
S * Offset: 0x00  OTG Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |VBUSDROP  |Drop VBUS Control
S * |        |          |If user application running on this OTG A-device wants to conserve power, set this bit to drop VBUS.
S * |        |          |BUSREQ (OTG_CTL[1]) will be also cleared no matter A-device or B-device.
S * |        |          |0 = Not drop the VBUS.
S * |        |          |1 = Drop the VBUS.
S * |[1]     |BUSREQ    |OTG Bus Request
S * |        |          |If OTG A-device wants to do data transfers via USB bus, setting this bit will drive VBUS high to detect USB device connection.
S * |        |          |If user won't use the bus any more, clearing this bit will drop VBUS to save power.
S * |        |          |This bit will be cleared when A-device goes to A_wait_vfall state. A_wait_vfall state is defined in OTG specification.
S * |        |          |This bit will be also cleared if VBUSDROP (OTG_CTL[0]) bit is set or IDSTS (OTG_STATUS[1]) changed.
S * |        |          |If user of an OTG-B Device wants to request VBUS, setting this bit will run SRP protocol.
S * |        |          |This bit will be cleared if SRP failure (OTG A-device does not provide VBUS after B-device issues ARP in specified interval, defined in OTG specification).
S * |        |          |This bit will be also cleared if VBUSDROP (OTG_CTL[0]) bit is set IDSTS (OTG_STATUS[1]) changed.
S * |        |          |0 = Not launch VBUS in OTG A-device or not request SRP in OTG B-device.
S * |        |          |1 = Launch VBUS in OTG A-device or request SRP in OTG B-device.
S * |[2]     |HNPREQEN  |OTG HNP Request Enable Bit
S * |        |          |When USB frame as A-device, set this bit when A-device allows to process Host Negotiation Protocol.
S * |        |          |This bit will be cleared when OTG state changes from a_suspend to a_peripheral or goes back to a_idle state.
S * |        |          |When USB frame is as B-device, set this bit after the OTG A-device successfully sends a SetFeature (b_hnp_enable) command to the OTG B-device to start role change.
S * |        |          |This bit will be cleared when OTG state changes from b_peripheral to b_wait_acon or goes back to b_idle state.
S * |        |          |0 = HNP request Disabled.
S * |        |          |1 = HNP request Enabled (A-device can change role from Host to Peripheral or B-device can change role from Peripheral to Host).
S * |        |          |Note: Refer to OTG specification to get a_suspend, a_peripheral, a_idle and b_idle state.
S * |[4]     |OTGEN     |OTG Function Enable Bit
S * |        |          |User needs to set this bit to enable OTG function while USB frame configured as OTG device.
S * |        |          |When USB frame not configured as OTG device, this bit is must be low.
S * |        |          |0 = OTG function Disabled.
S * |        |          |1 = OTG function Enabled.
S * |[5]     |WKEN      |OTG ID Pin Wake-Up Enable Bit
S * |        |          |0 = OTG ID pin status change wake-up function Disabled.
S * |        |          |1 = OTG ID pin status change wake-up function Enabled.
S * @var OTG_T::PHYCTL
S * Offset: 0x04  OTG PHY Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |OTGPHYEN  |OTG PHY Enable
S * |        |          |When USB frame is configured as OTG-device, user needs to set this bit before using OTG function.
S * |        |          |If device is not configured as OTG-device, this bit is "don't care".
S * |        |          |0 = OTG PHY Disabled.
S * |        |          |1 = OTG PHY Enabled.
S * |[1]     |IDDETEN   |ID Detection Enable Bit
S * |        |          |0 = Detect ID pin status Disabled.
S * |        |          |1 = Detect ID pin status Enabled.
S * |[4]     |VBENPOL   |Off-Chip USB VBUS Power Switch Enable Polarity
S * |        |          |The OTG controller will enable off-chip USB VBUS power switch to provide VBUS power when need.
S * |        |          |A USB_VBUS_EN pin is used to control the off-chip USB VBUS power switch.
S * |        |          |The polarity of enabling off-chip USB VBUS power switch (high active or low active) depends on the selected component.
S * |        |          |Set this bit as following according to the polarity of off-chip USB VBUS power switch.
S * |        |          |0 = The off-chip USB VBUS power switch enable is active high.
S * |        |          |1 = The off-chip USB VBUS power switch enable is active low.
S * |[5]     |VBSTSPOL  |Off-Chip USB VBUS Power Switch Status Polarity
S * |        |          |The polarity of off-chip USB VBUS power switch valid signal depends on the selected component.
S * |        |          |A USB_VBUS_ST pin is used to monitor the valid signal of the off-chip USB VBUS power switch.
S * |        |          |Set this bit as following according to the polarity of off-chip USB VBUS power switch.
S * |        |          |0 = The polarity of off-chip USB VBUS power switch valid status is high.
S * |        |          |1 = The polarity of off-chip USB VBUS power switch valid status is low.
S * @var OTG_T::INTEN
S * Offset: 0x08  OTG Interrupt Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ROLECHGIEN|Role (Host Or Peripheral) Changed Interrupt Enable Bit
S * |        |          |0 = Interrupt Disabled.
S * |        |          |1 = Interrupt Enabled.
S * |[1]     |VBEIEN    |VBUS Error Interrupt Enable Bit
S * |        |          |0 = Interrupt Disabled.
S * |        |          |1 = Interrupt Enabled.
S * |        |          |Note: VBUS error means going to a_vbus_err state. Please refer to A-device state diagram in OTG spec.
S * |[2]     |SRPFIEN   |SRP Fail Interrupt Enable Bit
S * |        |          |0 = Interrupt Disabled.
S * |        |          |1 = Interrupt Enabled.
S * |[3]     |HNPFIEN   |HNP Fail Interrupt Enable Bit
S * |        |          |0 = Interrupt Disabled.
S * |        |          |1 = Interrupt Enabled.
S * |[4]     |GOIDLEIEN |OTG Device Goes to IDLE State Interrupt Enable Bit
S * |        |          |0 = Interrupt Disabled.
S * |        |          |1 = Interrupt Enabled.
S * |        |          |Note: Going to idle state means going to a_idle or b_idle state.
S * |        |          |Please refer to A-device state diagram and B-device state diagram in OTG spec.
S * |[5]     |IDCHGIEN  |IDSTS Changed Interrupt Enable Bit
S * |        |          |If this bit is set to 1 and IDSTS (OTG_STATUS[1]) status is changed from high to low or from low to high, a interrupt will be asserted.
S * |        |          |0 = Interrupt Disabled.
S * |        |          |1 = Interrupt Enabled.
S * |[6]     |PDEVIEN   |Act As Peripheral Interrupt Enable Bit
S * |        |          |If this bit is set to 1 and the device is changed as a peripheral, a interrupt will be asserted.
S * |        |          |0 = This device as a peripheral interrupt Disabled.
S * |        |          |1 = This device as a peripheral interrupt Enabled.
S * |[7]     |HOSTIEN   |Act As Host Interrupt Enable Bit
S * |        |          |If this bit is set to 1 and the device is changed as a host, a interrupt will be asserted.
S * |        |          |0 = This device as a host interrupt Disabled.
S * |        |          |1 = This device as a host interrupt Enabled.
S * |[8]     |BVLDCHGIEN|B-Device Session Valid Status Changed Interrupt Enable Bit
S * |        |          |If this bit is set to 1 and BVLD (OTG_STATUS[3]) status is changed from high to low or from low to high, a interrupt will be asserted.
S * |        |          |0 = Interrupt Disabled.
S * |        |          |1 = Interrupt Enabled.
S * |[9]     |AVLDCHGIEN|A-Device Session Valid Status Changed Interrupt Enable Bit
S * |        |          |If this bit is set to 1 and AVLD (OTG_STATUS[4]) status is changed from high to low or from low to high, a interrupt will be asserted.
S * |        |          |0 = Interrupt Disabled.
S * |        |          |1 = Interrupt Enabled.
S * |[10]    |VBCHGIEN  |VBUSVLD Status Changed
S * |        |          |Interrupt Enable Bit
S * |        |          |If this bit is set to 1 and VBUSVLD (OTG_STATUS[5]) status is changed from high to low or from low to high, a interrupt will be asserted.
S * |        |          |0 = Interrupt Disabled.
S * |        |          |1 = Interrupt Enabled.
S * |[11]    |SECHGIEN  |SESSEND Status Changed Interrupt Enable Bit
S * |        |          |If this bit is set to 1 and SESSEND (OTG_STATUS[2]) status is changed from high to low or from low to high, a interrupt will be asserted.
S * |        |          |0 = Interrupt Disabled.
S * |        |          |1 = Interrupt Enabled.
S * |[13]    |SRPDETIEN |SRP Detected Interrupt Enable Bit
S * |        |          |0 = Interrupt Disabled.
S * |        |          |1 = Interrupt Enabled.
S * @var OTG_T::INTSTS
S * Offset: 0x0C  OTG Interrupt Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ROLECHGIF |OTG Role Change Interrupt Status
S * |        |          |This flag is set when the role of an OTG device changed from a host to a peripheral, or changed from a peripheral to a host while USB_ID pin status does not change.
S * |        |          |0 = OTG device role not changed.
S * |        |          |1 = OTG device role changed.
S * |        |          |Note: Write 1 to clear this flag.
S * |[1]     |VBEIF     |VBUS Error Interrupt Status
S * |        |          |This bit will be set when voltage on VBUS cannot reach a minimum valid threshold 4.4V within a maximum time of 100ms after OTG A-device starting to drive VBUS high.
S * |        |          |0 = OTG A-device drives VBUS over threshold voltage before this interval expires.
S * |        |          |1 = OTG A-device cannot drive VBUS over threshold voltage before this interval expires.
S * |        |          |Note: Write 1 to clear this flag and recover from the VBUS error state.
S * |[2]     |SRPFIF    |SRP Fail Interrupt Status
S * |        |          |After initiating SRP, an OTG B-device will wait for the OTG A-device to drive VBUS high at least TB_SRP_FAIL minimum, defined in OTG specification.
S * |        |          |This flag is set when the OTG B-device does not get VBUS high after this interval.
S * |        |          |0 = OTG B-device gets VBUS high before this interval.
S * |        |          |1 = OTG B-device does not get VBUS high before this interval.
S * |        |          |Note: Write 1 to clear this flag.
S * |[3]     |HNPFIF    |HNP Fail Interrupt Status
S * |        |          |When A-device has granted B-device to be host and USB bus is in SE0 (both USB_D+ and USB_D- low) state, this bit will be set when A-device does not connect after specified interval expires.
S * |        |          |0 = A-device connects to B-device before specified interval expires.
S * |        |          |1 = A-device does not connect to B-device before specified interval expires.
S * |        |          |Note: Write 1 to clear this flag.
S * |[4]     |GOIDLEIF  |OTG Device Goes to IDLE Interrupt Status
S * |        |          |Flag is set if the OTG device transfers from non-idle state to idle state.
S * |        |          |The OTG device will be neither a host nor a peripheral.
S * |        |          |0 = OTG device does not go back to idle state (a_idle or b_idle).
S * |        |          |1 = OTG device goes back to idle state (a_idle or b_idle).
S * |        |          |Note 1: Going to idle state means going to a_idle or b_idle state. Please refer to OTG specification for the details of a_idle state and b_idle state.
S * |        |          |Note 2: Write 1 to clear this flag.
S * |[5]     |IDCHGIF   |ID State Change Interrupt Status
S * |        |          |0 = IDSTS (OTG_STATUS[1]) not toggled.
S * |        |          |1 = IDSTS (OTG_STATUS[1]) from high to low or from low to high.
S * |        |          |Note: Write 1 to clear this flag.
S * |[6]     |PDEVIF    |Act As Peripheral Interrupt Status
S * |        |          |0 = This device does not act as a peripheral.
S * |        |          |1 = This device acts as a peripheral.
S * |        |          |Note: Write 1 to clear this flag.
S * |[7]     |HOSTIF    |Act As Host Interrupt Status
S * |        |          |0 = This device does not act as a host.
S * |        |          |1 = This device acts as a host.
S * |        |          |Note: Write 1 to clear this flag.
S * |[8]     |BVLDCHGIF |B-Device Session Valid State Change Interrupt Status
S * |        |          |0 = BVLD (OTG_STATUS[3]) is not toggled.
S * |        |          |1 = BVLD (OTG_STATUS[3]) from high to low or low to high.
S * |        |          |Note: Write 1 to clear this status.
S * |[9]     |AVLDCHGIF |A-Device Session Valid State Change Interrupt Status
S * |        |          |0 = AVLD (OTG_STATUS[4]) not toggled.
S * |        |          |1 = AVLD (OTG_STATUS[4]) from high to low or low to high.
S * |        |          |Note: Write 1 to clear this status.
S * |[10]    |VBCHGIF   |VBUSVLD State Change Interrupt Status
S * |        |          |0 = VBUSVLD (OTG_STATUS[5]) not toggled.
S * |        |          |1 = VBUSVLD (OTG_STATUS[5]) from high to low or from low to high.
S * |        |          |Note: Write 1 to clear this status.
S * |[11]    |SECHGIF   |SESSEND State Change Interrupt Status
S * |        |          |0 = SESSEND (OTG_STATUS[2]) not toggled.
S * |        |          |1 = SESSEND (OTG_STATUS[2]) from high to low or from low to high.
S * |        |          |Note: Write 1 to clear this flag.
S * |[13]    |SRPDETIF  |SRP Detected Interrupt Status
S * |        |          |0 = SRP not detected.
S * |        |          |1 = SRP detected.
S * |        |          |Note: Write 1 to clear this status.
S * @var OTG_T::STATUS
S * Offset: 0x10  OTG Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |OVERCUR   |Over Current Condition
S * |        |          |The voltage on VBUS cannot reach a minimum VBUS valid threshold, 4.4V minimum, within a maximum time of 100ms after OTG A-device drives VBUS high.
S * |        |          |0 = OTG A-device drives VBUS successfully.
S * |        |          |1 = OTG A-device cannot drives VBUS high in this interval.
S * |[1]     |IDSTS     |USB_ID Pin State Of Mini-B/Micro-Plug
S * |        |          |0 = Mini-A/Micro-A plug is attached.
S * |        |          |1 = Mini-B/Micro-B plug is attached.
S * |[2]     |SESSEND   |Session End Status
S * |        |          |When VBUS voltage is lower than 0.4V, this bit will be set to 1.
S * |        |          |Session end means no meaningful power on VBUS.
S * |        |          |0 = Session is not end.
S * |        |          |1 = Session is end.
S * |[3]     |BVLD      |B-Device Session Valid Status
S * |        |          |0 = B-device session is not valid.
S * |        |          |1 = B-device session is valid.
S * |[4]     |AVLD      |A-Device Session Valid Status
S * |        |          |0 = A-device session is not valid.
S * |        |          |1 = A-device session is valid.
S * |[5]     |VBUSVLD   |VBUS Valid Status
S * |        |          |When VBUS is larger than 4.7V, this bit will be set to 1.
S * |        |          |0 = VBUS is not valid.
S * |        |          |1 = VBUS is valid.
S */
S
S    __IO uint32_t CTL;           /* Offset: 0x00  OTG Control Register                                               */
S    __IO uint32_t PHYCTL;        /* Offset: 0x04  OTG PHY Control Register                                           */
S    __IO uint32_t INTEN;         /* Offset: 0x08  OTG Interrupt Enable Register                                      */
S    __IO uint32_t INTSTS;        /* Offset: 0x0C  OTG Interrupt Status Register                                      */
S    __I  uint32_t STATUS;        /* Offset: 0x10  OTG Status Register                                                */
S
S} OTG_T;
S
S
S
S/**
S    @addtogroup OTG_CONST OTG Bit Field Definition
S    Constant Definitions for OTG Controller
S@{ */
S
S#define OTG_CTL_VBUSDROP_Pos             (0)                                               /*!< OTG_T::CTL: VBUSDROP Position             */
S#define OTG_CTL_VBUSDROP_Msk             (0x1ul << OTG_CTL_VBUSDROP_Pos)                   /*!< OTG_T::CTL: VBUSDROP Mask                 */
S
S#define OTG_CTL_BUSREQ_Pos               (1)                                               /*!< OTG_T::CTL: BUSREQ Position               */
S#define OTG_CTL_BUSREQ_Msk               (0x1ul << OTG_CTL_BUSREQ_Pos)                     /*!< OTG_T::CTL: BUSREQ Mask                   */
S
S#define OTG_CTL_HNPREQEN_Pos             (2)                                               /*!< OTG_T::CTL: HNPREQEN Position             */
S#define OTG_CTL_HNPREQEN_Msk             (0x1ul << OTG_CTL_HNPREQEN_Pos)                   /*!< OTG_T::CTL: HNPREQEN Mask                 */
S
S#define OTG_CTL_OTGEN_Pos                (4)                                               /*!< OTG_T::CTL: OTGEN Position                */
S#define OTG_CTL_OTGEN_Msk                (0x1ul << OTG_CTL_OTGEN_Pos)                      /*!< OTG_T::CTL: OTGEN Mask                    */
S
S#define OTG_CTL_WKEN_Pos                 (5)                                               /*!< OTG_T::CTL: WKEN Position                 */
S#define OTG_CTL_WKEN_Msk                 (0x1ul << OTG_CTL_WKEN_Pos)                       /*!< OTG_T::CTL: WKEN Mask                     */
S
S#define OTG_PHYCTL_OTGPHYEN_Pos          (0)                                               /*!< OTG_T::PHYCTL: OTGPHYEN Position          */
S#define OTG_PHYCTL_OTGPHYEN_Msk          (0x1ul << OTG_PHYCTL_OTGPHYEN_Pos)                /*!< OTG_T::PHYCTL: OTGPHYEN Mask              */
S
S#define OTG_PHYCTL_IDDETEN_Pos           (1)                                               /*!< OTG_T::PHYCTL: IDDETEN Position           */
S#define OTG_PHYCTL_IDDETEN_Msk           (0x1ul << OTG_PHYCTL_IDDETEN_Pos)                 /*!< OTG_T::PHYCTL: IDDETEN Mask               */
S
S#define OTG_PHYCTL_VBENPOL_Pos           (4)                                               /*!< OTG_T::PHYCTL: VBENPOL Position           */
S#define OTG_PHYCTL_VBENPOL_Msk           (0x1ul << OTG_PHYCTL_VBENPOL_Pos)                 /*!< OTG_T::PHYCTL: VBENPOL Mask               */
S
S#define OTG_PHYCTL_VBSTSPOL_Pos          (5)                                               /*!< OTG_T::PHYCTL: VBSTSPOL Position          */
S#define OTG_PHYCTL_VBSTSPOL_Msk          (0x1ul << OTG_PHYCTL_VBSTSPOL_Pos)                /*!< OTG_T::PHYCTL: VBSTSPOL Mask              */
S
S#define OTG_INTEN_ROLECHGIEN_Pos         (0)                                               /*!< OTG_T::INTEN: ROLECHGIEN Position         */
S#define OTG_INTEN_ROLECHGIEN_Msk         (0x1ul << OTG_INTEN_ROLECHGIEN_Pos)               /*!< OTG_T::INTEN: ROLECHGIEN Mask             */
S
S#define OTG_INTEN_VBEIEN_Pos             (1)                                               /*!< OTG_T::INTEN: VBEIEN Position             */
S#define OTG_INTEN_VBEIEN_Msk             (0x1ul << OTG_INTEN_VBEIEN_Pos)                   /*!< OTG_T::INTEN: VBEIEN Mask                 */
S
S#define OTG_INTEN_SRPFIEN_Pos            (2)                                               /*!< OTG_T::INTEN: SRPFIEN Position            */
S#define OTG_INTEN_SRPFIEN_Msk            (0x1ul << OTG_INTEN_SRPFIEN_Pos)                  /*!< OTG_T::INTEN: SRPFIEN Mask                */
S
S#define OTG_INTEN_HNPFIEN_Pos            (3)                                               /*!< OTG_T::INTEN: HNPFIEN Position            */
S#define OTG_INTEN_HNPFIEN_Msk            (0x1ul << OTG_INTEN_HNPFIEN_Pos)                  /*!< OTG_T::INTEN: HNPFIEN Mask                */
S
S#define OTG_INTEN_GOIDLEIEN_Pos          (4)                                               /*!< OTG_T::INTEN: GOIDLEIEN Position          */
S#define OTG_INTEN_GOIDLEIEN_Msk          (0x1ul << OTG_INTEN_GOIDLEIEN_Pos)                /*!< OTG_T::INTEN: GOIDLEIEN Mask              */
S
S#define OTG_INTEN_IDCHGIEN_Pos           (5)                                               /*!< OTG_T::INTEN: IDCHGIEN Position           */
S#define OTG_INTEN_IDCHGIEN_Msk           (0x1ul << OTG_INTEN_IDCHGIEN_Pos)                 /*!< OTG_T::INTEN: IDCHGIEN Mask               */
S
S#define OTG_INTEN_PDEVIEN_Pos            (6)                                               /*!< OTG_T::INTEN: PDEVIEN Position            */
S#define OTG_INTEN_PDEVIEN_Msk            (0x1ul << OTG_INTEN_PDEVIEN_Pos)                  /*!< OTG_T::INTEN: PDEVIEN Mask                */
S
S#define OTG_INTEN_HOSTIEN_Pos            (7)                                               /*!< OTG_T::INTEN: HOSTIEN Position            */
S#define OTG_INTEN_HOSTIEN_Msk            (0x1ul << OTG_INTEN_HOSTIEN_Pos)                  /*!< OTG_T::INTEN: HOSTIEN Mask                */
S
S#define OTG_INTEN_BVLDCHGIEN_Pos         (8)                                               /*!< OTG_T::INTEN: BVLDCHGIEN Position         */
S#define OTG_INTEN_BVLDCHGIEN_Msk         (0x1ul << OTG_INTEN_BVLDCHGIEN_Pos)               /*!< OTG_T::INTEN: BVLDCHGIEN Mask             */
S
S#define OTG_INTEN_AVLDCHGIEN_Pos         (9)                                               /*!< OTG_T::INTEN: AVLDCHGIEN Position         */
S#define OTG_INTEN_AVLDCHGIEN_Msk         (0x1ul << OTG_INTEN_AVLDCHGIEN_Pos)               /*!< OTG_T::INTEN: AVLDCHGIEN Mask             */
S
S#define OTG_INTEN_VBCHGIEN_Pos           (10)                                              /*!< OTG_T::INTEN: VBCHGIEN Position           */
S#define OTG_INTEN_VBCHGIEN_Msk           (0x1ul << OTG_INTEN_VBCHGIEN_Pos)                 /*!< OTG_T::INTEN: VBCHGIEN Mask               */
S
S#define OTG_INTEN_SECHGIEN_Pos           (11)                                              /*!< OTG_T::INTEN: SECHGIEN Position           */
S#define OTG_INTEN_SECHGIEN_Msk           (0x1ul << OTG_INTEN_SECHGIEN_Pos)                 /*!< OTG_T::INTEN: SECHGIEN Mask               */
S
S#define OTG_INTEN_SRPDETIEN_Pos          (13)                                              /*!< OTG_T::INTEN: SRPDETIEN Position          */
S#define OTG_INTEN_SRPDETIEN_Msk          (0x1ul << OTG_INTEN_SRPDETIEN_Pos)                /*!< OTG_T::INTEN: SRPDETIEN Mask              */
S
S#define OTG_INTSTS_ROLECHGIF_Pos         (0)                                               /*!< OTG_T::INTSTS: ROLECHGIF Position         */
S#define OTG_INTSTS_ROLECHGIF_Msk         (0x1ul << OTG_INTSTS_ROLECHGIF_Pos)               /*!< OTG_T::INTSTS: ROLECHGIF Mask             */
S
S#define OTG_INTSTS_VBEIF_Pos             (1)                                               /*!< OTG_T::INTSTS: VBEIF Position             */
S#define OTG_INTSTS_VBEIF_Msk             (0x1ul << OTG_INTSTS_VBEIF_Pos)                   /*!< OTG_T::INTSTS: VBEIF Mask                 */
S
S#define OTG_INTSTS_SRPFIF_Pos            (2)                                               /*!< OTG_T::INTSTS: SRPFIF Position            */
S#define OTG_INTSTS_SRPFIF_Msk            (0x1ul << OTG_INTSTS_SRPFIF_Pos)                  /*!< OTG_T::INTSTS: SRPFIF Mask                */
S
S#define OTG_INTSTS_HNPFIF_Pos            (3)                                               /*!< OTG_T::INTSTS: HNPFIF Position            */
S#define OTG_INTSTS_HNPFIF_Msk            (0x1ul << OTG_INTSTS_HNPFIF_Pos)                  /*!< OTG_T::INTSTS: HNPFIF Mask                */
S
S#define OTG_INTSTS_GOIDLEIF_Pos          (4)                                               /*!< OTG_T::INTSTS: GOIDLEIF Position          */
S#define OTG_INTSTS_GOIDLEIF_Msk          (0x1ul << OTG_INTSTS_GOIDLEIF_Pos)                /*!< OTG_T::INTSTS: GOIDLEIF Mask              */
S
S#define OTG_INTSTS_IDCHGIF_Pos           (5)                                               /*!< OTG_T::INTSTS: IDCHGIF Position           */
S#define OTG_INTSTS_IDCHGIF_Msk           (0x1ul << OTG_INTSTS_IDCHGIF_Pos)                 /*!< OTG_T::INTSTS: IDCHGIF Mask               */
S
S#define OTG_INTSTS_PDEVIF_Pos            (6)                                               /*!< OTG_T::INTSTS: PDEVIF Position            */
S#define OTG_INTSTS_PDEVIF_Msk            (0x1ul << OTG_INTSTS_PDEVIF_Pos)                  /*!< OTG_T::INTSTS: PDEVIF Mask                */
S
S#define OTG_INTSTS_HOSTIF_Pos            (7)                                               /*!< OTG_T::INTSTS: HOSTIF Position            */
S#define OTG_INTSTS_HOSTIF_Msk            (0x1ul << OTG_INTSTS_HOSTIF_Pos)                  /*!< OTG_T::INTSTS: HOSTIF Mask                */
S
S#define OTG_INTSTS_BVLDCHGIF_Pos         (8)                                               /*!< OTG_T::INTSTS: BVLDCHGIF Position         */
S#define OTG_INTSTS_BVLDCHGIF_Msk         (0x1ul << OTG_INTSTS_BVLDCHGIF_Pos)               /*!< OTG_T::INTSTS: BVLDCHGIF Mask             */
S
S#define OTG_INTSTS_AVLDCHGIF_Pos         (9)                                               /*!< OTG_T::INTSTS: AVLDCHGIF Position         */
S#define OTG_INTSTS_AVLDCHGIF_Msk         (0x1ul << OTG_INTSTS_AVLDCHGIF_Pos)               /*!< OTG_T::INTSTS: AVLDCHGIF Mask             */
S
S#define OTG_INTSTS_VBCHGIF_Pos           (10)                                              /*!< OTG_T::INTSTS: VBCHGIF Position           */
S#define OTG_INTSTS_VBCHGIF_Msk           (0x1ul << OTG_INTSTS_VBCHGIF_Pos)                 /*!< OTG_T::INTSTS: VBCHGIF Mask               */
S
S#define OTG_INTSTS_SECHGIF_Pos           (11)                                              /*!< OTG_T::INTSTS: SECHGIF Position           */
S#define OTG_INTSTS_SECHGIF_Msk           (0x1ul << OTG_INTSTS_SECHGIF_Pos)                 /*!< OTG_T::INTSTS: SECHGIF Mask               */
S
S#define OTG_INTSTS_SRPDETIF_Pos          (13)                                              /*!< OTG_T::INTSTS: SRPDETIF Position          */
S#define OTG_INTSTS_SRPDETIF_Msk          (0x1ul << OTG_INTSTS_SRPDETIF_Pos)                /*!< OTG_T::INTSTS: SRPDETIF Mask              */
S
S#define OTG_STATUS_OVERCUR_Pos           (0)                                               /*!< OTG_T::STATUS: OVERCUR Position           */
S#define OTG_STATUS_OVERCUR_Msk           (0x1ul << OTG_STATUS_OVERCUR_Pos)                 /*!< OTG_T::STATUS: OVERCUR Mask               */
S
S#define OTG_STATUS_IDSTS_Pos             (1)                                               /*!< OTG_T::STATUS: IDSTS Position             */
S#define OTG_STATUS_IDSTS_Msk             (0x1ul << OTG_STATUS_IDSTS_Pos)                   /*!< OTG_T::STATUS: IDSTS Mask                 */
S
S#define OTG_STATUS_SESSEND_Pos           (2)                                               /*!< OTG_T::STATUS: SESSEND Position           */
S#define OTG_STATUS_SESSEND_Msk           (0x1ul << OTG_STATUS_SESSEND_Pos)                 /*!< OTG_T::STATUS: SESSEND Mask               */
S
S#define OTG_STATUS_BVLD_Pos              (3)                                               /*!< OTG_T::STATUS: BVLD Position              */
S#define OTG_STATUS_BVLD_Msk              (0x1ul << OTG_STATUS_BVLD_Pos)                    /*!< OTG_T::STATUS: BVLD Mask                  */
S
S#define OTG_STATUS_AVLD_Pos              (4)                                               /*!< OTG_T::STATUS: AVLD Position              */
S#define OTG_STATUS_AVLD_Msk              (0x1ul << OTG_STATUS_AVLD_Pos)                    /*!< OTG_T::STATUS: AVLD Mask                  */
S
S#define OTG_STATUS_VBUSVLD_Pos           (5)                                               /*!< OTG_T::STATUS: VBUSVLD Position           */
S#define OTG_STATUS_VBUSVLD_Msk           (0x1ul << OTG_STATUS_VBUSVLD_Pos)                 /*!< OTG_T::STATUS: VBUSVLD Mask               */
S
S/**@}*/ /* OTG_CONST */
S/**@}*/ /* end of OTG register group */
S
S
S/*---------------------- Peripheral Direct Memory Access Controller -------------------------*/
S/**
S    @addtogroup PDMA Peripheral Direct Memory Access Controller(PDMA)
S    Memory Mapped Structure for PDMA Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S/**
S * @var DSCT_T::CTL
S * Offset: 0x00/0x10/0x20/0x30/0x40/0x50/0x60/0x70/0x80/0x90/0xA0/0xB0  Descriptor Table Control Register of PDMA Channel 0~11
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |OPMODE    |PDMA Operation Mode Selection
S * |        |          |0 = Idle state: Channel is stopped or this table is complete, when PDMA finish channel table task, OPMODE will be cleared to idle state automatically.
S * |        |          |1 = Basic mode: The descriptor table only has one task.
S * |        |          |When this task is finished, the PDMA_INTSTS[x] will be asserted.
S * |        |          |2 = Scatter-Gather mode: When operating in this mode, user must give the next descriptor table address in PDMA_DSCT_NEXT register; PDMA controller will ignore this task, then load the next task to execute.
S * |        |          |3 = Reserved.
S * |        |          |Note: Before filling transfer task in the Descriptor Table, user must check if the descriptor table is complete.
S * |[2]     |TXTYPE    |Transfer Type
S * |        |          |0 = Burst transfer type.
S * |        |          |1 = Single transfer type.
S * |[6:4]   |BURSIZE   |Burst Size
S * |        |          |This field is used for peripheral to determine the burst size or used for determine the re-arbitration size.
S * |        |          |000 = 128 Transfers.
S * |        |          |001 = 64 Transfers.
S * |        |          |010 = 32 Transfers.
S * |        |          |011 = 16 Transfers.
S * |        |          |100 = 8 Transfers.
S * |        |          |101 = 4 Transfers.
S * |        |          |110 = 2 Transfers.
S * |        |          |111 = 1 Transfers.
S * |        |          |Note: This field is only useful in burst transfer type.
S * |[7]     |TBINTDIS  |Table Interrupt Disable
S * |        |          |This field can be used to decide whether to enable table interrupt or not.
S * |        |          |If the TBINTDIS bit is enabled when PDMA controller finishes transfer task, it will not generates interrupt.
S * |        |          |0 = Table interrupt Enabled.
S * |        |          |1 = Table interrupt Disabled.
S * |        |          |Note: If this bit set to '1', the TEMPTYF will not be set.
S * |[9:8]   |SAINC     |Source Address Increment
S * |        |          |This field is used to set the source address increment size.
S * |        |          |11 = No increment (fixed address).
S * |        |          |Others = Increment and size is depended on TXWIDTH selection.
S * |[11:10] |DAINC     |Destination Address Increment
S * |        |          |This field is used to set the destination address increment size.
S * |        |          |11 = No increment (fixed address).
S * |        |          |Others = Increment and size is depended on TXWIDTH selection.
S * |[13:12] |TXWIDTH   |Transfer Width Selection
S * |        |          |This field is used for transfer width.
S * |        |          |00 = One byte (8 bit) is transferred for every operation.
S * |        |          |01= One half-word (16 bit) is transferred for every operation.
S * |        |          |10 = One word (32-bit) is transferred for every operation.
S * |        |          |11 = Reserved.
S * |        |          |Note: The PDMA transfer source address (PDMA_DSCT_SA) and PDMA transfer destination address (PDMA_DSCT_DA) should be alignment under the TXWIDTH selection
S * |[29:16] |TXCNT     |Transfer Count
S * |        |          |The TXCNT represents the required number of PDMA transfer, the real transfer count is (TXCNT + 1); The maximum transfer count is 16384 , every transfer may be byte, half-word or word that is dependent on TXWIDTH field.
S * |        |          |Note: When PDMA finish each transfer data, this field will be decrease immediately.
S * @var DSCT_T::SA
S * Offset: 0x04/0x14/0x24/0x34/0x44/0x54/0x64/0x74/0x84/0x94/0xA4/0xB4  Source Address Register of PDMA Channel 0~11
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |SA        |PDMA Transfer Source Address Register
S * |        |          |This field indicates a 32-bit source address of PDMA controller.
S * @var DSCT_T::DA
S * Offset: 0x08/0x18/0x28/0x38/0x48/0x58/0x68/0x78/0x88/0x98/0xA8/0xB8  Destination Address Register of PDMA Channel 0~11
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |DA        |PDMA Transfer Destination Address Register
S * |        |          |This field indicates a 32-bit destination address of PDMA controller.
S * @var DSCT_T::NEXT
S * Offset: 0x0C/0x1C/0x2C/0x3C/0x4C/0x5C/0x6C/0x7C/0x8C/0x9C/0xAC/0xBC  First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 0~11
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:2]  |NEXT      |PDMA Next Descriptor Table Offset Address Register
S * |        |          |This field indicates the offset of next descriptor table address in system memory.
S * |        |          |The system memory based address is 0x2000_0000 (PDMA_SCATBA), if the next descriptor table is 0x2000_0100, then this field must fill in 0x0100.
S * |        |          |Note1: The next descriptor table address must be word boundary.
S * |        |          |Note2: Before filled transfer task in the descriptor table, user must check if the descriptor table is complete.
S */
S
S    __IO uint32_t CTL;           /* Offset: 0x00/0x10/0x20/0x30/0x40/0x50/0x60/0x70/0x80/0x90/0xA0/0xB0  Descriptor Table Control Register of PDMA Channel 0~11 */
S    __IO uint32_t SA;            /* Offset: 0x04/0x14/0x24/0x34/0x44/0x54/0x64/0x74/0x84/0x94/0xA4/0xB4  Source Address Register of PDMA Channel 0~11 */
S    __IO uint32_t DA;            /* Offset: 0x08/0x18/0x28/0x38/0x48/0x58/0x68/0x78/0x88/0x98/0xA8/0xB8  Destination Address Register of PDMA Channel 0~11 */
S    __IO uint32_t NEXT;          /* Offset: 0x0C/0x1C/0x2C/0x3C/0x4C/0x5C/0x6C/0x7C/0x8C/0x9C/0xAC/0xBC  First Scatter-Gather Descriptor Table Offset Address of PDMA Channel 0~11 */
S
S} DSCT_T;
S
S
S
S
Stypedef struct
S{
S
S
S/**
S * @var PDMA_T::DSCT
S * Offset: 0x0000 ~ 0x00BC  DMA Embedded Description Table 0~11
S * ---------------------------------------------------------------------------------------------------
S * @var PDMA_T::CURSCAT
S * Offset: 0xC0 ~ 0xEC Current Scatter-Gather Descriptor Table Address of PDMA Channel 0~11
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |CURADDR   |PDMA Current Description Address Register (Read Only)
S * |        |          |This field indicates a 32-bit current external description address of PDMA controller.
S * |        |          |Note: This field is read only and only used for Scatter-Gather mode to indicate the current external description address.
S * @var PDMA_T::CHCTL
S * Offset: 0x400  PDMA Channel Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[11:0]  |CHENn     |PDMA Channel Enable Bit
S * |        |          |Set this bit to 1 to enable PDMAn operation.
S * |        |          |If each channel is not set as enabled, each channel cannot be active.
S * |        |          |0 = PDMA channel [n] Disabled.
S * |        |          |1 = PDMA channel [n] Enabled.
S * |        |          |Note1: If software stops each PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
S * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
S * @var PDMA_T::STOP
S * Offset: 0x404  PDMA Transfer Stop Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[11:0]  |STOPn     |PDMA Transfer Stop Control Register (Write Only)
S * |        |          |User can stop the PDMA transfer by STOPn bit field or by software reset (writing '0xFFFF_FFFF' to PDMA_STOP register).
S * |        |          |By bit field:
S * |        |          |0 = No effect.
S * |        |          |1 = Stop PDMA transfer[n].
S * |        |          |When software set PDMA_STOP bit, the operation will finish the on-going transfer channel and then clear the channel enable bit (PDMA_CHCTL [CHEN]) and request active flag.
S * |        |          |By write 0xFFFF_FFFF to PDMA_STOP:
S * |        |          |Setting all PDMA_STOP bit to "1" will generate software reset to reset internal state machine (the DSCT will not be reset).
S * |        |          |When software reset, the operation will be stopped imminently that include the on-going transfer and the channel enable bit (PDMA_CHCTL [CHEN]) and request active flag will be cleared to '0'.
S * |        |          |Note: User can poll channel enable bit to know if the on-going transfer is finished.
S * @var PDMA_T::SWREQ
S * Offset: 0x408  PDMA Software Request Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[11:0]  |SWREQn    |PDMA Software Request Register (Write Only)
S * |        |          |Set this bit to 1 to generate a software request to PDMA [n].
S * |        |          |0 = No effect.
S * |        |          |1 = Generate a software request.
S * |        |          |Note1: User can read PDMA_TRGSTS register to know which channel is on active.
S * |        |          |Active flag may be triggered by software request or peripheral request.
S * |        |          |Note2: If user does not enable each PDMA channel, the software request will be ignored.
S * @var PDMA_T::TRGSTS
S * Offset: 0x40C  PDMA Channel Request Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[11:0]  |REQSTSn   |PDMA Channel Request Status (Read Only)
S * |        |          |This flag indicates whether channel[n] have a request or not, no matter request from software or peripheral.
S * |        |          |When PDMA controller finishes channel transfer, this bit will be cleared automatically.
S * |        |          |0 = PDMA Channel n has no request.
S * |        |          |1 = PDMA Channel n has a request.
S * |        |          |Note1: If software stops each PDMA transfer by setting PDMA_STOP register, this bit will be cleared automatically after finishing current transfer.
S * |        |          |Note2: Software reset (writing 0xFFFF_FFFF to PDMA_STOP register) will also clear this bit.
S * @var PDMA_T::PRISET
S * Offset: 0x410  PDMA Fixed Priority Setting Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[11:0]  |FPRISETn  |PDMA Fixed Priority Setting Register
S * |        |          |Set this bit to 1 to enable fixed priority level.
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Set PDMA channel [n] to fixed priority channel.
S * |        |          |Read Operation:
S * |        |          |0 = Corresponding PDMA channel is round-robin priority.
S * |        |          |1 = Corresponding PDMA channel is fixed priority.
S * |        |          |Note: This field only set to fixed priority, clear fixed priority use PDMA_PRICLR register.
S * @var PDMA_T::PRICLR
S * Offset: 0x414  PDMA Fixed Priority Clear Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[11:0]  |FPRICLRn  |PDMA Fixed Priority Clear Register (Write Only)
S * |        |          |Set this bit to 1 to clear fixed priority level.
S * |        |          |0 = No effect.
S * |        |          |1 = Clear PDMA channel [n] fixed priority setting.
S * |        |          |Note: User can read PDMA_PRISET register to know the channel priority.
S * @var PDMA_T::INTEN
S * Offset: 0x418  PDMA Interrupt Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[11:0]  |INTENn    |PDMA Interrupt Enable Register
S * |        |          |This field is used for enabling PDMA channel[n] interrupt.
S * |        |          |0 = PDMA channel n interrupt Disabled.
S * |        |          |1 = PDMA channel n interrupt Enabled.
S * |[31:12] |Reserved  |should be keep 0.
S * @var PDMA_T::INTSTS
S * Offset: 0x41C  PDMA Interrupt Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ABTIF     |PDMA Read/Write Target Abort Interrupt Flag (Read-Only)
S * |        |          |This bit indicates that PDMA has target abort error; Software can read PDMA_ABTSTS register to find which channel has target abort error.
S * |        |          |0 = No AHB bus ERROR response received.
S * |        |          |1 = AHB bus ERROR response received.
S * |[1]     |TDIF      |Transfer Done Interrupt Flag (Read Only)
S * |        |          |This bit indicates that PDMA controller has finished transmission; User can read PDMA_TDSTS register to indicate which channel finished transfer.
S * |        |          |0 = Not finished yet.
S * |        |          |1 = PDMA channel has finished transmission.
S * |[2]     |TEIF      |Table Empty Interrupt Flag (Read Only)
S * |        |          |This bit indicates that PDMA controller has finished each table transmission and the operation is Stop mode.
S * |        |          |User can read TEIF register to indicate which channel finished transfer.
S * |        |          |0 = PDMA channel transfer is not finished.
S * |        |          |1 = PDMA channel transfer is finished and the operation is in idle state.
S * |[8:15]  |REQTOFn   |Request Time-out Flag For Each Channel [N](M45xD/M45xC Only)
S * |        |          |This flag indicates that PDMA controller has waited peripheral request for a period defined by PDMA_TOCn, user can write 1 to clear these bits.
S * |        |          |0 = No request time-out.
S * |        |          |1 = Peripheral request time-out.
S * @var PDMA_T::ABTSTS
S * Offset: 0x420  PDMA Channel Read/Write Target Abort Flag Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[11:0]  |ABTIFn    |PDMA Read/Write Target Abort Interrupt Status Flag
S * |        |          |This bit indicates which PDMA controller has target abort error; User can write 1 to clear these bits.
S * |        |          |0 = No AHB bus ERROR response received when channel n transfer.
S * |        |          |1 = AHB bus ERROR response received when channel n transfer.
S * @var PDMA_T::TDSTS
S * Offset: 0x424  PDMA Channel Transfer Done Flag Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[11:0]  |TDIFn     |Transfer Done Flag Register
S * |        |          |This bit indicates whether PDMA controller channel transfer has been finished or not, user can write 1 to clear these bits.
S * |        |          |0 = PDMA channel transfer has not finished.
S * |        |          |1 = PDMA channel has finished transmission.
S * @var PDMA_T::SCATSTS
S * Offset: 0x428  PDMA Scatter-Gather Table Empty Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[11:0]  |TEMPTYFn  |Scatter-Gather Table Empty Flag Register
S * |        |          |This bit indicates which PDMA channel n Scatter Gather table is empty when SWREQn set to high or channel has finished transmission and the operation mode is Stop mode.
S * |        |          |User can write 1 to clear these bits.
S * |        |          |0 = PDMA channel scatter-gather table is not empty.
S * |        |          |1 = PDMA channel scatter-gather table is empty and PDMA SWREQ has be set.
S * @var PDMA_T::TACTSTS
S * Offset: 0x42C  PDMA Transfer Active Flag Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[11:0]  |TXACTFn   |Transfer On Active Flag Register (Read Only)
S * |        |          |This bit indicates which PDMA channel is in active.
S * |        |          |0 = PDMA channel is not finished.
S * |        |          |1 = PDMA channel is active.
S * @var PDMA_T::TOUTEN
S * Offset: 0x434  PDMA Time-out Enable register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |TOUTENn   |PDMA Time-Out Enable Bits
S * |        |          |0 = PDMA Channel n time-out function Disable.
S * |        |          |1 = PDMA Channel n time-out function Enable.
S * @var PDMA_T::TOUTIEN
S * Offset: 0x438  PDMA Time-out Interrupt Enable register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |TOUTIENn  |PDMA Time-Out Interrupt Enable Bits
S * |        |          |0 = PDMA Channel n time-out interrupt Disable.
S * |        |          |1 = PDMA Channel n time-out interrupt Enable.
S * @var PDMA_T::SCATBA
S * Offset: 0x43C  PDMA Scatter-Gather Descriptor Table Base Address Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:16] |SCATBA    |PDMA Scatter-Gather Descriptor Table Address Register
S * |        |          |In Scatter-Gather mode, this is the base address for calculating the next link - list address.
S * |        |          |The next link address equation is.
S * |        |          |Next Link Address = PDMA_SCATBA + PDMA_DSCT_NEXT.
S * |        |          |Note: Only useful in Scatter-Gather mode.
S * @var PDMA_T::TOC0_1
S * Offset: 0x440  PDMA Time-out Counter Ch1 and Ch0 Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:16] |TOC1      |Time-Out Counter For Channel 1
S * |        |          |This controls the period of time-out function for channel 1. The calculation unit is based on 10 kHz clock.
S * |[15:0]  |TOC0      |Time-Out Counter For Channel 0
S * |        |          |This controls the period of time-out function for channel 0. The calculation unit is based on 10 kHz clock.
S * @var PDMA_T::TOC2_3
S * Offset: 0x444  PDMA Time-out Counter Ch3 and Ch2 Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:16] |TOC3      |Time-Out Counter For Channel 3
S * |        |          |This controls the period of time-out function for channel 3. The calculation unit is based on 10 kHz clock.
S * |[15:0]  |TOC2      |Time-Out Counter For Channel 2
S * |        |          |This controls the period of time-out function for channel 2. The calculation unit is based on 10 kHz clock.
S * @var PDMA_T::TOC4_5
S * Offset: 0x448  PDMA Time-out Counter Ch5 and Ch4 Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:16] |TOC5      |Time-Out Counter For Channel 5
S * |        |          |This controls the period of time-out function for channel 5. The calculation unit is based on 10 kHz clock.
S * |[15:0]  |TOC4      |Time-Out Counter For Channel 4
S * |        |          |This controls the period of time-out function for channel 4. The calculation unit is based on 10 kHz clock.
S * @var PDMA_T::TOC6_7
S * Offset: 0x44C  PDMA Time-out Counter Ch7 and Ch6 Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:16] |TOC7      |Time-Out Counter For Channel 7
S * |        |          |This controls the period of time-out function for channel 7. The calculation unit is based on 10 kHz clock.
S * |[15:0]  |TOC6      |Time-Out Counter For Channel 6
S * |        |          |This controls the period of time-out function for channel 6. The calculation unit is based on 10 kHz clock.
S * @var PDMA_T::REQSEL0_3
S * Offset: 0x480  PDMA Request Source Select Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[4:0]   |REQSRC0   |Channel 0 Request Source Selection
S * |        |          |This filed defines which peripheral is connected to PDMA channel 0.
S * |        |          |User can configure the peripheral by setting REQSRC0.
S * |        |          |1 = Channel connects to SPI0_TX.
S * |        |          |2 = Channel connects to SPI1_TX.
S * |        |          |3 = Channel connects to SPI2_TX.
S * |        |          |4 = Channel connects to UART0_TX.
S * |        |          |5 = Channel connects to UART1_TX.
S * |        |          |6 = Channel connects to UART2_TX.
S * |        |          |7 = Channel connects to UART3_TX.
S * |        |          |8 = Channel connects to DAC_TX.
S * |        |          |9 = Channel connects to ADC_RX.
S * |        |          |11 = Channel connects to PWM0_P1_RX.
S * |        |          |12 = Channel connects to PWM0_P2_RX.
S * |        |          |13 = Channel connects to PWM0_P3_RX.
S * |        |          |14 = Channel connects to PWM1_P1_RX.
S * |        |          |15 = Channel connects to PWM1_P2_RX.
S * |        |          |16 = Channel connects to PWM1_P3_RX.
S * |        |          |17 = Channel connects to SPI0_RX.
S * |        |          |18 = Channel connects to SPI1_RX.
S * |        |          |19 = Channel connects to SPI2_RX.
S * |        |          |20 = Channel connects to UART0_RX.
S * |        |          |21 = Channel connects to UART1_RX.
S * |        |          |22 = Channel connects to UART2_RX.
S * |        |          |23 = Channel connects to UART3_RX.
S * |        |          |31 = Disable PDMA.
S * |        |          |Others = Reserved.
S * |        |          |Note 1: A peripheral can't assign to two channels at the same time.
S * |        |          |Note 2: This field is useless when transfer between memory and memory.
S * |[12:8]  |REQSRC1   |Channel 1 Request Source Selection
S * |        |          |This filed defines which peripheral is connected to PDMA channel 1.
S * |        |          |User can configure the peripheral setting by REQSRC1.
S * |        |          |Note: The channel configuration is the same as REQSRC0 field.
S * |        |          |Please refer to the explanation of REQSRC0.
S * |[20:16] |REQSRC2   |Channel 2 Request Source Selection
S * |        |          |This filed defines which peripheral is connected to PDMA channel 2.
S * |        |          |User can configure the peripheral setting by REQSRC2.
S * |        |          |Note: The channel configuration is the same as REQSRC0 field.
S * |        |          |Please refer to the explanation of REQSRC0.
S * |[28:24] |REQSRC3   |Channel 3 Request Source Selection
S * |        |          |This filed defines which peripheral is connected to PDMA channel 3.
S * |        |          |User can configure the peripheral setting by REQSRC3.
S * |        |          |Note: The channel configuration is the same as REQSRC0 field.
S * |        |          |Please refer to the explanation of REQSRC0.
S * @var PDMA_T::REQSEL4_7
S * Offset: 0x484  PDMA Request Source Select Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[4:0]   |REQSRC4   |Channel 4 Request Source Selection
S * |        |          |This filed defines which peripheral is connected to PDMA channel 4.
S * |        |          |User can configure the peripheral setting by REQSRC4.
S * |        |          |Note: The channel configuration is the same as REQSRC0 field.
S * |        |          |Please refer to the explanation of REQSRC0.
S * |[12:8]  |REQSRC5   |Channel 5 Request Source Selection
S * |        |          |This filed defines which peripheral is connected to PDMA channel 5.
S * |        |          |User can configure the peripheral setting by REQSRC5.
S * |        |          |Note: The channel configuration is the same as REQSRC0 field.
S * |        |          |Please refer to the explanation of REQSRC0.
S * |[20:16] |REQSRC6   |Channel 6 Request Source Selection
S * |        |          |This filed defines which peripheral is connected to PDMA channel 6.
S * |        |          |User can configure the peripheral setting by REQSRC6.
S * |        |          |Note: The channel configuration is the same as REQSRC0 field.
S * |        |          |Please refer to the explanation of REQSRC0.
S * |[28:24] |REQSRC7   |Channel 7 Request Source Selection
S * |        |          |This filed defines which peripheral is connected to PDMA channel 7.
S * |        |          |User can configure the peripheral setting by REQSRC7.
S * |        |          |Note: The channel configuration is the same as REQSRC0 field.
S * |        |          |Please refer to the explanation of REQSRC0.
S * @var PDMA_T::REQSEL8_11
S * Offset: 0x488  PDMA Request Source Select Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[4:0]   |REQSRC8   |Channel 8 Request Source Selection
S * |        |          |This filed defines which peripheral is connected to PDMA channel 8.
S * |        |          |User can configure the peripheral setting by REQSRC8.
S * |        |          |Note: The channel configuration is the same as REQSRC0 field.
S * |        |          |Please refer to the explanation of REQSRC0.
S * |[12:8]  |REQSRC9   |Channel 9 Request Source Selection
S * |        |          |This filed defines which peripheral is connected to PDMA channel 9.
S * |        |          |User can configure the peripheral setting by REQSRC9.
S * |        |          |Note: The channel configuration is the same as REQSRC0 field.
S * |        |          |Please refer to the explanation of REQSRC0.
S * |[20:16] |REQSRC10  |Channel 10 Request Source Selection
S * |        |          |This filed defines which peripheral is connected to PDMA channel 10.
S * |        |          |User can configure the peripheral setting by REQSRC10.
S * |        |          |Note: The channel configuration is the same as REQSRC0 field.
S * |        |          |Please refer to the explanation of REQSRC0.
S * |[28:24] |REQSRC11  |Channel 11 Request Source Selection
S * |        |          |This filed defines which peripheral is connected to PDMA channel 11.
S * |        |          |User can configure the peripheral setting by REQSRC11.
S * |        |          |Note: The channel configuration is the same as REQSRC0 field.
S * |        |          |Please refer to the explanation of REQSRC0.
S */
S    
S    DSCT_T        DSCT[12];      /* Offset: 0x0000 ~ 0x00BC  DMA Embedded Description Table 0~11                     */             
S    __I  uint32_t CURSCAT[12];                                                                                                      
S    __I  uint32_t RESERVE0[196]; /* Offset: 0xC0 ~ 0xEC Current Scatter-Gather Descriptor Table Address of PDMA Channel 0~11 */     
S    __IO uint32_t CHCTL;         /* Offset: 0x400  PDMA Channel Control Register                                     */             
S    __O  uint32_t STOP;          /* Offset: 0x404  PDMA Transfer Stop Control Register                               */             
S    __O  uint32_t SWREQ;         /* Offset: 0x408  PDMA Software Request Register                                    */             
S    __I  uint32_t TRGSTS;        /* Offset: 0x40C  PDMA Channel Request Status Register                              */             
S    __IO uint32_t PRISET;        /* Offset: 0x410  PDMA Fixed Priority Setting Register                              */             
S    __O  uint32_t PRICLR;        /* Offset: 0x414  PDMA Fixed Priority Clear Register                                */             
S    __IO uint32_t INTEN;         /* Offset: 0x418  PDMA Interrupt Enable Register                                    */             
S    __IO uint32_t INTSTS;        /* Offset: 0x41C  PDMA Interrupt Status Register                                    */             
S    __IO uint32_t ABTSTS;        /* Offset: 0x420  PDMA Channel Read/Write Target Abort Flag Register                */             
S    __IO uint32_t TDSTS;         /* Offset: 0x424  PDMA Channel Transfer Done Flag Register                          */             
S    __IO uint32_t SCATSTS;       /* Offset: 0x428  PDMA Scatter-Gather Table Empty Status Register                   */             
S    __I  uint32_t TACTSTS;                                                                                                          
S    __I  uint32_t RESERVE1[1];   /* Offset: 0x42C  PDMA Transfer Active Flag Register                                */             
S    __IO uint32_t TOUTEN;        /* Offset: 0x434  PDMA Time-out Enable register                                     */             
S    __IO uint32_t TOUTIEN;       /* Offset: 0x438  PDMA Time-out Interrupt Enable register                           */             
S    __IO uint32_t SCATBA;        /* Offset: 0x43C  PDMA Scatter-Gather Descriptor Table Base Address Register        */             
S    __IO uint32_t TOC0_1;        /* Offset: 0x440  PDMA Time-out Counter Ch1 and Ch0 Register                        */             
S    __IO uint32_t TOC2_3;        /* Offset: 0x444  PDMA Time-out Counter Ch3 and Ch2 Register                        */             
S    __IO uint32_t TOC4_5;        /* Offset: 0x448  PDMA Time-out Counter Ch5 and Ch4 Register                        */             
S    __IO uint32_t TOC6_7;                                                                                                           
S    __I  uint32_t RESERVE2[12];  /* Offset: 0x44C  PDMA Time-out Counter Ch7 and Ch6 Register                        */             
S    __IO uint32_t REQSEL0_3;     /* Offset: 0x480  PDMA Request Source Select Register 0                             */             
S    __IO uint32_t REQSEL4_7;     /* Offset: 0x484  PDMA Request Source Select Register 1                             */             
S    __IO uint32_t REQSEL8_11;    /* Offset: 0x484  PDMA Request Source Select Register 2                             */
S
S} PDMA_T;
S
S
S
S/**
S    @addtogroup PDMA_CONST PDMA Bit Field Definition
S    Constant Definitions for PDMA Controller
S@{ */
S
S#define PDMA_DSCT_CTL_OPMODE_Pos         (0)                                               /*!< DSCT_T::CTL: OPMODE Position              */
S#define PDMA_DSCT_CTL_OPMODE_Msk         (0x3ul << PDMA_DSCT_CTL_OPMODE_Pos)               /*!< DSCT_T::CTL: OPMODE Mask                  */
S
S#define PDMA_DSCT_CTL_TXTYPE_Pos         (2)                                               /*!< DSCT_T::CTL: TXTYPE Position              */
S#define PDMA_DSCT_CTL_TXTYPE_Msk         (1ul << PDMA_DSCT_CTL_TXTYPE_Pos)                 /*!< DSCT_T::CTL: TXTYPE Mask                  */
S
S#define PDMA_DSCT_CTL_BURSIZE_Pos        (4)                                               /*!< DSCT_T::CTL: BURSIZE Position             */
S#define PDMA_DSCT_CTL_BURSIZE_Msk        (0x7ul << PDMA_DSCT_CTL_BURSIZE_Pos)              /*!< DSCT_T::CTL: BURSIZE Mask                 */
S
S#define PDMA_DSCT_CTL_TBINTDIS_Pos       (7)                                               /*!< DSCT_T::CTL: TBINTDIS Position            */
S#define PDMA_DSCT_CTL_TBINTDIS_Msk       (1ul << PDMA_DSCT_CTL_TBINTDIS_Pos)               /*!< DSCT_T::CTL: TBINTDIS Mask                */
S
S#define PDMA_DSCT_CTL_SAINC_Pos          (8)                                               /*!< DSCT_T::CTL: SAINC Position               */
S#define PDMA_DSCT_CTL_SAINC_Msk          (0x3ul << PDMA_DSCT_CTL_SAINC_Pos)                /*!< DSCT_T::CTL: SAINC Mask                   */
S
S#define PDMA_DSCT_CTL_DAINC_Pos          (10)                                              /*!< DSCT_T::CTL: DAINC Position               */
S#define PDMA_DSCT_CTL_DAINC_Msk          (0x3ul << PDMA_DSCT_CTL_DAINC_Pos)                /*!< DSCT_T::CTL: DAINC Mask                   */
S
S#define PDMA_DSCT_CTL_TXWIDTH_Pos        (12)                                              /*!< DSCT_T::CTL: TXWIDTH Position             */
S#define PDMA_DSCT_CTL_TXWIDTH_Msk        (0x3ul << PDMA_DSCT_CTL_TXWIDTH_Pos)              /*!< DSCT_T::CTL: TXWIDTH Mask                 */
S
S#define PDMA_DSCT_CTL_TXCNT_Pos          (16)                                              /*!< DSCT_T::CTL: TXCNT Position               */
S#define PDMA_DSCT_CTL_TXCNT_Msk          (0x3FFFul << PDMA_DSCT_CTL_TXCNT_Pos)             /*!< DSCT_T::CTL: TXCNT Mask                   */
S
S#define PDMA_DSCT_SA_SA_Pos              (0)                                               /*!< DSCT_T::SA: SA Position                   */
S#define PDMA_DSCT_SA_SA_Msk              (0xFFFFFFFFul << PDMA_DSCT_SA_SA_Pos)             /*!< DSCT_T::SA: SA Mask                       */
S
S#define PDMA_DSCT_DA_DA_Pos              (0)                                               /*!< DSCT_T::DA: DA Position                   */
S#define PDMA_DSCT_DA_DA_Msk              (0xFFFFFFFFul << PDMA_DSCT_DA_DA_Pos)             /*!< DSCT_T::DA: DA Mask                       */
S
S#define PDMA_DSCT_NEXT_NEXT_Pos          (0)                                               /*!< DSCT_T::NEXT: NEXT Position               */
S#define PDMA_DSCT_NEXT_NEXT_Msk          (0xFFFFul << PDMA_DSCT_NEXT_NEXT_Pos)             /*!< DSCT_T::NEXT: NEXT Mask                   */
S
S#define PDMA_CURSCAT_CURADDR_Pos         (0)                                               /*!< PDMA_T::CURSCAT: CURADDR Position         */
S#define PDMA_CURSCAT_CURADDR_Msk         (0xfffffffful << PDMA_CURSCAT_CURADDR_Pos)        /*!< PDMA_T::CURSCAT: CURADDR Mask             */
S
S#define PDMA_CHCTL_CHENn_Pos             (0)                                               /*!< PDMA_T::CHCTL: CHENn Position             */
S#define PDMA_CHCTL_CHENn_Msk             (0xffful << PDMA_CHCTL_CHENn_Pos)                 /*!< PDMA_T::CHCTL: CHENn Mask                 */
S
S#define PDMA_STOP_STOPn_Pos              (0)                                               /*!< PDMA_T::STOP: STOPn Position              */
S#define PDMA_STOP_STOPn_Msk              (0xffful << PDMA_STOP_STOPn_Pos)                  /*!< PDMA_T::STOP: STOPn Mask                  */
S
S#define PDMA_SWREQ_SWREQn_Pos            (0)                                               /*!< PDMA_T::SWREQ: SWREQn Position            */
S#define PDMA_SWREQ_SWREQn_Msk            (0xffful << PDMA_SWREQ_SWREQn_Pos)                /*!< PDMA_T::SWREQ: SWREQn Mask                */
S
S#define PDMA_TRGSTS_REQSTSn_Pos          (0)                                               /*!< PDMA_T::TRGSTS: REQSTSn Position          */
S#define PDMA_TRGSTS_REQSTSn_Msk          (0xffful << PDMA_TRGSTS_REQSTSn_Pos)              /*!< PDMA_T::TRGSTS: REQSTSn Mask              */
S
S#define PDMA_PRISET_FPRISETn_Pos         (0)                                               /*!< PDMA_T::PRISET: FPRISETn Position         */
S#define PDMA_PRISET_FPRISETn_Msk         (0xffful << PDMA_PRISET_FPRISETn_Pos)             /*!< PDMA_T::PRISET: FPRISETn Mask             */
S
S#define PDMA_PRICLR_FPRICLRn_Pos         (0)                                               /*!< PDMA_T::PRICLR: FPRICLRn Position         */
S#define PDMA_PRICLR_FPRICLRn_Msk         (0xffful << PDMA_PRICLR_FPRICLRn_Pos)             /*!< PDMA_T::PRICLR: FPRICLRn Mask             */
S
S#define PDMA_INTEN_INTENn_Pos            (0)                                               /*!< PDMA_T::INTEN: INTENn Position            */
S#define PDMA_INTEN_INTENn_Msk            (0xffful << PDMA_INTEN_INTENn_Pos)                /*!< PDMA_T::INTEN: INTENn Mask                */
S
S#define PDMA_INTSTS_ABTIF_Pos            (0)                                               /*!< PDMA_T::INTSTS: ABTIF Position            */
S#define PDMA_INTSTS_ABTIF_Msk            (0x1ul << PDMA_INTSTS_ABTIF_Pos)                  /*!< PDMA_T::INTSTS: ABTIF Mask                */
S
S#define PDMA_INTSTS_TDIF_Pos             (1)                                               /*!< PDMA_T::INTSTS: TDIF Position             */
S#define PDMA_INTSTS_TDIF_Msk             (0x1ul << PDMA_INTSTS_TDIF_Pos)                   /*!< PDMA_T::INTSTS: TDIF Mask                 */
S
S#define PDMA_INTSTS_TEIF_Pos             (2)                                               /*!< PDMA_T::INTSTS: TEIF Position             */
S#define PDMA_INTSTS_TEIF_Msk             (0x1ul << PDMA_INTSTS_TEIF_Pos)                   /*!< PDMA_T::INTSTS: TEIF Mask                 */
S
S#define PDMA_INTSTS_REQTOFn_Pos          (8)                                               /*!< PDMA_T::INTSTS: REQTOFn Position          */
S#define PDMA_INTSTS_REQTOFn_Msk          (0xfful << PDMA_INTSTS_REQTOFn_Pos)               /*!< PDMA_T::INTSTS: REQTOFn Mask              */
S
S#define PDMA_ABTSTS_ABTIFn_Pos           (0)                                               /*!< PDMA_T::ABTSTS: ABTIFn Position           */
S#define PDMA_ABTSTS_ABTIFn_Msk           (0xffful << PDMA_ABTSTS_ABTIFn_Pos)               /*!< PDMA_T::ABTSTS: ABTIFn Mask               */
S
S#define PDMA_TDSTS_TDIFn_Pos             (0)                                               /*!< PDMA_T::TDSTS: TDIFn Position             */
S#define PDMA_TDSTS_TDIFn_Msk             (0xffful << PDMA_TDSTS_TDIFn_Pos)                 /*!< PDMA_T::TDSTS: TDIFn Mask                 */
S
S#define PDMA_SCATSTS_TEMPTYFn_Pos        (0)                                               /*!< PDMA_T::SCATSTS: TEMPTYFn Position        */
S#define PDMA_SCATSTS_TEMPTYFn_Msk        (0xffful << PDMA_SCATSTS_TEMPTYFn_Pos)            /*!< PDMA_T::SCATSTS: TEMPTYFn Mask            */
S
S#define PDMA_TACTSTS_TXACTFn_Pos         (0)                                               /*!< PDMA_T::TACTSTS: TXACTFn Position         */
S#define PDMA_TACTSTS_TXACTFn_Msk         (0xffful << PDMA_TACTSTS_TXACTFn_Pos)             /*!< PDMA_T::TACTSTS: TXACTFn Mask             */
S
S#define PDMA_TOUTEN_TOUTENn_Pos          (0)                                               /*!< PDMA_T::TOUTEN: TOUTENn Position          */
S#define PDMA_TOUTEN_TOUTENn_Msk          (0xfful << PDMA_TOUTEN_TOUTENn_Pos)               /*!< PDMA_T::TOUTEN: TOUTENn Mask              */
S
S#define PDMA_TOUTIEN_TOUTIENn_Pos        (0)                                               /*!< PDMA_T::TOUTIEN: TOUTIENn Position        */
S#define PDMA_TOUTIEN_TOUTIENn_Msk        (0xfful << PDMA_TOUTIEN_TOUTIENn_Pos)             /*!< PDMA_T::TOUTIEN: TOUTIENn Mask            */
S
S#define PDMA_SCATBA_SCATBA_Pos           (16)                                              /*!< PDMA_T::SCATBA: SCATBA Position           */
S#define PDMA_SCATBA_SCATBA_Msk           (0xfffful << PDMA_SCATBA_SCATBA_Pos)              /*!< PDMA_T::SCATBA: SCATBA Mask               */
S
S#define PDMA_TOC0_1_TOC0_Pos             (0)                                               /*!< PDMA_T::TOC0_1: TOC0 Position             */
S#define PDMA_TOC0_1_TOC0_Msk             (0xfffful << PDMA_TOC0_1_TOC0_Pos)                /*!< PDMA_T::TOC0_1: TOC0 Mask                 */
S
S#define PDMA_TOC0_1_TOC1_Pos             (16)                                              /*!< PDMA_T::TOC0_1: TOC1 Position             */
S#define PDMA_TOC0_1_TOC1_Msk             (0xfffful << PDMA_TOC0_1_TOC1_Pos)                /*!< PDMA_T::TOC0_1: TOC1 Mask                 */
S
S#define PDMA_TOC2_3_TOC2_Pos             (0)                                               /*!< PDMA_T::TOC2_3: TOC2 Position             */
S#define PDMA_TOC2_3_TOC2_Msk             (0xfffful << PDMA_TOC2_3_TOC2_Pos)                /*!< PDMA_T::TOC2_3: TOC2 Mask                 */
S
S#define PDMA_TOC2_3_TOC3_Pos             (16)                                              /*!< PDMA_T::TOC2_3: TOC3 Position             */
S#define PDMA_TOC2_3_TOC3_Msk             (0xfffful << PDMA_TOC2_3_TOC3_Pos)                /*!< PDMA_T::TOC2_3: TOC3 Mask                 */
S
S#define PDMA_TOC4_5_TOC4_Pos             (0)                                               /*!< PDMA_T::TOC4_5: TOC4 Position             */
S#define PDMA_TOC4_5_TOC4_Msk             (0xfffful << PDMA_TOC4_5_TOC4_Pos)                /*!< PDMA_T::TOC4_5: TOC4 Mask                 */
S
S#define PDMA_TOC4_5_TOC5_Pos             (16)                                              /*!< PDMA_T::TOC4_5: TOC5 Position             */
S#define PDMA_TOC4_5_TOC5_Msk             (0xfffful << PDMA_TOC4_5_TOC5_Pos)                /*!< PDMA_T::TOC4_5: TOC5 Mask                 */
S
S#define PDMA_TOC6_7_TOC6_Pos             (0)                                               /*!< PDMA_T::TOC6_7: TOC6 Position             */
S#define PDMA_TOC6_7_TOC6_Msk             (0xfffful << PDMA_TOC6_7_TOC6_Pos)                /*!< PDMA_T::TOC6_7: TOC6 Mask                 */
S
S#define PDMA_TOC6_7_TOC7_Pos             (16)                                              /*!< PDMA_T::TOC6_7: TOC7 Position             */
S#define PDMA_TOC6_7_TOC7_Msk             (0xfffful << PDMA_TOC6_7_TOC7_Pos)                /*!< PDMA_T::TOC6_7: TOC7 Mask                 */
S
S#define PDMA_REQSEL0_3_REQSRC0_Pos       (0)                                               /*!< PDMA_T::REQSEL0_3: REQSRC0 Position       */
S#define PDMA_REQSEL0_3_REQSRC0_Msk       (0x1ful << PDMA_REQSEL0_3_REQSRC0_Pos)            /*!< PDMA_T::REQSEL0_3: REQSRC0 Mask           */
S
S#define PDMA_REQSEL0_3_REQSRC1_Pos       (8)                                               /*!< PDMA_T::REQSEL0_3: REQSRC1 Position       */
S#define PDMA_REQSEL0_3_REQSRC1_Msk       (0x1ful << PDMA_REQSEL0_3_REQSRC1_Pos)            /*!< PDMA_T::REQSEL0_3: REQSRC1 Mask           */
S
S#define PDMA_REQSEL0_3_REQSRC2_Pos       (16)                                              /*!< PDMA_T::REQSEL0_3: REQSRC2 Position       */
S#define PDMA_REQSEL0_3_REQSRC2_Msk       (0x1ful << PDMA_REQSEL0_3_REQSRC2_Pos)            /*!< PDMA_T::REQSEL0_3: REQSRC2 Mask           */
S
S#define PDMA_REQSEL0_3_REQSRC3_Pos       (24)                                              /*!< PDMA_T::REQSEL0_3: REQSRC3 Position       */
S#define PDMA_REQSEL0_3_REQSRC3_Msk       (0x1ful << PDMA_REQSEL0_3_REQSRC3_Pos)            /*!< PDMA_T::REQSEL0_3: REQSRC3 Mask           */
S
S#define PDMA_REQSEL4_7_REQSRC4_Pos       (0)                                               /*!< PDMA_T::REQSEL4_7: REQSRC4 Position       */
S#define PDMA_REQSEL4_7_REQSRC4_Msk       (0x1ful << PDMA_REQSEL4_7_REQSRC4_Pos)            /*!< PDMA_T::REQSEL4_7: REQSRC4 Mask           */
S
S#define PDMA_REQSEL4_7_REQSRC5_Pos       (8)                                               /*!< PDMA_T::REQSEL4_7: REQSRC5 Position       */
S#define PDMA_REQSEL4_7_REQSRC5_Msk       (0x1ful << PDMA_REQSEL4_7_REQSRC5_Pos)            /*!< PDMA_T::REQSEL4_7: REQSRC5 Mask           */
S
S#define PDMA_REQSEL4_7_REQSRC6_Pos       (16)                                              /*!< PDMA_T::REQSEL4_7: REQSRC6 Position       */
S#define PDMA_REQSEL4_7_REQSRC6_Msk       (0x1ful << PDMA_REQSEL4_7_REQSRC6_Pos)            /*!< PDMA_T::REQSEL4_7: REQSRC6 Mask           */
S
S#define PDMA_REQSEL4_7_REQSRC7_Pos       (24)                                              /*!< PDMA_T::REQSEL4_7: REQSRC7 Position       */
S#define PDMA_REQSEL4_7_REQSRC7_Msk       (0x1ful << PDMA_REQSEL4_7_REQSRC7_Pos)            /*!< PDMA_T::REQSEL4_7: REQSRC7 Mask           */
S
S#define PDMA_REQSEL8_11_REQSRC8_Pos      (0)                                               /*!< PDMA_T::REQSEL8_11: REQSRC8 Position      */
S#define PDMA_REQSEL8_11_REQSRC8_Msk      (0x1ful << PDMA_REQSEL8_11_REQSRC8_Pos)           /*!< PDMA_T::REQSEL8_11: REQSRC8 Mask          */
S
S#define PDMA_REQSEL8_11_REQSRC9_Pos      (8)                                               /*!< PDMA_T::REQSEL8_11: REQSRC9 Position      */
S#define PDMA_REQSEL8_11_REQSRC9_Msk      (0x1ful << PDMA_REQSEL8_11_REQSRC9_Pos)           /*!< PDMA_T::REQSEL8_11: REQSRC9 Mask          */
S
S#define PDMA_REQSEL8_11_REQSRC10_Pos     (16)                                              /*!< PDMA_T::REQSEL8_11: REQSRC10 Position     */
S#define PDMA_REQSEL8_11_REQSRC10_Msk     (0x1ful << PDMA_REQSEL8_11_REQSRC10_Pos)          /*!< PDMA_T::REQSEL8_11: REQSRC10 Mask         */
S
S#define PDMA_REQSEL8_11_REQSRC11_Pos     (24)                                              /*!< PDMA_T::REQSEL8_11: REQSRC11 Position     */
S#define PDMA_REQSEL8_11_REQSRC11_Msk     (0x1ful << PDMA_REQSEL8_11_REQSRC11_Pos)          /*!< PDMA_T::REQSEL8_11: REQSRC11 Mask         */
S
S/**@}*/ /* PDMA_CONST */
S/**@}*/ /* end of PDMA register group */
S
S
S/*---------------------- Pulse Width Modulation Controller -------------------------*/
S/**
S    @addtogroup PWM Pulse Width Modulation Controller(PWM)
S    Memory Mapped Structure for PWM Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S/**
S * @var PWM_T::CTL0
S * Offset: 0x00  PWM Control Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |CTRLDn    |Center Re-Load
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |In up-down counter type, PERIOD will load to PBUF at the end point of each period.
S * |        |          |CMPDAT will load to CMPBUF at the center point of a period.
S * |[13:8]  |WINLDENn  |Window Load Enable
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |0 = PERIOD will load to PBUF at the end point of each period.
S * |        |          |CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
S * |        |          |1 = PERIOD will load to PBUF at the end point of each period.
S * |        |          |CMPDAT will load to CMPBUF at the end point of each period when valid reload window is set.
S * |        |          |The valid reload window is set by software write 1 to PWM_LOAD register and cleared by hardware after load success.
S * |[21:16] |IMMLDENn  |Immediately Load Enable
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |0 = PERIOD will load to PBUF at the end point of each period.
S * |        |          |CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
S * |        |          |1 = PERIOD/CMPDAT will load to PBUF and CMPBUF immediately when software update PERIOD/CMPDAT.
S * |        |          |Note: If IMMLDENn is enabled, WINLDENn and CTRLDn will be invalid.
S * |[24]    |GROUPEN   |Group Function Enable
S * |        |          |0 = The output waveform of each PWM channel are independent.
S * |        |          |1 = Unify the PWM_CH2 and PWM_CH4 to output the same waveform as PWM_CH0 and unify the PWM_CH3 and PWM_CH5 to output the same waveform as PWM_CH1.
S * |[30]    |DBGHALT   |ICE Debug Mode Counter Halt (Write Protect)
S * |        |          |If counter halt is enabled, PWM all counters will keep current value until exit ICE debug mode.
S * |        |          |0 = ICE debug mode counter halt disable.
S * |        |          |1 = ICE debug mode counter halt enable.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[31]    |DBGTRIOFF |ICE Debug Mode Acknowledge Disable (Write Protect)
S * |        |          |0 = ICE debug mode acknowledgement effects PWM output.
S * |        |          |PWM pin will be forced as tri-state while ICE debug mode acknowledged.
S * |        |          |1 = ICE debug mode acknowledgement disabled.
S * |        |          |PWM pin will keep output no matter ICE debug mode acknowledged or not.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * @var PWM_T::CTL1
S * Offset: 0x04  PWM Control Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[11:0]  |CNTTYPEn  |PWM Counter Behavior Type
S * |        |          |Each bit n controls corresponding PWM channel n.
S * |        |          |00 = Up counter type (supports in capture mode).
S * |        |          |01 = Down count type (supports in capture mode).
S * |        |          |10 = Up-down counter type.
S * |        |          |11 = Reserved.
S * |[21:16] |CNTMODEn  |PWM Counter Mode
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |0 = Auto-reload mode.
S * |        |          |1 = One-shot mode.
S * |[26:24] |OUTMODEn  |PWM Output Mode
S * |        |          |Each bit n controls the
S * |        |          |output mode of
S * |        |          |corresponding PWM channel n.
S * |        |          |0 = PWM independent mode.
S * |        |          |1 = PWM complementary mode.
S * |        |          |Note: When operating in group function, these bits must all set to the same mode.
S * @var PWM_T::SYNC
S * Offset: 0x08  PWM Synchronization Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[2:0]   |PHSENn    |SYNC Phase Enable
S * |        |          |Each bit n controls corresponding PWM channel n.
S * |        |          |0 = PWM counter disable to load PHS value.
S * |        |          |1 = PWM counter enable to load PHS value.
S * |[13:8]  |SINSRCn   |PWM_SYNC_IN Source Selection
S * |        |          |Each bit n controls corresponding PWM channel n.
S * |        |          |00 = Synchronize source from SYNC_IN or SWSYNC.
S * |        |          |01 = Counter equal to 0.
S * |        |          |10 = Counter equal to PWM_CMPDATm, m denotes 1, 3, 5.
S * |        |          |11 = SYNC_OUT will not be generated.
S * |[16]    |SNFLTEN   |PWM_SYNC_IN Noise Filter Enable
S * |        |          |0 = Noise filter of input pin PWM_SYNC_IN is Disabled.
S * |        |          |1 = Noise filter of input pin PWM_SYNC_IN is Enabled.
S * |[19:17] |SFLTCSEL  |SYNC Edge Detector Filter Clock Selection
S * |        |          |000 = Filter clock = HCLK.
S * |        |          |001 = Filter clock = HCLK/2.
S * |        |          |010 = Filter clock = HCLK/4.
S * |        |          |011 = Filter clock = HCLK/8.
S * |        |          |100 = Filter clock = HCLK/16.
S * |        |          |101 = Filter clock = HCLK/32.
S * |        |          |110 = Filter clock = HCLK/64.
S * |        |          |111 = Filter clock = HCLK/128.
S * |[22:20] |SFLTCNT   |SYNC Edge Detector Filter Count
S * |        |          |The register bits control the counter number of edge detector.
S * |[23]    |SINPINV   |SYNC Input Pin Inverse
S * |        |          |0 = The state of pin SYNC is passed to the negative edge detector.
S * |        |          |1 = The inverted state of pin SYNC is passed to the negative edge detector.
S * |[26:24] |PHSDIRn   |PWM Phase Direction Control
S * |        |          |Each bit n controls corresponding PWM channel n.
S * |        |          |0 = Control PWM counter count decrement after synchronizing.
S * |        |          |1 = Control PWM counter count increment after synchronizing.
S * @var PWM_T::SWSYNC
S * Offset: 0x0C  PWM Software Control Synchronization Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[2:0]   |SWSYNCn   |Software SYNC Function
S * |        |          |Each bit n controls corresponding PWM channel n.
S * |        |          |When SINSRCn (PWM_SYNC[13:8]) is selected to 0, SYNC_OUT source is come from SYNC_IN or this bit.
S * @var PWM_T::CLKSRC
S * Offset: 0x10  PWM Clock Source Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[2:0]   |ECLKSRC0  |PWM_CH01 External Clock Source Select
S * |        |          |000 = PWMx_CLK, x denotes 0 or 1.
S * |        |          |001 = TIMER0 overflow.
S * |        |          |010 = TIMER1 overflow.
S * |        |          |011 = TIMER2 overflow.
S * |        |          |100 = TIMER3 overflow.
S * |        |          |Others = Reserved.
S * |[10:8]  |ECLKSRC2  |PWM_CH23 External Clock Source Select
S * |        |          |000 = PWMx_CLK, x denotes 0 or 1.
S * |        |          |001 = TIMER0 overflow.
S * |        |          |010 = TIMER1 overflow.
S * |        |          |011 = TIMER2 overflow.
S * |        |          |100 = TIMER3 overflow.
S * |        |          |Others = Reserved.
S * |[18:16] |ECLKSRC4  |PWM_CH45 External Clock Source Select
S * |        |          |000 = PWMx_CLK, x denotes 0 or 1.
S * |        |          |001 = TIMER0 overflow.
S * |        |          |010 = TIMER1 overflow.
S * |        |          |011 = TIMER2 overflow.
S * |        |          |100 = TIMER3 overflow.
S * |        |          |Others = Reserved.
S * @var PWM_T::CLKPSC0_1
S * Offset: 0x14  PWM Clock Pre-scale Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-Scale
S * |        |          |The clock of PWM counter is decided by clock prescaler.
S * |        |          |Each PWM pair share one PWM counter clock prescaler.
S * |        |          |The clock of PWM counter is divided by (CLKPSC+ 1).
S * @var PWM_T::CLKPSC2_3
S * Offset: 0x18  PWM Clock Pre-scale Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-Scale
S * |        |          |The clock of PWM counter is decided by clock prescaler.
S * |        |          |Each PWM pair share one PWM counter clock prescaler.
S * |        |          |The clock of PWM counter is divided by (CLKPSC+ 1).
S * @var PWM_T::CLKPSC4_5
S * Offset: 0x1C  PWM Clock Pre-scale Register 4
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-Scale
S * |        |          |The clock of PWM counter is decided by clock prescaler.
S * |        |          |Each PWM pair share one PWM counter clock prescaler.
S * |        |          |The clock of PWM counter is divided by (CLKPSC+ 1).
S * @var PWM_T::CNTEN
S * Offset: 0x20  PWM Counter Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |CNTENn    |PWM Counter Enable
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |0 = PWM Counter and clock prescaler Stop Running.
S * |        |          |1 = PWM Counter and clock prescaler Start Running.
S * @var PWM_T::CNTCLR
S * Offset: 0x24  PWM Clear Counter Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |CNTCLRn   |Clear PWM Counter Control Bit
S * |        |          |It is automatically cleared by hardware. Each bit n controls the corresponding PWM channel n.
S * |        |          |0 = No effect.
S * |        |          |1 = Clear 16-bit PWM counter to 0000H.
S * @var PWM_T::LOAD
S * Offset: 0x28  PWM Load Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |LOADn     |Re-Load PWM Comparator Register (CMPDAT) Control Bit
S * |        |          |This bit is software write, hardware clear when current PWM period end.
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Set load window of window loading mode.
S * |        |          |Read Operation:
S * |        |          |0 = No load window is set.
S * |        |          |1 = Load window is set.
S * |        |          |Note: This bit only use in window loading mode, WINLDENn(PWM_CTL0[13:8]) = 1.
S * @var PWM_T::PERIOD
S * Offset: 0x30~0x44  PWM Period Register 0~5
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |PERIOD    |PWM Period Register
S * |        |          |Up-Count mode: In this mode, PWM counter counts from 0 to PERIOD, and restarts from 0.
S * |        |          |Down-Count mode: In this mode, PWM counter counts from PERIOD to 0, and restarts from PERIOD.
S * |        |          |PWM period time = (PERIOD+1) * PWM_CLK period.
S * |        |          |Up-Down-Count mode: In this mode, PWM counter counts from 0 to PERIOD, then decrements to 0 and repeats again.
S * |        |          |PWM period time = 2 * PERIOD * PWM_CLK period.
S * @var PWM_T::CMPDAT
S * Offset: 0x50~0x64  PWM Comparator Register 0~5
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CMP       |PWM Comparator Register
S * |        |          |CMP use to compare with CNTR to generate PWM waveform, interrupt and trigger EADC/DAC.
S * |        |          |In independent mode, CMPDAT0~5 denote as 6 independent PWM_CH0~5 compared point.
S * |        |          |In complementary mode, CMPDAT0, 2, 4 denote as first compared point, and CMPDAT1, 3, 5 denote as second compared point for the corresponding 3 complementary pairs PWM_CH0 and PWM_CH1, PWM_CH2 and PWM_CH3, PWM_CH4 and PWM_CH5.
S * @var PWM_T::DTCTL0_1
S * Offset: 0x70  PWM Dead-Time Control Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[11:0]  |DTCNT     |Dead-Time Counter (Write Protect)
S * |        |          |The dead-time can be calculated from the following formula:
S * |        |          |Dead-time = (DTCNT[11:0]+1) * PWM_CLK period.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[16]    |DTEN      |Enable Dead-Time Insertion For PWM Pair (PWM_CH0, PWM_CH1) (PWM_CH2, PWM_CH3) (PWM_CH4, PWM_CH5) (Write Protect)
S * |        |          |Dead-time insertion is only active when this pair of complementary PWM is enabled.
S * |        |          |If dead- time insertion is inactive, the outputs of pin pair are complementary without any delay.
S * |        |          |0 = Dead-time insertion Disabled on the pin pair.
S * |        |          |1 = Dead-time insertion Enabled on the pin pair.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[24]    |DTCKSEL   |Dead-Time Clock Select (Write Protect) (M45xD/M45xC Only)
S * |        |          |0 = Dead-time clock source from PWM_CLK.
S * |        |          |1 = Dead-time clock source from prescaler output.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * @var PWM_T::DTCTL2_3
S * Offset: 0x74  PWM Dead-Time Control Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[11:0]  |DTCNT     |Dead-Time Counter (Write Protect)
S * |        |          |The dead-time can be calculated from the following formula:
S * |        |          |Dead-time = (DTCNT[11:0]+1) * PWM_CLK period.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[16]    |DTEN      |Enable Dead-Time Insertion For PWM Pair (PWM_CH0, PWM_CH1) (PWM_CH2, PWM_CH3) (PWM_CH4, PWM_CH5) (Write Protect)
S * |        |          |Dead-time insertion is only active when this pair of complementary PWM is enabled.
S * |        |          |If dead- time insertion is inactive, the outputs of pin pair are complementary without any delay.
S * |        |          |0 = Dead-time insertion Disabled on the pin pair.
S * |        |          |1 = Dead-time insertion Enabled on the pin pair.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[24]    |DTCKSEL   |Dead-Time Clock Select (Write Protect) (M45xD/M45xC Only)
S * |        |          |0 = Dead-time clock source from PWM_CLK.
S * |        |          |1 = Dead-time clock source from prescaler output.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * @var PWM_T::DTCTL4_5
S * Offset: 0x78  PWM Dead-Time Control Register 4
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[11:0]  |DTCNT     |Dead-Time Counter (Write Protect)
S * |        |          |The dead-time can be calculated from the following formula:
S * |        |          |Dead-time = (DTCNT[11:0]+1) * PWM_CLK period.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[16]    |DTEN      |Enable Dead-Time Insertion For PWM Pair (PWM_CH0, PWM_CH1) (PWM_CH2, PWM_CH3) (PWM_CH4, PWM_CH5) (Write Protect)
S * |        |          |Dead-time insertion is only active when this pair of complementary PWM is enabled.
S * |        |          |If dead- time insertion is inactive, the outputs of pin pair are complementary without any delay.
S * |        |          |0 = Dead-time insertion Disabled on the pin pair.
S * |        |          |1 = Dead-time insertion Enabled on the pin pair.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[24]    |DTCKSEL   |Dead-Time Clock Select (Write Protect) (M45xD/M45xC Only)
S * |        |          |0 = Dead-time clock source from PWM_CLK.
S * |        |          |1 = Dead-time clock source from prescaler output.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * @var PWM_T::PHS0_1
S * Offset: 0x80  PWM Counter Phase Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |PHS       |PWM Synchronous Start Phase Bits
S * |        |          |PHS determines the PWM synchronous start phase value. These bits only use in synchronous function.
S * @var PWM_T::PHS2_3
S * Offset: 0x84  PWM Counter Phase Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |PHS       |PWM Synchronous Start Phase Bits
S * |        |          |PHS determines the PWM synchronous start phase value. These bits only use in synchronous function.
S * @var PWM_T::PHS4_5
S * Offset: 0x88  PWM Counter Phase Register 4
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |PHS       |PWM Synchronous Start Phase Bits
S * |        |          |PHS determines the PWM synchronous start phase value. These bits only use in synchronous function.
S * @var PWM_T::CNT
S * Offset: 0x90~0xA4  PWM Counter Register 0~5
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CNT       |PWM Data Register (Read Only)
S * |        |          |User can monitor CNTR to know the current value in 16-bit period counter.
S * |[16]    |DIRF      |PWM Direction Indicator Flag (Read Only)
S * |        |          |0 = Counter is Down count.
S * |        |          |1 = Counter is UP count.
S * @var PWM_T::WGCTL0
S * Offset: 0xB0  PWM Generation Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[11:0]  |ZPCTLn    |PWM Zero Point Control
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |00 = Do nothing.
S * |        |          |01 = PWM zero point output Low.
S * |        |          |10 = PWM zero point output High.
S * |        |          |11 = PWM zero point output Toggle.
S * |        |          |PWM can control output level when PWM counter count to zero.
S * |[27:16] |PRDPCTLn  |PWM Period (Center) Point Control
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |00 = Do nothing.
S * |        |          |01 = PWM period (center) point output Low.
S * |        |          |10 = PWM period (center) point output High.
S * |        |          |11 = PWM period (center) point output Toggle.
S * |        |          |PWM can control output level when PWM counter count to (PERIODn+1).
S * |        |          |Note: This bit is center point control when PWM counter operating in up-down counter type.
S * @var PWM_T::WGCTL1
S * Offset: 0xB4  PWM Generation Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[11:0]  |CMPUCTLn  |PWM Compare Up Point Control
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |00 = Do nothing.
S * |        |          |01 = PWM compare up point output Low.
S * |        |          |10 = PWM compare up point output High.
S * |        |          |11 = PWM compare up point output Toggle.
S * |        |          |PWM can control output level when PWM counter up count to CMPDAT.
S * |        |          |Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
S * |[27:16] |CMPDCTLn  |PWM Compare Down Point Control
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |00 = Do nothing.
S * |        |          |01 = PWM compare down point output Low.
S * |        |          |10 = PWM compare down point output High.
S * |        |          |11 = PWM compare down point output Toggle.
S * |        |          |PWM can control output level when PWM counter down count to CMPDAT.
S * |        |          |Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
S * @var PWM_T::MSKEN
S * Offset: 0xB8  PWM Mask Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |MSKENn    |PWM Mask Enable
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |The PWM output signal will be masked when this bit is enabled.
S * |        |          |The corresponding PWM channel n will output MSKDATn (PWM_MSK[5:0]) data.
S * |        |          |0 = PWM output signal is non-masked.
S * |        |          |1 = PWM output signal is masked and output MSKDATn data.
S * @var PWM_T::MSK
S * Offset: 0xBC  PWM Mask Data Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |MSKDATn   |PWM Mask Data Bit
S * |        |          |This data bit control the state of PWMn output pin, if corresponding mask function is enabled.
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |0 = Output logic low to PWMn.
S * |        |          |1 = Output logic high to PWMn.
S * @var PWM_T::BNF
S * Offset: 0xC0  PWM Brake Noise Filter Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |BRK0NFEN  |PWM Brake 0 Noise Filter Enable
S * |        |          |0 = Noise filter of PWM Brake 0 Disabled.
S * |        |          |1 = Noise filter of PWM Brake 0 Enabled.
S * |[3:1]   |BRK0NFSEL |Brake 0 Edge Detector Filter Clock Selection
S * |        |          |000 = Filter clock = HCLK.
S * |        |          |001 = Filter clock = HCLK/2.
S * |        |          |010 = Filter clock = HCLK/4.
S * |        |          |011 = Filter clock = HCLK/8.
S * |        |          |100 = Filter clock = HCLK/16.
S * |        |          |101 = Filter clock = HCLK/32.
S * |        |          |110 = Filter clock = HCLK/64.
S * |        |          |111 = Filter clock = HCLK/128.
S * |[6:4]   |BRK0FCNT  |Brake 0 Edge Detector Filter Count
S * |        |          |The register bits control the Brake0 filter counter to count from 0 to BRK1FCNT.
S * |[7]     |BRK0PINV  |Brake 0 Pin Inverse
S * |        |          |0 = The state of pin PWMx_BRAKE0 is passed to the negative edge detector.
S * |        |          |1 = The inverted state of pin PWMx_BRAKE10 is passed to the negative edge detector.
S * |[8]     |BRK1NFEN  |PWM Brake 1 Noise Filter Enable
S * |        |          |0 = Noise filter of PWM Brake 1 Disabled.
S * |        |          |1 = Noise filter of PWM Brake 1 Enabled.
S * |[11:9]  |BRK1NFSEL |Brake 1 Edge Detector Filter Clock Selection
S * |        |          |000 = Filter clock = HCLK.
S * |        |          |001 = Filter clock = HCLK/2.
S * |        |          |010 = Filter clock = HCLK/4.
S * |        |          |011 = Filter clock = HCLK/8.
S * |        |          |100 = Filter clock = HCLK/16.
S * |        |          |101 = Filter clock = HCLK/32.
S * |        |          |110 = Filter clock = HCLK/64.
S * |        |          |111 = Filter clock = HCLK/128.
S * |[14:12] |BRK1FCNT  |Brake 1 Edge Detector Filter Count
S * |        |          |The register bits control the Brake1 filter counter to count from 0 to BRK1FCNT.
S * |[15]    |BRK1PINV  |Brake 1 Pin Inverse
S * |        |          |0 = The state of pin PWMx_BRAKE1 is passed to the negative edge detector.
S * |        |          |1 = The inverted state of pin PWMx_BRAKE1 is passed to the negative edge detector.
S * |[16]    |BK0SRC    |Brake 0 Pin Source Select (M45xD/M45xC Only)
S * |        |          |For PWM0 setting:
S * |        |          |0 = Brake 0 pin source come from PWM0_BRAKE0.
S * |        |          |1 = Brake 0 pin source come from PWM1_BRAKE0.
S * |        |          |For PWM1 setting:
S * |        |          |0 = Brake 0 pin source come from PWM1_BRAKE0.
S * |        |          |1 = Brake 0 pin source come from PWM0_BRAKE0.
S * |[24]    |BK1SRC    |Brake 1 Pin Source Select (M45xD/M45xC Only)
S * |        |          |For PWM0 setting:
S * |        |          |0 = Brake 1 pin source come from PWM0_BRAKE1.
S * |        |          |1 = Brake 1 pin source come from PWM1_BRAKE1.
S * |        |          |For PWM1 setting:
S * |        |          |0 = Brake 1 pin source come from PWM1_BRAKE1.
S * |        |          |1 = Brake 1 pin source come from PWM0_BRAKE1.
S * @var PWM_T::FAILBRK
S * Offset: 0xC4  PWM System Fail Brake Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |CSSBRKEN  |Clock Security System Detection Trigger PWM Brake Function 0 Enable
S * |        |          |0 = Brake Function triggered by CSS detection Disabled.
S * |        |          |1 = Brake Function triggered by CSS detection Enabled.
S * |[1]     |BODBRKEN  |Brown-Out Detection Trigger PWM Brake Function 0 Enable
S * |        |          |0 = Brake Function triggered by BOD Disabled.
S * |        |          |1 = Brake Function triggered by BOD Enabled.
S * |[2]     |RAMBRKEN  |SRAM Parity Error Detection Trigger PWM Brake Function 0 Enable
S * |        |          |0 = Brake Function triggered by SRAM parity error detection Disabled.
S * |        |          |1 = Brake Function triggered by SRAM parity error detection Enabled.
S * |[3]     |CORBRKEN  |Core Lockup Detection Trigger PWM Brake Function 0 Enable
S * |        |          |0 = Brake Function triggered by Core lockup detection Disabled.
S * |        |          |1 = Brake Function triggered by Core lockup detection Enabled.
S * @var PWM_T::BRKCTL0_1
S * Offset: 0xC8  PWM Brake Edge Detect Control Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |CPO0EBEN  |Enable ACMP0_O Digital Output As Edge-Detect Brake Source (Write Protect)
S * |        |          |0 = ACMP0_O as edge-detect brake source Disabled.
S * |        |          |1 = ACMP0_O as edge-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[1]     |CPO1EBEN  |Enable ACMP1_O Digital Output As Edge-Detect Brake Source (Write Protect)
S * |        |          |0 = ACMP1_O as edge-detect brake source Disabled.
S * |        |          |1 = ACMP1_O as edge-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[4]     |BRKP0EEN  |Enable PWMx_BRAKE0 Pin As Edge-Detect Brake Source (Write Protect)
S * |        |          |0 = BKP0 pin as edge-detect brake source Disabled.
S * |        |          |1 = BKP0 pin as edge-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[5]     |BRKP1EEN  |Enable PWMx_BRAKE1 Pin As Edge-Detect Brake Source (Write Protect)
S * |        |          |0 = BKP1 pin as edge-detect brake source Disabled.
S * |        |          |1 = BKP1 pin as edge-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[7]     |SYSEBEN   |Enable System Fail As Edge-Detect Brake Source (Write Protect)
S * |        |          |0 = System Fail condition as edge-detect brake source Disabled.
S * |        |          |1 = System Fail condition as edge-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[8]     |CPO0LBEN  |Enable ACMP0_O Digital Output As Level-Detect Brake Source (Write Protect)
S * |        |          |0 = ACMP0_O as level-detect brake source Disabled.
S * |        |          |1 = ACMP0_O as level-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[9]     |CPO1LBEN  |Enable ACMP1_O Digital Output As Level-Detect Brake Source (Write Protect)
S * |        |          |0 = ACMP1_O as level-detect brake source Disabled.
S * |        |          |1 = ACMP1_O as level-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[12]    |BRKP0LEN  |Enable BKP0 Pin As Level-Detect Brake Source (Write Protect)
S * |        |          |0 = PWMx_BRAKE0 pin as level-detect brake source Disabled.
S * |        |          |1 = PWMx_BRAKE0 pin as level-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[13]    |BRKP1LEN  |Enable BKP1 Pin As Level-Detect Brake Source (Write Protect)
S * |        |          |0 = PWMx_BRAKE1 pin as level-detect brake source Disabled.
S * |        |          |1 = PWMx_BRAKE1 pin as level-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[15]    |SYSLBEN   |Enable System Fail As Level-Detect Brake Source (Write Protect)
S * |        |          |0 = System Fail condition as level-detect brake source Disabled.
S * |        |          |1 = System Fail condition as level-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[17:16] |BRKAEVEN  |PWM Brake Action Select For Even Channel (Write Protect)
S * |        |          |00 = PWM even channel level-detect brake function not affect channel output.
S * |        |          |01 = PWM even channel output tri-state when level-detect brake happened.
S * |        |          |10 = PWM even channel output low level when level-detect brake happened.
S * |        |          |11 = PWM even channel output high level when level-detect brake happened.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[19:18] |BRKAODD   |PWM Brake Action Select For Odd Channel (Write Protect)
S * |        |          |00 = PWM odd channel level-detect brake function not affect channel output.
S * |        |          |01 = PWM odd channel output tri-state when level-detect brake happened.
S * |        |          |10 = PWM odd channel output low level when level-detect brake happened.
S * |        |          |11 = PWM odd channel output high level when level-detect brake happened.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * @var PWM_T::BRKCTL2_3
S * Offset: 0xCC  PWM Brake Edge Detect Control Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |CPO0EBEN  |Enable ACMP0_O Digital Output As Edge-Detect Brake Source (Write Protect)
S * |        |          |0 = ACMP0_O as edge-detect brake source Disabled.
S * |        |          |1 = ACMP0_O as edge-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[1]     |CPO1EBEN  |Enable ACMP1_O Digital Output As Edge-Detect Brake Source (Write Protect)
S * |        |          |0 = ACMP1_O as edge-detect brake source Disabled.
S * |        |          |1 = ACMP1_O as edge-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[4]     |BRKP0EEN  |Enable PWMx_BRAKE0 Pin As Edge-Detect Brake Source (Write Protect)
S * |        |          |0 = BKP0 pin as edge-detect brake source Disabled.
S * |        |          |1 = BKP0 pin as edge-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[5]     |BRKP1EEN  |Enable PWMx_BRAKE1 Pin As Edge-Detect Brake Source (Write Protect)
S * |        |          |0 = BKP1 pin as edge-detect brake source Disabled.
S * |        |          |1 = BKP1 pin as edge-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[7]     |SYSEBEN   |Enable System Fail As Edge-Detect Brake Source (Write Protect)
S * |        |          |0 = System Fail condition as edge-detect brake source Disabled.
S * |        |          |1 = System Fail condition as edge-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[8]     |CPO0LBEN  |Enable ACMP0_O Digital Output As Level-Detect Brake Source (Write Protect)
S * |        |          |0 = ACMP0_O as level-detect brake source Disabled.
S * |        |          |1 = ACMP0_O as level-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[9]     |CPO1LBEN  |Enable ACMP1_O Digital Output As Level-Detect Brake Source (Write Protect)
S * |        |          |0 = ACMP1_O as level-detect brake source Disabled.
S * |        |          |1 = ACMP1_O as level-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[12]    |BRKP0LEN  |Enable BKP0 Pin As Level-Detect Brake Source (Write Protect)
S * |        |          |0 = PWMx_BRAKE0 pin as level-detect brake source Disabled.
S * |        |          |1 = PWMx_BRAKE0 pin as level-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[13]    |BRKP1LEN  |Enable BKP1 Pin As Level-Detect Brake Source (Write Protect)
S * |        |          |0 = PWMx_BRAKE1 pin as level-detect brake source Disabled.
S * |        |          |1 = PWMx_BRAKE1 pin as level-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[15]    |SYSLBEN   |Enable System Fail As Level-Detect Brake Source (Write Protect)
S * |        |          |0 = System Fail condition as level-detect brake source Disabled.
S * |        |          |1 = System Fail condition as level-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[17:16] |BRKAEVEN  |PWM Brake Action Select For Even Channel (Write Protect)
S * |        |          |00 = PWM even channel level-detect brake function not affect channel output.
S * |        |          |01 = PWM even channel output tri-state when level-detect brake happened.
S * |        |          |10 = PWM even channel output low level when level-detect brake happened.
S * |        |          |11 = PWM even channel output high level when level-detect brake happened.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[19:18] |BRKAODD   |PWM Brake Action Select For Odd Channel (Write Protect)
S * |        |          |00 = PWM odd channel level-detect brake function not affect channel output.
S * |        |          |01 = PWM odd channel output tri-state when level-detect brake happened.
S * |        |          |10 = PWM odd channel output low level when level-detect brake happened.
S * |        |          |11 = PWM odd channel output high level when level-detect brake happened.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * @var PWM_T::BRKCTL4_5
S * Offset: 0xD0  PWM Brake Edge Detect Control Register 4
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |CPO0EBEN  |Enable ACMP0_O Digital Output As Edge-Detect Brake Source (Write Protect)
S * |        |          |0 = ACMP0_O as edge-detect brake source Disabled.
S * |        |          |1 = ACMP0_O as edge-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[1]     |CPO1EBEN  |Enable ACMP1_O Digital Output As Edge-Detect Brake Source (Write Protect)
S * |        |          |0 = ACMP1_O as edge-detect brake source Disabled.
S * |        |          |1 = ACMP1_O as edge-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[4]     |BRKP0EEN  |Enable PWMx_BRAKE0 Pin As Edge-Detect Brake Source (Write Protect)
S * |        |          |0 = BKP0 pin as edge-detect brake source Disabled.
S * |        |          |1 = BKP0 pin as edge-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[5]     |BRKP1EEN  |Enable PWMx_BRAKE1 Pin As Edge-Detect Brake Source (Write Protect)
S * |        |          |0 = BKP1 pin as edge-detect brake source Disabled.
S * |        |          |1 = BKP1 pin as edge-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[7]     |SYSEBEN   |Enable System Fail As Edge-Detect Brake Source (Write Protect)
S * |        |          |0 = System Fail condition as edge-detect brake source Disabled.
S * |        |          |1 = System Fail condition as edge-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[8]     |CPO0LBEN  |Enable ACMP0_O Digital Output As Level-Detect Brake Source (Write Protect)
S * |        |          |0 = ACMP0_O as level-detect brake source Disabled.
S * |        |          |1 = ACMP0_O as level-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[9]     |CPO1LBEN  |Enable ACMP1_O Digital Output As Level-Detect Brake Source (Write Protect)
S * |        |          |0 = ACMP1_O as level-detect brake source Disabled.
S * |        |          |1 = ACMP1_O as level-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[12]    |BRKP0LEN  |Enable BKP0 Pin As Level-Detect Brake Source (Write Protect)
S * |        |          |0 = PWMx_BRAKE0 pin as level-detect brake source Disabled.
S * |        |          |1 = PWMx_BRAKE0 pin as level-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[13]    |BRKP1LEN  |Enable BKP1 Pin As Level-Detect Brake Source (Write Protect)
S * |        |          |0 = PWMx_BRAKE1 pin as level-detect brake source Disabled.
S * |        |          |1 = PWMx_BRAKE1 pin as level-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[15]    |SYSLBEN   |Enable System Fail As Level-Detect Brake Source (Write Protect)
S * |        |          |0 = System Fail condition as level-detect brake source Disabled.
S * |        |          |1 = System Fail condition as level-detect brake source Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[17:16] |BRKAEVEN  |PWM Brake Action Select For Even Channel (Write Protect)
S * |        |          |00 = PWM even channel level-detect brake function not affect channel output.
S * |        |          |01 = PWM even channel output tri-state when level-detect brake happened.
S * |        |          |10 = PWM even channel output low level when level-detect brake happened.
S * |        |          |11 = PWM even channel output high level when level-detect brake happened.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[19:18] |BRKAODD   |PWM Brake Action Select For Odd Channel (Write Protect)
S * |        |          |00 = PWM odd channel level-detect brake function not affect channel output.
S * |        |          |01 = PWM odd channel output tri-state when level-detect brake happened.
S * |        |          |10 = PWM odd channel output low level when level-detect brake happened.
S * |        |          |11 = PWM odd channel output high level when level-detect brake happened.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * @var PWM_T::POLCTL
S * Offset: 0xD4  PWM Pin Polar Inverse Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |PINVn     |PWM PIN Polar Inverse Control
S * |        |          |The register controls polarity state of PWM output.
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |0 = PWM output polar inverse Disabled.
S * |        |          |1 = PWM output polar inverse Enabled.
S * @var PWM_T::POEN
S * Offset: 0xD8  PWM Output Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |POENn     |PWM Pin Output Enable
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |0 = PWM pin at tri-state.
S * |        |          |1 = PWM pin in output mode.
S * @var PWM_T::SWBRK
S * Offset: 0xDC  PWM Software Brake Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[2:0]   |BRKETRGn  |PWM Edge Brake Software Trigger (Write Only) (Write Protect) (M45xD/M45xC Only)
S * |        |          |Each bit n controls the corresponding PWM pair n.
S * |        |          |Write 1 to this bit will trigger edge brake, and set BRKEIFn to 1 in PWM_INTSTS1 register.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[10:8]  |BRKLTRGn  |PWM Level Brake Software Trigger (Write Only) (Write Protect)
S * |        |          |Each bit n controls the corresponding PWM pair n.
S * |        |          |Write 1 to this bit will trigger level brake, and set BRKLIFn to 1 in PWM_INTSTS1 register.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * @var PWM_T::INTEN0
S * Offset: 0xE0  PWM Interrupt Enable Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |ZIENn     |PWM Zero Point Interrupt Enable
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |0 = Zero point interrupt Disabled.
S * |        |          |1 = Zero point interrupt Enabled.
S * |        |          |Note: Odd channels will read always 0 at complementary mode.
S * |[7]     |IFAIEN0_1 |PWM_CH0/1 Interrupt Flag Accumulator Interrupt Enable
S * |        |          |0 = Interrupt Flag accumulator interrupt Disabled.
S * |        |          |1 = Interrupt Flag accumulator interrupt Enabled.
S * |[13:8]  |PIENn     |PWM Period Point Interrupt Enable
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |0 = Period point interrupt Disabled.
S * |        |          |1 = Period point interrupt Enabled.
S * |        |          |Note1: When up-down counter type period point means center point.
S * |        |          |Note2: Odd channels will read always 0 at complementary mode.
S * |[15]    |IFAIEN2_3 |PWM_CH2/3 Interrupt Flag Accumulator Interrupt Enable
S * |        |          |0 = Interrupt Flag accumulator interrupt Disabled.
S * |        |          |1 = Interrupt Flag accumulator interrupt Enabled.
S * |[21:16] |CMPUIENn  |PWM Compare Up Count Interrupt Enable
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |0 = Compare up count interrupt Disabled.
S * |        |          |1 = Compare up count interrupt Enabled.
S * |        |          |Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
S * |[23]    |IFAIEN4_5 |PWM_CH4/5 Interrupt Flag Accumulator Interrupt Enable
S * |        |          |0 = Interrupt Flag accumulator interrupt Disabled.
S * |        |          |1 = Interrupt Flag accumulator interrupt Enabled.
S * |[29:24] |CMPDIENn  |PWM Compare Down Count Interrupt Enable
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |0 = Compare down count interrupt Disabled.
S * |        |          |1 = Compare down count interrupt Enabled.
S * |        |          |Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
S * @var PWM_T::INTEN1
S * Offset: 0xE4  PWM Interrupt Enable Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |BRKEIEN0_1|PWM Edge-Detect Brake Interrupt Enable For Channel0/1 (Write Protect)
S * |        |          |0 = Edge-detect Brake interrupt for channel0/1 Disabled.
S * |        |          |1 = Edge-detect Brake interrupt for channel0/1 Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[1]     |BRKEIEN2_3|PWM Edge-Detect Brake Interrupt Enable For Channel2/3 (Write Protect)
S * |        |          |0 = Edge-detect Brake interrupt for channel2/3 Disabled.
S * |        |          |1 = Edge-detect Brake interrupt for channel2/3 Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[2]     |BRKEIEN4_5|PWM Edge-Detect Brake Interrupt Enable For Channel4/5 (Write Protect)
S * |        |          |0 = Edge-detect Brake interrupt for channel4/5 Disabled.
S * |        |          |1 = Edge-detect Brake interrupt for channel4/5 Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[8]     |BRKLIEN0_1|PWM Level-Detect Brake Interrupt Enable For Channel0/1 (Write Protect)
S * |        |          |0 = Level-detect Brake interrupt for channel0/1 Disabled.
S * |        |          |1 = Level-detect Brake interrupt for channel0/1 Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[9]     |BRKLIEN2_3|PWM Level-Detect Brake Interrupt Enable For Channel2/3 (Write Protect)
S * |        |          |0 = Level-detect Brake interrupt for channel2/3 Disabled.
S * |        |          |1 = Level-detect Brake interrupt for channel2/3 Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[10]    |BRKLIEN4_5|PWM Level-Detect Brake Interrupt Enable For Channel4/5 (Write Protect)
S * |        |          |0 = Level-detect Brake interrupt for channel4/5 Disabled.
S * |        |          |1 = Level-detect Brake interrupt for channel4/5 Enabled.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * @var PWM_T::INTSTS0
S * Offset: 0xE8  PWM Interrupt Flag Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |ZIFn      |PWM Zero Point Interrupt Flag
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |This bit is set by hardware when PWM counter reaches zero, software can write 1 to clear this bit to zero.
S * |[7]     |IFAIF0_1  |PWM_CH0/1 Interrupt Flag Accumulator Interrupt Flag
S * |        |          |Flag is set by hardware when condition match IFSEL0_1 in PWM_IFA register, software can clear this bit by writing 1 to it.
S * |[13:8]  |PIFn      |PWM Period Point Interrupt Flag
S * |        |          |This bit is set by hardware when PWM counter reaches PWM_PERIODn, software can write 1 to clear this bit to zero.
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |[15]    |IFAIF2_3  |PWM_CH2/3 Interrupt Flag Accumulator Interrupt Flag
S * |        |          |Flag is set by hardware when condition match IFSEL2_3 in PWM_IFA register, software can clear this bit by writing 1 to it.
S * |[21:16] |CMPUIFn   |PWM Compare Up Count Interrupt Flag
S * |        |          |Flag is set by hardware when PWM counter up count and reaches PWM_CMPDATn, software can clear this bit by writing 1 to it.
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
S * |        |          |Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
S * |[23]    |IFAIF4_5  |PWM_CH4/5 Interrupt Flag Accumulator Interrupt Flag
S * |        |          |Flag is set by hardware when condition match IFSEL4_5 in PWM_IFA register, software can clear this bit by writing 1 to it.
S * |[29:24] |CMPDIFn   |PWM Compare Down Count Interrupt Flag
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |Flag is set by hardware when PWM counter down count and reaches PWM_CMPDATn, software can clear this bit by writing 1 to it.
S * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in down counter type selection.
S * |        |          |Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
S * @var PWM_T::INTSTS1
S * Offset: 0xEC  PWM Interrupt Flag Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |BRKEIF0   |PWM Channel0 Edge-Detect Brake Interrupt Flag (Write Protect)
S * |        |          |0 = PWM channel0 edge-detect brake event do not happened.
S * |        |          |1 = When PWM channel0 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[1]     |BRKEIF1   |PWM Channel1 Edge-Detect Brake Interrupt Flag (Write Protect)
S * |        |          |0 = PWM channel1 edge-detect brake event do not happened.
S * |        |          |1 = When PWM channel1 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[2]     |BRKEIF2   |PWM Channel2 Edge-Detect Brake Interrupt Flag (Write Protect)
S * |        |          |0 = PWM channel2 edge-detect brake event do not happened.
S * |        |          |1 = When PWM channel2 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[3]     |BRKEIF3   |PWM Channel3 Edge-Detect Brake Interrupt Flag (Write Protect)
S * |        |          |0 = PWM channel3 edge-detect brake event do not happened.
S * |        |          |1 = When PWM channel3 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[4]     |BRKEIF4   |PWM Channel4 Edge-Detect Brake Interrupt Flag (Write Protect)
S * |        |          |0 = PWM channel4 edge-detect brake event do not happened.
S * |        |          |1 = When PWM channel4 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[5]     |BRKEIF5   |PWM Channel5 Edge-Detect Brake Interrupt Flag (Write Protect)
S * |        |          |0 = PWM channel5 edge-detect brake event do not happened.
S * |        |          |1 = When PWM channel5 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[8]     |BRKLIF0   |PWM Channel0 Level-Detect Brake Interrupt Flag (Write Protect)
S * |        |          |0 = PWM channel0 level-detect brake event do not happened.
S * |        |          |1 = When PWM channel0 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[9]     |BRKLIF1   |PWM Channel1 Level-Detect Brake Interrupt Flag (Write Protect)
S * |        |          |0 = PWM channel1 level-detect brake event do not happened.
S * |        |          |1 = When PWM channel1 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[10]    |BRKLIF2   |PWM Channel2 Level-Detect Brake Interrupt Flag (Write Protect)
S * |        |          |0 = PWM channel2 level-detect brake event do not happened.
S * |        |          |1 = When PWM channel2 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[11]    |BRKLIF3   |PWM Channel3 Level-Detect Brake Interrupt Flag (Write Protect)
S * |        |          |0 = PWM channel3 level-detect brake event do not happened.
S * |        |          |1 = When PWM channel3 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[12]    |BRKLIF4   |PWM Channel4 Level-Detect Brake Interrupt Flag (Write Protect)
S * |        |          |0 = PWM channel4 level-detect brake event do not happened.
S * |        |          |1 = When PWM channel4 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[13]    |BRKLIF5   |PWM Channel5 Level-Detect Brake Interrupt Flag (Write Protect)
S * |        |          |0 = PWM channel5 level-detect brake event do not happened.
S * |        |          |1 = When PWM channel5 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
S * |        |          |Note: This register is write protected. Refer to SYS_REGLCTL register.
S * |[16]    |BRKESTS0  |PWM Channel0 Edge-Detect Brake Status
S * |        |          |0 = PWM channel0 edge-detect brake state is released.
S * |        |          |1 = When PWM channel0 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel0 at brake state, writing 1 to clear.
S * |[17]    |BRKESTS1  |PWM Channel1 Edge-Detect Brake Status
S * |        |          |0 = PWM channel1 edge-detect brake state is released.
S * |        |          |1 = When PWM channel1 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel1 at brake state, writing 1 to clear.
S * |[18]    |BRKESTS2  |PWM Channel2 Edge-Detect Brake Status
S * |        |          |0 = PWM channel2 edge-detect brake state is released.
S * |        |          |1 = When PWM channel2 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel2 at brake state, writing 1 to clear.
S * |[19]    |BRKESTS3  |PWM Channel3 Edge-Detect Brake Status
S * |        |          |0 = PWM channel3 edge-detect brake state is released.
S * |        |          |1 = When PWM channel3 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel3 at brake state, writing 1 to clear.
S * |[20]    |BRKESTS4  |PWM Channel4 Edge-Detect Brake Status
S * |        |          |0 = PWM channel4 edge-detect brake state is released.
S * |        |          |1 = When PWM channel4 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel4 at brake state, writing 1 to clear.
S * |[21]    |BRKESTS5  |PWM Channel5 Edge-Detect Brake Status
S * |        |          |0 = PWM channel5 edge-detect brake state is released.
S * |        |          |1 = When PWM channel5 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel5 at brake state, writing 1 to clear.
S * |[24]    |BRKLSTS0  |PWM Channel0 Level-Detect Brake Status (Read Only)
S * |        |          |0 = PWM channel0 level-detect brake state is released.
S * |        |          |1 = When PWM channel0 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel0 at brake state.
S * |        |          |Note: This bit is read only and auto cleared by hardware.
S * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished.
S * |        |          |The PWM waveform will start output from next full PWM period.
S * |[25]    |BRKLSTS1  |PWM Channel1 Level-Detect Brake Status (Read Only)
S * |        |          |0 = PWM channel1 level-detect brake state is released.
S * |        |          |1 = When PWM channel1 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel1 at brake state.
S * |        |          |Note: This bit is read only and auto cleared by hardware.
S * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished.
S * |        |          |The PWM waveform will start output from next full PWM period.
S * |[26]    |BRKLSTS2  |PWM Channel2 Level-Detect Brake Status (Read Only)
S * |        |          |0 = PWM channel2 level-detect brake state is released.
S * |        |          |1 = When PWM channel2 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel2 at brake state.
S * |        |          |Note: This bit is read only and auto cleared by hardware.
S * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished.
S * |        |          |The PWM waveform will start output from next full PWM period.
S * |[27]    |BRKLSTS3  |PWM Channel3 Level-Detect Brake Status (Read Only)
S * |        |          |0 = PWM channel3 level-detect brake state is released.
S * |        |          |1 = When PWM channel3 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel3 at brake state.
S * |        |          |Note: This bit is read only and auto cleared by hardware.
S * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished.
S * |        |          |The PWM waveform will start output from next full PWM period.
S * |[28]    |BRKLSTS4  |PWM Channel4 Level-Detect Brake Status (Read Only)
S * |        |          |0 = PWM channel4 level-detect brake state is released.
S * |        |          |1 = When PWM channel4 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel4 at brake state.
S * |        |          |Note: This bit is read only and auto cleared by hardware.
S * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished.
S * |        |          |The PWM waveform will start output from next full PWM period.
S * |[29]    |BRKLSTS5  |PWM Channel5 Level-Detect Brake Status (Read Only)
S * |        |          |0 = PWM channel5 level-detect brake state is released.
S * |        |          |1 = When PWM channel5 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the PWM channel5 at brake state.
S * |        |          |Note: This bit is read only and auto cleared by hardware.
S * |        |          |When enabled brake source return to high level, PWM will release brake state until current PWM period finished.
S * |        |          |The PWM waveform will start output from next full PWM period.
S * @var PWM_T::IFA
S * Offset: 0xF0  PWM Interrupt Flag Accumulator Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |IFCNT0_1  |PWM_CH0 And PWM_CH1 Interrupt Flag Counter
S * |        |          |The register sets the count number which defines how many times of PWM_CH0 and PWM_CH1 period occurs to set bit IFAIF0_1 to request the PWM period interrupt.
S * |        |          |PWM flag will be set in every IFCNT0_1 [3:0] times of PWM period.
S * |[6:4]   |IFSEL0_1  |PWM_CH0 And PWM_CH1 Interrupt Flag Accumulator Source Select
S * |        |          |000 = CNT equal to Zero in channel 0.
S * |        |          |001 = CNT equal to PERIOD in channel 0.
S * |        |          |010 = CNT equal to CMPU in channel 0.
S * |        |          |011 = CNT equal to CMPD in channel 0.
S * |        |          |100 = CNT equal to Zero in channel 1.
S * |        |          |101 = CNT equal to PERIOD in channel 1.
S * |        |          |110 = CNT equal to CMPU in channel 1.
S * |        |          |111 = CNT equal to CMPD in channel 1.
S * |[7]     |IFAEN0_1  |PWM_CH0 And PWM_CH1 Interrupt Flag Accumulator Enable
S * |        |          |0 = PWM_CH0 and PWM_CH1 interrupt flag accumulator disable.
S * |        |          |1 = PWM_CH0 and PWM_CH1 interrupt flag accumulator enable.
S * |[11:8]  |IFCNT2_3  |PWM_CH2 And PWM_CH3 Interrupt Flag Counter
S * |        |          |The register sets the count number which defines how many times of PWM_CH2 and PWM_CH3 period occurs to set bit IFAIF2_3 to request the PWM period interrupt.
S * |        |          |PWM flag will be set in every IFCNT2_3[3:0] times of PWM period.
S * |[14:12] |IFSEL2_3  |PWM_CH2 And PWM_CH3 Interrupt Flag Accumulator Source Select
S * |        |          |000 = CNT equal to Zero in channel 2.
S * |        |          |001 = CNT equal to PERIOD in channel 2.
S * |        |          |010 = CNT equal to CMPU in channel 2.
S * |        |          |011 = CNT equal to CMPD in channel 2.
S * |        |          |100 = CNT equal to Zero in channel 3.
S * |        |          |101 = CNT equal to PERIOD in channel 3.
S * |        |          |110 = CNT equal to CMPU in channel 3.
S * |        |          |111 = CNT equal to CMPD in channel 3.
S * |[15]    |IFAEN2_3  |PWM_CH2 And PWM_CH3 Interrupt Flag Accumulator Enable
S * |        |          |0 = PWM_CH2 and PWM_CH3 interrupt flag accumulator disable.
S * |        |          |1 = PWM_CH2 and PWM_CH3 interrupt flag accumulator enable.
S * |[19:16] |IFCNT4_5  |PWM_CH4 And PWM_CH5 Interrupt Flag Counter
S * |        |          |The register sets the count number which defines how many times of PWM_CH4 and PWM_CH5 period occurs to set bit IFAIF4_5 to request the PWM period interrupt.
S * |        |          |PWM flag will be set in every IFCNT4_5[3:0] times of PWM period.
S * |[22:20] |IFSEL4_5  |PWM_CH4 And PWM_CH5 Interrupt Flag Accumulator Source Select
S * |        |          |000 = CNT equal to Zero in channel 4.
S * |        |          |001 = CNT equal to PERIOD in channel 4.
S * |        |          |010 = CNT equal to CMPU in channel 4.
S * |        |          |011 = CNT equal to CMPD in channel 4.
S * |        |          |100 = CNT equal to Zero in channel 5.
S * |        |          |101 = CNT equal to PERIOD in channel 5.
S * |        |          |110 = CNT equal to CMPU in channel 5.
S * |        |          |111 = CNT equal to CMPD in channel 5.
S * |[23]    |IFAEN4_5  |PWM_CH4 And PWM_CH5 Interrupt Flag Accumulator Enable
S * |        |          |0 = PWM_CH4 and PWM_CH5 interrupt flag accumulator disable.
S * |        |          |1 = PWM_CH4 and PWM_CH5 interrupt flag accumulator enable.
S * @var PWM_T::DACTRGEN
S * Offset: 0xF4  PWM Trigger DAC Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |ZTEn      |PWM Zero Point Trigger DAC Enable
S * |        |          |0 = PWM period point trigger DAC function Disabled.
S * |        |          |1 = PWM period point trigger DAC function Enabled.
S * |        |          |PWM can trigger EADC/DAC/DMA to start action when PWM counter down count to zero if this bit is set to 1.
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |[13:8]  |PTEn      |PWM Period Point Trigger DAC Enable
S * |        |          |0 = PWM period point trigger DAC function Disabled.
S * |        |          |1 = PWM period point trigger DAC function Enabled.
S * |        |          |PWM can trigger DAC to start action when PWM counter up count to (PERIODn+1) if this bit is set to 1.
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |[21:16] |CUTRGEn   |PWM Compare Up Count Point Trigger DAC Enable
S * |        |          |0 = PWM Compare Up point trigger DAC function Disabled.
S * |        |          |1 = PWM Compare Up point trigger DAC function Enabled.
S * |        |          |PWM can trigger DAC to start action when PWM counter up count to CMPDAT if this bit is set to 1.
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |Note1: This bit should keep at 0 when PWM counter operating in down counter type.
S * |        |          |Note2: In complementary mode, CUTRGE1, 3, 5 use as another CUTRGE for channel 0, 2, 4.
S * |[29:24] |CDTRGEn   |PWM Compare Down Count Point Trigger DAC Enable
S * |        |          |0 = PWM Compare Down count point trigger DAC function Disabled.
S * |        |          |1 = PWM Compare Down count point trigger DAC function Enabled.
S * |        |          |PWM can trigger DAC to start action when PWM counter down count to CMPDAT if this bit is set to 1.
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |Note1: This bit should keep at 0 when PWM counter operating in up counter type.
S * |        |          |Note2: In complementary mode, CDTRGE1, 3, 5 use as another CDTRGE for channel 0, 2, 4.
S * @var PWM_T::EADCTS0
S * Offset: 0xF8  PWM Trigger EADC Source Select Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |TRGSEL0   |PWM_CH0 Trigger EADC Source Select
S * |        |          |0000 = PWM_CH0 zero point.
S * |        |          |0001 = PWM_CH0 period point.
S * |        |          |0010 = PWM_CH0 zero or period point.
S * |        |          |0011 = PWM_CH0 up-count CMPDAT point.
S * |        |          |0100 = PWM_CH0 down-count CMPDAT point.
S * |        |          |0101 = PWM_CH1 zero point.
S * |        |          |0110 = PWM_CH1 period point.
S * |        |          |0111 = PWM_CH1 zero or period point.
S * |        |          |1000 = PWM_CH1 up-count CMPDAT point.
S * |        |          |1001 = PWM_CH1 down-count CMPDAT point.
S * |        |          |1010 = PWM_CH0 up-count free CMPDAT point.
S * |        |          |1011 = PWM_CH0 down-count free CMPDAT point.
S * |        |          |1100 = PWM_CH2 up-count free CMPDAT point.
S * |        |          |1101 = PWM_CH2 down-count free CMPDAT point.
S * |        |          |1110 = PWM_CH4 up-count free CMPDAT point.
S * |        |          |1111 = PWM_CH4 down-count free CMPDAT point.
S * |[7]     |TRGEN0    |PWM_CH0 Trigger EADC enable bit
S * |[11:8]  |TRGSEL1   |PWM_CH1 Trigger EADC Source Select
S * |        |          |0000 = PWM_CH0 zero point.
S * |        |          |0001 = PWM_CH0 period point.
S * |        |          |0010 = PWM_CH0 zero or period point.
S * |        |          |0011 = PWM_CH0 up-count CMPDAT point.
S * |        |          |0100 = PWM_CH0 down-count CMPDAT point.
S * |        |          |0101 = PWM_CH1 zero point.
S * |        |          |0110 = PWM_CH1 period point.
S * |        |          |0111 = PWM_CH1 zero or period point.
S * |        |          |1000 = PWM_CH1 up-count CMPDAT point.
S * |        |          |1001 = PWM_CH1 down-count CMPDAT point.
S * |        |          |1010 = PWM_CH0 up-count free CMPDAT point.
S * |        |          |1011 = PWM_CH0 down-count free CMPDAT point.
S * |        |          |1100 = PWM_CH2 up-count free CMPDAT point.
S * |        |          |1101 = PWM_CH2 down-count free CMPDAT point.
S * |        |          |1110 = PWM_CH4 up-count free CMPDAT point.
S * |        |          |1111 = PWM_CH4 down-count free CMPDAT point.
S * |[15]    |TRGEN1    |PWM_CH1 Trigger EADC enable bit
S * |[19:16] |TRGSEL2   |PWM_CH2 Trigger EADC Source Select
S * |        |          |0000 = PWM_CH2 zero point.
S * |        |          |0001 = PWM_CH2 period point.
S * |        |          |0010 = PWM_CH2 zero or period point.
S * |        |          |0011 = PWM_CH2 up-count CMPDAT point.
S * |        |          |0100 = PWM_CH2 down-count CMPDAT point.
S * |        |          |0101 = PWM_CH3 zero point.
S * |        |          |0110 = PWM_CH3 period point.
S * |        |          |0111 = PWM_CH3 zero or period point.
S * |        |          |1000 = PWM_CH3 up-count CMPDAT point.
S * |        |          |1001 = PWM_CH3 down-count CMPDAT point.
S * |        |          |1010 = PWM_CH0 up-count free CMPDAT point.
S * |        |          |1011 = PWM_CH0 down-count free CMPDAT point.
S * |        |          |1100 = PWM_CH2 up-count free CMPDAT point.
S * |        |          |1101 = PWM_CH2 down-count free CMPDAT point.
S * |        |          |1110 = PWM_CH4 up-count free CMPDAT point.
S * |        |          |1111 = PWM_CH4 down-count free CMPDAT point.
S * |[23]    |TRGEN2    |PWM_CH2 Trigger EADC enable bit
S * |[27:24] |TRGSEL3   |PWM_CH3 Trigger EADC Source Select
S * |        |          |0000 = PWM_CH2 zero point.
S * |        |          |0001 = PWM_CH2 period point.
S * |        |          |0010 = PWM_CH2 zero or period point.
S * |        |          |0011 = PWM_CH2 up-count CMPDAT point.
S * |        |          |0100 = PWM_CH2 down-count CMPDAT point.
S * |        |          |0101 = PWM_CH3 zero point.
S * |        |          |0110 = PWM_CH3 period point.
S * |        |          |0111 = PWM_CH3 zero or period point.
S * |        |          |1000 = PWM_CH3 up-count CMPDAT point.
S * |        |          |1001 = PWM_CH3 down-count CMPDAT point.
S * |        |          |1010 = PWM_CH0 up-count free CMPDAT point.
S * |        |          |1011 = PWM_CH0 down-count free CMPDAT point.
S * |        |          |1100 = PWM_CH2 up-count free CMPDAT point.
S * |        |          |1101 = PWM_CH2 down-count free CMPDAT point.
S * |        |          |1110 = PWM_CH4 up-count free CMPDAT point.
S * |        |          |1111 = PWM_CH4 down-count free CMPDAT point.
S * |[31]    |TRGEN3    |PWM_CH3 Trigger EADC enable bit
S * @var PWM_T::EADCTS1
S * Offset: 0xFC  PWM Trigger EADC Source Select Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |TRGSEL4   |PWM_CH4 Trigger EADC Source Select
S * |        |          |0000 = PWM_CH4 zero point.
S * |        |          |0001 = PWM_CH4 period point.
S * |        |          |0010 = PWM_CH4 zero or period point.
S * |        |          |0011 = PWM_CH4 up-count CMPDAT point.
S * |        |          |0100 = PWM_CH4 down-count CMPDAT point.
S * |        |          |0101 = PWM_CH5 zero point.
S * |        |          |0110 = PWM_CH5 period point.
S * |        |          |0111 = PWM_CH5 zero or period point.
S * |        |          |1000 = PWM_CH5 up-count CMPDAT point.
S * |        |          |1001 = PWM_CH5 down-count CMPDAT point.
S * |        |          |1010 = PWM_CH0 up-count free CMPDAT point.
S * |        |          |1011 = PWM_CH0 down-count free CMPDAT point.
S * |        |          |1100 = PWM_CH2 up-count free CMPDAT point.
S * |        |          |1101 = PWM_CH2 down-count free CMPDAT point.
S * |        |          |1110 = PWM_CH4 up-count free CMPDAT point.
S * |        |          |1111 = PWM_CH4 down-count free CMPDAT point.
S * |[7]     |TRGEN4    |PWM_CH4 Trigger EADC enable bit
S * |[11:8]  |TRGSEL5   |PWM_CH5 Trigger EADC Source Select
S * |        |          |0000 = PWM_CH4 zero point.
S * |        |          |0001 = PWM_CH4 period point.
S * |        |          |0010 = PWM_CH4 zero or period point.
S * |        |          |0011 = PWM_CH4 up-count CMPDAT point.
S * |        |          |0100 = PWM_CH4 down-count CMPDAT point.
S * |        |          |0101 = PWM_CH5 zero point.
S * |        |          |0110 = PWM_CH5 period point.
S * |        |          |0111 = PWM_CH5 zero or period point.
S * |        |          |1000 = PWM_CH5 up-count CMPDAT point.
S * |        |          |1001 = PWM_CH5 down-count CMPDAT point.
S * |        |          |1010 = PWM_CH0 up-count free CMPDAT point.
S * |        |          |1011 = PWM_CH0 down-count free CMPDAT point.
S * |        |          |1100 = PWM_CH2 up-count free CMPDAT point.
S * |        |          |1101 = PWM_CH2 down-count free CMPDAT point.
S * |        |          |1110 = PWM_CH4 up-count free CMPDAT point.
S * |        |          |1111 = PWM_CH4 down-count free CMPDAT point.
S * |[15]    |TRGEN5    |PWM_CH5 Trigger EADC enable bit
S * @var PWM_T::FTCMPDAT0_1
S * Offset: 0x100  PWM Free Trigger Compare Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |FTCMP     |PWM Free Trigger Compare Register
S * |        |          |FTCMP use to compare with even CNTR to trigger EADC.
S * |        |          |FTCMPDAT0, 2, 4 corresponding complementary pairs PWM_CH0and PWM_CH1, PWM_CH2 and PWM_CH3, PWM_CH4 and PWM_CH5.
S * @var PWM_T::FTCMPDAT2_3
S * Offset: 0x104  PWM Free Trigger Compare Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |FTCMP     |PWM Free Trigger Compare Register
S * |        |          |FTCMP use to compare with even CNTR to trigger EADC.
S * |        |          |FTCMPDAT0, 2, 4 corresponding complementary pairs PWM_CH0and PWM_CH1, PWM_CH2 and PWM_CH3, PWM_CH4 and PWM_CH5.
S * @var PWM_T::FTCMPDAT4_5
S * Offset: 0x108  PWM Free Trigger Compare Register 4
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |FTCMP     |PWM Free Trigger Compare Register
S * |        |          |FTCMP use to compare with even CNTR to trigger EADC.
S * |        |          |FTCMPDAT0, 2, 4 corresponding complementary pairs PWM_CH0and PWM_CH1, PWM_CH2 and PWM_CH3, PWM_CH4 and PWM_CH5.
S * @var PWM_T::SSCTL
S * Offset: 0x110  PWM Synchronous Start Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |SSENn     |PWM Synchronous Start Function Enable
S * |        |          |When synchronous start function is enabled, the PWM counter enable register (PWM_CNTEN) can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |0 = PWM synchronous start function Disabled.
S * |        |          |1 = PWM synchronous start function Enabled.
S * @var PWM_T::SSTRG
S * Offset: 0x114  PWM Synchronous Start Trigger Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |CNTSEN    |PWM Counter Synchronous Start Enable (Write Only)
S * |        |          |PMW counter synchronous enable function is used to make selected PWM channels (include PWM0_CHx and PWM1_CHx) start counting at the same time.
S * |        |          |Writing this bit to 1 will also set the counter enable bit (CNTENn, n denotes channel 0 to 5) if correlated PWM channel counter synchronous start function is enabled.
S * |        |          |Note: This bit only present in PWM0_BA.
S * @var PWM_T::STATUS
S * Offset: 0x120  PWM Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |CNTMAXFn  |Time-Base Counter Equal To 0xFFFF Latched Flag
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |0 = indicates the time-base counter never reached its maximum value 0xFFFF.
S * |        |          |1 = indicates the time-base counter reached its maximum value, software can write 1 to clear this bit.
S * |[10:8]  |SYNCINFn  |Input Synchronization Latched Flag
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |0 = Indicates no SYNC_IN event has occurred.
S * |        |          |1 = Indicates an SYNC_IN event has occurred, software can write 1 to clear this bit.
S * |[21:16] |ADCTRGFn  |EADC Start Of Conversion Flag
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |0 = Indicates no EADC start of conversion trigger event has occurred.
S * |        |          |1 = Indicates an EADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
S * |[24]    |DACTRGF   |DAC Start Of Conversion Flag
S * |        |          |0 = Indicates no DAC start of conversion trigger event has occurred.
S * |        |          |1 = Indicates an DAC start of conversion trigger event has occurred, software can write 1 to clear this bit
S * @var PWM_T::CAPINEN
S * Offset: 0x200  PWM Capture Input Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |CAPINENn  |Capture Input Enable
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |0 = PWM Channel capture input path Disabled.
S * |        |          |The input of PWM channel capture function is always regarded as 0.
S * |        |          |1 = PWM Channel capture input path Enabled.
S * |        |          |The input of PWM channel capture function comes from correlative multifunction pin.
S * @var PWM_T::CAPCTL
S * Offset: 0x204  PWM Capture Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |CAPENn    |Capture Function Enable
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |0 = Capture function Disabled. RCAPDAT/FCAPDAT register will not be updated.
S * |        |          |1 = Capture function Enabled.
S * |        |          |Capture latched the PWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch).
S * |[13:8]  |CAPINVn   |Capture Inverter Enable
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |0 = Capture source inverter Disabled.
S * |        |          |1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
S * |[21:16] |RCRLDENn  |Rising Capture Reload Enable
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |0 = Rising capture reload counter Disabled.
S * |        |          |1 = Rising capture reload counter Enabled.
S * |[29:24] |FCRLDENn  |Falling Capture Reload Enable
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |0 = Falling capture reload counter Disabled.
S * |        |          |1 = Falling capture reload counter Enabled.
S * @var PWM_T::CAPSTS
S * Offset: 0x208  PWM Capture Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |CRLIFOVn  |Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
S * |        |          |This flag indicates if rising latch happened when the corresponding CRLIF is 1.
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |Note: This bit will be cleared automatically when user clear corresponding CRLIF.
S * |[13:8]  |CFLIFOVn  |Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
S * |        |          |This flag indicates if falling latch happened when the corresponding CFLIF is 1.
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |Note: This bit will be cleared automatically when user clear corresponding CFLIF.
S * @var PWM_T::RCAPDAT0
S * Offset: 0x20C  PWM Rising Capture Data Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
S * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
S * @var PWM_T::FCAPDAT0
S * Offset: 0x210  PWM Falling Capture Data Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
S * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
S * @var PWM_T::RCAPDAT1
S * Offset: 0x214  PWM Rising Capture Data Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
S * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
S * @var PWM_T::FCAPDAT1
S * Offset: 0x218  PWM Falling Capture Data Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
S * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
S * @var PWM_T::RCAPDAT2
S * Offset: 0x21C  PWM Rising Capture Data Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
S * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
S * @var PWM_T::FCAPDAT2
S * Offset: 0x220  PWM Falling Capture Data Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
S * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
S * @var PWM_T::RCAPDAT3
S * Offset: 0x224  PWM Rising Capture Data Register 3
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
S * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
S * @var PWM_T::FCAPDAT3
S * Offset: 0x228  PWM Falling Capture Data Register 3
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
S * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
S * @var PWM_T::RCAPDAT4
S * Offset: 0x22C  PWM Rising Capture Data Register 4
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
S * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
S * @var PWM_T::FCAPDAT4
S * Offset: 0x230  PWM Falling Capture Data Register 4
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
S * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
S * @var PWM_T::RCAPDAT5
S * Offset: 0x234  PWM Rising Capture Data Register 5
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
S * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
S * @var PWM_T::FCAPDAT5
S * Offset: 0x238  PWM Falling Capture Data Register 5
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
S * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
S * @var PWM_T::PDMACTL
S * Offset: 0x23C  PWM PDMA Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |CHEN0_1   |Channel 0/1 PDMA Enable
S * |        |          |0 = Channel 0/1 PDMA function Disabled.
S * |        |          |1 = Channel 0/1 PDMA function Enabled for the channel 0/1 captured data and transfer to memory.
S * |[2:1]   |CAPMOD0_1 |Select PWM_RCAPDAT0/1 Or PWM_FCAPDAT0/1 To Do PDMA Transfer
S * |        |          |00 = Reserved.
S * |        |          |01 = PWM_RCAPDAT0/1.
S * |        |          |10 = PWM_FCAPDAT0/1.
S * |        |          |11 = Both PWM_RCAPDAT0/1 and PWM_FCAPDAT0/1.
S * |[3]     |CAPORD0_1 |Capture Channel 0/1 Rising/Falling Order
S * |        |          |Set this bit to determine whether the PWM_RCAPDAT0/1 or PWM_FCAPDAT0/1 is the first captured data transferred to memory through PDMA when CAPMOD0_1 = 11.
S * |        |          |0 = PWM_FCAPDAT0/1 is the first captured data to memory.
S * |        |          |1 = PWM_RCAPDAT0/1 is the first captured data to memory.
S * |[4]     |CHSEL0_1  |Select Channel 0/1 To Do PDMA Transfer
S * |        |          |0 = Channel0.
S * |        |          |1 = Channel1.
S * |[8]     |CHEN2_3   |Channel 2/3 PDMA Enable
S * |        |          |0 = Channel 2/3 PDMA function Disabled.
S * |        |          |1 = Channel 2/3 PDMA function Enabled for the channel 2/3 captured data and transfer to memory.
S * |[10:9]  |CAPMOD2_3 |Select PWM_RCAPDAT2/3 Or PWM_FCAODAT2/3 To Do PDMA Transfer
S * |        |          |00 = Reserved.
S * |        |          |01 = PWM_RCAPDAT2/3.
S * |        |          |10 = PWM_FCAPDAT2/3.
S * |        |          |11 = Both PWM_RCAPDAT2/3 and PWM_FCAPDAT2/3.
S * |[11]    |CAPORD2_3 |Capture Channel 2/3 Rising/Falling Order
S * |        |          |Set this bit to determine whether the PWM_RCAPDAT2/3 or PWM_FCAPDAT2/3 is the first captured data transferred to memory through PDMA when CAPMOD2_3 = 11.
S * |        |          |0 = PWM_FCAPDAT2/3 is the first captured data to memory.
S * |        |          |1 = PWM_RCAPDAT2/3 is the first captured data to memory.
S * |[12]    |CHSEL2_3  |Select Channel 2/3 To Do PDMA Transfer
S * |        |          |0 = Channel2.
S * |        |          |1 = Channel3.
S * |[16]    |CHEN4_5   |Channel 4/5 PDMA Enable
S * |        |          |0 = Channel 4/5 PDMA function Disabled.
S * |        |          |1 = Channel 4/5 PDMA function Enabled for the channel 4/5 captured data and transfer to memory.
S * |[18:17] |CAPMOD4_5 |Select PWM_RCAPDAT4/5 Or PWM_FCAPDAT4/5 To Do PDMA Transfer
S * |        |          |00 = Reserved.
S * |        |          |01 = PWM_RCAPDAT4/5.
S * |        |          |10 = PWM_FCAPDAT4/5.
S * |        |          |11 = Both PWM_RCAPDAT4/5 and PWM_FCAPDAT4/5.
S * |[19]    |CAPORD4_5 |Capture Channel 4/5 Rising/Falling Order
S * |        |          |Set this bit to determine whether the PWM_RCAPDAT4/5 or PWM_FCAPDAT4/5 is the first captured data transferred to memory through PDMA when CAPMOD4_5 = 11.
S * |        |          |0 = PWM_FCAPDAT4/5 is the first captured data to memory.
S * |        |          |1 = PWM_RCAPDAT4/5 is the first captured data to memory.
S * |[20]    |CHSEL4_5  |Select Channel 4/5 To Do PDMA Transfer
S * |        |          |0 = Channel4.
S * |        |          |1 = Channel5.
S * @var PWM_T::PDMACAP0_1
S * Offset: 0x240  PWM Capture Channel 01 PDMA Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CAPBUF    |PWM Capture PDMA Register
S * |        |          |(Read Only)
S * |        |          |This register is use as a buffer to transfer PWM capture rising or falling data to memory by PDMA.
S * @var PWM_T::PDMACAP2_3
S * Offset: 0x244  PWM Capture Channel 23 PDMA Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CAPBUF    |PWM Capture PDMA Register
S * |        |          |(Read Only)
S * |        |          |This register is use as a buffer to transfer PWM capture rising or falling data to memory by PDMA.
S * @var PWM_T::PDMACAP4_5
S * Offset: 0x248  PWM Capture Channel 45 PDMA Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CAPBUF    |PWM Capture PDMA Register
S * |        |          |(Read Only)
S * |        |          |This register is use as a buffer to transfer PWM capture rising or falling data to memory by PDMA.
S * @var PWM_T::CAPIEN
S * Offset: 0x250  PWM Capture Interrupt Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |CAPRIENn  |PWM Capture Rising Latch Interrupt Enable
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |0 = Capture rising edge latch interrupt Disabled.
S * |        |          |1 = Capture rising edge latch interrupt Enabled.
S * |        |          |Note: When Capture with PDMA operating, CINTENR corresponding channel CAPRIEN must be disabled.
S * |[13:8]  |CAPFIENn  |PWM Capture Falling Latch Interrupt Enable
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |        |          |0 = Capture falling edge latch interrupt Disabled.
S * |        |          |1 = Capture falling edge latch interrupt Enabled.
S * |        |          |Note: When Capture with PDMA operating, CINTENR corresponding channel CAPFIEN must be disabled.
S * @var PWM_T::CAPIF
S * Offset: 0x254  PWM Capture Interrupt Flag Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |CRLIFn    |PWM Capture Rising Latch Interrupt Flag
S * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
S * |        |          |0 = No capture rising latch condition happened.
S * |        |          |1 = Capture rising latch condition happened, this flag will be set to high.
S * |        |          |Note: When Capture with PDMA operating, CIFR corresponding channel CRLIF will cleared by hardware after PDMA transfer data.
S * |[13:8]  |CFLIFn    |PWM Capture Falling Latch Interrupt Flag
S * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
S * |        |          |0 = No capture falling latch condition happened.
S * |        |          |1 = Capture falling latch condition happened, this flag will be set to high.
S * |        |          |Note: When Capture with PDMA operating, CIFR corresponding channel CFLIF will cleared by hardware after PDMA transfer data.
S * @var PWM_T::PBUF
S * Offset: 0x304~0x318  PWM PERIOD0~5 Buffer
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |PBUF      |PWM Period Register Buffer
S * |        |          |(Read Only)
S * |        |          |Used as PERIOD active register.
S * @var PWM_T::CMPBUF
S * Offset: 0x31C~0x330  PWM CMPDAT0~5 Buffer
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CMPBUF    |PWM Comparator Register Buffer
S * |        |          |(Read Only)
S * |        |          |Used as CMP active register.
S * @var PWM_T::FTCBUF0_1
S * Offset: 0x340  PWM FTCMPDAT0_1 Buffer
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |FTCMPBUF  |PWM FTCMPDAT Buffer (Read Only)
S * |        |          |Used as FTCMPDAT active register.
S * @var PWM_T::FTCBUF2_3
S * Offset: 0x344  PWM FTCMPDAT2_3 Buffer
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |FTCMPBUF  |PWM FTCMPDAT Buffer (Read Only)
S * |        |          |Used as FTCMPDAT active register.
S * @var PWM_T::FTCBUF4_5
S * Offset: 0x348  PWM FTCMPDAT4_5 Buffer
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |FTCMPBUF  |PWM FTCMPDAT Buffer (Read Only)
S * |        |          |Used as FTCMPDAT active register.
S * @var PWM_T::FTCI
S * Offset: 0x34C  PWM FTCMPDAT Indicator Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[2:0]   |FTCMUn    |PWM FTCMPDAT Up Indicator
S * |        |          |Indicator will be set to high when FTCMPDATn equal to PERIODn and DIRF=1, software can write 1 to clear this bit.
S * |        |          |Each bit n controls the corresponding PWM channel n.
S * |[10:8]  |FTCMDn    |PWM FTCMPDAT Down Indicator
S * |        |          |Indicator will be set to high when FTCMPDATn equal to PERIODn and DIRF=0, software can write 1 to clear this bit.
S * |        |          |Each bit n controls the corresponding PWM channel n.
S */
S
S    __IO uint32_t CTL0;          /* Offset: 0x00  PWM Control Register 0                                             */
S    __IO uint32_t CTL1;          /* Offset: 0x04  PWM Control Register 1                                             */
S    __IO uint32_t SYNC;          /* Offset: 0x08  PWM Synchronization Register                                       */
S    __IO uint32_t SWSYNC;        /* Offset: 0x0C  PWM Software Control Synchronization Register                      */
S    __IO uint32_t CLKSRC;        /* Offset: 0x10  PWM Clock Source Register                                          */
S    __IO uint32_t CLKPSC0_1;     /* Offset: 0x14  PWM Clock Pre-scale Register 0                                     */
S    __IO uint32_t CLKPSC2_3;     /* Offset: 0x18  PWM Clock Pre-scale Register 2                                     */
S    __IO uint32_t CLKPSC4_5;     /* Offset: 0x1C  PWM Clock Pre-scale Register 4                                     */
S    __IO uint32_t CNTEN;         /* Offset: 0x20  PWM Counter Enable Register                                        */
S    __IO uint32_t CNTCLR;        /* Offset: 0x24  PWM Clear Counter Register                                         */
S    __IO uint32_t LOAD;          /* Offset: 0x28  PWM Load Register                                                  */
S    __I  uint32_t RESERVE0[1];  
S    __IO uint32_t PERIOD[6];     /* Offset: 0x30~0x44  PWM Period Register 0~5                                       */
S    __I  uint32_t RESERVE1[2];  
S    __IO uint32_t CMPDAT[6];     /* Offset: 0x50~0x64  PWM Comparator Register 0~5                                   */
S    __I  uint32_t RESERVE2[2];  
S    __IO uint32_t DTCTL0_1;      /* Offset: 0x70  PWM Dead-Time Control Register 0                                   */
S    __IO uint32_t DTCTL2_3;      /* Offset: 0x74  PWM Dead-Time Control Register 2                                   */
S    __IO uint32_t DTCTL4_5;      /* Offset: 0x78  PWM Dead-Time Control Register 4                                   */
S    __I  uint32_t RESERVE3[1];  
S    __IO uint32_t PHS0_1;        /* Offset: 0x80  PWM Counter Phase Register 0                                       */
S    __IO uint32_t PHS2_3;        /* Offset: 0x84  PWM Counter Phase Register 2                                       */
S    __IO uint32_t PHS4_5;        /* Offset: 0x88  PWM Counter Phase Register 4                                       */
S    __I  uint32_t RESERVE4[1];  
S    __I  uint32_t CNT[6];        /* Offset: 0x90~0xA4  PWM Counter Register 0~5                                      */
S    __I  uint32_t RESERVE5[2];  
S    __IO uint32_t WGCTL0;        /* Offset: 0xB0  PWM Generation Register 0                                          */
S    __IO uint32_t WGCTL1;        /* Offset: 0xB4  PWM Generation Register 1                                          */
S    __IO uint32_t MSKEN;         /* Offset: 0xB8  PWM Mask Enable Register                                           */
S    __IO uint32_t MSK;           /* Offset: 0xBC  PWM Mask Data Register                                             */
S    __IO uint32_t BNF;           /* Offset: 0xC0  PWM Brake Noise Filter Register                                    */
S    __IO uint32_t FAILBRK;       /* Offset: 0xC4  PWM System Fail Brake Control Register                             */
S    __IO uint32_t BRKCTL0_1;     /* Offset: 0xC8  PWM Brake Edge Detect Control Register 0                           */
S    __IO uint32_t BRKCTL2_3;     /* Offset: 0xCC  PWM Brake Edge Detect Control Register 2                           */
S    __IO uint32_t BRKCTL4_5;     /* Offset: 0xD0  PWM Brake Edge Detect Control Register 4                           */
S    __IO uint32_t POLCTL;        /* Offset: 0xD4  PWM Pin Polar Inverse Register                                     */
S    __IO uint32_t POEN;          /* Offset: 0xD8  PWM Output Enable Register                                         */
S    __O  uint32_t SWBRK;         /* Offset: 0xDC  PWM Software Brake Control Register                                */
S    __IO uint32_t INTEN0;        /* Offset: 0xE0  PWM Interrupt Enable Register 0                                    */
S    __IO uint32_t INTEN1;        /* Offset: 0xE4  PWM Interrupt Enable Register 1                                    */
S    __IO uint32_t INTSTS0;       /* Offset: 0xE8  PWM Interrupt Flag Register 0                                      */
S    __IO uint32_t INTSTS1;       /* Offset: 0xEC  PWM Interrupt Flag Register 1                                      */
S    __IO uint32_t IFA;           /* Offset: 0xF0  PWM Interrupt Flag Accumulator Register                            */
S    __IO uint32_t DACTRGEN;      /* Offset: 0xF4  PWM Trigger DAC Enable Register                                    */
S    __IO uint32_t EADCTS0;       /* Offset: 0xF8  PWM Trigger EADC Source Select Register 0                          */
S    __IO uint32_t EADCTS1;       /* Offset: 0xFC  PWM Trigger EADC Source Select Register 1                          */
S    __IO uint32_t FTCMPDAT0_1;   /* Offset: 0x100  PWM Free Trigger Compare Register 0                               */
S    __IO uint32_t FTCMPDAT2_3;   /* Offset: 0x104  PWM Free Trigger Compare Register 2                               */
S    __IO uint32_t FTCMPDAT4_5;   /* Offset: 0x108  PWM Free Trigger Compare Register 4                               */
S    __I  uint32_t RESERVE6[1];  
S    __IO uint32_t SSCTL;         /* Offset: 0x110  PWM Synchronous Start Control Register                            */
S    __O  uint32_t SSTRG;         /* Offset: 0x114  PWM Synchronous Start Trigger Register                            */
S    __I  uint32_t RESERVE7[2];  
S    __IO uint32_t STATUS;        /* Offset: 0x120  PWM Status Register                                               */
S    __I  uint32_t RESERVE8[55]; 
S    __IO uint32_t CAPINEN;       /* Offset: 0x200  PWM Capture Input Enable Register                                 */
S    __IO uint32_t CAPCTL;        /* Offset: 0x204  PWM Capture Control Register                                      */
S    __I  uint32_t CAPSTS;        /* Offset: 0x208  PWM Capture Status Register                                       */
S    __I  uint32_t RCAPDAT0;      /* Offset: 0x20C  PWM Rising Capture Data Register 0                                */
S    __I  uint32_t FCAPDAT0;      /* Offset: 0x210  PWM Falling Capture Data Register 0                               */
S    __I  uint32_t RCAPDAT1;      /* Offset: 0x214  PWM Rising Capture Data Register 1                                */
S    __I  uint32_t FCAPDAT1;      /* Offset: 0x218  PWM Falling Capture Data Register 1                               */
S    __I  uint32_t RCAPDAT2;      /* Offset: 0x21C  PWM Rising Capture Data Register 2                                */
S    __I  uint32_t FCAPDAT2;      /* Offset: 0x220  PWM Falling Capture Data Register 2                               */
S    __I  uint32_t RCAPDAT3;      /* Offset: 0x224  PWM Rising Capture Data Register 3                                */
S    __I  uint32_t FCAPDAT3;      /* Offset: 0x228  PWM Falling Capture Data Register 3                               */
S    __I  uint32_t RCAPDAT4;      /* Offset: 0x22C  PWM Rising Capture Data Register 4                                */
S    __I  uint32_t FCAPDAT4;      /* Offset: 0x230  PWM Falling Capture Data Register 4                               */
S    __I  uint32_t RCAPDAT5;      /* Offset: 0x234  PWM Rising Capture Data Register 5                                */
S    __I  uint32_t FCAPDAT5;      /* Offset: 0x238  PWM Falling Capture Data Register 5                               */
S    __IO uint32_t PDMACTL;       /* Offset: 0x23C  PWM PDMA Control Register                                         */
S    __I  uint32_t PDMACAP0_1;    /* Offset: 0x240  PWM Capture Channel 01 PDMA Register                              */
S    __I  uint32_t PDMACAP2_3;    /* Offset: 0x244  PWM Capture Channel 23 PDMA Register                              */
S    __I  uint32_t PDMACAP4_5;    /* Offset: 0x248  PWM Capture Channel 45 PDMA Register                              */
S    __I  uint32_t RESERVE9[1];  
S    __IO uint32_t CAPIEN;        /* Offset: 0x250  PWM Capture Interrupt Enable Register                             */
S    __IO uint32_t CAPIF;         /* Offset: 0x254  PWM Capture Interrupt Flag Register                               */
S    __I  uint32_t RESERVE10[43];
S    __I  uint32_t PBUF[6];       /* Offset: 0x304~0x318  PWM PERIOD0~5 Buffer                                        */
S    __I  uint32_t CMPBUF[6];     /* Offset: 0x31C~0x330  PWM CMPDAT0~5 Buffer                                        */
S    __I  uint32_t RESERVE11[3]; 
S    __I  uint32_t FTCBUF0_1;     /* Offset: 0x340  PWM FTCMPDAT0_1 Buffer                                            */
S    __I  uint32_t FTCBUF2_3;     /* Offset: 0x344  PWM FTCMPDAT2_3 Buffer                                            */
S    __I  uint32_t FTCBUF4_5;     /* Offset: 0x348  PWM FTCMPDAT4_5 Buffer                                            */
S    __IO uint32_t FTCI;          /* Offset: 0x34C  PWM FTCMPDAT Indicator Register                                   */
S
S} PWM_T;
S
S
S
S/**
S    @addtogroup PWM_CONST PWM Bit Field Definition
S    Constant Definitions for PWM Controller
S@{ */
S
S#define PWM_CTL0_CTRLDn_Pos              (0)                                               /*!< PWM_T::CTL0: CTRLDn Position              */
S#define PWM_CTL0_CTRLDn_Msk              (0x3ful << PWM_CTL0_CTRLDn_Pos)                   /*!< PWM_T::CTL0: CTRLDn Mask                  */
S
S#define PWM_CTL0_CTRLD0_Pos              (0)                                               /*!< PWM_T::CTL0: CTRLD0 Position              */
S#define PWM_CTL0_CTRLD0_Msk              (0x1ul << PWM_CTL0_CTRLD0_Pos)                    /*!< PWM_T::CTL0: CTRLD0 Mask                  */
S
S#define PWM_CTL0_CTRLD1_Pos              (1)                                               /*!< PWM_T::CTL0: CTRLD1 Position              */
S#define PWM_CTL0_CTRLD1_Msk              (0x1ul << PWM_CTL0_CTRLD1_Pos)                    /*!< PWM_T::CTL0: CTRLD1 Mask                  */
S
S#define PWM_CTL0_CTRLD2_Pos              (2)                                               /*!< PWM_T::CTL0: CTRLD2 Position              */
S#define PWM_CTL0_CTRLD2_Msk              (0x1ul << PWM_CTL0_CTRLD2_Pos)                    /*!< PWM_T::CTL0: CTRLD2 Mask                  */
S
S#define PWM_CTL0_CTRLD3_Pos              (3)                                               /*!< PWM_T::CTL0: CTRLD3 Position              */
S#define PWM_CTL0_CTRLD3_Msk              (0x1ul << PWM_CTL0_CTRLD3_Pos)                    /*!< PWM_T::CTL0: CTRLD3 Mask                  */
S
S#define PWM_CTL0_CTRLD4_Pos              (4)                                               /*!< PWM_T::CTL0: CTRLD4 Position              */
S#define PWM_CTL0_CTRLD4_Msk              (0x1ul << PWM_CTL0_CTRLD4_Pos)                    /*!< PWM_T::CTL0: CTRLD4 Mask                  */
S
S#define PWM_CTL0_CTRLD5_Pos              (5)                                               /*!< PWM_T::CTL0: CTRLD5 Position              */
S#define PWM_CTL0_CTRLD5_Msk              (0x1ul << PWM_CTL0_CTRLD5_Pos)                    /*!< PWM_T::CTL0: CTRLD5 Mask                  */
S
S#define PWM_CTL0_WINLDENn_Pos            (8)                                               /*!< PWM_T::CTL0: WINLDENn Position            */
S#define PWM_CTL0_WINLDENn_Msk            (0x3ful << PWM_CTL0_WINLDENn_Pos)                 /*!< PWM_T::CTL0: WINLDENn Mask                */
S
S#define PWM_CTL0_WINLDEN0_Pos            (8)                                               /*!< PWM_T::CTL0: WINLDEN0 Position            */
S#define PWM_CTL0_WINLDEN0_Msk            (0x1ul << PWM_CTL0_WINLDEN0_Pos)                  /*!< PWM_T::CTL0: WINLDEN0 Mask                */
S
S#define PWM_CTL0_WINLDEN1_Pos            (9)                                               /*!< PWM_T::CTL0: WINLDEN1 Position            */
S#define PWM_CTL0_WINLDEN1_Msk            (0x1ul << PWM_CTL0_WINLDEN1_Pos)                  /*!< PWM_T::CTL0: WINLDEN1 Mask                */
S
S#define PWM_CTL0_WINLDEN2_Pos            (10)                                              /*!< PWM_T::CTL0: WINLDEN2 Position            */
S#define PWM_CTL0_WINLDEN2_Msk            (0x1ul << PWM_CTL0_WINLDEN2_Pos)                  /*!< PWM_T::CTL0: WINLDEN2 Mask                */
S
S#define PWM_CTL0_WINLDEN3_Pos            (11)                                              /*!< PWM_T::CTL0: WINLDEN3 Position            */
S#define PWM_CTL0_WINLDEN3_Msk            (0x1ul << PWM_CTL0_WINLDEN3_Pos)                  /*!< PWM_T::CTL0: WINLDEN3 Mask                */
S
S#define PWM_CTL0_WINLDEN4_Pos            (12)                                              /*!< PWM_T::CTL0: WINLDEN4 Position            */
S#define PWM_CTL0_WINLDEN4_Msk            (0x1ul << PWM_CTL0_WINLDEN4_Pos)                  /*!< PWM_T::CTL0: WINLDEN4 Mask                */
S
S#define PWM_CTL0_WINLDEN5_Pos            (13)                                              /*!< PWM_T::CTL0: WINLDEN5 Position            */
S#define PWM_CTL0_WINLDEN5_Msk            (0x1ul << PWM_CTL0_WINLDEN5_Pos)                  /*!< PWM_T::CTL0: WINLDEN5 Mask                */
S
S#define PWM_CTL0_IMMLDENn_Pos            (16)                                              /*!< PWM_T::CTL0: IMMLDENn Position            */
S#define PWM_CTL0_IMMLDENn_Msk            (0x3ful << PWM_CTL0_IMMLDENn_Pos)                 /*!< PWM_T::CTL0: IMMLDENn Mask                */
S
S#define PWM_CTL0_IMMLDEN0_Pos            (16)                                              /*!< PWM_T::CTL0: IMMLDEN0 Position            */
S#define PWM_CTL0_IMMLDEN0_Msk            (0x1ul << PWM_CTL0_IMMLDEN0_Pos)                  /*!< PWM_T::CTL0: IMMLDEN0 Mask                */
S
S#define PWM_CTL0_IMMLDEN1_Pos            (17)                                              /*!< PWM_T::CTL0: IMMLDEN1 Position            */
S#define PWM_CTL0_IMMLDEN1_Msk            (0x1ul << PWM_CTL0_IMMLDEN1_Pos)                  /*!< PWM_T::CTL0: IMMLDEN1 Mask                */
S
S#define PWM_CTL0_IMMLDEN2_Pos            (18)                                              /*!< PWM_T::CTL0: IMMLDEN2 Position            */
S#define PWM_CTL0_IMMLDEN2_Msk            (0x1ul << PWM_CTL0_IMMLDEN2_Pos)                  /*!< PWM_T::CTL0: IMMLDEN2 Mask                */
S
S#define PWM_CTL0_IMMLDEN3_Pos            (19)                                              /*!< PWM_T::CTL0: IMMLDEN3 Position            */
S#define PWM_CTL0_IMMLDEN3_Msk            (0x1ul << PWM_CTL0_IMMLDEN3_Pos)                  /*!< PWM_T::CTL0: IMMLDEN3 Mask                */
S
S#define PWM_CTL0_IMMLDEN4_Pos            (20)                                              /*!< PWM_T::CTL0: IMMLDEN4 Position            */
S#define PWM_CTL0_IMMLDEN4_Msk            (0x1ul << PWM_CTL0_IMMLDEN4_Pos)                  /*!< PWM_T::CTL0: IMMLDEN4 Mask                */
S
S#define PWM_CTL0_IMMLDEN5_Pos            (21)                                              /*!< PWM_T::CTL0: IMMLDEN5 Position            */
S#define PWM_CTL0_IMMLDEN5_Msk            (0x1ul << PWM_CTL0_IMMLDEN5_Pos)                  /*!< PWM_T::CTL0: IMMLDEN5 Mask                */
S
S#define PWM_CTL0_GROUPEN_Pos             (24)                                              /*!< PWM_T::CTL0: GROUPEN Position             */
S#define PWM_CTL0_GROUPEN_Msk             (0x1ul << PWM_CTL0_GROUPEN_Pos)                   /*!< PWM_T::CTL0: GROUPEN Mask                 */
S
S#define PWM_CTL0_DBGHALT_Pos             (30)                                              /*!< PWM_T::CTL0: DBGHALT Position             */
S#define PWM_CTL0_DBGHALT_Msk             (0x1ul << PWM_CTL0_DBGHALT_Pos)                   /*!< PWM_T::CTL0: DBGHALT Mask                 */
S
S#define PWM_CTL0_DBGTRIOFF_Pos           (31)                                              /*!< PWM_T::CTL0: DBGTRIOFF Position           */
S#define PWM_CTL0_DBGTRIOFF_Msk           (0x1ul << PWM_CTL0_DBGTRIOFF_Pos)                 /*!< PWM_T::CTL0: DBGTRIOFF Mask               */
S
S#define PWM_CTL1_CNTTYPEn_Pos            (0)                                               /*!< PWM_T::CTL1: CNTTYPEn Position            */
S#define PWM_CTL1_CNTTYPEn_Msk            (0xffful << PWM_CTL1_CNTTYPEn_Pos)                /*!< PWM_T::CTL1: CNTTYPEn Mask                */
S
S#define PWM_CTL1_CNTTYPE0_Pos            (0)                                               /*!< PWM_T::CTL1: CNTTYPE0 Position            */
S#define PWM_CTL1_CNTTYPE0_Msk            (0x3ul << PWM_CTL1_CNTTYPE0_Pos)                  /*!< PWM_T::CTL1: CNTTYPE0 Mask                */
S
S#define PWM_CTL1_CNTTYPE1_Pos            (2)                                               /*!< PWM_T::CTL1: CNTTYPE1 Position            */
S#define PWM_CTL1_CNTTYPE1_Msk            (0x3ul << PWM_CTL1_CNTTYPE1_Pos)                  /*!< PWM_T::CTL1: CNTTYPE1 Mask                */
S
S#define PWM_CTL1_CNTTYPE2_Pos            (4)                                               /*!< PWM_T::CTL1: CNTTYPE2 Position            */
S#define PWM_CTL1_CNTTYPE2_Msk            (0x3ul << PWM_CTL1_CNTTYPE2_Pos)                  /*!< PWM_T::CTL1: CNTTYPE2 Mask                */
S
S#define PWM_CTL1_CNTTYPE3_Pos            (6)                                               /*!< PWM_T::CTL1: CNTTYPE3 Position            */
S#define PWM_CTL1_CNTTYPE3_Msk            (0x3ul << PWM_CTL1_CNTTYPE3_Pos)                  /*!< PWM_T::CTL1: CNTTYPE3 Mask                */
S
S#define PWM_CTL1_CNTTYPE4_Pos            (8)                                               /*!< PWM_T::CTL1: CNTTYPE4 Position            */
S#define PWM_CTL1_CNTTYPE4_Msk            (0x3ul << PWM_CTL1_CNTTYPE4_Pos)                  /*!< PWM_T::CTL1: CNTTYPE4 Mask                */
S
S#define PWM_CTL1_CNTTYPE5_Pos            (10)                                              /*!< PWM_T::CTL1: CNTTYPE5 Position            */
S#define PWM_CTL1_CNTTYPE5_Msk            (0x3ul << PWM_CTL1_CNTTYPE5_Pos)                  /*!< PWM_T::CTL1: CNTTYPE5 Mask                */
S
S#define PWM_CTL1_CNTMODEn_Pos            (16)                                              /*!< PWM_T::CTL1: CNTMODEn Position            */
S#define PWM_CTL1_CNTMODEn_Msk            (0x3ful << PWM_CTL1_CNTMODEn_Pos)                 /*!< PWM_T::CTL1: CNTMODEn Mask                */
S
S#define PWM_CTL1_CNTMODE0_Pos            (16)                                              /*!< PWM_T::CTL1: CNTMODE0 Position            */
S#define PWM_CTL1_CNTMODE0_Msk            (0x1ul << PWM_CTL1_CNTMODE0_Pos)                  /*!< PWM_T::CTL1: CNTMODE0 Mask                */
S
S#define PWM_CTL1_CNTMODE1_Pos            (17)                                              /*!< PWM_T::CTL1: CNTMODE1 Position            */
S#define PWM_CTL1_CNTMODE1_Msk            (0x1ul << PWM_CTL1_CNTMODE1_Pos)                  /*!< PWM_T::CTL1: CNTMODE1 Mask                */
S
S#define PWM_CTL1_CNTMODE2_Pos            (18)                                              /*!< PWM_T::CTL1: CNTMODE2 Position            */
S#define PWM_CTL1_CNTMODE2_Msk            (0x1ul << PWM_CTL1_CNTMODE2_Pos)                  /*!< PWM_T::CTL1: CNTMODE2 Mask                */
S
S#define PWM_CTL1_CNTMODE3_Pos            (19)                                              /*!< PWM_T::CTL1: CNTMODE3 Position            */
S#define PWM_CTL1_CNTMODE3_Msk            (0x1ul << PWM_CTL1_CNTMODE3_Pos)                  /*!< PWM_T::CTL1: CNTMODE3 Mask                */
S
S#define PWM_CTL1_CNTMODE4_Pos            (20)                                              /*!< PWM_T::CTL1: CNTMODE4 Position            */
S#define PWM_CTL1_CNTMODE4_Msk            (0x1ul << PWM_CTL1_CNTMODE4_Pos)                  /*!< PWM_T::CTL1: CNTMODE4 Mask                */
S
S#define PWM_CTL1_CNTMODE5_Pos            (21)                                              /*!< PWM_T::CTL1: CNTMODE5 Position            */
S#define PWM_CTL1_CNTMODE5_Msk            (0x1ul << PWM_CTL1_CNTMODE5_Pos)                  /*!< PWM_T::CTL1: CNTMODE5 Mask                */
S
S#define PWM_CTL1_OUTMODEn_Pos            (24)                                              /*!< PWM_T::CTL1: OUTMODEn Position            */
S#define PWM_CTL1_OUTMODEn_Msk            (0x7ul << PWM_CTL1_OUTMODEn_Pos)                  /*!< PWM_T::CTL1: OUTMODEn Mask                */
S
S#define PWM_CTL1_OUTMODE0_Pos            (24)                                              /*!< PWM_T::CTL1: OUTMODE0 Position            */
S#define PWM_CTL1_OUTMODE0_Msk            (0x1ul << PWM_CTL1_OUTMODE0_Pos)                  /*!< PWM_T::CTL1: OUTMODE0 Mask                */
S
S#define PWM_CTL1_OUTMODE2_Pos            (25)                                              /*!< PWM_T::CTL1: OUTMODE2 Position            */
S#define PWM_CTL1_OUTMODE2_Msk            (0x1ul << PWM_CTL1_OUTMODE2_Pos)                  /*!< PWM_T::CTL1: OUTMODE2 Mask                */
S
S#define PWM_CTL1_OUTMODE4_Pos            (26)                                              /*!< PWM_T::CTL1: OUTMODE4 Position            */
S#define PWM_CTL1_OUTMODE4_Msk            (0x1ul << PWM_CTL1_OUTMODE4_Pos)                  /*!< PWM_T::CTL1: OUTMODE4 Mask                */
S
S#define PWM_SYNC_PHSENn_Pos              (0)                                               /*!< PWM_T::SYNC: PHSENn Position              */
S#define PWM_SYNC_PHSENn_Msk              (0x7ul << PWM_SYNC_PHSENn_Pos)                    /*!< PWM_T::SYNC: PHSENn Mask                  */
S
S#define PWM_SYNC_PHSEN0_Pos              (0)                                               /*!< PWM_T::SYNC: PHSEN0 Position              */
S#define PWM_SYNC_PHSEN0_Msk              (0x1ul << PWM_SYNC_PHSEN0_Pos)                    /*!< PWM_T::SYNC: PHSEN0 Mask                  */
S
S#define PWM_SYNC_PHSEN2_Pos              (1)                                               /*!< PWM_T::SYNC: PHSEN2 Position              */
S#define PWM_SYNC_PHSEN2_Msk              (0x1ul << PWM_SYNC_PHSEN2_Pos)                    /*!< PWM_T::SYNC: PHSEN2 Mask                  */
S
S#define PWM_SYNC_PHSEN4_Pos              (2)                                               /*!< PWM_T::SYNC: PHSEN4 Position              */
S#define PWM_SYNC_PHSEN4_Msk              (0x1ul << PWM_SYNC_PHSEN4_Pos)                    /*!< PWM_T::SYNC: PHSEN4 Mask                  */
S
S#define PWM_SYNC_SINSRCn_Pos             (8)                                               /*!< PWM_T::SYNC: SINSRCn Position             */
S#define PWM_SYNC_SINSRCn_Msk             (0x3ful << PWM_SYNC_SINSRCn_Pos)                  /*!< PWM_T::SYNC: SINSRCn Mask                 */
S
S#define PWM_SYNC_SINSRC0_Pos             (8)                                               /*!< PWM_T::SYNC: SINSRC0 Position             */
S#define PWM_SYNC_SINSRC0_Msk             (0x3ul << PWM_SYNC_SINSRC0_Pos)                   /*!< PWM_T::SYNC: SINSRC0 Mask                 */
S
S#define PWM_SYNC_SINSRC2_Pos             (10)                                              /*!< PWM_T::SYNC: SINSRC2 Position             */
S#define PWM_SYNC_SINSRC2_Msk             (0x3ul << PWM_SYNC_SINSRC2_Pos)                   /*!< PWM_T::SYNC: SINSRC2 Mask                 */
S
S#define PWM_SYNC_SINSRC4_Pos             (12)                                              /*!< PWM_T::SYNC: SINSRC4 Position             */
S#define PWM_SYNC_SINSRC4_Msk             (0x3ul << PWM_SYNC_SINSRC4_Pos)                   /*!< PWM_T::SYNC: SINSRC4 Mask                 */
S
S#define PWM_SYNC_SNFLTEN_Pos             (16)                                              /*!< PWM_T::SYNC: SNFLTEN Position             */
S#define PWM_SYNC_SNFLTEN_Msk             (0x1ul << PWM_SYNC_SNFLTEN_Pos)                   /*!< PWM_T::SYNC: SNFLTEN Mask                 */
S
S#define PWM_SYNC_SFLTCSEL_Pos            (17)                                              /*!< PWM_T::SYNC: SFLTCSEL Position            */
S#define PWM_SYNC_SFLTCSEL_Msk            (0x7ul << PWM_SYNC_SFLTCSEL_Pos)                  /*!< PWM_T::SYNC: SFLTCSEL Mask                */
S
S#define PWM_SYNC_SFLTCNT_Pos             (20)                                              /*!< PWM_T::SYNC: SFLTCNT Position             */
S#define PWM_SYNC_SFLTCNT_Msk             (0x7ul << PWM_SYNC_SFLTCNT_Pos)                   /*!< PWM_T::SYNC: SFLTCNT Mask                 */
S
S#define PWM_SYNC_SINPINV_Pos             (23)                                              /*!< PWM_T::SYNC: SINPINV Position             */
S#define PWM_SYNC_SINPINV_Msk             (0x1ul << PWM_SYNC_SINPINV_Pos)                   /*!< PWM_T::SYNC: SINPINV Mask                 */
S
S#define PWM_SYNC_PHSDIRn_Pos             (24)                                              /*!< PWM_T::SYNC: PHSDIRn Position             */
S#define PWM_SYNC_PHSDIRn_Msk             (0x7ul << PWM_SYNC_PHSDIRn_Pos)                   /*!< PWM_T::SYNC: PHSDIRn Mask                 */
S
S#define PWM_SYNC_PHSDIR0_Pos             (24)                                              /*!< PWM_T::SYNC: PHSDIR0 Position             */
S#define PWM_SYNC_PHSDIR0_Msk             (0x1ul << PWM_SYNC_PHSDIR0_Pos)                   /*!< PWM_T::SYNC: PHSDIR0 Mask                 */
S
S#define PWM_SYNC_PHSDIR2_Pos             (25)                                              /*!< PWM_T::SYNC: PHSDIR2 Position             */
S#define PWM_SYNC_PHSDIR2_Msk             (0x1ul << PWM_SYNC_PHSDIR2_Pos)                   /*!< PWM_T::SYNC: PHSDIR2 Mask                 */
S
S#define PWM_SYNC_PHSDIR4_Pos             (26)                                              /*!< PWM_T::SYNC: PHSDIR4 Position             */
S#define PWM_SYNC_PHSDIR4_Msk             (0x1ul << PWM_SYNC_PHSDIR4_Pos)                   /*!< PWM_T::SYNC: PHSDIR4 Mask                 */
S
S#define PWM_SWSYNC_SWSYNCn_Pos           (0)                                               /*!< PWM_T::SWSYNC: SWSYNCn Position           */
S#define PWM_SWSYNC_SWSYNCn_Msk           (0x7ul << PWM_SWSYNC_SWSYNCn_Pos)                 /*!< PWM_T::SWSYNC: SWSYNCn Mask               */
S
S#define PWM_SWSYNC_SWSYNC0_Pos           (0)                                               /*!< PWM_T::SWSYNC: SWSYNC0 Position           */
S#define PWM_SWSYNC_SWSYNC0_Msk           (0x1ul << PWM_SWSYNC_SWSYNC0_Pos)                 /*!< PWM_T::SWSYNC: SWSYNC0 Mask               */
S
S#define PWM_SWSYNC_SWSYNC2_Pos           (1)                                               /*!< PWM_T::SWSYNC: SWSYNC2 Position           */
S#define PWM_SWSYNC_SWSYNC2_Msk           (0x1ul << PWM_SWSYNC_SWSYNC2_Pos)                 /*!< PWM_T::SWSYNC: SWSYNC2 Mask               */
S
S#define PWM_SWSYNC_SWSYNC4_Pos           (2)                                               /*!< PWM_T::SWSYNC: SWSYNC4 Position           */
S#define PWM_SWSYNC_SWSYNC4_Msk           (0x1ul << PWM_SWSYNC_SWSYNC4_Pos)                 /*!< PWM_T::SWSYNC: SWSYNC4 Mask               */
S
S#define PWM_CLKSRC_ECLKSRC0_Pos          (0)                                               /*!< PWM_T::CLKSRC: ECLKSRC0 Position          */
S#define PWM_CLKSRC_ECLKSRC0_Msk          (0x7ul << PWM_CLKSRC_ECLKSRC0_Pos)                /*!< PWM_T::CLKSRC: ECLKSRC0 Mask              */
S
S#define PWM_CLKSRC_ECLKSRC2_Pos          (8)                                               /*!< PWM_T::CLKSRC: ECLKSRC2 Position          */
S#define PWM_CLKSRC_ECLKSRC2_Msk          (0x7ul << PWM_CLKSRC_ECLKSRC2_Pos)                /*!< PWM_T::CLKSRC: ECLKSRC2 Mask              */
S
S#define PWM_CLKSRC_ECLKSRC4_Pos          (16)                                              /*!< PWM_T::CLKSRC: ECLKSRC4 Position          */
S#define PWM_CLKSRC_ECLKSRC4_Msk          (0x7ul << PWM_CLKSRC_ECLKSRC4_Pos)                /*!< PWM_T::CLKSRC: ECLKSRC4 Mask              */
S
S#define PWM_CLKPSC0_1_CLKPSC_Pos         (0)                                               /*!< PWM_T::CLKPSC0_1: CLKPSC Position         */
S#define PWM_CLKPSC0_1_CLKPSC_Msk         (0xffful << PWM_CLKPSC0_1_CLKPSC_Pos)             /*!< PWM_T::CLKPSC0_1: CLKPSC Mask             */
S
S#define PWM_CLKPSC2_3_CLKPSC_Pos         (0)                                               /*!< PWM_T::CLKPSC2_3: CLKPSC Position         */
S#define PWM_CLKPSC2_3_CLKPSC_Msk         (0xffful << PWM_CLKPSC2_3_CLKPSC_Pos)             /*!< PWM_T::CLKPSC2_3: CLKPSC Mask             */
S
S#define PWM_CLKPSC4_5_CLKPSC_Pos         (0)                                               /*!< PWM_T::CLKPSC4_5: CLKPSC Position         */
S#define PWM_CLKPSC4_5_CLKPSC_Msk         (0xffful << PWM_CLKPSC4_5_CLKPSC_Pos)             /*!< PWM_T::CLKPSC4_5: CLKPSC Mask             */
S
S#define PWM_CNTEN_CNTENn_Pos             (0)                                               /*!< PWM_T::CNTEN: CNTENn Position             */
S#define PWM_CNTEN_CNTENn_Msk             (0x3ful << PWM_CNTEN_CNTENn_Pos)                  /*!< PWM_T::CNTEN: CNTENn Mask                 */
S
S#define PWM_CNTEN_CNTEN0_Pos             (0)                                               /*!< PWM_T::CNTEN: CNTEN0 Position             */
S#define PWM_CNTEN_CNTEN0_Msk             (0x1ul << PWM_CNTEN_CNTEN0_Pos)                   /*!< PWM_T::CNTEN: CNTEN0 Mask                 */
S
S#define PWM_CNTEN_CNTEN1_Pos             (1)                                               /*!< PWM_T::CNTEN: CNTEN1 Position             */
S#define PWM_CNTEN_CNTEN1_Msk             (0x1ul << PWM_CNTEN_CNTEN1_Pos)                   /*!< PWM_T::CNTEN: CNTEN1 Mask                 */
S
S#define PWM_CNTEN_CNTEN2_Pos             (2)                                               /*!< PWM_T::CNTEN: CNTEN2 Position             */
S#define PWM_CNTEN_CNTEN2_Msk             (0x1ul << PWM_CNTEN_CNTEN2_Pos)                   /*!< PWM_T::CNTEN: CNTEN2 Mask                 */
S
S#define PWM_CNTEN_CNTEN3_Pos             (3)                                               /*!< PWM_T::CNTEN: CNTEN3 Position             */
S#define PWM_CNTEN_CNTEN3_Msk             (0x1ul << PWM_CNTEN_CNTEN3_Pos)                   /*!< PWM_T::CNTEN: CNTEN3 Mask                 */
S
S#define PWM_CNTEN_CNTEN4_Pos             (4)                                               /*!< PWM_T::CNTEN: CNTEN4 Position             */
S#define PWM_CNTEN_CNTEN4_Msk             (0x1ul << PWM_CNTEN_CNTEN4_Pos)                   /*!< PWM_T::CNTEN: CNTEN4 Mask                 */
S
S#define PWM_CNTEN_CNTEN5_Pos             (5)                                               /*!< PWM_T::CNTEN: CNTEN5 Position             */
S#define PWM_CNTEN_CNTEN5_Msk             (0x1ul << PWM_CNTEN_CNTEN5_Pos)                   /*!< PWM_T::CNTEN: CNTEN5 Mask                 */
S
S#define PWM_CNTCLR_CNTCLRn_Pos           (0)                                               /*!< PWM_T::CNTCLR: CNTCLRn Position           */
S#define PWM_CNTCLR_CNTCLRn_Msk           (0x3ful << PWM_CNTCLR_CNTCLRn_Pos)                /*!< PWM_T::CNTCLR: CNTCLRn Mask               */
S
S#define PWM_CNTCLR_CNTCLR0_Pos           (0)                                               /*!< PWM_T::CNTCLR: CNTCLR0 Position           */
S#define PWM_CNTCLR_CNTCLR0_Msk           (0x1ul << PWM_CNTCLR_CNTCLR0_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR0 Mask               */
S
S#define PWM_CNTCLR_CNTCLR1_Pos           (1)                                               /*!< PWM_T::CNTCLR: CNTCLR1 Position           */
S#define PWM_CNTCLR_CNTCLR1_Msk           (0x1ul << PWM_CNTCLR_CNTCLR1_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR1 Mask               */
S
S#define PWM_CNTCLR_CNTCLR2_Pos           (2)                                               /*!< PWM_T::CNTCLR: CNTCLR2 Position           */
S#define PWM_CNTCLR_CNTCLR2_Msk           (0x1ul << PWM_CNTCLR_CNTCLR2_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR2 Mask               */
S
S#define PWM_CNTCLR_CNTCLR3_Pos           (3)                                               /*!< PWM_T::CNTCLR: CNTCLR3 Position           */
S#define PWM_CNTCLR_CNTCLR3_Msk           (0x1ul << PWM_CNTCLR_CNTCLR3_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR3 Mask               */
S
S#define PWM_CNTCLR_CNTCLR4_Pos           (4)                                               /*!< PWM_T::CNTCLR: CNTCLR4 Position           */
S#define PWM_CNTCLR_CNTCLR4_Msk           (0x1ul << PWM_CNTCLR_CNTCLR4_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR4 Mask               */
S
S#define PWM_CNTCLR_CNTCLR5_Pos           (5)                                               /*!< PWM_T::CNTCLR: CNTCLR5 Position           */
S#define PWM_CNTCLR_CNTCLR5_Msk           (0x1ul << PWM_CNTCLR_CNTCLR5_Pos)                 /*!< PWM_T::CNTCLR: CNTCLR5 Mask               */
S
S#define PWM_LOAD_LOADn_Pos               (0)                                               /*!< PWM_T::LOAD: LOADn Position               */
S#define PWM_LOAD_LOADn_Msk               (0x3ful << PWM_LOAD_LOADn_Pos)                    /*!< PWM_T::LOAD: LOADn Mask                   */
S
S#define PWM_LOAD_LOAD0_Pos               (0)                                               /*!< PWM_T::LOAD: LOAD0 Position               */
S#define PWM_LOAD_LOAD0_Msk               (0x1ul << PWM_LOAD_LOAD0_Pos)                     /*!< PWM_T::LOAD: LOAD0 Mask                   */
S
S#define PWM_LOAD_LOAD1_Pos               (1)                                               /*!< PWM_T::LOAD: LOAD1 Position               */
S#define PWM_LOAD_LOAD1_Msk               (0x1ul << PWM_LOAD_LOAD1_Pos)                     /*!< PWM_T::LOAD: LOAD1 Mask                   */
S
S#define PWM_LOAD_LOAD2_Pos               (2)                                               /*!< PWM_T::LOAD: LOAD2 Position               */
S#define PWM_LOAD_LOAD2_Msk               (0x1ul << PWM_LOAD_LOAD2_Pos)                     /*!< PWM_T::LOAD: LOAD2 Mask                   */
S
S#define PWM_LOAD_LOAD3_Pos               (3)                                               /*!< PWM_T::LOAD: LOAD3 Position               */
S#define PWM_LOAD_LOAD3_Msk               (0x1ul << PWM_LOAD_LOAD3_Pos)                     /*!< PWM_T::LOAD: LOAD3 Mask                   */
S
S#define PWM_LOAD_LOAD4_Pos               (4)                                               /*!< PWM_T::LOAD: LOAD4 Position               */
S#define PWM_LOAD_LOAD4_Msk               (0x1ul << PWM_LOAD_LOAD4_Pos)                     /*!< PWM_T::LOAD: LOAD4 Mask                   */
S
S#define PWM_LOAD_LOAD5_Pos               (5)                                               /*!< PWM_T::LOAD: LOAD5 Position               */
S#define PWM_LOAD_LOAD5_Msk               (0x1ul << PWM_LOAD_LOAD5_Pos)                     /*!< PWM_T::LOAD: LOAD5 Mask                   */
S
S#define PWM_PERIOD_PERIOD_Pos            (0)                                               /*!< PWM_T::PERIOD: PERIOD Position            */
S#define PWM_PERIOD_PERIOD_Msk            (0xfffful << PWM_PERIOD_PERIOD_Pos)               /*!< PWM_T::PERIOD: PERIOD Mask                */
S
S#define PWM_CMPDAT_CMP_Pos               (0)                                               /*!< PWM_T::CMPDAT: CMP Position               */
S#define PWM_CMPDAT_CMP_Msk               (0xfffful << PWM_CMPDAT_CMP_Pos)                  /*!< PWM_T::CMPDAT: CMP Mask                   */
S
S#define PWM_DTCTL0_1_DTCNT_Pos           (0)                                               /*!< PWM_T::DTCTL0_1: DTCNT Position           */
S#define PWM_DTCTL0_1_DTCNT_Msk           (0xffful << PWM_DTCTL0_1_DTCNT_Pos)               /*!< PWM_T::DTCTL0_1: DTCNT Mask               */
S
S#define PWM_DTCTL0_1_DTEN_Pos            (16)                                              /*!< PWM_T::DTCTL0_1: DTEN Position            */
S#define PWM_DTCTL0_1_DTEN_Msk            (0x1ul << PWM_DTCTL0_1_DTEN_Pos)                  /*!< PWM_T::DTCTL0_1: DTEN Mask                */
S
S#define PWM_DTCTL0_1_DTCKSEL_Pos         (24)                                              /*!< PWM_T::DTCTL0_1: DTCKSEL Position         */
S#define PWM_DTCTL0_1_DTCKSEL_Msk         (0x1ul << PWM_DTCTL0_1_DTCKSEL_Pos)               /*!< PWM_T::DTCTL0_1: DTCKSEL Mask             */
S
S#define PWM_DTCTL2_3_DTCNT_Pos           (0)                                               /*!< PWM_T::DTCTL2_3: DTCNT Position           */
S#define PWM_DTCTL2_3_DTCNT_Msk           (0xffful << PWM_DTCTL2_3_DTCNT_Pos)               /*!< PWM_T::DTCTL2_3: DTCNT Mask               */
S
S#define PWM_DTCTL2_3_DTEN_Pos            (16)                                              /*!< PWM_T::DTCTL2_3: DTEN Position            */
S#define PWM_DTCTL2_3_DTEN_Msk            (0x1ul << PWM_DTCTL2_3_DTEN_Pos)                  /*!< PWM_T::DTCTL2_3: DTEN Mask                */
S
S#define PWM_DTCTL2_3_DTCKSEL_Pos         (24)                                              /*!< PWM_T::DTCTL2_3: DTCKSEL Position         */
S#define PWM_DTCTL2_3_DTCKSEL_Msk         (0x1ul << PWM_DTCTL2_3_DTCKSEL_Pos)               /*!< PWM_T::DTCTL2_3: DTCKSEL Mask             */
S
S#define PWM_DTCTL4_5_DTCNT_Pos           (0)                                               /*!< PWM_T::DTCTL4_5: DTCNT Position           */
S#define PWM_DTCTL4_5_DTCNT_Msk           (0xffful << PWM_DTCTL4_5_DTCNT_Pos)               /*!< PWM_T::DTCTL4_5: DTCNT Mask               */
S
S#define PWM_DTCTL4_5_DTEN_Pos            (16)                                              /*!< PWM_T::DTCTL4_5: DTEN Position            */
S#define PWM_DTCTL4_5_DTEN_Msk            (0x1ul << PWM_DTCTL4_5_DTEN_Pos)                  /*!< PWM_T::DTCTL4_5: DTEN Mask                */
S
S#define PWM_DTCTL4_5_DTCKSEL_Pos         (24)                                              /*!< PWM_T::DTCTL4_5: DTCKSEL Position         */
S#define PWM_DTCTL4_5_DTCKSEL_Msk         (0x1ul << PWM_DTCTL4_5_DTCKSEL_Pos)               /*!< PWM_T::DTCTL4_5: DTCKSEL Mask             */
S
S#define PWM_PHS0_1_PHS_Pos               (0)                                               /*!< PWM_T::PHS0_1: PHS Position               */
S#define PWM_PHS0_1_PHS_Msk               (0xfffful << PWM_PHS0_1_PHS_Pos)                  /*!< PWM_T::PHS0_1: PHS Mask                   */
S
S#define PWM_PHS2_3_PHS_Pos               (0)                                               /*!< PWM_T::PHS2_3: PHS Position               */
S#define PWM_PHS2_3_PHS_Msk               (0xfffful << PWM_PHS2_3_PHS_Pos)                  /*!< PWM_T::PHS2_3: PHS Mask                   */
S
S#define PWM_PHS4_5_PHS_Pos               (0)                                               /*!< PWM_T::PHS4_5: PHS Position               */
S#define PWM_PHS4_5_PHS_Msk               (0xfffful << PWM_PHS4_5_PHS_Pos)                  /*!< PWM_T::PHS4_5: PHS Mask                   */
S
S#define PWM_CNT_CNT_Pos                  (0)                                               /*!< PWM_T::CNT: CNT Position                  */
S#define PWM_CNT_CNT_Msk                  (0xfffful << PWM_CNT_CNT_Pos)                     /*!< PWM_T::CNT: CNT Mask                      */
S
S#define PWM_CNT_DIRF_Pos                 (16)                                              /*!< PWM_T::CNT: DIRF Position                 */
S#define PWM_CNT_DIRF_Msk                 (0x1ul << PWM_CNT_DIRF_Pos)                       /*!< PWM_T::CNT: DIRF Mask                     */
S
S#define PWM_WGCTL0_ZPCTLn_Pos            (0)                                               /*!< PWM_T::WGCTL0: ZPCTLn Position            */
S#define PWM_WGCTL0_ZPCTLn_Msk            (0xffful << PWM_WGCTL0_ZPCTLn_Pos)                /*!< PWM_T::WGCTL0: ZPCTLn Mask                */
S
S#define PWM_WGCTL0_ZPCTL0_Pos            (0)                                               /*!< PWM_T::WGCTL0: ZPCTL0 Position            */
S#define PWM_WGCTL0_ZPCTL0_Msk            (0x3ul << PWM_WGCTL0_ZPCTL0_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL0 Mask                */
S
S#define PWM_WGCTL0_ZPCTL1_Pos            (2)                                               /*!< PWM_T::WGCTL0: ZPCTL1 Position            */
S#define PWM_WGCTL0_ZPCTL1_Msk            (0x3ul << PWM_WGCTL0_ZPCTL1_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL1 Mask                */
S
S#define PWM_WGCTL0_ZPCTL2_Pos            (4)                                               /*!< PWM_T::WGCTL0: ZPCTL2 Position            */
S#define PWM_WGCTL0_ZPCTL2_Msk            (0x3ul << PWM_WGCTL0_ZPCTL2_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL2 Mask                */
S
S#define PWM_WGCTL0_ZPCTL3_Pos            (6)                                               /*!< PWM_T::WGCTL0: ZPCTL3 Position            */
S#define PWM_WGCTL0_ZPCTL3_Msk            (0x3ul << PWM_WGCTL0_ZPCTL3_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL3 Mask                */
S
S#define PWM_WGCTL0_ZPCTL4_Pos            (8)                                               /*!< PWM_T::WGCTL0: ZPCTL4 Position            */
S#define PWM_WGCTL0_ZPCTL4_Msk            (0x3ul << PWM_WGCTL0_ZPCTL4_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL4 Mask                */
S
S#define PWM_WGCTL0_ZPCTL5_Pos            (10)                                              /*!< PWM_T::WGCTL0: ZPCTL5 Position            */
S#define PWM_WGCTL0_ZPCTL5_Msk            (0x3ul << PWM_WGCTL0_ZPCTL5_Pos)                  /*!< PWM_T::WGCTL0: ZPCTL5 Mask                */
S
S#define PWM_WGCTL0_PRDPCTLn_Pos          (16)                                              /*!< PWM_T::WGCTL0: PRDPCTLn Position          */
S#define PWM_WGCTL0_PRDPCTLn_Msk          (0xffful << PWM_WGCTL0_PRDPCTLn_Pos)              /*!< PWM_T::WGCTL0: PRDPCTLn Mask              */
S
S#define PWM_WGCTL0_PRDPCTL0_Pos          (16)                                              /*!< PWM_T::WGCTL0: PRDPCTL0 Position          */
S#define PWM_WGCTL0_PRDPCTL0_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL0_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL0 Mask              */
S
S#define PWM_WGCTL0_PRDPCTL1_Pos          (18)                                              /*!< PWM_T::WGCTL0: PRDPCTL1 Position          */
S#define PWM_WGCTL0_PRDPCTL1_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL1_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL1 Mask              */
S
S#define PWM_WGCTL0_PRDPCTL2_Pos          (20)                                              /*!< PWM_T::WGCTL0: PRDPCTL2 Position          */
S#define PWM_WGCTL0_PRDPCTL2_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL2_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL2 Mask              */
S
S#define PWM_WGCTL0_PRDPCTL3_Pos          (22)                                              /*!< PWM_T::WGCTL0: PRDPCTL3 Position          */
S#define PWM_WGCTL0_PRDPCTL3_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL3_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL3 Mask              */
S
S#define PWM_WGCTL0_PRDPCTL4_Pos          (24)                                              /*!< PWM_T::WGCTL0: PRDPCTL4 Position          */
S#define PWM_WGCTL0_PRDPCTL4_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL4_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL4 Mask              */
S
S#define PWM_WGCTL0_PRDPCTL5_Pos          (26)                                              /*!< PWM_T::WGCTL0: PRDPCTL5 Position          */
S#define PWM_WGCTL0_PRDPCTL5_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL5_Pos)                /*!< PWM_T::WGCTL0: PRDPCTL5 Mask              */
S
S#define PWM_WGCTL1_CMPUCTLn_Pos          (0)                                               /*!< PWM_T::WGCTL1: CMPUCTLn Position          */
S#define PWM_WGCTL1_CMPUCTLn_Msk          (0xffful << PWM_WGCTL1_CMPUCTLn_Pos)              /*!< PWM_T::WGCTL1: CMPUCTLn Mask              */
S
S#define PWM_WGCTL1_CMPUCTL0_Pos          (0)                                               /*!< PWM_T::WGCTL1: CMPUCTL0 Position          */
S#define PWM_WGCTL1_CMPUCTL0_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL0_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL0 Mask              */
S
S#define PWM_WGCTL1_CMPUCTL1_Pos          (2)                                               /*!< PWM_T::WGCTL1: CMPUCTL1 Position          */
S#define PWM_WGCTL1_CMPUCTL1_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL1_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL1 Mask              */
S
S#define PWM_WGCTL1_CMPUCTL2_Pos          (4)                                               /*!< PWM_T::WGCTL1: CMPUCTL2 Position          */
S#define PWM_WGCTL1_CMPUCTL2_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL2_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL2 Mask              */
S
S#define PWM_WGCTL1_CMPUCTL3_Pos          (6)                                               /*!< PWM_T::WGCTL1: CMPUCTL3 Position          */
S#define PWM_WGCTL1_CMPUCTL3_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL3_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL3 Mask              */
S
S#define PWM_WGCTL1_CMPUCTL4_Pos          (8)                                               /*!< PWM_T::WGCTL1: CMPUCTL4 Position          */
S#define PWM_WGCTL1_CMPUCTL4_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL4_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL4 Mask              */
S
S#define PWM_WGCTL1_CMPUCTL5_Pos          (10)                                              /*!< PWM_T::WGCTL1: CMPUCTL5 Position          */
S#define PWM_WGCTL1_CMPUCTL5_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL5_Pos)                /*!< PWM_T::WGCTL1: CMPUCTL5 Mask              */
S
S#define PWM_WGCTL1_CMPDCTLn_Pos          (16)                                              /*!< PWM_T::WGCTL1: CMPDCTLn Position          */
S#define PWM_WGCTL1_CMPDCTLn_Msk          (0xffful << PWM_WGCTL1_CMPDCTLn_Pos)              /*!< PWM_T::WGCTL1: CMPDCTLn Mask              */
S
S#define PWM_WGCTL1_CMPDCTL0_Pos          (16)                                              /*!< PWM_T::WGCTL1: CMPDCTL0 Position          */
S#define PWM_WGCTL1_CMPDCTL0_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL0_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL0 Mask              */
S
S#define PWM_WGCTL1_CMPDCTL1_Pos          (18)                                              /*!< PWM_T::WGCTL1: CMPDCTL1 Position          */
S#define PWM_WGCTL1_CMPDCTL1_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL1_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL1 Mask              */
S
S#define PWM_WGCTL1_CMPDCTL2_Pos          (20)                                              /*!< PWM_T::WGCTL1: CMPDCTL2 Position          */
S#define PWM_WGCTL1_CMPDCTL2_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL2_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL2 Mask              */
S
S#define PWM_WGCTL1_CMPDCTL3_Pos          (22)                                              /*!< PWM_T::WGCTL1: CMPDCTL3 Position          */
S#define PWM_WGCTL1_CMPDCTL3_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL3_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL3 Mask              */
S
S#define PWM_WGCTL1_CMPDCTL4_Pos          (24)                                              /*!< PWM_T::WGCTL1: CMPDCTL4 Position          */
S#define PWM_WGCTL1_CMPDCTL4_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL4_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL4 Mask              */
S
S#define PWM_WGCTL1_CMPDCTL5_Pos          (26)                                              /*!< PWM_T::WGCTL1: CMPDCTL5 Position          */
S#define PWM_WGCTL1_CMPDCTL5_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL5_Pos)                /*!< PWM_T::WGCTL1: CMPDCTL5 Mask              */
S
S#define PWM_MSKEN_MSKENn_Pos             (0)                                               /*!< PWM_T::MSKEN: MSKENn Position             */
S#define PWM_MSKEN_MSKENn_Msk             (0x3ful << PWM_MSKEN_MSKENn_Pos)                  /*!< PWM_T::MSKEN: MSKENn Mask                 */
S
S#define PWM_MSKEN_MSKEN0_Pos             (0)                                               /*!< PWM_T::MSKEN: MSKEN0 Position             */
S#define PWM_MSKEN_MSKEN0_Msk             (0x1ul << PWM_MSKEN_MSKEN0_Pos)                   /*!< PWM_T::MSKEN: MSKEN0 Mask                 */
S
S#define PWM_MSKEN_MSKEN1_Pos             (1)                                               /*!< PWM_T::MSKEN: MSKEN1 Position             */
S#define PWM_MSKEN_MSKEN1_Msk             (0x1ul << PWM_MSKEN_MSKEN1_Pos)                   /*!< PWM_T::MSKEN: MSKEN1 Mask                 */
S
S#define PWM_MSKEN_MSKEN2_Pos             (2)                                               /*!< PWM_T::MSKEN: MSKEN2 Position             */
S#define PWM_MSKEN_MSKEN2_Msk             (0x1ul << PWM_MSKEN_MSKEN2_Pos)                   /*!< PWM_T::MSKEN: MSKEN2 Mask                 */
S
S#define PWM_MSKEN_MSKEN3_Pos             (3)                                               /*!< PWM_T::MSKEN: MSKEN3 Position             */
S#define PWM_MSKEN_MSKEN3_Msk             (0x1ul << PWM_MSKEN_MSKEN3_Pos)                   /*!< PWM_T::MSKEN: MSKEN3 Mask                 */
S
S#define PWM_MSKEN_MSKEN4_Pos             (4)                                               /*!< PWM_T::MSKEN: MSKEN4 Position             */
S#define PWM_MSKEN_MSKEN4_Msk             (0x1ul << PWM_MSKEN_MSKEN4_Pos)                   /*!< PWM_T::MSKEN: MSKEN4 Mask                 */
S
S#define PWM_MSKEN_MSKEN5_Pos             (5)                                               /*!< PWM_T::MSKEN: MSKEN5 Position             */
S#define PWM_MSKEN_MSKEN5_Msk             (0x1ul << PWM_MSKEN_MSKEN5_Pos)                   /*!< PWM_T::MSKEN: MSKEN5 Mask                 */
S
S#define PWM_MSK_MSKDATn_Pos              (0)                                               /*!< PWM_T::MSK: MSKDATn Position              */
S#define PWM_MSK_MSKDATn_Msk              (0x3ful << PWM_MSK_MSKDATn_Pos)                   /*!< PWM_T::MSK: MSKDATn Mask                  */
S
S#define PWM_MSK_MSKDAT0_Pos              (0)                                               /*!< PWM_T::MSK: MSKDAT0 Position              */
S#define PWM_MSK_MSKDAT0_Msk              (0x1ul << PWM_MSK_MSKDAT0_Pos)                    /*!< PWM_T::MSK: MSKDAT0 Mask                  */
S
S#define PWM_MSK_MSKDAT1_Pos              (1)                                               /*!< PWM_T::MSK: MSKDAT1 Position              */
S#define PWM_MSK_MSKDAT1_Msk              (0x1ul << PWM_MSK_MSKDAT1_Pos)                    /*!< PWM_T::MSK: MSKDAT1 Mask                  */
S
S#define PWM_MSK_MSKDAT2_Pos              (2)                                               /*!< PWM_T::MSK: MSKDAT2 Position              */
S#define PWM_MSK_MSKDAT2_Msk              (0x1ul << PWM_MSK_MSKDAT2_Pos)                    /*!< PWM_T::MSK: MSKDAT2 Mask                  */
S
S#define PWM_MSK_MSKDAT3_Pos              (3)                                               /*!< PWM_T::MSK: MSKDAT3 Position              */
S#define PWM_MSK_MSKDAT3_Msk              (0x1ul << PWM_MSK_MSKDAT3_Pos)                    /*!< PWM_T::MSK: MSKDAT3 Mask                  */
S
S#define PWM_MSK_MSKDAT4_Pos              (4)                                               /*!< PWM_T::MSK: MSKDAT4 Position              */
S#define PWM_MSK_MSKDAT4_Msk              (0x1ul << PWM_MSK_MSKDAT4_Pos)                    /*!< PWM_T::MSK: MSKDAT4 Mask                  */
S
S#define PWM_MSK_MSKDAT5_Pos              (5)                                               /*!< PWM_T::MSK: MSKDAT5 Position              */
S#define PWM_MSK_MSKDAT5_Msk              (0x1ul << PWM_MSK_MSKDAT5_Pos)                    /*!< PWM_T::MSK: MSKDAT5 Mask                  */
S
S#define PWM_BNF_BRK0NFEN_Pos             (0)                                               /*!< PWM_T::BNF: BRK0NFEN Position             */
S#define PWM_BNF_BRK0NFEN_Msk             (0x1ul << PWM_BNF_BRK0NFEN_Pos)                   /*!< PWM_T::BNF: BRK0NFEN Mask                 */
S
S#define PWM_BNF_BRK0NFSEL_Pos            (1)                                               /*!< PWM_T::BNF: BRK0NFSEL Position            */
S#define PWM_BNF_BRK0NFSEL_Msk            (0x7ul << PWM_BNF_BRK0NFSEL_Pos)                  /*!< PWM_T::BNF: BRK0NFSEL Mask                */
S
S#define PWM_BNF_BRK0FCNT_Pos             (4)                                               /*!< PWM_T::BNF: BRK0FCNT Position             */
S#define PWM_BNF_BRK0FCNT_Msk             (0x7ul << PWM_BNF_BRK0FCNT_Pos)                   /*!< PWM_T::BNF: BRK0FCNT Mask                 */
S
S#define PWM_BNF_BRK0PINV_Pos             (7)                                               /*!< PWM_T::BNF: BRK0PINV Position             */
S#define PWM_BNF_BRK0PINV_Msk             (0x1ul << PWM_BNF_BRK0PINV_Pos)                   /*!< PWM_T::BNF: BRK0PINV Mask                 */
S
S#define PWM_BNF_BRK1NFEN_Pos             (8)                                               /*!< PWM_T::BNF: BRK1NFEN Position             */
S#define PWM_BNF_BRK1NFEN_Msk             (0x1ul << PWM_BNF_BRK1NFEN_Pos)                   /*!< PWM_T::BNF: BRK1NFEN Mask                 */
S
S#define PWM_BNF_BRK1NFSEL_Pos            (9)                                               /*!< PWM_T::BNF: BRK1NFSEL Position            */
S#define PWM_BNF_BRK1NFSEL_Msk            (0x7ul << PWM_BNF_BRK1NFSEL_Pos)                  /*!< PWM_T::BNF: BRK1NFSEL Mask                */
S
S#define PWM_BNF_BRK1FCNT_Pos             (12)                                              /*!< PWM_T::BNF: BRK1FCNT Position             */
S#define PWM_BNF_BRK1FCNT_Msk             (0x7ul << PWM_BNF_BRK1FCNT_Pos)                   /*!< PWM_T::BNF: BRK1FCNT Mask                 */
S
S#define PWM_BNF_BRK1PINV_Pos             (15)                                              /*!< PWM_T::BNF: BRK1PINV Position             */
S#define PWM_BNF_BRK1PINV_Msk             (0x1ul << PWM_BNF_BRK1PINV_Pos)                   /*!< PWM_T::BNF: BRK1PINV Mask                 */
S
S#define PWM_BNF_BK0SRC_Pos               (16)                                              /*!< PWM_T::BNF: BK0SRC Position               */
S#define PWM_BNF_BK0SRC_Msk               (0x1ul << PWM_BNF_BK0SRC_Pos)                     /*!< PWM_T::BNF: BK0SRC Mask                   */
S
S#define PWM_BNF_BK1SRC_Pos               (24)                                              /*!< PWM_T::BNF: BK1SRC Position               */
S#define PWM_BNF_BK1SRC_Msk               (0x1ul << PWM_BNF_BK1SRC_Pos)                     /*!< PWM_T::BNF: BK1SRC Mask                   */
S
S#define PWM_FAILBRK_CSSBRKEN_Pos         (0)                                               /*!< PWM_T::FAILBRK: CSSBRKEN Position         */
S#define PWM_FAILBRK_CSSBRKEN_Msk         (0x1ul << PWM_FAILBRK_CSSBRKEN_Pos)               /*!< PWM_T::FAILBRK: CSSBRKEN Mask             */
S
S#define PWM_FAILBRK_BODBRKEN_Pos         (1)                                               /*!< PWM_T::FAILBRK: BODBRKEN Position         */
S#define PWM_FAILBRK_BODBRKEN_Msk         (0x1ul << PWM_FAILBRK_BODBRKEN_Pos)               /*!< PWM_T::FAILBRK: BODBRKEN Mask             */
S
S#define PWM_FAILBRK_RAMBRKEN_Pos         (2)                                               /*!< PWM_T::FAILBRK: RAMBRKEN Position         */
S#define PWM_FAILBRK_RAMBRKEN_Msk         (0x1ul << PWM_FAILBRK_RAMBRKEN_Pos)               /*!< PWM_T::FAILBRK: RAMBRKEN Mask             */
S
S#define PWM_FAILBRK_CORBRKEN_Pos         (3)                                               /*!< PWM_T::FAILBRK: CORBRKEN Position         */
S#define PWM_FAILBRK_CORBRKEN_Msk         (0x1ul << PWM_FAILBRK_CORBRKEN_Pos)               /*!< PWM_T::FAILBRK: CORBRKEN Mask             */
S
S#define PWM_BRKCTL0_1_CPO0EBEN_Pos       (0)                                               /*!< PWM_T::BRKCTL0_1: CPO0EBEN Position       */
S#define PWM_BRKCTL0_1_CPO0EBEN_Msk       (0x1ul << PWM_BRKCTL0_1_CPO0EBEN_Pos)             /*!< PWM_T::BRKCTL0_1: CPO0EBEN Mask           */
S
S#define PWM_BRKCTL0_1_CPO1EBEN_Pos       (1)                                               /*!< PWM_T::BRKCTL0_1: CPO1EBEN Position       */
S#define PWM_BRKCTL0_1_CPO1EBEN_Msk       (0x1ul << PWM_BRKCTL0_1_CPO1EBEN_Pos)             /*!< PWM_T::BRKCTL0_1: CPO1EBEN Mask           */
S
S#define PWM_BRKCTL0_1_BRKP0EEN_Pos       (4)                                               /*!< PWM_T::BRKCTL0_1: BRKP0EEN Position       */
S#define PWM_BRKCTL0_1_BRKP0EEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP0EEN_Pos)             /*!< PWM_T::BRKCTL0_1: BRKP0EEN Mask           */
S
S#define PWM_BRKCTL0_1_BRKP1EEN_Pos       (5)                                               /*!< PWM_T::BRKCTL0_1: BRKP1EEN Position       */
S#define PWM_BRKCTL0_1_BRKP1EEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP1EEN_Pos)             /*!< PWM_T::BRKCTL0_1: BRKP1EEN Mask           */
S
S#define PWM_BRKCTL0_1_SYSEBEN_Pos        (7)                                               /*!< PWM_T::BRKCTL0_1: SYSEBEN Position        */
S#define PWM_BRKCTL0_1_SYSEBEN_Msk        (0x1ul << PWM_BRKCTL0_1_SYSEBEN_Pos)              /*!< PWM_T::BRKCTL0_1: SYSEBEN Mask            */
S
S#define PWM_BRKCTL0_1_CPO0LBEN_Pos       (8)                                               /*!< PWM_T::BRKCTL0_1: CPO0LBEN Position       */
S#define PWM_BRKCTL0_1_CPO0LBEN_Msk       (0x1ul << PWM_BRKCTL0_1_CPO0LBEN_Pos)             /*!< PWM_T::BRKCTL0_1: CPO0LBEN Mask           */
S
S#define PWM_BRKCTL0_1_CPO1LBEN_Pos       (9)                                               /*!< PWM_T::BRKCTL0_1: CPO1LBEN Position       */
S#define PWM_BRKCTL0_1_CPO1LBEN_Msk       (0x1ul << PWM_BRKCTL0_1_CPO1LBEN_Pos)             /*!< PWM_T::BRKCTL0_1: CPO1LBEN Mask           */
S
S#define PWM_BRKCTL0_1_BRKP0LEN_Pos       (12)                                              /*!< PWM_T::BRKCTL0_1: BRKP0LEN Position       */
S#define PWM_BRKCTL0_1_BRKP0LEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP0LEN_Pos)             /*!< PWM_T::BRKCTL0_1: BRKP0LEN Mask           */
S
S#define PWM_BRKCTL0_1_BRKP1LEN_Pos       (13)                                              /*!< PWM_T::BRKCTL0_1: BRKP1LEN Position       */
S#define PWM_BRKCTL0_1_BRKP1LEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP1LEN_Pos)             /*!< PWM_T::BRKCTL0_1: BRKP1LEN Mask           */
S
S#define PWM_BRKCTL0_1_SYSLBEN_Pos        (15)                                              /*!< PWM_T::BRKCTL0_1: SYSLBEN Position        */
S#define PWM_BRKCTL0_1_SYSLBEN_Msk        (0x1ul << PWM_BRKCTL0_1_SYSLBEN_Pos)              /*!< PWM_T::BRKCTL0_1: SYSLBEN Mask            */
S
S#define PWM_BRKCTL0_1_BRKAEVEN_Pos       (16)                                              /*!< PWM_T::BRKCTL0_1: BRKAEVEN Position       */
S#define PWM_BRKCTL0_1_BRKAEVEN_Msk       (0x3ul << PWM_BRKCTL0_1_BRKAEVEN_Pos)             /*!< PWM_T::BRKCTL0_1: BRKAEVEN Mask           */
S
S#define PWM_BRKCTL0_1_BRKAODD_Pos        (18)                                              /*!< PWM_T::BRKCTL0_1: BRKAODD Position        */
S#define PWM_BRKCTL0_1_BRKAODD_Msk        (0x3ul << PWM_BRKCTL0_1_BRKAODD_Pos)              /*!< PWM_T::BRKCTL0_1: BRKAODD Mask            */
S
S#define PWM_BRKCTL2_3_CPO0EBEN_Pos       (0)                                               /*!< PWM_T::BRKCTL2_3: CPO0EBEN Position       */
S#define PWM_BRKCTL2_3_CPO0EBEN_Msk       (0x1ul << PWM_BRKCTL2_3_CPO0EBEN_Pos)             /*!< PWM_T::BRKCTL2_3: CPO0EBEN Mask           */
S
S#define PWM_BRKCTL2_3_CPO1EBEN_Pos       (1)                                               /*!< PWM_T::BRKCTL2_3: CPO1EBEN Position       */
S#define PWM_BRKCTL2_3_CPO1EBEN_Msk       (0x1ul << PWM_BRKCTL2_3_CPO1EBEN_Pos)             /*!< PWM_T::BRKCTL2_3: CPO1EBEN Mask           */
S
S#define PWM_BRKCTL2_3_BRKP0EEN_Pos       (4)                                               /*!< PWM_T::BRKCTL2_3: BRKP0EEN Position       */
S#define PWM_BRKCTL2_3_BRKP0EEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP0EEN_Pos)             /*!< PWM_T::BRKCTL2_3: BRKP0EEN Mask           */
S
S#define PWM_BRKCTL2_3_BRKP1EEN_Pos       (5)                                               /*!< PWM_T::BRKCTL2_3: BRKP1EEN Position       */
S#define PWM_BRKCTL2_3_BRKP1EEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP1EEN_Pos)             /*!< PWM_T::BRKCTL2_3: BRKP1EEN Mask           */
S
S#define PWM_BRKCTL2_3_SYSEBEN_Pos        (7)                                               /*!< PWM_T::BRKCTL2_3: SYSEBEN Position        */
S#define PWM_BRKCTL2_3_SYSEBEN_Msk        (0x1ul << PWM_BRKCTL2_3_SYSEBEN_Pos)              /*!< PWM_T::BRKCTL2_3: SYSEBEN Mask            */
S
S#define PWM_BRKCTL2_3_CPO0LBEN_Pos       (8)                                               /*!< PWM_T::BRKCTL2_3: CPO0LBEN Position       */
S#define PWM_BRKCTL2_3_CPO0LBEN_Msk       (0x1ul << PWM_BRKCTL2_3_CPO0LBEN_Pos)             /*!< PWM_T::BRKCTL2_3: CPO0LBEN Mask           */
S
S#define PWM_BRKCTL2_3_CPO1LBEN_Pos       (9)                                               /*!< PWM_T::BRKCTL2_3: CPO1LBEN Position       */
S#define PWM_BRKCTL2_3_CPO1LBEN_Msk       (0x1ul << PWM_BRKCTL2_3_CPO1LBEN_Pos)             /*!< PWM_T::BRKCTL2_3: CPO1LBEN Mask           */
S
S#define PWM_BRKCTL2_3_BRKP0LEN_Pos       (12)                                              /*!< PWM_T::BRKCTL2_3: BRKP0LEN Position       */
S#define PWM_BRKCTL2_3_BRKP0LEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP0LEN_Pos)             /*!< PWM_T::BRKCTL2_3: BRKP0LEN Mask           */
S
S#define PWM_BRKCTL2_3_BRKP1LEN_Pos       (13)                                              /*!< PWM_T::BRKCTL2_3: BRKP1LEN Position       */
S#define PWM_BRKCTL2_3_BRKP1LEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP1LEN_Pos)             /*!< PWM_T::BRKCTL2_3: BRKP1LEN Mask           */
S
S#define PWM_BRKCTL2_3_SYSLBEN_Pos        (15)                                              /*!< PWM_T::BRKCTL2_3: SYSLBEN Position        */
S#define PWM_BRKCTL2_3_SYSLBEN_Msk        (0x1ul << PWM_BRKCTL2_3_SYSLBEN_Pos)              /*!< PWM_T::BRKCTL2_3: SYSLBEN Mask            */
S
S#define PWM_BRKCTL2_3_BRKAEVEN_Pos       (16)                                              /*!< PWM_T::BRKCTL2_3: BRKAEVEN Position       */
S#define PWM_BRKCTL2_3_BRKAEVEN_Msk       (0x3ul << PWM_BRKCTL2_3_BRKAEVEN_Pos)             /*!< PWM_T::BRKCTL2_3: BRKAEVEN Mask           */
S
S#define PWM_BRKCTL2_3_BRKAODD_Pos        (18)                                              /*!< PWM_T::BRKCTL2_3: BRKAODD Position        */
S#define PWM_BRKCTL2_3_BRKAODD_Msk        (0x3ul << PWM_BRKCTL2_3_BRKAODD_Pos)              /*!< PWM_T::BRKCTL2_3: BRKAODD Mask            */
S
S#define PWM_BRKCTL4_5_CPO0EBEN_Pos       (0)                                               /*!< PWM_T::BRKCTL4_5: CPO0EBEN Position       */
S#define PWM_BRKCTL4_5_CPO0EBEN_Msk       (0x1ul << PWM_BRKCTL4_5_CPO0EBEN_Pos)             /*!< PWM_T::BRKCTL4_5: CPO0EBEN Mask           */
S
S#define PWM_BRKCTL4_5_CPO1EBEN_Pos       (1)                                               /*!< PWM_T::BRKCTL4_5: CPO1EBEN Position       */
S#define PWM_BRKCTL4_5_CPO1EBEN_Msk       (0x1ul << PWM_BRKCTL4_5_CPO1EBEN_Pos)             /*!< PWM_T::BRKCTL4_5: CPO1EBEN Mask           */
S
S#define PWM_BRKCTL4_5_BRKP0EEN_Pos       (4)                                               /*!< PWM_T::BRKCTL4_5: BRKP0EEN Position       */
S#define PWM_BRKCTL4_5_BRKP0EEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP0EEN_Pos)             /*!< PWM_T::BRKCTL4_5: BRKP0EEN Mask           */
S
S#define PWM_BRKCTL4_5_BRKP1EEN_Pos       (5)                                               /*!< PWM_T::BRKCTL4_5: BRKP1EEN Position       */
S#define PWM_BRKCTL4_5_BRKP1EEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP1EEN_Pos)             /*!< PWM_T::BRKCTL4_5: BRKP1EEN Mask           */
S
S#define PWM_BRKCTL4_5_SYSEBEN_Pos        (7)                                               /*!< PWM_T::BRKCTL4_5: SYSEBEN Position        */
S#define PWM_BRKCTL4_5_SYSEBEN_Msk        (0x1ul << PWM_BRKCTL4_5_SYSEBEN_Pos)              /*!< PWM_T::BRKCTL4_5: SYSEBEN Mask            */
S
S#define PWM_BRKCTL4_5_CPO0LBEN_Pos       (8)                                               /*!< PWM_T::BRKCTL4_5: CPO0LBEN Position       */
S#define PWM_BRKCTL4_5_CPO0LBEN_Msk       (0x1ul << PWM_BRKCTL4_5_CPO0LBEN_Pos)             /*!< PWM_T::BRKCTL4_5: CPO0LBEN Mask           */
S
S#define PWM_BRKCTL4_5_CPO1LBEN_Pos       (9)                                               /*!< PWM_T::BRKCTL4_5: CPO1LBEN Position       */
S#define PWM_BRKCTL4_5_CPO1LBEN_Msk       (0x1ul << PWM_BRKCTL4_5_CPO1LBEN_Pos)             /*!< PWM_T::BRKCTL4_5: CPO1LBEN Mask           */
S
S#define PWM_BRKCTL4_5_BRKP0LEN_Pos       (12)                                              /*!< PWM_T::BRKCTL4_5: BRKP0LEN Position       */
S#define PWM_BRKCTL4_5_BRKP0LEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP0LEN_Pos)             /*!< PWM_T::BRKCTL4_5: BRKP0LEN Mask           */
S
S#define PWM_BRKCTL4_5_BRKP1LEN_Pos       (13)                                              /*!< PWM_T::BRKCTL4_5: BRKP1LEN Position       */
S#define PWM_BRKCTL4_5_BRKP1LEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP1LEN_Pos)             /*!< PWM_T::BRKCTL4_5: BRKP1LEN Mask           */
S
S#define PWM_BRKCTL4_5_SYSLBEN_Pos        (15)                                              /*!< PWM_T::BRKCTL4_5: SYSLBEN Position        */
S#define PWM_BRKCTL4_5_SYSLBEN_Msk        (0x1ul << PWM_BRKCTL4_5_SYSLBEN_Pos)              /*!< PWM_T::BRKCTL4_5: SYSLBEN Mask            */
S
S#define PWM_BRKCTL4_5_BRKAEVEN_Pos       (16)                                              /*!< PWM_T::BRKCTL4_5: BRKAEVEN Position       */
S#define PWM_BRKCTL4_5_BRKAEVEN_Msk       (0x3ul << PWM_BRKCTL4_5_BRKAEVEN_Pos)             /*!< PWM_T::BRKCTL4_5: BRKAEVEN Mask           */
S
S#define PWM_BRKCTL4_5_BRKAODD_Pos        (18)                                              /*!< PWM_T::BRKCTL4_5: BRKAODD Position        */
S#define PWM_BRKCTL4_5_BRKAODD_Msk        (0x3ul << PWM_BRKCTL4_5_BRKAODD_Pos)              /*!< PWM_T::BRKCTL4_5: BRKAODD Mask            */
S
S#define PWM_POLCTL_PINVn_Pos             (0)                                               /*!< PWM_T::POLCTL: PINVn Position             */
S#define PWM_POLCTL_PINVn_Msk             (0x3ful << PWM_POLCTL_PINVn_Pos)                  /*!< PWM_T::POLCTL: PINVn Mask                 */
S
S#define PWM_POLCTL_PINV0_Pos             (0)                                               /*!< PWM_T::POLCTL: PINV0 Position             */
S#define PWM_POLCTL_PINV0_Msk             (0x1ul << PWM_POLCTL_PINV0_Pos)                   /*!< PWM_T::POLCTL: PINV0 Mask                 */
S
S#define PWM_POLCTL_PINV1_Pos             (1)                                               /*!< PWM_T::POLCTL: PINV1 Position             */
S#define PWM_POLCTL_PINV1_Msk             (0x1ul << PWM_POLCTL_PINV1_Pos)                   /*!< PWM_T::POLCTL: PINV1 Mask                 */
S
S#define PWM_POLCTL_PINV2_Pos             (2)                                               /*!< PWM_T::POLCTL: PINV2 Position             */
S#define PWM_POLCTL_PINV2_Msk             (0x1ul << PWM_POLCTL_PINV2_Pos)                   /*!< PWM_T::POLCTL: PINV2 Mask                 */
S
S#define PWM_POLCTL_PINV3_Pos             (3)                                               /*!< PWM_T::POLCTL: PINV3 Position             */
S#define PWM_POLCTL_PINV3_Msk             (0x1ul << PWM_POLCTL_PINV3_Pos)                   /*!< PWM_T::POLCTL: PINV3 Mask                 */
S
S#define PWM_POLCTL_PINV4_Pos             (4)                                               /*!< PWM_T::POLCTL: PINV4 Position             */
S#define PWM_POLCTL_PINV4_Msk             (0x1ul << PWM_POLCTL_PINV4_Pos)                   /*!< PWM_T::POLCTL: PINV4 Mask                 */
S
S#define PWM_POLCTL_PINV5_Pos             (5)                                               /*!< PWM_T::POLCTL: PINV5 Position             */
S#define PWM_POLCTL_PINV5_Msk             (0x1ul << PWM_POLCTL_PINV5_Pos)                   /*!< PWM_T::POLCTL: PINV5 Mask                 */
S
S#define PWM_POEN_POENn_Pos               (0)                                               /*!< PWM_T::POEN: POENn Position               */
S#define PWM_POEN_POENn_Msk               (0x3ful << PWM_POEN_POENn_Pos)                    /*!< PWM_T::POEN: POENn Mask                   */
S
S#define PWM_POEN_POEN0_Pos               (0)                                               /*!< PWM_T::POEN: POEN0 Position               */
S#define PWM_POEN_POEN0_Msk               (0x1ul << PWM_POEN_POEN0_Pos)                     /*!< PWM_T::POEN: POEN0 Mask                   */
S
S#define PWM_POEN_POEN1_Pos               (1)                                               /*!< PWM_T::POEN: POEN1 Position               */
S#define PWM_POEN_POEN1_Msk               (0x1ul << PWM_POEN_POEN1_Pos)                     /*!< PWM_T::POEN: POEN1 Mask                   */
S
S#define PWM_POEN_POEN2_Pos               (2)                                               /*!< PWM_T::POEN: POEN2 Position               */
S#define PWM_POEN_POEN2_Msk               (0x1ul << PWM_POEN_POEN2_Pos)                     /*!< PWM_T::POEN: POEN2 Mask                   */
S
S#define PWM_POEN_POEN3_Pos               (3)                                               /*!< PWM_T::POEN: POEN3 Position               */
S#define PWM_POEN_POEN3_Msk               (0x1ul << PWM_POEN_POEN3_Pos)                     /*!< PWM_T::POEN: POEN3 Mask                   */
S
S#define PWM_POEN_POEN4_Pos               (4)                                               /*!< PWM_T::POEN: POEN4 Position               */
S#define PWM_POEN_POEN4_Msk               (0x1ul << PWM_POEN_POEN4_Pos)                     /*!< PWM_T::POEN: POEN4 Mask                   */
S
S#define PWM_POEN_POEN5_Pos               (5)                                               /*!< PWM_T::POEN: POEN5 Position               */
S#define PWM_POEN_POEN5_Msk               (0x1ul << PWM_POEN_POEN5_Pos)                     /*!< PWM_T::POEN: POEN5 Mask                   */
S
S#define PWM_SWBRK_BRKETRGn_Pos           (0)                                               /*!< PWM_T::SWBRK: BRKETRGn Position           */
S#define PWM_SWBRK_BRKETRGn_Msk           (0x7ul << PWM_SWBRK_BRKETRGn_Pos)                 /*!< PWM_T::SWBRK: BRKETRGn Mask               */
S
S#define PWM_SWBRK_BRKETRG0_Pos           (0)                                               /*!< PWM_T::SWBRK: BRKETRG0 Position           */
S#define PWM_SWBRK_BRKETRG0_Msk           (0x1ul << PWM_SWBRK_BRKETRG0_Pos)                 /*!< PWM_T::SWBRK: BRKETRG0 Mask               */
S
S#define PWM_SWBRK_BRKETRG2_Pos           (1)                                               /*!< PWM_T::SWBRK: BRKETRG2 Position           */
S#define PWM_SWBRK_BRKETRG2_Msk           (0x1ul << PWM_SWBRK_BRKETRG2_Pos)                 /*!< PWM_T::SWBRK: BRKETRG2 Mask               */
S
S#define PWM_SWBRK_BRKETRG4_Pos           (2)                                               /*!< PWM_T::SWBRK: BRKETRG4 Position           */
S#define PWM_SWBRK_BRKETRG4_Msk           (0x1ul << PWM_SWBRK_BRKETRG4_Pos)                 /*!< PWM_T::SWBRK: BRKETRG4 Mask               */
S
S#define PWM_SWBRK_BRKLTRGn_Pos           (8)                                               /*!< PWM_T::SWBRK: BRKLTRGn Position           */
S#define PWM_SWBRK_BRKLTRGn_Msk           (0x7ul << PWM_SWBRK_BRKLTRGn_Pos)                 /*!< PWM_T::SWBRK: BRKLTRGn Mask               */
S
S#define PWM_SWBRK_BRKLTRG0_Pos           (8)                                               /*!< PWM_T::SWBRK: BRKLTRG0 Position           */
S#define PWM_SWBRK_BRKLTRG0_Msk           (0x1ul << PWM_SWBRK_BRKLTRG0_Pos)                 /*!< PWM_T::SWBRK: BRKLTRG0 Mask               */
S
S#define PWM_SWBRK_BRKLTRG2_Pos           (9)                                               /*!< PWM_T::SWBRK: BRKLTRG2 Position           */
S#define PWM_SWBRK_BRKLTRG2_Msk           (0x1ul << PWM_SWBRK_BRKLTRG2_Pos)                 /*!< PWM_T::SWBRK: BRKLTRG2 Mask               */
S
S#define PWM_SWBRK_BRKLTRG4_Pos           (10)                                              /*!< PWM_T::SWBRK: BRKLTRG4 Position           */
S#define PWM_SWBRK_BRKLTRG4_Msk           (0x1ul << PWM_SWBRK_BRKLTRG4_Pos)                 /*!< PWM_T::SWBRK: BRKLTRG4 Mask               */
S
S#define PWM_INTEN0_ZIENn_Pos             (0)                                               /*!< PWM_T::INTEN0: ZIENn Position             */
S#define PWM_INTEN0_ZIENn_Msk             (0x3ful << PWM_INTEN0_ZIENn_Pos)                  /*!< PWM_T::INTEN0: ZIENn Mask                 */
S
S#define PWM_INTEN0_ZIEN0_Pos             (0)                                               /*!< PWM_T::INTEN0: ZIEN0 Position             */
S#define PWM_INTEN0_ZIEN0_Msk             (0x1ul << PWM_INTEN0_ZIEN0_Pos)                   /*!< PWM_T::INTEN0: ZIEN0 Mask                 */
S
S#define PWM_INTEN0_ZIEN1_Pos             (1)                                               /*!< PWM_T::INTEN0: ZIEN1 Position             */
S#define PWM_INTEN0_ZIEN1_Msk             (0x1ul << PWM_INTEN0_ZIEN1_Pos)                   /*!< PWM_T::INTEN0: ZIEN1 Mask                 */
S
S#define PWM_INTEN0_ZIEN2_Pos             (2)                                               /*!< PWM_T::INTEN0: ZIEN2 Position             */
S#define PWM_INTEN0_ZIEN2_Msk             (0x1ul << PWM_INTEN0_ZIEN2_Pos)                   /*!< PWM_T::INTEN0: ZIEN2 Mask                 */
S
S#define PWM_INTEN0_ZIEN3_Pos             (3)                                               /*!< PWM_T::INTEN0: ZIEN3 Position             */
S#define PWM_INTEN0_ZIEN3_Msk             (0x1ul << PWM_INTEN0_ZIEN3_Pos)                   /*!< PWM_T::INTEN0: ZIEN3 Mask                 */
S
S#define PWM_INTEN0_ZIEN4_Pos             (4)                                               /*!< PWM_T::INTEN0: ZIEN4 Position             */
S#define PWM_INTEN0_ZIEN4_Msk             (0x1ul << PWM_INTEN0_ZIEN4_Pos)                   /*!< PWM_T::INTEN0: ZIEN4 Mask                 */
S
S#define PWM_INTEN0_ZIEN5_Pos             (5)                                               /*!< PWM_T::INTEN0: ZIEN5 Position             */
S#define PWM_INTEN0_ZIEN5_Msk             (0x1ul << PWM_INTEN0_ZIEN5_Pos)                   /*!< PWM_T::INTEN0: ZIEN5 Mask                 */
S
S#define PWM_INTEN0_IFAIEN0_1_Pos         (7)                                               /*!< PWM_T::INTEN0: IFAIEN0_1 Position         */
S#define PWM_INTEN0_IFAIEN0_1_Msk         (0x1ul << PWM_INTEN0_IFAIEN0_1_Pos)               /*!< PWM_T::INTEN0: IFAIEN0_1 Mask             */
S
S#define PWM_INTEN0_PIENn_Pos             (8)                                               /*!< PWM_T::INTEN0: PIENn Position             */
S#define PWM_INTEN0_PIENn_Msk             (0x3ful << PWM_INTEN0_PIENn_Pos)                  /*!< PWM_T::INTEN0: PIENn Mask                 */
S
S#define PWM_INTEN0_PIEN0_Pos             (8)                                               /*!< PWM_T::INTEN0: PIEN0 Position             */
S#define PWM_INTEN0_PIEN0_Msk             (0x1ul << PWM_INTEN0_PIEN0_Pos)                   /*!< PWM_T::INTEN0: PIEN0 Mask                 */
S
S#define PWM_INTEN0_PIEN1_Pos             (9)                                               /*!< PWM_T::INTEN0: PIEN1 Position             */
S#define PWM_INTEN0_PIEN1_Msk             (0x1ul << PWM_INTEN0_PIEN1_Pos)                   /*!< PWM_T::INTEN0: PIEN1 Mask                 */
S
S#define PWM_INTEN0_PIEN2_Pos             (10)                                              /*!< PWM_T::INTEN0: PIEN2 Position             */
S#define PWM_INTEN0_PIEN2_Msk             (0x1ul << PWM_INTEN0_PIEN2_Pos)                   /*!< PWM_T::INTEN0: PIEN2 Mask                 */
S
S#define PWM_INTEN0_PIEN3_Pos             (11)                                              /*!< PWM_T::INTEN0: PIEN3 Position             */
S#define PWM_INTEN0_PIEN3_Msk             (0x1ul << PWM_INTEN0_PIEN3_Pos)                   /*!< PWM_T::INTEN0: PIEN3 Mask                 */
S
S#define PWM_INTEN0_PIEN4_Pos             (12)                                              /*!< PWM_T::INTEN0: PIEN4 Position             */
S#define PWM_INTEN0_PIEN4_Msk             (0x1ul << PWM_INTEN0_PIEN4_Pos)                   /*!< PWM_T::INTEN0: PIEN4 Mask                 */
S
S#define PWM_INTEN0_PIEN5_Pos             (13)                                              /*!< PWM_T::INTEN0: PIEN5 Position             */
S#define PWM_INTEN0_PIEN5_Msk             (0x1ul << PWM_INTEN0_PIEN5_Pos)                   /*!< PWM_T::INTEN0: PIEN5 Mask                 */
S
S#define PWM_INTEN0_IFAIEN2_3_Pos         (15)                                              /*!< PWM_T::INTEN0: IFAIEN2_3 Position         */
S#define PWM_INTEN0_IFAIEN2_3_Msk         (0x1ul << PWM_INTEN0_IFAIEN2_3_Pos)               /*!< PWM_T::INTEN0: IFAIEN2_3 Mask             */
S
S#define PWM_INTEN0_CMPUIENn_Pos          (16)                                              /*!< PWM_T::INTEN0: CMPUIENn Position          */
S#define PWM_INTEN0_CMPUIENn_Msk          (0x3ful << PWM_INTEN0_CMPUIENn_Pos)               /*!< PWM_T::INTEN0: CMPUIENn Mask              */
S
S#define PWM_INTEN0_CMPUIEN0_Pos          (16)                                              /*!< PWM_T::INTEN0: CMPUIEN0 Position          */
S#define PWM_INTEN0_CMPUIEN0_Msk          (0x1ul << PWM_INTEN0_CMPUIEN0_Pos)                /*!< PWM_T::INTEN0: CMPUIEN0 Mask              */
S
S#define PWM_INTEN0_CMPUIEN1_Pos          (17)                                              /*!< PWM_T::INTEN0: CMPUIEN1 Position          */
S#define PWM_INTEN0_CMPUIEN1_Msk          (0x1ul << PWM_INTEN0_CMPUIEN1_Pos)                /*!< PWM_T::INTEN0: CMPUIEN1 Mask              */
S
S#define PWM_INTEN0_CMPUIEN2_Pos          (18)                                              /*!< PWM_T::INTEN0: CMPUIEN2 Position          */
S#define PWM_INTEN0_CMPUIEN2_Msk          (0x1ul << PWM_INTEN0_CMPUIEN2_Pos)                /*!< PWM_T::INTEN0: CMPUIEN2 Mask              */
S
S#define PWM_INTEN0_CMPUIEN3_Pos          (19)                                              /*!< PWM_T::INTEN0: CMPUIEN3 Position          */
S#define PWM_INTEN0_CMPUIEN3_Msk          (0x1ul << PWM_INTEN0_CMPUIEN3_Pos)                /*!< PWM_T::INTEN0: CMPUIEN3 Mask              */
S
S#define PWM_INTEN0_CMPUIEN4_Pos          (20)                                              /*!< PWM_T::INTEN0: CMPUIEN4 Position          */
S#define PWM_INTEN0_CMPUIEN4_Msk          (0x1ul << PWM_INTEN0_CMPUIEN4_Pos)                /*!< PWM_T::INTEN0: CMPUIEN4 Mask              */
S
S#define PWM_INTEN0_CMPUIEN5_Pos          (21)                                              /*!< PWM_T::INTEN0: CMPUIEN5 Position          */
S#define PWM_INTEN0_CMPUIEN5_Msk          (0x1ul << PWM_INTEN0_CMPUIEN5_Pos)                /*!< PWM_T::INTEN0: CMPUIEN5 Mask              */
S
S#define PWM_INTEN0_IFAIEN4_5_Pos         (23)                                              /*!< PWM_T::INTEN0: IFAIEN4_5 Position         */
S#define PWM_INTEN0_IFAIEN4_5_Msk         (0x1ul << PWM_INTEN0_IFAIEN4_5_Pos)               /*!< PWM_T::INTEN0: IFAIEN4_5 Mask             */
S
S#define PWM_INTEN0_CMPDIENn_Pos          (24)                                              /*!< PWM_T::INTEN0: CMPDIENn Position          */
S#define PWM_INTEN0_CMPDIENn_Msk          (0x3ful << PWM_INTEN0_CMPDIENn_Pos)               /*!< PWM_T::INTEN0: CMPDIENn Mask              */
S
S#define PWM_INTEN0_CMPDIEN0_Pos          (24)                                              /*!< PWM_T::INTEN0: CMPDIEN0 Position          */
S#define PWM_INTEN0_CMPDIEN0_Msk          (0x1ul << PWM_INTEN0_CMPDIEN0_Pos)                /*!< PWM_T::INTEN0: CMPDIEN0 Mask              */
S
S#define PWM_INTEN0_CMPDIEN1_Pos          (25)                                              /*!< PWM_T::INTEN0: CMPDIEN1 Position          */
S#define PWM_INTEN0_CMPDIEN1_Msk          (0x1ul << PWM_INTEN0_CMPDIEN1_Pos)                /*!< PWM_T::INTEN0: CMPDIEN1 Mask              */
S
S#define PWM_INTEN0_CMPDIEN2_Pos          (26)                                              /*!< PWM_T::INTEN0: CMPDIEN2 Position          */
S#define PWM_INTEN0_CMPDIEN2_Msk          (0x1ul << PWM_INTEN0_CMPDIEN2_Pos)                /*!< PWM_T::INTEN0: CMPDIEN2 Mask              */
S
S#define PWM_INTEN0_CMPDIEN3_Pos          (27)                                              /*!< PWM_T::INTEN0: CMPDIEN3 Position          */
S#define PWM_INTEN0_CMPDIEN3_Msk          (0x1ul << PWM_INTEN0_CMPDIEN3_Pos)                /*!< PWM_T::INTEN0: CMPDIEN3 Mask              */
S
S#define PWM_INTEN0_CMPDIEN4_Pos          (28)                                              /*!< PWM_T::INTEN0: CMPDIEN4 Position          */
S#define PWM_INTEN0_CMPDIEN4_Msk          (0x1ul << PWM_INTEN0_CMPDIEN4_Pos)                /*!< PWM_T::INTEN0: CMPDIEN4 Mask              */
S
S#define PWM_INTEN0_CMPDIEN5_Pos          (29)                                              /*!< PWM_T::INTEN0: CMPDIEN5 Position          */
S#define PWM_INTEN0_CMPDIEN5_Msk          (0x1ul << PWM_INTEN0_CMPDIEN5_Pos)                /*!< PWM_T::INTEN0: CMPDIEN5 Mask              */
S
S#define PWM_INTEN1_BRKEIEN0_1_Pos        (0)                                               /*!< PWM_T::INTEN1: BRKEIEN0_1 Position        */
S#define PWM_INTEN1_BRKEIEN0_1_Msk        (0x1ul << PWM_INTEN1_BRKEIEN0_1_Pos)              /*!< PWM_T::INTEN1: BRKEIEN0_1 Mask            */
S
S#define PWM_INTEN1_BRKEIEN2_3_Pos        (1)                                               /*!< PWM_T::INTEN1: BRKEIEN2_3 Position        */
S#define PWM_INTEN1_BRKEIEN2_3_Msk        (0x1ul << PWM_INTEN1_BRKEIEN2_3_Pos)              /*!< PWM_T::INTEN1: BRKEIEN2_3 Mask            */
S
S#define PWM_INTEN1_BRKEIEN4_5_Pos        (2)                                               /*!< PWM_T::INTEN1: BRKEIEN4_5 Position        */
S#define PWM_INTEN1_BRKEIEN4_5_Msk        (0x1ul << PWM_INTEN1_BRKEIEN4_5_Pos)              /*!< PWM_T::INTEN1: BRKEIEN4_5 Mask            */
S
S#define PWM_INTEN1_BRKLIEN0_1_Pos        (8)                                               /*!< PWM_T::INTEN1: BRKLIEN0_1 Position        */
S#define PWM_INTEN1_BRKLIEN0_1_Msk        (0x1ul << PWM_INTEN1_BRKLIEN0_1_Pos)              /*!< PWM_T::INTEN1: BRKLIEN0_1 Mask            */
S
S#define PWM_INTEN1_BRKLIEN2_3_Pos        (9)                                               /*!< PWM_T::INTEN1: BRKLIEN2_3 Position        */
S#define PWM_INTEN1_BRKLIEN2_3_Msk        (0x1ul << PWM_INTEN1_BRKLIEN2_3_Pos)              /*!< PWM_T::INTEN1: BRKLIEN2_3 Mask            */
S
S#define PWM_INTEN1_BRKLIEN4_5_Pos        (10)                                              /*!< PWM_T::INTEN1: BRKLIEN4_5 Position        */
S#define PWM_INTEN1_BRKLIEN4_5_Msk        (0x1ul << PWM_INTEN1_BRKLIEN4_5_Pos)              /*!< PWM_T::INTEN1: BRKLIEN4_5 Mask            */
S
S#define PWM_INTSTS0_ZIFn_Pos             (0)                                               /*!< PWM_T::INTSTS0: ZIFn Position             */
S#define PWM_INTSTS0_ZIFn_Msk             (0x3ful << PWM_INTSTS0_ZIFn_Pos)                  /*!< PWM_T::INTSTS0: ZIFn Mask                 */
S
S#define PWM_INTSTS0_ZIF0_Pos             (0)                                               /*!< PWM_T::INTSTS0: ZIF0 Position             */
S#define PWM_INTSTS0_ZIF0_Msk             (0x1ul << PWM_INTSTS0_ZIF0_Pos)                   /*!< PWM_T::INTSTS0: ZIF0 Mask                 */
S
S#define PWM_INTSTS0_ZIF1_Pos             (1)                                               /*!< PWM_T::INTSTS0: ZIF1 Position             */
S#define PWM_INTSTS0_ZIF1_Msk             (0x1ul << PWM_INTSTS0_ZIF1_Pos)                   /*!< PWM_T::INTSTS0: ZIF1 Mask                 */
S
S#define PWM_INTSTS0_ZIF2_Pos             (2)                                               /*!< PWM_T::INTSTS0: ZIF2 Position             */
S#define PWM_INTSTS0_ZIF2_Msk             (0x1ul << PWM_INTSTS0_ZIF2_Pos)                   /*!< PWM_T::INTSTS0: ZIF2 Mask                 */
S
S#define PWM_INTSTS0_ZIF3_Pos             (3)                                               /*!< PWM_T::INTSTS0: ZIF3 Position             */
S#define PWM_INTSTS0_ZIF3_Msk             (0x1ul << PWM_INTSTS0_ZIF3_Pos)                   /*!< PWM_T::INTSTS0: ZIF3 Mask                 */
S
S#define PWM_INTSTS0_ZIF4_Pos             (4)                                               /*!< PWM_T::INTSTS0: ZIF4 Position             */
S#define PWM_INTSTS0_ZIF4_Msk             (0x1ul << PWM_INTSTS0_ZIF4_Pos)                   /*!< PWM_T::INTSTS0: ZIF4 Mask                 */
S
S#define PWM_INTSTS0_ZIF5_Pos             (5)                                               /*!< PWM_T::INTSTS0: ZIF5 Position             */
S#define PWM_INTSTS0_ZIF5_Msk             (0x1ul << PWM_INTSTS0_ZIF5_Pos)                   /*!< PWM_T::INTSTS0: ZIF5 Mask                 */
S
S#define PWM_INTSTS0_IFAIF0_1_Pos         (7)                                               /*!< PWM_T::INTSTS0: IFAIF0_1 Position         */
S#define PWM_INTSTS0_IFAIF0_1_Msk         (0x1ul << PWM_INTSTS0_IFAIF0_1_Pos)               /*!< PWM_T::INTSTS0: IFAIF0_1 Mask             */
S
S#define PWM_INTSTS0_PIFn_Pos             (8)                                               /*!< PWM_T::INTSTS0: PIFn Position             */
S#define PWM_INTSTS0_PIFn_Msk             (0x3ful << PWM_INTSTS0_PIFn_Pos)                  /*!< PWM_T::INTSTS0: PIFn Mask                 */
S
S#define PWM_INTSTS0_PIF0_Pos             (8)                                               /*!< PWM_T::INTSTS0: PIF0 Position             */
S#define PWM_INTSTS0_PIF0_Msk             (0x1ul << PWM_INTSTS0_PIF0_Pos)                   /*!< PWM_T::INTSTS0: PIF0 Mask                 */
S
S#define PWM_INTSTS0_PIF1_Pos             (9)                                               /*!< PWM_T::INTSTS0: PIF1 Position             */
S#define PWM_INTSTS0_PIF1_Msk             (0x1ul << PWM_INTSTS0_PIF1_Pos)                   /*!< PWM_T::INTSTS0: PIF1 Mask                 */
S
S#define PWM_INTSTS0_PIF2_Pos             (10)                                              /*!< PWM_T::INTSTS0: PIF2 Position             */
S#define PWM_INTSTS0_PIF2_Msk             (0x1ul << PWM_INTSTS0_PIF2_Pos)                   /*!< PWM_T::INTSTS0: PIF2 Mask                 */
S
S#define PWM_INTSTS0_PIF3_Pos             (11)                                              /*!< PWM_T::INTSTS0: PIF3 Position             */
S#define PWM_INTSTS0_PIF3_Msk             (0x1ul << PWM_INTSTS0_PIF3_Pos)                   /*!< PWM_T::INTSTS0: PIF3 Mask                 */
S
S#define PWM_INTSTS0_PIF4_Pos             (12)                                              /*!< PWM_T::INTSTS0: PIF4 Position             */
S#define PWM_INTSTS0_PIF4_Msk             (0x1ul << PWM_INTSTS0_PIF4_Pos)                   /*!< PWM_T::INTSTS0: PIF4 Mask                 */
S
S#define PWM_INTSTS0_PIF5_Pos             (13)                                              /*!< PWM_T::INTSTS0: PIF5 Position             */
S#define PWM_INTSTS0_PIF5_Msk             (0x1ul << PWM_INTSTS0_PIF5_Pos)                   /*!< PWM_T::INTSTS0: PIF5 Mask                 */
S
S#define PWM_INTSTS0_IFAIF2_3_Pos         (15)                                              /*!< PWM_T::INTSTS0: IFAIF2_3 Position         */
S#define PWM_INTSTS0_IFAIF2_3_Msk         (0x1ul << PWM_INTSTS0_IFAIF2_3_Pos)               /*!< PWM_T::INTSTS0: IFAIF2_3 Mask             */
S
S#define PWM_INTSTS0_CMPUIFn_Pos          (16)                                              /*!< PWM_T::INTSTS0: CMPUIFn Position          */
S#define PWM_INTSTS0_CMPUIFn_Msk          (0x3ful << PWM_INTSTS0_CMPUIFn_Pos)               /*!< PWM_T::INTSTS0: CMPUIFn Mask              */
S
S#define PWM_INTSTS0_CMPUIF0_Pos          (16)                                              /*!< PWM_T::INTSTS0: CMPUIF0 Position          */
S#define PWM_INTSTS0_CMPUIF0_Msk          (0x1ul << PWM_INTSTS0_CMPUIF0_Pos)                /*!< PWM_T::INTSTS0: CMPUIF0 Mask              */
S
S#define PWM_INTSTS0_CMPUIF1_Pos          (17)                                              /*!< PWM_T::INTSTS0: CMPUIF1 Position          */
S#define PWM_INTSTS0_CMPUIF1_Msk          (0x1ul << PWM_INTSTS0_CMPUIF1_Pos)                /*!< PWM_T::INTSTS0: CMPUIF1 Mask              */
S
S#define PWM_INTSTS0_CMPUIF2_Pos          (18)                                              /*!< PWM_T::INTSTS0: CMPUIF2 Position          */
S#define PWM_INTSTS0_CMPUIF2_Msk          (0x1ul << PWM_INTSTS0_CMPUIF2_Pos)                /*!< PWM_T::INTSTS0: CMPUIF2 Mask              */
S
S#define PWM_INTSTS0_CMPUIF3_Pos          (19)                                              /*!< PWM_T::INTSTS0: CMPUIF3 Position          */
S#define PWM_INTSTS0_CMPUIF3_Msk          (0x1ul << PWM_INTSTS0_CMPUIF3_Pos)                /*!< PWM_T::INTSTS0: CMPUIF3 Mask              */
S
S#define PWM_INTSTS0_CMPUIF4_Pos          (20)                                              /*!< PWM_T::INTSTS0: CMPUIF4 Position          */
S#define PWM_INTSTS0_CMPUIF4_Msk          (0x1ul << PWM_INTSTS0_CMPUIF4_Pos)                /*!< PWM_T::INTSTS0: CMPUIF4 Mask              */
S
S#define PWM_INTSTS0_CMPUIF5_Pos          (21)                                              /*!< PWM_T::INTSTS0: CMPUIF5 Position          */
S#define PWM_INTSTS0_CMPUIF5_Msk          (0x1ul << PWM_INTSTS0_CMPUIF5_Pos)                /*!< PWM_T::INTSTS0: CMPUIF5 Mask              */
S
S#define PWM_INTSTS0_IFAIF4_5_Pos         (23)                                              /*!< PWM_T::INTSTS0: IFAIF4_5 Position         */
S#define PWM_INTSTS0_IFAIF4_5_Msk         (0x1ul << PWM_INTSTS0_IFAIF4_5_Pos)               /*!< PWM_T::INTSTS0: IFAIF4_5 Mask             */
S
S#define PWM_INTSTS0_CMPDIFn_Pos          (24)                                              /*!< PWM_T::INTSTS0: CMPDIFn Position          */
S#define PWM_INTSTS0_CMPDIFn_Msk          (0x3ful << PWM_INTSTS0_CMPDIFn_Pos)               /*!< PWM_T::INTSTS0: CMPDIFn Mask              */
S
S#define PWM_INTSTS0_CMPDIF0_Pos          (24)                                              /*!< PWM_T::INTSTS0: CMPDIF0 Position          */
S#define PWM_INTSTS0_CMPDIF0_Msk          (0x1ul << PWM_INTSTS0_CMPDIF0_Pos)                /*!< PWM_T::INTSTS0: CMPDIF0 Mask              */
S
S#define PWM_INTSTS0_CMPDIF1_Pos          (25)                                              /*!< PWM_T::INTSTS0: CMPDIF1 Position          */
S#define PWM_INTSTS0_CMPDIF1_Msk          (0x1ul << PWM_INTSTS0_CMPDIF1_Pos)                /*!< PWM_T::INTSTS0: CMPDIF1 Mask              */
S
S#define PWM_INTSTS0_CMPDIF2_Pos          (26)                                              /*!< PWM_T::INTSTS0: CMPDIF2 Position          */
S#define PWM_INTSTS0_CMPDIF2_Msk          (0x1ul << PWM_INTSTS0_CMPDIF2_Pos)                /*!< PWM_T::INTSTS0: CMPDIF2 Mask              */
S
S#define PWM_INTSTS0_CMPDIF3_Pos          (27)                                              /*!< PWM_T::INTSTS0: CMPDIF3 Position          */
S#define PWM_INTSTS0_CMPDIF3_Msk          (0x1ul << PWM_INTSTS0_CMPDIF3_Pos)                /*!< PWM_T::INTSTS0: CMPDIF3 Mask              */
S
S#define PWM_INTSTS0_CMPDIF4_Pos          (28)                                              /*!< PWM_T::INTSTS0: CMPDIF4 Position          */
S#define PWM_INTSTS0_CMPDIF4_Msk          (0x1ul << PWM_INTSTS0_CMPDIF4_Pos)                /*!< PWM_T::INTSTS0: CMPDIF4 Mask              */
S
S#define PWM_INTSTS0_CMPDIF5_Pos          (29)                                              /*!< PWM_T::INTSTS0: CMPDIF5 Position          */
S#define PWM_INTSTS0_CMPDIF5_Msk          (0x1ul << PWM_INTSTS0_CMPDIF5_Pos)                /*!< PWM_T::INTSTS0: CMPDIF5 Mask              */
S
S#define PWM_INTSTS1_BRKEIFn_Pos          (0)                                               /*!< PWM_T::INTSTS1: BRKEIFn Position          */
S#define PWM_INTSTS1_BRKEIFn_Msk          (0x3ful << PWM_INTSTS1_BRKEIFn_Pos)               /*!< PWM_T::INTSTS1: BRKEIFn Mask              */
S
S#define PWM_INTSTS1_BRKEIF0_Pos          (0)                                               /*!< PWM_T::INTSTS1: BRKEIF0 Position          */
S#define PWM_INTSTS1_BRKEIF0_Msk          (0x1ul << PWM_INTSTS1_BRKEIF0_Pos)                /*!< PWM_T::INTSTS1: BRKEIF0 Mask              */
S
S#define PWM_INTSTS1_BRKEIF1_Pos          (1)                                               /*!< PWM_T::INTSTS1: BRKEIF1 Position          */
S#define PWM_INTSTS1_BRKEIF1_Msk          (0x1ul << PWM_INTSTS1_BRKEIF1_Pos)                /*!< PWM_T::INTSTS1: BRKEIF1 Mask              */
S
S#define PWM_INTSTS1_BRKEIF2_Pos          (2)                                               /*!< PWM_T::INTSTS1: BRKEIF2 Position          */
S#define PWM_INTSTS1_BRKEIF2_Msk          (0x1ul << PWM_INTSTS1_BRKEIF2_Pos)                /*!< PWM_T::INTSTS1: BRKEIF2 Mask              */
S
S#define PWM_INTSTS1_BRKEIF3_Pos          (3)                                               /*!< PWM_T::INTSTS1: BRKEIF3 Position          */
S#define PWM_INTSTS1_BRKEIF3_Msk          (0x1ul << PWM_INTSTS1_BRKEIF3_Pos)                /*!< PWM_T::INTSTS1: BRKEIF3 Mask              */
S
S#define PWM_INTSTS1_BRKEIF4_Pos          (4)                                               /*!< PWM_T::INTSTS1: BRKEIF4 Position          */
S#define PWM_INTSTS1_BRKEIF4_Msk          (0x1ul << PWM_INTSTS1_BRKEIF4_Pos)                /*!< PWM_T::INTSTS1: BRKEIF4 Mask              */
S
S#define PWM_INTSTS1_BRKEIF5_Pos          (5)                                               /*!< PWM_T::INTSTS1: BRKEIF5 Position          */
S#define PWM_INTSTS1_BRKEIF5_Msk          (0x1ul << PWM_INTSTS1_BRKEIF5_Pos)                /*!< PWM_T::INTSTS1: BRKEIF5 Mask              */
S
S#define PWM_INTSTS1_BRKLIFn_Pos          (8)                                               /*!< PWM_T::INTSTS1: BRKLIFn Position          */
S#define PWM_INTSTS1_BRKLIFn_Msk          (0x3ful << PWM_INTSTS1_BRKLIFn_Pos)               /*!< PWM_T::INTSTS1: BRKLIFn Mask              */
S
S#define PWM_INTSTS1_BRKLIF0_Pos          (8)                                               /*!< PWM_T::INTSTS1: BRKLIF0 Position          */
S#define PWM_INTSTS1_BRKLIF0_Msk          (0x1ul << PWM_INTSTS1_BRKLIF0_Pos)                /*!< PWM_T::INTSTS1: BRKLIF0 Mask              */
S
S#define PWM_INTSTS1_BRKLIF1_Pos          (9)                                               /*!< PWM_T::INTSTS1: BRKLIF1 Position          */
S#define PWM_INTSTS1_BRKLIF1_Msk          (0x1ul << PWM_INTSTS1_BRKLIF1_Pos)                /*!< PWM_T::INTSTS1: BRKLIF1 Mask              */
S
S#define PWM_INTSTS1_BRKLIF2_Pos          (10)                                              /*!< PWM_T::INTSTS1: BRKLIF2 Position          */
S#define PWM_INTSTS1_BRKLIF2_Msk          (0x1ul << PWM_INTSTS1_BRKLIF2_Pos)                /*!< PWM_T::INTSTS1: BRKLIF2 Mask              */
S
S#define PWM_INTSTS1_BRKLIF3_Pos          (11)                                              /*!< PWM_T::INTSTS1: BRKLIF3 Position          */
S#define PWM_INTSTS1_BRKLIF3_Msk          (0x1ul << PWM_INTSTS1_BRKLIF3_Pos)                /*!< PWM_T::INTSTS1: BRKLIF3 Mask              */
S
S#define PWM_INTSTS1_BRKLIF4_Pos          (12)                                              /*!< PWM_T::INTSTS1: BRKLIF4 Position          */
S#define PWM_INTSTS1_BRKLIF4_Msk          (0x1ul << PWM_INTSTS1_BRKLIF4_Pos)                /*!< PWM_T::INTSTS1: BRKLIF4 Mask              */
S
S#define PWM_INTSTS1_BRKLIF5_Pos          (13)                                              /*!< PWM_T::INTSTS1: BRKLIF5 Position          */
S#define PWM_INTSTS1_BRKLIF5_Msk          (0x1ul << PWM_INTSTS1_BRKLIF5_Pos)                /*!< PWM_T::INTSTS1: BRKLIF5 Mask              */
S
S#define PWM_INTSTS1_BRKESTS0_Pos         (16)                                              /*!< PWM_T::INTSTS1: BRKESTS0 Position         */
S#define PWM_INTSTS1_BRKESTS0_Msk         (0x1ul << PWM_INTSTS1_BRKESTS0_Pos)               /*!< PWM_T::INTSTS1: BRKESTS0 Mask             */
S
S#define PWM_INTSTS1_BRKESTS1_Pos         (17)                                              /*!< PWM_T::INTSTS1: BRKESTS1 Position         */
S#define PWM_INTSTS1_BRKESTS1_Msk         (0x1ul << PWM_INTSTS1_BRKESTS1_Pos)               /*!< PWM_T::INTSTS1: BRKESTS1 Mask             */
S
S#define PWM_INTSTS1_BRKESTS2_Pos         (18)                                              /*!< PWM_T::INTSTS1: BRKESTS2 Position         */
S#define PWM_INTSTS1_BRKESTS2_Msk         (0x1ul << PWM_INTSTS1_BRKESTS2_Pos)               /*!< PWM_T::INTSTS1: BRKESTS2 Mask             */
S
S#define PWM_INTSTS1_BRKESTS3_Pos         (19)                                              /*!< PWM_T::INTSTS1: BRKESTS3 Position         */
S#define PWM_INTSTS1_BRKESTS3_Msk         (0x1ul << PWM_INTSTS1_BRKESTS3_Pos)               /*!< PWM_T::INTSTS1: BRKESTS3 Mask             */
S
S#define PWM_INTSTS1_BRKESTS4_Pos         (20)                                              /*!< PWM_T::INTSTS1: BRKESTS4 Position         */
S#define PWM_INTSTS1_BRKESTS4_Msk         (0x1ul << PWM_INTSTS1_BRKESTS4_Pos)               /*!< PWM_T::INTSTS1: BRKESTS4 Mask             */
S
S#define PWM_INTSTS1_BRKESTS5_Pos         (21)                                              /*!< PWM_T::INTSTS1: BRKESTS5 Position         */
S#define PWM_INTSTS1_BRKESTS5_Msk         (0x1ul << PWM_INTSTS1_BRKESTS5_Pos)               /*!< PWM_T::INTSTS1: BRKESTS5 Mask             */
S
S#define PWM_INTSTS1_BRKLSTS0_Pos         (24)                                              /*!< PWM_T::INTSTS1: BRKLSTS0 Position         */
S#define PWM_INTSTS1_BRKLSTS0_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS0_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS0 Mask             */
S
S#define PWM_INTSTS1_BRKLSTS1_Pos         (25)                                              /*!< PWM_T::INTSTS1: BRKLSTS1 Position         */
S#define PWM_INTSTS1_BRKLSTS1_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS1_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS1 Mask             */
S
S#define PWM_INTSTS1_BRKLSTS2_Pos         (26)                                              /*!< PWM_T::INTSTS1: BRKLSTS2 Position         */
S#define PWM_INTSTS1_BRKLSTS2_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS2_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS2 Mask             */
S
S#define PWM_INTSTS1_BRKLSTS3_Pos         (27)                                              /*!< PWM_T::INTSTS1: BRKLSTS3 Position         */
S#define PWM_INTSTS1_BRKLSTS3_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS3_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS3 Mask             */
S
S#define PWM_INTSTS1_BRKLSTS4_Pos         (28)                                              /*!< PWM_T::INTSTS1: BRKLSTS4 Position         */
S#define PWM_INTSTS1_BRKLSTS4_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS4_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS4 Mask             */
S
S#define PWM_INTSTS1_BRKLSTS5_Pos         (29)                                              /*!< PWM_T::INTSTS1: BRKLSTS5 Position         */
S#define PWM_INTSTS1_BRKLSTS5_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS5_Pos)               /*!< PWM_T::INTSTS1: BRKLSTS5 Mask             */
S
S#define PWM_IFA_IFCNT0_1_Pos             (0)                                               /*!< PWM_T::IFA: IFCNT0_1 Position             */
S#define PWM_IFA_IFCNT0_1_Msk             (0xful << PWM_IFA_IFCNT0_1_Pos)                   /*!< PWM_T::IFA: IFCNT0_1 Mask                 */
S
S#define PWM_IFA_IFSEL0_1_Pos             (4)                                               /*!< PWM_T::IFA: IFSEL0_1 Position             */
S#define PWM_IFA_IFSEL0_1_Msk             (0x7ul << PWM_IFA_IFSEL0_1_Pos)                   /*!< PWM_T::IFA: IFSEL0_1 Mask                 */
S
S#define PWM_IFA_IFAEN0_1_Pos             (7)                                               /*!< PWM_T::IFA: IFAEN0_1 Position             */
S#define PWM_IFA_IFAEN0_1_Msk             (0x1ul << PWM_IFA_IFAEN0_1_Pos)                   /*!< PWM_T::IFA: IFAEN0_1 Mask                 */
S
S#define PWM_IFA_IFCNT2_3_Pos             (8)                                               /*!< PWM_T::IFA: IFCNT2_3 Position             */
S#define PWM_IFA_IFCNT2_3_Msk             (0xful << PWM_IFA_IFCNT2_3_Pos)                   /*!< PWM_T::IFA: IFCNT2_3 Mask                 */
S
S#define PWM_IFA_IFSEL2_3_Pos             (12)                                              /*!< PWM_T::IFA: IFSEL2_3 Position             */
S#define PWM_IFA_IFSEL2_3_Msk             (0x7ul << PWM_IFA_IFSEL2_3_Pos)                   /*!< PWM_T::IFA: IFSEL2_3 Mask                 */
S
S#define PWM_IFA_IFAEN2_3_Pos             (15)                                              /*!< PWM_T::IFA: IFAEN2_3 Position             */
S#define PWM_IFA_IFAEN2_3_Msk             (0x1ul << PWM_IFA_IFAEN2_3_Pos)                   /*!< PWM_T::IFA: IFAEN2_3 Mask                 */
S
S#define PWM_IFA_IFCNT4_5_Pos             (16)                                              /*!< PWM_T::IFA: IFCNT4_5 Position             */
S#define PWM_IFA_IFCNT4_5_Msk             (0xful << PWM_IFA_IFCNT4_5_Pos)                   /*!< PWM_T::IFA: IFCNT4_5 Mask                 */
S
S#define PWM_IFA_IFSEL4_5_Pos             (20)                                              /*!< PWM_T::IFA: IFSEL4_5 Position             */
S#define PWM_IFA_IFSEL4_5_Msk             (0x7ul << PWM_IFA_IFSEL4_5_Pos)                   /*!< PWM_T::IFA: IFSEL4_5 Mask                 */
S
S#define PWM_IFA_IFAEN4_5_Pos             (23)                                              /*!< PWM_T::IFA: IFAEN4_5 Position             */
S#define PWM_IFA_IFAEN4_5_Msk             (0x1ul << PWM_IFA_IFAEN4_5_Pos)                   /*!< PWM_T::IFA: IFAEN4_5 Mask                 */
S
S#define PWM_DACTRGEN_ZTEn_Pos            (0)                                               /*!< PWM_T::DACTRGEN: ZTEn Position            */
S#define PWM_DACTRGEN_ZTEn_Msk            (0x3ful << PWM_DACTRGEN_ZTEn_Pos)                 /*!< PWM_T::DACTRGEN: ZTEn Mask                */
S
S#define PWM_DACTRGEN_ZTE0_Pos            (0)                                               /*!< PWM_T::DACTRGEN: ZTE0 Position            */
S#define PWM_DACTRGEN_ZTE0_Msk            (0x1ul << PWM_DACTRGEN_ZTE0_Pos)                  /*!< PWM_T::DACTRGEN: ZTE0 Mask                */
S
S#define PWM_DACTRGEN_ZTE1_Pos            (1)                                               /*!< PWM_T::DACTRGEN: ZTE1 Position            */
S#define PWM_DACTRGEN_ZTE1_Msk            (0x1ul << PWM_DACTRGEN_ZTE1_Pos)                  /*!< PWM_T::DACTRGEN: ZTE1 Mask                */
S
S#define PWM_DACTRGEN_ZTE2_Pos            (2)                                               /*!< PWM_T::DACTRGEN: ZTE2 Position            */
S#define PWM_DACTRGEN_ZTE2_Msk            (0x1ul << PWM_DACTRGEN_ZTE2_Pos)                  /*!< PWM_T::DACTRGEN: ZTE2 Mask                */
S
S#define PWM_DACTRGEN_ZTE3_Pos            (3)                                               /*!< PWM_T::DACTRGEN: ZTE3 Position            */
S#define PWM_DACTRGEN_ZTE3_Msk            (0x1ul << PWM_DACTRGEN_ZTE3_Pos)                  /*!< PWM_T::DACTRGEN: ZTE3 Mask                */
S
S#define PWM_DACTRGEN_ZTE4_Pos            (4)                                               /*!< PWM_T::DACTRGEN: ZTE4 Position            */
S#define PWM_DACTRGEN_ZTE4_Msk            (0x1ul << PWM_DACTRGEN_ZTE4_Pos)                  /*!< PWM_T::DACTRGEN: ZTE4 Mask                */
S
S#define PWM_DACTRGEN_ZTE5_Pos            (5)                                               /*!< PWM_T::DACTRGEN: ZTE5 Position            */
S#define PWM_DACTRGEN_ZTE5_Msk            (0x1ul << PWM_DACTRGEN_ZTE5_Pos)                  /*!< PWM_T::DACTRGEN: ZTE5 Mask                */
S
S#define PWM_DACTRGEN_PTEn_Pos            (8)                                               /*!< PWM_T::DACTRGEN: PTEn Position            */
S#define PWM_DACTRGEN_PTEn_Msk            (0x3ful << PWM_DACTRGEN_PTEn_Pos)                 /*!< PWM_T::DACTRGEN: PTEn Mask                */
S
S#define PWM_DACTRGEN_PTE0_Pos            (8)                                               /*!< PWM_T::DACTRGEN: PTE0 Position            */
S#define PWM_DACTRGEN_PTE0_Msk            (0x1ul << PWM_DACTRGEN_PTE0_Pos)                  /*!< PWM_T::DACTRGEN: PTE0 Mask                */
S
S#define PWM_DACTRGEN_PTE1_Pos            (9)                                               /*!< PWM_T::DACTRGEN: PTE1 Position            */
S#define PWM_DACTRGEN_PTE1_Msk            (0x1ul << PWM_DACTRGEN_PTE1_Pos)                  /*!< PWM_T::DACTRGEN: PTE1 Mask                */
S
S#define PWM_DACTRGEN_PTE2_Pos            (10)                                              /*!< PWM_T::DACTRGEN: PTE2 Position            */
S#define PWM_DACTRGEN_PTE2_Msk            (0x1ul << PWM_DACTRGEN_PTE2_Pos)                  /*!< PWM_T::DACTRGEN: PTE2 Mask                */
S
S#define PWM_DACTRGEN_PTE3_Pos            (11)                                              /*!< PWM_T::DACTRGEN: PTE3 Position            */
S#define PWM_DACTRGEN_PTE3_Msk            (0x1ul << PWM_DACTRGEN_PTE3_Pos)                  /*!< PWM_T::DACTRGEN: PTE3 Mask                */
S
S#define PWM_DACTRGEN_PTE4_Pos            (12)                                              /*!< PWM_T::DACTRGEN: PTE4 Position            */
S#define PWM_DACTRGEN_PTE4_Msk            (0x1ul << PWM_DACTRGEN_PTE4_Pos)                  /*!< PWM_T::DACTRGEN: PTE4 Mask                */
S
S#define PWM_DACTRGEN_PTE5_Pos            (13)                                              /*!< PWM_T::DACTRGEN: PTE5 Position            */
S#define PWM_DACTRGEN_PTE5_Msk            (0x1ul << PWM_DACTRGEN_PTE5_Pos)                  /*!< PWM_T::DACTRGEN: PTE5 Mask                */
S
S#define PWM_DACTRGEN_CUTRGEn_Pos         (16)                                              /*!< PWM_T::DACTRGEN: CUTRGEn Position         */
S#define PWM_DACTRGEN_CUTRGEn_Msk         (0x3ful << PWM_DACTRGEN_CUTRGEn_Pos)              /*!< PWM_T::DACTRGEN: CUTRGEn Mask             */
S
S#define PWM_DACTRGEN_CUTRGE0_Pos         (16)                                              /*!< PWM_T::DACTRGEN: CUTRGE0 Position         */
S#define PWM_DACTRGEN_CUTRGE0_Msk         (0x1ul << PWM_DACTRGEN_CUTRGE0_Pos)               /*!< PWM_T::DACTRGEN: CUTRGE0 Mask             */
S
S#define PWM_DACTRGEN_CUTRGE1_Pos         (17)                                              /*!< PWM_T::DACTRGEN: CUTRGE1 Position         */
S#define PWM_DACTRGEN_CUTRGE1_Msk         (0x1ul << PWM_DACTRGEN_CUTRGE1_Pos)               /*!< PWM_T::DACTRGEN: CUTRGE1 Mask             */
S
S#define PWM_DACTRGEN_CUTRGE2_Pos         (18)                                              /*!< PWM_T::DACTRGEN: CUTRGE2 Position         */
S#define PWM_DACTRGEN_CUTRGE2_Msk         (0x1ul << PWM_DACTRGEN_CUTRGE2_Pos)               /*!< PWM_T::DACTRGEN: CUTRGE2 Mask             */
S
S#define PWM_DACTRGEN_CUTRGE3_Pos         (19)                                              /*!< PWM_T::DACTRGEN: CUTRGE3 Position         */
S#define PWM_DACTRGEN_CUTRGE3_Msk         (0x1ul << PWM_DACTRGEN_CUTRGE3_Pos)               /*!< PWM_T::DACTRGEN: CUTRGE3 Mask             */
S
S#define PWM_DACTRGEN_CUTRGE4_Pos         (20)                                              /*!< PWM_T::DACTRGEN: CUTRGE4 Position         */
S#define PWM_DACTRGEN_CUTRGE4_Msk         (0x1ul << PWM_DACTRGEN_CUTRGE4_Pos)               /*!< PWM_T::DACTRGEN: CUTRGE4 Mask             */
S
S#define PWM_DACTRGEN_CUTRGE5_Pos         (21)                                              /*!< PWM_T::DACTRGEN: CUTRGE5 Position         */
S#define PWM_DACTRGEN_CUTRGE5_Msk         (0x1ul << PWM_DACTRGEN_CUTRGE5_Pos)               /*!< PWM_T::DACTRGEN: CUTRGE5 Mask             */
S
S#define PWM_DACTRGEN_CDTRGEn_Pos         (24)                                              /*!< PWM_T::DACTRGEN: CDTRGEn Position         */
S#define PWM_DACTRGEN_CDTRGEn_Msk         (0x3ful << PWM_DACTRGEN_CDTRGEn_Pos)              /*!< PWM_T::DACTRGEN: CDTRGEn Mask             */
S
S#define PWM_DACTRGEN_CDTRGE0_Pos         (24)                                              /*!< PWM_T::DACTRGEN: CDTRGE0 Position         */
S#define PWM_DACTRGEN_CDTRGE0_Msk         (0x1ul << PWM_DACTRGEN_CDTRGE0_Pos)               /*!< PWM_T::DACTRGEN: CDTRGE0 Mask             */
S
S#define PWM_DACTRGEN_CDTRGE1_Pos         (25)                                              /*!< PWM_T::DACTRGEN: CDTRGE1 Position         */
S#define PWM_DACTRGEN_CDTRGE1_Msk         (0x1ul << PWM_DACTRGEN_CDTRGE1_Pos)               /*!< PWM_T::DACTRGEN: CDTRGE1 Mask             */
S
S#define PWM_DACTRGEN_CDTRGE2_Pos         (26)                                              /*!< PWM_T::DACTRGEN: CDTRGE2 Position         */
S#define PWM_DACTRGEN_CDTRGE2_Msk         (0x1ul << PWM_DACTRGEN_CDTRGE2_Pos)               /*!< PWM_T::DACTRGEN: CDTRGE2 Mask             */
S
S#define PWM_DACTRGEN_CDTRGE3_Pos         (27)                                              /*!< PWM_T::DACTRGEN: CDTRGE3 Position         */
S#define PWM_DACTRGEN_CDTRGE3_Msk         (0x1ul << PWM_DACTRGEN_CDTRGE3_Pos)               /*!< PWM_T::DACTRGEN: CDTRGE3 Mask             */
S
S#define PWM_DACTRGEN_CDTRGE4_Pos         (28)                                              /*!< PWM_T::DACTRGEN: CDTRGE4 Position         */
S#define PWM_DACTRGEN_CDTRGE4_Msk         (0x1ul << PWM_DACTRGEN_CDTRGE4_Pos)               /*!< PWM_T::DACTRGEN: CDTRGE4 Mask             */
S
S#define PWM_DACTRGEN_CDTRGE5_Pos         (29)                                              /*!< PWM_T::DACTRGEN: CDTRGE5 Position         */
S#define PWM_DACTRGEN_CDTRGE5_Msk         (0x1ul << PWM_DACTRGEN_CDTRGE5_Pos)               /*!< PWM_T::DACTRGEN: CDTRGE5 Mask             */
S
S#define PWM_EADCTS0_TRGSEL0_Pos          (0)                                               /*!< PWM_T::EADCTS0: TRGSEL0 Position          */
S#define PWM_EADCTS0_TRGSEL0_Msk          (0xful << PWM_EADCTS0_TRGSEL0_Pos)                /*!< PWM_T::EADCTS0: TRGSEL0 Mask              */
S
S#define PWM_EADCTS0_TRGEN0_Pos           (7)                                               /*!< PWM_T::EADCTS0: TRGEN0 Position           */
S#define PWM_EADCTS0_TRGEN0_Msk           (0x1ul << PWM_EADCTS0_TRGEN0_Pos)                 /*!< PWM_T::EADCTS0: TRGEN0 Mask               */
S
S#define PWM_EADCTS0_TRGSEL1_Pos          (8)                                               /*!< PWM_T::EADCTS0: TRGSEL1 Position          */
S#define PWM_EADCTS0_TRGSEL1_Msk          (0xful << PWM_EADCTS0_TRGSEL1_Pos)                /*!< PWM_T::EADCTS0: TRGSEL1 Mask              */
S
S#define PWM_EADCTS0_TRGEN1_Pos           (15)                                              /*!< PWM_T::EADCTS0: TRGEN1 Position           */
S#define PWM_EADCTS0_TRGEN1_Msk           (0x1ul << PWM_EADCTS0_TRGEN1_Pos)                 /*!< PWM_T::EADCTS0: TRGEN1 Mask               */
S
S#define PWM_EADCTS0_TRGSEL2_Pos          (16)                                              /*!< PWM_T::EADCTS0: TRGSEL2 Position          */
S#define PWM_EADCTS0_TRGSEL2_Msk          (0xful << PWM_EADCTS0_TRGSEL2_Pos)                /*!< PWM_T::EADCTS0: TRGSEL2 Mask              */
S
S#define PWM_EADCTS0_TRGEN2_Pos           (23)                                              /*!< PWM_T::EADCTS0: TRGEN2 Position           */
S#define PWM_EADCTS0_TRGEN2_Msk           (0x1ul << PWM_EADCTS0_TRGEN2_Pos)                 /*!< PWM_T::EADCTS0: TRGEN2 Mask               */
S
S#define PWM_EADCTS0_TRGSEL3_Pos          (24)                                              /*!< PWM_T::EADCTS0: TRGSEL3 Position          */
S#define PWM_EADCTS0_TRGSEL3_Msk          (0xful << PWM_EADCTS0_TRGSEL3_Pos)                /*!< PWM_T::EADCTS0: TRGSEL3 Mask              */
S
S#define PWM_EADCTS0_TRGEN3_Pos           (31)                                              /*!< PWM_T::EADCTS0: TRGEN3 Position           */
S#define PWM_EADCTS0_TRGEN3_Msk           (0x1ul << PWM_EADCTS0_TRGEN3_Pos)                 /*!< PWM_T::EADCTS0: TRGEN3 Mask               */
S
S#define PWM_EADCTS1_TRGSEL4_Pos          (0)                                               /*!< PWM_T::EADCTS1: TRGSEL4 Position          */
S#define PWM_EADCTS1_TRGSEL4_Msk          (0xful << PWM_EADCTS1_TRGSEL4_Pos)                /*!< PWM_T::EADCTS1: TRGSEL4 Mask              */
S
S#define PWM_EADCTS1_TRGEN4_Pos           (7)                                               /*!< PWM_T::EADCTS1: TRGEN4 Position           */
S#define PWM_EADCTS1_TRGEN4_Msk           (0x1ul << PWM_EADCTS1_TRGEN4_Pos)                 /*!< PWM_T::EADCTS1: TRGEN4 Mask               */
S
S#define PWM_EADCTS1_TRGSEL5_Pos          (8)                                               /*!< PWM_T::EADCTS1: TRGSEL5 Position          */
S#define PWM_EADCTS1_TRGSEL5_Msk          (0xful << PWM_EADCTS1_TRGSEL5_Pos)                /*!< PWM_T::EADCTS1: TRGSEL5 Mask              */
S
S#define PWM_EADCTS1_TRGEN5_Pos           (15)                                              /*!< PWM_T::EADCTS1: TRGEN5 Position           */
S#define PWM_EADCTS1_TRGEN5_Msk           (0x1ul << PWM_EADCTS1_TRGEN5_Pos)                 /*!< PWM_T::EADCTS1: TRGEN5 Mask               */
S
S#define PWM_FTCMPDAT0_1_FTCMP_Pos        (0)                                               /*!< PWM_T::FTCMPDAT0_1: FTCMP Position        */
S#define PWM_FTCMPDAT0_1_FTCMP_Msk        (0xfffful << PWM_FTCMPDAT0_1_FTCMP_Pos)           /*!< PWM_T::FTCMPDAT0_1: FTCMP Mask            */
S
S#define PWM_FTCMPDAT2_3_FTCMP_Pos        (0)                                               /*!< PWM_T::FTCMPDAT2_3: FTCMP Position        */
S#define PWM_FTCMPDAT2_3_FTCMP_Msk        (0xfffful << PWM_FTCMPDAT2_3_FTCMP_Pos)           /*!< PWM_T::FTCMPDAT2_3: FTCMP Mask            */
S
S#define PWM_FTCMPDAT4_5_FTCMP_Pos        (0)                                               /*!< PWM_T::FTCMPDAT4_5: FTCMP Position        */
S#define PWM_FTCMPDAT4_5_FTCMP_Msk        (0xfffful << PWM_FTCMPDAT4_5_FTCMP_Pos)           /*!< PWM_T::FTCMPDAT4_5: FTCMP Mask            */
S
S#define PWM_SSCTL_SSENn_Pos              (0)                                               /*!< PWM_T::SSCTL: SSENn Position              */
S#define PWM_SSCTL_SSENn_Msk              (0x3ful << PWM_SSCTL_SSENn_Pos)                   /*!< PWM_T::SSCTL: SSENn Mask                  */
S
S#define PWM_SSCTL_SSEN0_Pos              (0)                                               /*!< PWM_T::SSCTL: SSEN0 Position              */
S#define PWM_SSCTL_SSEN0_Msk              (0x1ul << PWM_SSCTL_SSEN0_Pos)                    /*!< PWM_T::SSCTL: SSEN0 Mask                  */
S
S#define PWM_SSCTL_SSEN1_Pos              (1)                                               /*!< PWM_T::SSCTL: SSEN1 Position              */
S#define PWM_SSCTL_SSEN1_Msk              (0x1ul << PWM_SSCTL_SSEN1_Pos)                    /*!< PWM_T::SSCTL: SSEN1 Mask                  */
S
S#define PWM_SSCTL_SSEN2_Pos              (2)                                               /*!< PWM_T::SSCTL: SSEN2 Position              */
S#define PWM_SSCTL_SSEN2_Msk              (0x1ul << PWM_SSCTL_SSEN2_Pos)                    /*!< PWM_T::SSCTL: SSEN2 Mask                  */
S
S#define PWM_SSCTL_SSEN3_Pos              (3)                                               /*!< PWM_T::SSCTL: SSEN3 Position              */
S#define PWM_SSCTL_SSEN3_Msk              (0x1ul << PWM_SSCTL_SSEN3_Pos)                    /*!< PWM_T::SSCTL: SSEN3 Mask                  */
S
S#define PWM_SSCTL_SSEN4_Pos              (4)                                               /*!< PWM_T::SSCTL: SSEN4 Position              */
S#define PWM_SSCTL_SSEN4_Msk              (0x1ul << PWM_SSCTL_SSEN4_Pos)                    /*!< PWM_T::SSCTL: SSEN4 Mask                  */
S
S#define PWM_SSCTL_SSEN5_Pos              (5)                                               /*!< PWM_T::SSCTL: SSEN5 Position              */
S#define PWM_SSCTL_SSEN5_Msk              (0x1ul << PWM_SSCTL_SSEN5_Pos)                    /*!< PWM_T::SSCTL: SSEN5 Mask                  */
S
S#define PWM_SSTRG_CNTSEN_Pos             (0)                                               /*!< PWM_T::SSTRG: CNTSEN Position             */
S#define PWM_SSTRG_CNTSEN_Msk             (0x1ul << PWM_SSTRG_CNTSEN_Pos)                   /*!< PWM_T::SSTRG: CNTSEN Mask                 */
S
S#define PWM_STATUS_CNTMAXFn_Pos          (0)                                               /*!< PWM_T::STATUS: CNTMAXFn Position          */
S#define PWM_STATUS_CNTMAXFn_Msk          (0x3ful << PWM_STATUS_CNTMAXFn_Pos)               /*!< PWM_T::STATUS: CNTMAXFn Mask              */
S
S#define PWM_STATUS_CNTMAXF0_Pos          (0)                                               /*!< PWM_T::STATUS: CNTMAXF0 Position          */
S#define PWM_STATUS_CNTMAXF0_Msk          (0x1ul << PWM_STATUS_CNTMAXF0_Pos)                /*!< PWM_T::STATUS: CNTMAXF0 Mask              */
S
S#define PWM_STATUS_CNTMAXF1_Pos          (1)                                               /*!< PWM_T::STATUS: CNTMAXF1 Position          */
S#define PWM_STATUS_CNTMAXF1_Msk          (0x1ul << PWM_STATUS_CNTMAXF1_Pos)                /*!< PWM_T::STATUS: CNTMAXF1 Mask              */
S
S#define PWM_STATUS_CNTMAXF2_Pos          (2)                                               /*!< PWM_T::STATUS: CNTMAXF2 Position          */
S#define PWM_STATUS_CNTMAXF2_Msk          (0x1ul << PWM_STATUS_CNTMAXF2_Pos)                /*!< PWM_T::STATUS: CNTMAXF2 Mask              */
S
S#define PWM_STATUS_CNTMAXF3_Pos          (3)                                               /*!< PWM_T::STATUS: CNTMAXF3 Position          */
S#define PWM_STATUS_CNTMAXF3_Msk          (0x1ul << PWM_STATUS_CNTMAXF3_Pos)                /*!< PWM_T::STATUS: CNTMAXF3 Mask              */
S
S#define PWM_STATUS_CNTMAXF4_Pos          (4)                                               /*!< PWM_T::STATUS: CNTMAXF4 Position          */
S#define PWM_STATUS_CNTMAXF4_Msk          (0x1ul << PWM_STATUS_CNTMAXF4_Pos)                /*!< PWM_T::STATUS: CNTMAXF4 Mask              */
S
S#define PWM_STATUS_CNTMAXF5_Pos          (5)                                               /*!< PWM_T::STATUS: CNTMAXF5 Position          */
S#define PWM_STATUS_CNTMAXF5_Msk          (0x1ul << PWM_STATUS_CNTMAXF5_Pos)                /*!< PWM_T::STATUS: CNTMAXF5 Mask              */
S
S#define PWM_STATUS_SYNCINFn_Pos          (8)                                               /*!< PWM_T::STATUS: SYNCINFn Position          */
S#define PWM_STATUS_SYNCINFn_Msk          (0x7ul << PWM_STATUS_SYNCINFn_Pos)                /*!< PWM_T::STATUS: SYNCINFn Mask              */
S
S#define PWM_STATUS_SYNCINF0_Pos          (8)                                               /*!< PWM_T::STATUS: SYNCINF0 Position          */
S#define PWM_STATUS_SYNCINF0_Msk          (0x1ul << PWM_STATUS_SYNCINF0_Pos)                /*!< PWM_T::STATUS: SYNCINF0 Mask              */
S
S#define PWM_STATUS_SYNCINF2_Pos          (9)                                               /*!< PWM_T::STATUS: SYNCINF2 Position          */
S#define PWM_STATUS_SYNCINF2_Msk          (0x1ul << PWM_STATUS_SYNCINF2_Pos)                /*!< PWM_T::STATUS: SYNCINF2 Mask              */
S
S#define PWM_STATUS_SYNCINF4_Pos          (10)                                              /*!< PWM_T::STATUS: SYNCINF4 Position          */
S#define PWM_STATUS_SYNCINF4_Msk          (0x1ul << PWM_STATUS_SYNCINF4_Pos)                /*!< PWM_T::STATUS: SYNCINF4 Mask              */
S
S#define PWM_STATUS_ADCTRGFn_Pos          (16)                                              /*!< PWM_T::STATUS: ADCTRGFn Position          */
S#define PWM_STATUS_ADCTRGFn_Msk          (0x3ful << PWM_STATUS_ADCTRGFn_Pos)               /*!< PWM_T::STATUS: ADCTRGFn Mask              */
S
S#define PWM_STATUS_ADCTRGF0_Pos          (16)                                              /*!< PWM_T::STATUS: ADCTRGF0 Position          */
S#define PWM_STATUS_ADCTRGF0_Msk          (0x1ul << PWM_STATUS_ADCTRGF0_Pos)                /*!< PWM_T::STATUS: ADCTRGF0 Mask              */
S
S#define PWM_STATUS_ADCTRGF1_Pos          (17)                                              /*!< PWM_T::STATUS: ADCTRGF1 Position          */
S#define PWM_STATUS_ADCTRGF1_Msk          (0x1ul << PWM_STATUS_ADCTRGF1_Pos)                /*!< PWM_T::STATUS: ADCTRGF1 Mask              */
S
S#define PWM_STATUS_ADCTRGF2_Pos          (18)                                              /*!< PWM_T::STATUS: ADCTRGF2 Position          */
S#define PWM_STATUS_ADCTRGF2_Msk          (0x1ul << PWM_STATUS_ADCTRGF2_Pos)                /*!< PWM_T::STATUS: ADCTRGF2 Mask              */
S
S#define PWM_STATUS_ADCTRGF3_Pos          (19)                                              /*!< PWM_T::STATUS: ADCTRGF3 Position          */
S#define PWM_STATUS_ADCTRGF3_Msk          (0x1ul << PWM_STATUS_ADCTRGF3_Pos)                /*!< PWM_T::STATUS: ADCTRGF3 Mask              */
S
S#define PWM_STATUS_ADCTRGF4_Pos          (20)                                              /*!< PWM_T::STATUS: ADCTRGF4 Position          */
S#define PWM_STATUS_ADCTRGF4_Msk          (0x1ul << PWM_STATUS_ADCTRGF4_Pos)                /*!< PWM_T::STATUS: ADCTRGF4 Mask              */
S
S#define PWM_STATUS_ADCTRGF5_Pos          (21)                                              /*!< PWM_T::STATUS: ADCTRGF5 Position          */
S#define PWM_STATUS_ADCTRGF5_Msk          (0x1ul << PWM_STATUS_ADCTRGF5_Pos)                /*!< PWM_T::STATUS: ADCTRGF5 Mask              */
S
S#define PWM_STATUS_DACTRGF_Pos           (24)                                              /*!< PWM_T::STATUS: DACTRGF Position           */
S#define PWM_STATUS_DACTRGF_Msk           (0x1ul << PWM_STATUS_DACTRGF_Pos)                 /*!< PWM_T::STATUS: DACTRGF Mask               */
S
S#define PWM_CAPINEN_CAPINENn_Pos         (0)                                               /*!< PWM_T::CAPINEN: CAPINENn Position         */
S#define PWM_CAPINEN_CAPINENn_Msk         (0x3ful << PWM_CAPINEN_CAPINENn_Pos)              /*!< PWM_T::CAPINEN: CAPINENn Mask             */
S
S#define PWM_CAPINEN_CAPINEN0_Pos         (0)                                               /*!< PWM_T::CAPINEN: CAPINEN0 Position         */
S#define PWM_CAPINEN_CAPINEN0_Msk         (0x1ul << PWM_CAPINEN_CAPINEN0_Pos)               /*!< PWM_T::CAPINEN: CAPINEN0 Mask             */
S
S#define PWM_CAPINEN_CAPINEN1_Pos         (1)                                               /*!< PWM_T::CAPINEN: CAPINEN1 Position         */
S#define PWM_CAPINEN_CAPINEN1_Msk         (0x1ul << PWM_CAPINEN_CAPINEN1_Pos)               /*!< PWM_T::CAPINEN: CAPINEN1 Mask             */
S
S#define PWM_CAPINEN_CAPINEN2_Pos         (2)                                               /*!< PWM_T::CAPINEN: CAPINEN2 Position         */
S#define PWM_CAPINEN_CAPINEN2_Msk         (0x1ul << PWM_CAPINEN_CAPINEN2_Pos)               /*!< PWM_T::CAPINEN: CAPINEN2 Mask             */
S
S#define PWM_CAPINEN_CAPINEN3_Pos         (3)                                               /*!< PWM_T::CAPINEN: CAPINEN3 Position         */
S#define PWM_CAPINEN_CAPINEN3_Msk         (0x1ul << PWM_CAPINEN_CAPINEN3_Pos)               /*!< PWM_T::CAPINEN: CAPINEN3 Mask             */
S
S#define PWM_CAPINEN_CAPINEN4_Pos         (4)                                               /*!< PWM_T::CAPINEN: CAPINEN4 Position         */
S#define PWM_CAPINEN_CAPINEN4_Msk         (0x1ul << PWM_CAPINEN_CAPINEN4_Pos)               /*!< PWM_T::CAPINEN: CAPINEN4 Mask             */
S
S#define PWM_CAPINEN_CAPINEN5_Pos         (5)                                               /*!< PWM_T::CAPINEN: CAPINEN5 Position         */
S#define PWM_CAPINEN_CAPINEN5_Msk         (0x1ul << PWM_CAPINEN_CAPINEN5_Pos)               /*!< PWM_T::CAPINEN: CAPINEN5 Mask             */
S
S#define PWM_CAPCTL_CAPENn_Pos            (0)                                               /*!< PWM_T::CAPCTL: CAPENn Position            */
S#define PWM_CAPCTL_CAPENn_Msk            (0x3ful << PWM_CAPCTL_CAPENn_Pos)                 /*!< PWM_T::CAPCTL: CAPENn Mask                */
S
S#define PWM_CAPCTL_CAPEN0_Pos            (0)                                               /*!< PWM_T::CAPCTL: CAPEN0 Position            */
S#define PWM_CAPCTL_CAPEN0_Msk            (0x1ul << PWM_CAPCTL_CAPEN0_Pos)                  /*!< PWM_T::CAPCTL: CAPEN0 Mask                */
S
S#define PWM_CAPCTL_CAPEN1_Pos            (1)                                               /*!< PWM_T::CAPCTL: CAPEN1 Position            */
S#define PWM_CAPCTL_CAPEN1_Msk            (0x1ul << PWM_CAPCTL_CAPEN1_Pos)                  /*!< PWM_T::CAPCTL: CAPEN1 Mask                */
S
S#define PWM_CAPCTL_CAPEN2_Pos            (2)                                               /*!< PWM_T::CAPCTL: CAPEN2 Position            */
S#define PWM_CAPCTL_CAPEN2_Msk            (0x1ul << PWM_CAPCTL_CAPEN2_Pos)                  /*!< PWM_T::CAPCTL: CAPEN2 Mask                */
S
S#define PWM_CAPCTL_CAPEN3_Pos            (3)                                               /*!< PWM_T::CAPCTL: CAPEN3 Position            */
S#define PWM_CAPCTL_CAPEN3_Msk            (0x1ul << PWM_CAPCTL_CAPEN3_Pos)                  /*!< PWM_T::CAPCTL: CAPEN3 Mask                */
S
S#define PWM_CAPCTL_CAPEN4_Pos            (4)                                               /*!< PWM_T::CAPCTL: CAPEN4 Position            */
S#define PWM_CAPCTL_CAPEN4_Msk            (0x1ul << PWM_CAPCTL_CAPEN4_Pos)                  /*!< PWM_T::CAPCTL: CAPEN4 Mask                */
S
S#define PWM_CAPCTL_CAPEN5_Pos            (5)                                               /*!< PWM_T::CAPCTL: CAPEN5 Position            */
S#define PWM_CAPCTL_CAPEN5_Msk            (0x1ul << PWM_CAPCTL_CAPEN5_Pos)                  /*!< PWM_T::CAPCTL: CAPEN5 Mask                */
S
S#define PWM_CAPCTL_CAPINVn_Pos           (8)                                               /*!< PWM_T::CAPCTL: CAPINVn Position           */
S#define PWM_CAPCTL_CAPINVn_Msk           (0x3ful << PWM_CAPCTL_CAPINVn_Pos)                /*!< PWM_T::CAPCTL: CAPINVn Mask               */
S
S#define PWM_CAPCTL_CAPINV0_Pos           (8)                                               /*!< PWM_T::CAPCTL: CAPINV0 Position           */
S#define PWM_CAPCTL_CAPINV0_Msk           (0x1ul << PWM_CAPCTL_CAPINV0_Pos)                 /*!< PWM_T::CAPCTL: CAPINV0 Mask               */
S
S#define PWM_CAPCTL_CAPINV1_Pos           (9)                                               /*!< PWM_T::CAPCTL: CAPINV1 Position           */
S#define PWM_CAPCTL_CAPINV1_Msk           (0x1ul << PWM_CAPCTL_CAPINV1_Pos)                 /*!< PWM_T::CAPCTL: CAPINV1 Mask               */
S
S#define PWM_CAPCTL_CAPINV2_Pos           (10)                                              /*!< PWM_T::CAPCTL: CAPINV2 Position           */
S#define PWM_CAPCTL_CAPINV2_Msk           (0x1ul << PWM_CAPCTL_CAPINV2_Pos)                 /*!< PWM_T::CAPCTL: CAPINV2 Mask               */
S
S#define PWM_CAPCTL_CAPINV3_Pos           (11)                                              /*!< PWM_T::CAPCTL: CAPINV3 Position           */
S#define PWM_CAPCTL_CAPINV3_Msk           (0x1ul << PWM_CAPCTL_CAPINV3_Pos)                 /*!< PWM_T::CAPCTL: CAPINV3 Mask               */
S
S#define PWM_CAPCTL_CAPINV4_Pos           (12)                                              /*!< PWM_T::CAPCTL: CAPINV4 Position           */
S#define PWM_CAPCTL_CAPINV4_Msk           (0x1ul << PWM_CAPCTL_CAPINV4_Pos)                 /*!< PWM_T::CAPCTL: CAPINV4 Mask               */
S
S#define PWM_CAPCTL_CAPINV5_Pos           (13)                                              /*!< PWM_T::CAPCTL: CAPINV5 Position           */
S#define PWM_CAPCTL_CAPINV5_Msk           (0x1ul << PWM_CAPCTL_CAPINV5_Pos)                 /*!< PWM_T::CAPCTL: CAPINV5 Mask               */
S
S#define PWM_CAPCTL_RCRLDENn_Pos          (16)                                              /*!< PWM_T::CAPCTL: RCRLDENn Position          */
S#define PWM_CAPCTL_RCRLDENn_Msk          (0x3ful << PWM_CAPCTL_RCRLDENn_Pos)               /*!< PWM_T::CAPCTL: RCRLDENn Mask              */
S
S#define PWM_CAPCTL_RCRLDEN0_Pos          (16)                                              /*!< PWM_T::CAPCTL: RCRLDEN0 Position          */
S#define PWM_CAPCTL_RCRLDEN0_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN0_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN0 Mask              */
S
S#define PWM_CAPCTL_RCRLDEN1_Pos          (17)                                              /*!< PWM_T::CAPCTL: RCRLDEN1 Position          */
S#define PWM_CAPCTL_RCRLDEN1_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN1_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN1 Mask              */
S
S#define PWM_CAPCTL_RCRLDEN2_Pos          (18)                                              /*!< PWM_T::CAPCTL: RCRLDEN2 Position          */
S#define PWM_CAPCTL_RCRLDEN2_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN2_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN2 Mask              */
S
S#define PWM_CAPCTL_RCRLDEN3_Pos          (19)                                              /*!< PWM_T::CAPCTL: RCRLDEN3 Position          */
S#define PWM_CAPCTL_RCRLDEN3_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN3_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN3 Mask              */
S
S#define PWM_CAPCTL_RCRLDEN4_Pos          (20)                                              /*!< PWM_T::CAPCTL: RCRLDEN4 Position          */
S#define PWM_CAPCTL_RCRLDEN4_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN4_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN4 Mask              */
S
S#define PWM_CAPCTL_RCRLDEN5_Pos          (21)                                              /*!< PWM_T::CAPCTL: RCRLDEN5 Position          */
S#define PWM_CAPCTL_RCRLDEN5_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN5_Pos)                /*!< PWM_T::CAPCTL: RCRLDEN5 Mask              */
S
S#define PWM_CAPCTL_FCRLDENn_Pos          (24)                                              /*!< PWM_T::CAPCTL: FCRLDENn Position          */
S#define PWM_CAPCTL_FCRLDENn_Msk          (0x3ful << PWM_CAPCTL_FCRLDENn_Pos)               /*!< PWM_T::CAPCTL: FCRLDENn Mask              */
S
S#define PWM_CAPCTL_FCRLDEN0_Pos          (24)                                              /*!< PWM_T::CAPCTL: FCRLDEN0 Position          */
S#define PWM_CAPCTL_FCRLDEN0_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN0_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN0 Mask              */
S
S#define PWM_CAPCTL_FCRLDEN1_Pos          (25)                                              /*!< PWM_T::CAPCTL: FCRLDEN1 Position          */
S#define PWM_CAPCTL_FCRLDEN1_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN1_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN1 Mask              */
S
S#define PWM_CAPCTL_FCRLDEN2_Pos          (26)                                              /*!< PWM_T::CAPCTL: FCRLDEN2 Position          */
S#define PWM_CAPCTL_FCRLDEN2_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN2_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN2 Mask              */
S
S#define PWM_CAPCTL_FCRLDEN3_Pos          (27)                                              /*!< PWM_T::CAPCTL: FCRLDEN3 Position          */
S#define PWM_CAPCTL_FCRLDEN3_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN3_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN3 Mask              */
S
S#define PWM_CAPCTL_FCRLDEN4_Pos          (28)                                              /*!< PWM_T::CAPCTL: FCRLDEN4 Position          */
S#define PWM_CAPCTL_FCRLDEN4_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN4_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN4 Mask              */
S
S#define PWM_CAPCTL_FCRLDEN5_Pos          (29)                                              /*!< PWM_T::CAPCTL: FCRLDEN5 Position          */
S#define PWM_CAPCTL_FCRLDEN5_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN5_Pos)                /*!< PWM_T::CAPCTL: FCRLDEN5 Mask              */
S
S#define PWM_CAPSTS_CRLIFOVn_Pos          (0)                                               /*!< PWM_T::CAPSTS: CRLIFOVn Position          */
S#define PWM_CAPSTS_CRLIFOVn_Msk          (0x3ful << PWM_CAPSTS_CRLIFOVn_Pos)               /*!< PWM_T::CAPSTS: CRLIFOVn Mask              */
S
S#define PWM_CAPSTS_CRLIFOV0_Pos          (0)                                               /*!< PWM_T::CAPSTS: CRLIFOV0 Position          */
S#define PWM_CAPSTS_CRLIFOV0_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV0_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV0 Mask              */
S
S#define PWM_CAPSTS_CRLIFOV1_Pos          (1)                                               /*!< PWM_T::CAPSTS: CRLIFOV1 Position          */
S#define PWM_CAPSTS_CRLIFOV1_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV1_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV1 Mask              */
S
S#define PWM_CAPSTS_CRLIFOV2_Pos          (2)                                               /*!< PWM_T::CAPSTS: CRLIFOV2 Position          */
S#define PWM_CAPSTS_CRLIFOV2_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV2_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV2 Mask              */
S
S#define PWM_CAPSTS_CRLIFOV3_Pos          (3)                                               /*!< PWM_T::CAPSTS: CRLIFOV3 Position          */
S#define PWM_CAPSTS_CRLIFOV3_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV3_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV3 Mask              */
S
S#define PWM_CAPSTS_CRLIFOV4_Pos          (4)                                               /*!< PWM_T::CAPSTS: CRLIFOV4 Position          */
S#define PWM_CAPSTS_CRLIFOV4_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV4_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV4 Mask              */
S
S#define PWM_CAPSTS_CRLIFOV5_Pos          (5)                                               /*!< PWM_T::CAPSTS: CRLIFOV5 Position          */
S#define PWM_CAPSTS_CRLIFOV5_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV5_Pos)                /*!< PWM_T::CAPSTS: CRLIFOV5 Mask              */
S
S#define PWM_CAPSTS_CFLIFOVn_Pos          (8)                                               /*!< PWM_T::CAPSTS: CFLIFOVn Position          */
S#define PWM_CAPSTS_CFLIFOVn_Msk          (0x3ful << PWM_CAPSTS_CFLIFOVn_Pos)               /*!< PWM_T::CAPSTS: CFLIFOVn Mask              */
S
S#define PWM_CAPSTS_CFLIFOV0_Pos          (8)                                               /*!< PWM_T::CAPSTS: CFLIFOV0 Position          */
S#define PWM_CAPSTS_CFLIFOV0_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV0_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV0 Mask              */
S
S#define PWM_CAPSTS_CFLIFOV1_Pos          (9)                                               /*!< PWM_T::CAPSTS: CFLIFOV1 Position          */
S#define PWM_CAPSTS_CFLIFOV1_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV1_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV1 Mask              */
S
S#define PWM_CAPSTS_CFLIFOV2_Pos          (10)                                              /*!< PWM_T::CAPSTS: CFLIFOV2 Position          */
S#define PWM_CAPSTS_CFLIFOV2_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV2_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV2 Mask              */
S
S#define PWM_CAPSTS_CFLIFOV3_Pos          (11)                                              /*!< PWM_T::CAPSTS: CFLIFOV3 Position          */
S#define PWM_CAPSTS_CFLIFOV3_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV3_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV3 Mask              */
S
S#define PWM_CAPSTS_CFLIFOV4_Pos          (12)                                              /*!< PWM_T::CAPSTS: CFLIFOV4 Position          */
S#define PWM_CAPSTS_CFLIFOV4_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV4_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV4 Mask              */
S
S#define PWM_CAPSTS_CFLIFOV5_Pos          (13)                                              /*!< PWM_T::CAPSTS: CFLIFOV5 Position          */
S#define PWM_CAPSTS_CFLIFOV5_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV5_Pos)                /*!< PWM_T::CAPSTS: CFLIFOV5 Mask              */
S
S#define PWM_RCAPDAT0_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT0: RCAPDAT Position         */
S#define PWM_RCAPDAT0_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT0_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT0: RCAPDAT Mask             */
S
S#define PWM_FCAPDAT0_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT0: FCAPDAT Position         */
S#define PWM_FCAPDAT0_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT0_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT0: FCAPDAT Mask             */
S
S#define PWM_RCAPDAT1_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT1: RCAPDAT Position         */
S#define PWM_RCAPDAT1_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT1_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT1: RCAPDAT Mask             */
S
S#define PWM_FCAPDAT1_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT1: FCAPDAT Position         */
S#define PWM_FCAPDAT1_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT1_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT1: FCAPDAT Mask             */
S
S#define PWM_RCAPDAT2_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT2: RCAPDAT Position         */
S#define PWM_RCAPDAT2_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT2_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT2: RCAPDAT Mask             */
S
S#define PWM_FCAPDAT2_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT2: FCAPDAT Position         */
S#define PWM_FCAPDAT2_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT2_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT2: FCAPDAT Mask             */
S
S#define PWM_RCAPDAT3_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT3: RCAPDAT Position         */
S#define PWM_RCAPDAT3_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT3_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT3: RCAPDAT Mask             */
S
S#define PWM_FCAPDAT3_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT3: FCAPDAT Position         */
S#define PWM_FCAPDAT3_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT3_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT3: FCAPDAT Mask             */
S
S#define PWM_RCAPDAT4_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT4: RCAPDAT Position         */
S#define PWM_RCAPDAT4_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT4_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT4: RCAPDAT Mask             */
S
S#define PWM_FCAPDAT4_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT4: FCAPDAT Position         */
S#define PWM_FCAPDAT4_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT4_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT4: FCAPDAT Mask             */
S
S#define PWM_RCAPDAT5_RCAPDAT_Pos         (0)                                               /*!< PWM_T::RCAPDAT5: RCAPDAT Position         */
S#define PWM_RCAPDAT5_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT5_RCAPDAT_Pos)            /*!< PWM_T::RCAPDAT5: RCAPDAT Mask             */
S
S#define PWM_FCAPDAT5_FCAPDAT_Pos         (0)                                               /*!< PWM_T::FCAPDAT5: FCAPDAT Position         */
S#define PWM_FCAPDAT5_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT5_FCAPDAT_Pos)            /*!< PWM_T::FCAPDAT5: FCAPDAT Mask             */
S
S#define PWM_PDMACTL_CHEN0_1_Pos          (0)                                               /*!< PWM_T::PDMACTL: CHEN0_1 Position          */
S#define PWM_PDMACTL_CHEN0_1_Msk          (0x1ul << PWM_PDMACTL_CHEN0_1_Pos)                /*!< PWM_T::PDMACTL: CHEN0_1 Mask              */
S
S#define PWM_PDMACTL_CAPMOD0_1_Pos        (1)                                               /*!< PWM_T::PDMACTL: CAPMOD0_1 Position        */
S#define PWM_PDMACTL_CAPMOD0_1_Msk        (0x3ul << PWM_PDMACTL_CAPMOD0_1_Pos)              /*!< PWM_T::PDMACTL: CAPMOD0_1 Mask            */
S
S#define PWM_PDMACTL_CAPORD0_1_Pos        (3)                                               /*!< PWM_T::PDMACTL: CAPORD0_1 Position        */
S#define PWM_PDMACTL_CAPORD0_1_Msk        (0x1ul << PWM_PDMACTL_CAPORD0_1_Pos)              /*!< PWM_T::PDMACTL: CAPORD0_1 Mask            */
S
S#define PWM_PDMACTL_CHSEL0_1_Pos         (4)                                               /*!< PWM_T::PDMACTL: CHSEL0_1 Position         */
S#define PWM_PDMACTL_CHSEL0_1_Msk         (0x1ul << PWM_PDMACTL_CHSEL0_1_Pos)               /*!< PWM_T::PDMACTL: CHSEL0_1 Mask             */
S
S#define PWM_PDMACTL_CHEN2_3_Pos          (8)                                               /*!< PWM_T::PDMACTL: CHEN2_3 Position          */
S#define PWM_PDMACTL_CHEN2_3_Msk          (0x1ul << PWM_PDMACTL_CHEN2_3_Pos)                /*!< PWM_T::PDMACTL: CHEN2_3 Mask              */
S
S#define PWM_PDMACTL_CAPMOD2_3_Pos        (9)                                               /*!< PWM_T::PDMACTL: CAPMOD2_3 Position        */
S#define PWM_PDMACTL_CAPMOD2_3_Msk        (0x3ul << PWM_PDMACTL_CAPMOD2_3_Pos)              /*!< PWM_T::PDMACTL: CAPMOD2_3 Mask            */
S
S#define PWM_PDMACTL_CAPORD2_3_Pos        (11)                                              /*!< PWM_T::PDMACTL: CAPORD2_3 Position        */
S#define PWM_PDMACTL_CAPORD2_3_Msk        (0x1ul << PWM_PDMACTL_CAPORD2_3_Pos)              /*!< PWM_T::PDMACTL: CAPORD2_3 Mask            */
S
S#define PWM_PDMACTL_CHSEL2_3_Pos         (12)                                              /*!< PWM_T::PDMACTL: CHSEL2_3 Position         */
S#define PWM_PDMACTL_CHSEL2_3_Msk         (0x1ul << PWM_PDMACTL_CHSEL2_3_Pos)               /*!< PWM_T::PDMACTL: CHSEL2_3 Mask             */
S
S#define PWM_PDMACTL_CHEN4_5_Pos          (16)                                              /*!< PWM_T::PDMACTL: CHEN4_5 Position          */
S#define PWM_PDMACTL_CHEN4_5_Msk          (0x1ul << PWM_PDMACTL_CHEN4_5_Pos)                /*!< PWM_T::PDMACTL: CHEN4_5 Mask              */
S
S#define PWM_PDMACTL_CAPMOD4_5_Pos        (17)                                              /*!< PWM_T::PDMACTL: CAPMOD4_5 Position        */
S#define PWM_PDMACTL_CAPMOD4_5_Msk        (0x3ul << PWM_PDMACTL_CAPMOD4_5_Pos)              /*!< PWM_T::PDMACTL: CAPMOD4_5 Mask            */
S
S#define PWM_PDMACTL_CAPORD4_5_Pos        (19)                                              /*!< PWM_T::PDMACTL: CAPORD4_5 Position        */
S#define PWM_PDMACTL_CAPORD4_5_Msk        (0x1ul << PWM_PDMACTL_CAPORD4_5_Pos)              /*!< PWM_T::PDMACTL: CAPORD4_5 Mask            */
S
S#define PWM_PDMACTL_CHSEL4_5_Pos         (20)                                              /*!< PWM_T::PDMACTL: CHSEL4_5 Position         */
S#define PWM_PDMACTL_CHSEL4_5_Msk         (0x1ul << PWM_PDMACTL_CHSEL4_5_Pos)               /*!< PWM_T::PDMACTL: CHSEL4_5 Mask             */
S
S#define PWM_PDMACAP0_1_CAPBUF_Pos        (0)                                               /*!< PWM_T::PDMACAP0_1: CAPBUF Position        */
S#define PWM_PDMACAP0_1_CAPBUF_Msk        (0xfffful << PWM_PDMACAP0_1_CAPBUF_Pos)           /*!< PWM_T::PDMACAP0_1: CAPBUF Mask            */
S
S#define PWM_PDMACAP2_3_CAPBUF_Pos        (0)                                               /*!< PWM_T::PDMACAP2_3: CAPBUF Position        */
S#define PWM_PDMACAP2_3_CAPBUF_Msk        (0xfffful << PWM_PDMACAP2_3_CAPBUF_Pos)           /*!< PWM_T::PDMACAP2_3: CAPBUF Mask            */
S
S#define PWM_PDMACAP4_5_CAPBUF_Pos        (0)                                               /*!< PWM_T::PDMACAP4_5: CAPBUF Position        */
S#define PWM_PDMACAP4_5_CAPBUF_Msk        (0xfffful << PWM_PDMACAP4_5_CAPBUF_Pos)           /*!< PWM_T::PDMACAP4_5: CAPBUF Mask            */
S
S#define PWM_CAPIEN_CAPRIENn_Pos          (0)                                               /*!< PWM_T::CAPIEN: CAPRIENn Position          */
S#define PWM_CAPIEN_CAPRIENn_Msk          (0x3ful << PWM_CAPIEN_CAPRIENn_Pos)               /*!< PWM_T::CAPIEN: CAPRIENn Mask              */
S
S#define PWM_CAPIEN_CAPRIEN0_Pos          (0)                                               /*!< PWM_T::CAPIEN: CAPRIEN0 Position          */
S#define PWM_CAPIEN_CAPRIEN0_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN0_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN0 Mask              */
S
S#define PWM_CAPIEN_CAPRIEN1_Pos          (1)                                               /*!< PWM_T::CAPIEN: CAPRIEN1 Position          */
S#define PWM_CAPIEN_CAPRIEN1_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN1_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN1 Mask              */
S
S#define PWM_CAPIEN_CAPRIEN2_Pos          (2)                                               /*!< PWM_T::CAPIEN: CAPRIEN2 Position          */
S#define PWM_CAPIEN_CAPRIEN2_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN2_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN2 Mask              */
S
S#define PWM_CAPIEN_CAPRIEN3_Pos          (3)                                               /*!< PWM_T::CAPIEN: CAPRIEN3 Position          */
S#define PWM_CAPIEN_CAPRIEN3_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN3_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN3 Mask              */
S
S#define PWM_CAPIEN_CAPRIEN4_Pos          (4)                                               /*!< PWM_T::CAPIEN: CAPRIEN4 Position          */
S#define PWM_CAPIEN_CAPRIEN4_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN4_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN4 Mask              */
S
S#define PWM_CAPIEN_CAPRIEN5_Pos          (5)                                               /*!< PWM_T::CAPIEN: CAPRIEN5 Position          */
S#define PWM_CAPIEN_CAPRIEN5_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN5_Pos)                /*!< PWM_T::CAPIEN: CAPRIEN5 Mask              */
S
S#define PWM_CAPIEN_CAPFIENn_Pos          (8)                                               /*!< PWM_T::CAPIEN: CAPFIENn Position          */
S#define PWM_CAPIEN_CAPFIENn_Msk          (0x3ful << PWM_CAPIEN_CAPFIENn_Pos)               /*!< PWM_T::CAPIEN: CAPFIENn Mask              */
S
S#define PWM_CAPIEN_CAPFIEN0_Pos          (8)                                               /*!< PWM_T::CAPIEN: CAPFIEN0 Position          */
S#define PWM_CAPIEN_CAPFIEN0_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN0_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN0 Mask              */
S
S#define PWM_CAPIEN_CAPFIEN1_Pos          (9)                                               /*!< PWM_T::CAPIEN: CAPFIEN1 Position          */
S#define PWM_CAPIEN_CAPFIEN1_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN1_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN1 Mask              */
S
S#define PWM_CAPIEN_CAPFIEN2_Pos          (10)                                              /*!< PWM_T::CAPIEN: CAPFIEN2 Position          */
S#define PWM_CAPIEN_CAPFIEN2_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN2_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN2 Mask              */
S
S#define PWM_CAPIEN_CAPFIEN3_Pos          (11)                                              /*!< PWM_T::CAPIEN: CAPFIEN3 Position          */
S#define PWM_CAPIEN_CAPFIEN3_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN3_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN3 Mask              */
S
S#define PWM_CAPIEN_CAPFIEN4_Pos          (12)                                              /*!< PWM_T::CAPIEN: CAPFIEN4 Position          */
S#define PWM_CAPIEN_CAPFIEN4_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN4_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN4 Mask              */
S
S#define PWM_CAPIEN_CAPFIEN5_Pos          (13)                                              /*!< PWM_T::CAPIEN: CAPFIEN5 Position          */
S#define PWM_CAPIEN_CAPFIEN5_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN5_Pos)                /*!< PWM_T::CAPIEN: CAPFIEN5 Mask              */
S
S#define PWM_CAPIF_CRLIFn_Pos             (0)                                               /*!< PWM_T::CAPIF: CRLIFn Position             */
S#define PWM_CAPIF_CRLIFn_Msk             (0x3ful << PWM_CAPIF_CRLIFn_Pos)                  /*!< PWM_T::CAPIF: CRLIFn Mask                 */
S
S#define PWM_CAPIF_CRLIF0_Pos             (0)                                               /*!< PWM_T::CAPIF: CRLIF0 Position             */
S#define PWM_CAPIF_CRLIF0_Msk             (0x1ul << PWM_CAPIF_CRLIF0_Pos)                   /*!< PWM_T::CAPIF: CRLIF0 Mask                 */
S
S#define PWM_CAPIF_CRLIF1_Pos             (1)                                               /*!< PWM_T::CAPIF: CRLIF1 Position             */
S#define PWM_CAPIF_CRLIF1_Msk             (0x1ul << PWM_CAPIF_CRLIF1_Pos)                   /*!< PWM_T::CAPIF: CRLIF1 Mask                 */
S
S#define PWM_CAPIF_CRLIF2_Pos             (2)                                               /*!< PWM_T::CAPIF: CRLIF2 Position             */
S#define PWM_CAPIF_CRLIF2_Msk             (0x1ul << PWM_CAPIF_CRLIF2_Pos)                   /*!< PWM_T::CAPIF: CRLIF2 Mask                 */
S
S#define PWM_CAPIF_CRLIF3_Pos             (3)                                               /*!< PWM_T::CAPIF: CRLIF3 Position             */
S#define PWM_CAPIF_CRLIF3_Msk             (0x1ul << PWM_CAPIF_CRLIF3_Pos)                   /*!< PWM_T::CAPIF: CRLIF3 Mask                 */
S
S#define PWM_CAPIF_CRLIF4_Pos             (4)                                               /*!< PWM_T::CAPIF: CRLIF4 Position             */
S#define PWM_CAPIF_CRLIF4_Msk             (0x1ul << PWM_CAPIF_CRLIF4_Pos)                   /*!< PWM_T::CAPIF: CRLIF4 Mask                 */
S
S#define PWM_CAPIF_CRLIF5_Pos             (5)                                               /*!< PWM_T::CAPIF: CRLIF5 Position             */
S#define PWM_CAPIF_CRLIF5_Msk             (0x1ul << PWM_CAPIF_CRLIF5_Pos)                   /*!< PWM_T::CAPIF: CRLIF5 Mask                 */
S
S#define PWM_CAPIF_CFLIFn_Pos             (8)                                               /*!< PWM_T::CAPIF: CFLIFn Position             */
S#define PWM_CAPIF_CFLIFn_Msk             (0x3ful << PWM_CAPIF_CFLIFn_Pos)                  /*!< PWM_T::CAPIF: CFLIFn Mask                 */
S
S#define PWM_CAPIF_CFLIF0_Pos             (8)                                               /*!< PWM_T::CAPIF: CFLIF0 Position             */
S#define PWM_CAPIF_CFLIF0_Msk             (0x1ul << PWM_CAPIF_CFLIF0_Pos)                   /*!< PWM_T::CAPIF: CFLIF0 Mask                 */
S
S#define PWM_CAPIF_CFLIF1_Pos             (9)                                               /*!< PWM_T::CAPIF: CFLIF1 Position             */
S#define PWM_CAPIF_CFLIF1_Msk             (0x1ul << PWM_CAPIF_CFLIF1_Pos)                   /*!< PWM_T::CAPIF: CFLIF1 Mask                 */
S
S#define PWM_CAPIF_CFLIF2_Pos             (10)                                              /*!< PWM_T::CAPIF: CFLIF2 Position             */
S#define PWM_CAPIF_CFLIF2_Msk             (0x1ul << PWM_CAPIF_CFLIF2_Pos)                   /*!< PWM_T::CAPIF: CFLIF2 Mask                 */
S
S#define PWM_CAPIF_CFLIF3_Pos             (11)                                              /*!< PWM_T::CAPIF: CFLIF3 Position             */
S#define PWM_CAPIF_CFLIF3_Msk             (0x1ul << PWM_CAPIF_CFLIF3_Pos)                   /*!< PWM_T::CAPIF: CFLIF3 Mask                 */
S
S#define PWM_CAPIF_CFLIF4_Pos             (12)                                              /*!< PWM_T::CAPIF: CFLIF4 Position             */
S#define PWM_CAPIF_CFLIF4_Msk             (0x1ul << PWM_CAPIF_CFLIF4_Pos)                   /*!< PWM_T::CAPIF: CFLIF4 Mask                 */
S
S#define PWM_CAPIF_CFLIF5_Pos             (13)                                              /*!< PWM_T::CAPIF: CFLIF5 Position             */
S#define PWM_CAPIF_CFLIF5_Msk             (0x1ul << PWM_CAPIF_CFLIF5_Pos)                   /*!< PWM_T::CAPIF: CFLIF5 Mask                 */
S
S#define PWM_PBUF_PBUF_Pos                (0)                                               /*!< PWM_T::PBUF: PBUF Position                */
S#define PWM_PBUF_PBUF_Msk                (0xfffful << PWM_PBUF_PBUF_Pos)                   /*!< PWM_T::PBUF: PBUF Mask                    */
S
S#define PWM_CMPBUF_CMPBUF_Pos            (0)                                               /*!< PWM_T::CMPBUF: CMPBUF Position            */
S#define PWM_CMPBUF_CMPBUF_Msk            (0xfffful << PWM_CMPBUF_CMPBUF_Pos)               /*!< PWM_T::CMPBUF: CMPBUF Mask                */
S
S#define PWM_FTCBUF0_1_FTCMPBUF_Pos       (0)                                               /*!< PWM_T::FTCBUF0_1: FTCMPBUF Position       */
S#define PWM_FTCBUF0_1_FTCMPBUF_Msk       (0xfffful << PWM_FTCBUF0_1_FTCMPBUF_Pos)          /*!< PWM_T::FTCBUF0_1: FTCMPBUF Mask           */
S
S#define PWM_FTCBUF2_3_FTCMPBUF_Pos       (0)                                               /*!< PWM_T::FTCBUF2_3: FTCMPBUF Position       */
S#define PWM_FTCBUF2_3_FTCMPBUF_Msk       (0xfffful << PWM_FTCBUF2_3_FTCMPBUF_Pos)          /*!< PWM_T::FTCBUF2_3: FTCMPBUF Mask           */
S
S#define PWM_FTCBUF4_5_FTCMPBUF_Pos       (0)                                               /*!< PWM_T::FTCBUF4_5: FTCMPBUF Position       */
S#define PWM_FTCBUF4_5_FTCMPBUF_Msk       (0xfffful << PWM_FTCBUF4_5_FTCMPBUF_Pos)          /*!< PWM_T::FTCBUF4_5: FTCMPBUF Mask           */
S
S#define PWM_FTCI_FTCMUn_Pos              (0)                                               /*!< PWM_T::FTCI: FTCMUn Position              */
S#define PWM_FTCI_FTCMUn_Msk              (0x7ul << PWM_FTCI_FTCMUn_Pos)                    /*!< PWM_T::FTCI: FTCMUn Mask                  */
S
S#define PWM_FTCI_FTCMU0_Pos              (0)                                               /*!< PWM_T::FTCI: FTCMU0 Position              */
S#define PWM_FTCI_FTCMU0_Msk              (0x1ul << PWM_FTCI_FTCMU0_Pos)                    /*!< PWM_T::FTCI: FTCMU0 Mask                  */
S
S#define PWM_FTCI_FTCMU2_Pos              (1)                                               /*!< PWM_T::FTCI: FTCMU2 Position              */
S#define PWM_FTCI_FTCMU2_Msk              (0x1ul << PWM_FTCI_FTCMU2_Pos)                    /*!< PWM_T::FTCI: FTCMU2 Mask                  */
S
S#define PWM_FTCI_FTCMU4_Pos              (2)                                               /*!< PWM_T::FTCI: FTCMU4 Position              */
S#define PWM_FTCI_FTCMU4_Msk              (0x1ul << PWM_FTCI_FTCMU4_Pos)                    /*!< PWM_T::FTCI: FTCMU4 Mask                  */
S
S#define PWM_FTCI_FTCMDn_Pos              (8)                                               /*!< PWM_T::FTCI: FTCMDn Position              */
S#define PWM_FTCI_FTCMDn_Msk              (0x7ul << PWM_FTCI_FTCMDn_Pos)                    /*!< PWM_T::FTCI: FTCMDn Mask                  */
S
S#define PWM_FTCI_FTCMD0_Pos              (8)                                               /*!< PWM_T::FTCI: FTCMD0 Position              */
S#define PWM_FTCI_FTCMD0_Msk              (0x1ul << PWM_FTCI_FTCMD0_Pos)                    /*!< PWM_T::FTCI: FTCMD0 Mask                  */
S
S#define PWM_FTCI_FTCMD2_Pos              (9)                                               /*!< PWM_T::FTCI: FTCMD2 Position              */
S#define PWM_FTCI_FTCMD2_Msk              (0x1ul << PWM_FTCI_FTCMD2_Pos)                    /*!< PWM_T::FTCI: FTCMD2 Mask                  */
S
S#define PWM_FTCI_FTCMD4_Pos              (10)                                              /*!< PWM_T::FTCI: FTCMD4 Position              */
S#define PWM_FTCI_FTCMD4_Msk              (0x1ul << PWM_FTCI_FTCMD4_Pos)                    /*!< PWM_T::FTCI: FTCMD4 Mask                  */
S
S/**@}*/ /* PWM_CONST */
S/**@}*/ /* end of PWM register group */
S
S
S/*---------------------- Real Time Clock Controller -------------------------*/
S/**
S    @addtogroup RTC Real Time Clock Controller(RTC)
S    Memory Mapped Structure for RTC Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S
S
S/**
S * @var RTC_T::INIT
S * Offset: 0x00  RTC Initiation Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |INIT[0]/ACTIVE|RTC Active Status (Read Only)
S * |        |          |0 = RTC is at reset state.
S * |        |          |1 = RTC is at normal active state.
S * |[31:1]  |INIT[31:1]|RTC Initiation
S * |        |          |When RTC block is powered on, RTC is at reset state.
S * |        |          |User has to write a number (0x a5eb1357) to INIT to make RTC leaving reset state.
S * |        |          |Once the INIT is written as 0xa5eb1357, the RTC will be in un-reset state permanently.
S * |        |          |The INIT is a write-only field and read value will be always 0.
S * @var RTC_T::RWEN
S * Offset: 0x04  RTC Access Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |RWEN      |RTC Register Access Enable Password (Write Only)
S * |        |          |Writing 0xA965 to this register will enable RTC access and keep 1024 RTC clock.
S * |[16]    |RWENF     |RTC Register Access Enable Flag (Read Only)
S * |        |          |0 = RTC register read/write Disabled.
S * |        |          |1 = RTC register read/write Enabled.
S * |        |          |This bit will be set after RTC_RWEN[15:0] register is load a 0xA965, and be cleared automatically after 1024 RTC clock.
S * @var RTC_T::FREQADJ
S * Offset: 0x08  RTC Frequency Compensation Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |FRACTION  |Fraction Part
S * |        |          |Formula = (fraction part of detected value) x 60.
S * |        |          |Note: Digit in RTC_FREQADJ must be expressed as hexadecimal number.
S * |[11:8]  |INTEGER   |Integer Part
S * @var RTC_T::TIME
S * Offset: 0x0C  Time Loading Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |SEC       |1-Sec Time Digit (0~9)
S * |[6:4]   |TENSEC    |10-Sec Time Digit (0~5)
S * |[11:8]  |MIN       |1-Min Time Digit (0~9)
S * |[14:12] |TENMIN    |10-Min Time Digit (0~5)
S * |[19:16] |HR        |1-Hour Time Digit (0~9)
S * |[21:20] |TENHR     |10-Hour Time Digit (0~2)
S * @var RTC_T::CAL
S * Offset: 0x10  RTC Calendar Loading Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |DAY       |1-Day Calendar Digit (0~9)
S * |[5:4]   |TENDAY    |10-Day Calendar Digit (0~3)
S * |[11:8]  |MON       |1-Month Calendar Digit (0~9)
S * |[12]    |TENMON    |10-Month Calendar Digit (0~1)
S * |[19:16] |YEAR      |1-Year Calendar Digit (0~9)
S * |[23:20] |TENYEAR   |10-Year Calendar Digit (0~9)
S * @var RTC_T::CLKFMT
S * Offset: 0x14  Time Scale Selection Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |24HEN     |24-Hour / 12-Hour Time Scale Selection
S * |        |          |Indicates that RTC_TIME and RTC_TALM are in 24-hour time scale or 12-hour time scale
S * |        |          |0 = 12-hour time scale with AM and PM indication selected.
S * |        |          |1 = 24-hour time scale selected.
S * @var RTC_T::WEEKDAY
S * Offset: 0x18  Day of the Week Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[2:0]   |WEEKDAY   |Day Of The Week Register
S * |        |          |000 = Sunday.
S * |        |          |001 = Monday.
S * |        |          |010 = Tuesday.
S * |        |          |011 = Wednesday.
S * |        |          |100 = Thursday.
S * |        |          |101 = Friday.
S * |        |          |110 = Saturday.
S * |        |          |111 = Reserved.
S * @var RTC_T::TALM
S * Offset: 0x1C  Time Alarm Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |SEC       |1-Sec Time Digit of Alarm Setting (0~9)
S * |[6:4]   |TENSEC    |10-Sec Time Digit of Alarm Setting (0~5)
S * |[11:8]  |MIN       |1-Min Time Digit of Alarm Setting (0~9)
S * |[14:12] |TENMIN    |10-Min Time Digit of Alarm Setting (0~5)
S * |[19:16] |HR        |1-Hour Time Digit of Alarm Setting (0~9)
S * |[21:20] |TENHR     |10-Hour Time Digit of Alarm Setting (0~2)
S * @var RTC_T::CALM
S * Offset: 0x20  Calendar Alarm Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |DAY       |1-Day Calendar Digit of Alarm Setting (0~9)
S * |[5:4]   |TENDAY    |10-Day Calendar Digit of Alarm Setting (0~3)
S * |[11:8]  |MON       |1-Month Calendar Digit of Alarm Setting (0~9)
S * |[12]    |TENMON    |10-Month Calendar Digit of Alarm Setting (0~1)
S * |[19:16] |YEAR      |1-Year Calendar Digit of Alarm Setting (0~9)
S * |[23:20] |TENYEAR   |10-Year Calendar Digit of Alarm Setting (0~9)
S * @var RTC_T::LEAPYEAR
S * Offset: 0x24  RTC Leap Year Indicator Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |LEAPYEAR  |Leap Year Indication Register (Read Only)
S * |        |          |0 = This year is not a leap year.
S * |        |          |1 = This year is leap year.
S * @var RTC_T::INTEN
S * Offset: 0x28  RTC Interrupt Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ALMIEN    |Alarm Interrupt Enable Bit
S * |        |          |0 = RTC Alarm interrupt Disabled.
S * |        |          |1 = RTC Alarm interrupt Enabled.
S * |[1]     |TICKIEN   |Time Tick Interrupt Enable Bit
S * |        |          |0 = RTC Time Tick interrupt Disabled.
S * |        |          |1 = RTC Time Tick interrupt Enabled.
S * |[2]     |SNPDIEN   |Snoop Detection Interrupt Enable Bit
S * |        |          |0 = Snoop detected interrupt Disabled.
S * |        |          |1 = Snoop detected interrupt Enabled.
S * @var RTC_T::INTSTS
S * Offset: 0x2C  RTC Interrupt Indicator Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ALMIF     |RTC Alarm Interrupt Flag
S * |        |          |When RTC time counters RTC_TIME and RTC_CAL match the alarm setting time registers RTC_TALM and RTC_CALM, this bit will be set to 1 and an interrupt will be generated if RTC Alarm Interrupt enabled ALMIEN (RTC_INTEN[0]) is set to 1.
S * |        |          |Chip will be waken up if RTC Alarm Interrupt is enabled when chip is at Power-down mode.
S * |        |          |0 = Alarm condition is not matched.
S * |        |          |1 = Alarm condition is matched.
S * |        |          |Note: Write 1 to clear this bit.
S * |[1]     |TICKIF    |RTC Time Tick Interrupt Flag
S * |        |          |When RTC time tick happened, this bit will be set to 1 and an interrupt will be generated if RTC Tick Interrupt enabled TICKIEN (RTC_INTEN[1]) is set to 1.
S * |        |          |Chip will also be waken up if RTC Tick Interrupt is enabled and this bit is set to 1 when chip is running at Power-down mode.
S * |        |          |0 = Tick condition does not occur.
S * |        |          |1 = Tick condition occur.
S * |        |          |Note: Write 1 to clear to clear this bit.
S * |[2]     |SNPDIF    |Snoop Detect Interrupt Flag
S * |        |          |When tamper pin transition event is detected, this bit is set to 1 and an interrupt is generated if Snoop Detection Interrupt enabled SNPDIEN (RTC_INTEN[2]) is set to1.
S * |        |          |Chip will be waken up from Power-down mode if spare register snooper detect interrupt is enabled.
S * |        |          |0 = No snoop event is detected.
S * |        |          |1 = Snoop event is detected.
S * |        |          |Note: Write 1 to clear this bit.
S * @var RTC_T::TICK
S * Offset: 0x30  RTC Time Tick Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[2:0]   |TICK      |Time Tick Register
S * |        |          |These bits are used to select RTC time tick period for Periodic Time Tick Interrupt request.
S * |        |          |000 = Time tick is 1 second.
S * |        |          |001 = Time tick is 1/2 second.
S * |        |          |010 = Time tick is 1/4 second.
S * |        |          |011 = Time tick is 1/8 second.
S * |        |          |100 = Time tick is 1/16 second.
S * |        |          |101 = Time tick is 1/32 second.
S * |        |          |110 = Time tick is 1/64 second.
S * |        |          |111 = Time tick is 1/28 second.
S * |        |          |Note: This register can be read back after the RTC register access enable bit RWENF (RTC_RWEN[16]) is active.
S * @var RTC_T::TAMSK
S * Offset: 0x34  Time Alarm Mask Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |MSEC      |Mask 1-Sec Time Digit of Alarm Setting (0~9)
S * |[1]     |MTENSEC   |Mask 10-Sec Time Digit of Alarm Setting (0~5)
S * |[2]     |MMIN      |Mask 1-Min Time Digit of Alarm Setting (0~9)
S * |[3]     |MTENMIN   |Mask 10-Min Time Digit of Alarm Setting (0~5)
S * |[4]     |MHR       |Mask 1-Hour Time Digit of Alarm Setting (0~9)
S * |[5]     |MTENHR    |Mask 10-Hour Time Digit of Alarm Setting (0~2)
S * @var RTC_T::CAMSK
S * Offset: 0x38  Calendar Alarm Mask Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |MDAY      |Mask 1-Day Calendar Digit of Alarm Setting (0~9)
S * |[1]     |MTENDAY   |Mask 10-Day Calendar Digit of Alarm Setting (0~3)
S * |[2]     |MMON      |Mask 1-Month Calendar Digit of Alarm Setting (0~9)
S * |[3]     |MTENMON   |Mask 10-Month Calendar Digit of Alarm Setting (0~1)
S * |[4]     |MYEAR     |Mask 1-Year Calendar Digit of Alarm Setting (0~9)
S * |[5]     |MTENYEAR  |Mask 10-Year Calendar Digit of Alarm Setting (0~9)
S * @var RTC_T::SPRCTL
S * Offset: 0x3C  RTC Spare Functional Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |SNPDEN    |Snoop Detection Enable Bit
S * |        |          |0 = TAMPER pin detection is Disabled.
S * |        |          |1 = TAMPER pin detection is Enabled.
S * |[1]     |SNPTYPE0  |Snoop Detection Level
S * |        |          |This bit controls TAMPER detect event is high level/rising edge or low level/falling edge.
S * |        |          |0 = Low level/Falling edge detection.
S * |        |          |1 = High level/Rising edge detection.
S * |[2]     |SPRRWEN   |Spare Register Enable Bit
S * |        |          |0 = Spare register is Disabled.
S * |        |          |1 = Spare register is Enabled.
S * |        |          |Note: When spare register is disabled, RTC_SPR0 ~ RTC_SPR19 cannot be accessed.
S * |[3]     |SNPTYPE1  |Snoop Detection Mode
S * |        |          |This bit controls TAMPER pin is edge or level detection
S * |        |          |0 = Level detection.
S * |        |          |1 = Edge detection.
S * |[5]     |SPRCSTS   |SPR Clear Flag
S * |        |          |This bit indicates if the RTC_SPR0 ~RTC_SPR19 content is cleared when specify snoop event is detected.
S * |        |          |0 = Spare register content is not cleared.
S * |        |          |1 = Spare register content is cleared.
S * |        |          |Writes 1 to clear this bit.
S * |[7]     |SPRRWRDY  |SPR Register Ready
S * |        |          |This bit indicates if the registers RTC_SPRCTL, RTC_SPR0 ~ RTC_SPR19 are ready to be accessed.
S * |        |          |After user writing registers RTC_SPRCTL, RTC_SPR0 ~ RTC_SPR19, read this bit to check if these registers are updated done is necessary.
S * |        |          |0 = RTC_SPRCTL, RTC_SPR0 ~ RTC_SPR19 updating is in progress.
S * |        |          |1 = RTC_SPRCTL, RTC_SPR0 ~ RTC_SPR19 are updated done and ready to be accessed.
S * |        |          |Note: This bit is read only and any write to it won't take any effect.
S * @var RTC_T::SPR
S * Offset: 0x40 ~ 0x8C  RTC Spare Register 0 ~ 19
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |SPARE     |Spare Register
S * |        |          |This field is used to store back-up information defined by user.
S * |        |          |This field will be cleared by hardware automatically once a snooper pin event is detected.
S * |        |          |Before storing back-up information in to RTC_SPRx register, user should write 0xA965 to RTC_RWEN[15:0] to make sure register read/write enable bit REWNF (RTC_RWEN[16]) is enabled.
S * @var RTC_T::LXTCTL
S * Offset: 0x100  RTC 32.768 kHz Oscillator Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |LXTEN     |Backup Domain 32K Oscillator Enable Bit
S * |        |          |0 = Oscillator is Disabled.
S * |        |          |1 = Oscillator is Enabled.
S * |        |          |This bit controls 32 kHz oscillator on/off.
S * |        |          |User can set either LXTEN in RTC domain or system manager control register CLK_PWRCTL[1] (LXTEN) to enable 32 kHz oscillator.
S * |        |          |If this bit is set 1, X32 kHz oscillator keep running after system power is turned off, if this bit is clear to 0, oscillator is turned off when system power is turned off.
S * |[3:1]   |GAIN      |Oscillator Gain Option
S * |        |          |User can select oscillator gain according to crystal external loading and operating temperature range.
S * |        |          |The larger gain value corresponding to stronger driving capability and higher power consumption.
S * |        |          |000 = L0 mode.
S * |        |          |001 = L1 mode.
S * |        |          |010 = L2 mode.
S * |        |          |011 = L3 mode.
S * |        |          |100 = L4 mode.
S * |        |          |101 = L5 mode.
S * |        |          |110 = L6 mode.
S * |        |          |111 = L7 mode (Default).
S * @var RTC_T::LXTOCTL
S * Offset: 0x104  X32KO Pin Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |OPMODE    |GPF0 Operation Mode
S * |        |          |00 = X32KO (PF.0) is input only mode, without pull-up resistor.
S * |        |          |01 = X32KO (PF.0) is output push pull mode.
S * |        |          |10 = X32KO (PF.0) is open drain mode.
S * |        |          |11 = X32KO (PF.0) is input only mode with internal pull up.
S * |[2]     |DOUT      |IO Output Data
S * |        |          |0 = X32KO (PF.0) output low.
S * |        |          |1 = X32KO (PF.0) output high.
S * |[3]     |CTLSEL    |IO Pin State Backup Selection
S * |        |          |When low speed 32 kHz oscillator is disabled, X32KO (PF.0) pin can be used as GPIO function.
S * |        |          |User can program CTLSEL bit to decide X32KO (PF.0) I/O function is controlled by system power domain GPIO module or VBAT power domain RTC_LXTOCTL control register.
S * |        |          |0 = X32KO (PF.0) pin I/O function is controlled by GPIO module.
S * |        |          |It becomes floating when system power is turned off.
S * |        |          |1 = X32KO (PF.0) pin I/O function is controlled by VBAT power domain, X32KO (PF.0) pin function and I/O status are controlled by OPMODE[1:0] and DOUT after CTLSEL it set to 1.
S * |        |          |I/O pin keeps the previous state after system power is turned off.
S * @var RTC_T::LXTICTL
S * Offset: 0x108  X32KI Pin Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |OPMODE    |IO Operation Mode
S * |        |          |00 = X32KI (PF.1) is input only mode, without pull-up resistor.
S * |        |          |01 = X32KI (PF.1) is output push pull mode.
S * |        |          |10 = X32KI (PF.1) is open drain mode.
S * |        |          |11 = X32KI (PF.1) is input only mode with internal pull up.
S * |[2]     |DOUT      |IO Output Data
S * |        |          |0 = X32KI (PF.1) output low.
S * |        |          |1 = X32KI (PF.1) output high.
S * |[3]     |CTLSEL    |IO Pin State Backup Selection
S * |        |          |When low speed 32 kHz oscillator is disabled, X32KI (PF.1) pin can be used as GPIO function.
S * |        |          |User can program CTLSEL bit to decide X32KI (PF.1) I/O function is controlled by system power domain GPIO module or VBAT power domain RTC_LXTICTL control register.
S * |        |          |0 = X32KI (PF.1) pin I/O function is controlled by GPIO module.
S * |        |          |It becomes floating state when system power is turned off.
S * |        |          |1 = X32KI (PF.1) pin I/O function is controlled by VBAT power domain, X32KI (PF.1) pin function and I/O status are controlled by OPMODE[1:0] and DOUT after CTLSEL it set to 1.
S * |        |          |I/O pin keeps the previous state after system power is turned off.
S * @var RTC_T::TAMPCTL
S * Offset: 0x10C  TAMPER Pin Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |OPMODE    |IO Operation Mode
S * |        |          |00 = TAMPER (PF.2) is input only mode, without pull-up resistor.
S * |        |          |01 = TAMPER (PF.2) is output push pull mode.
S * |        |          |10 = TAMPER (PF.2) is open drain mode.
S * |        |          |11 = TAMPER (PF.2) is input only mode with internal pull up.
S * |[2]     |DOUT      |IO Output Data
S * |        |          |0 = TAMPER (PF.2) output low.
S * |        |          |1 = TAMPER (PF.2) output high.
S * |[3]     |CTLSEL    |IO Pin State Backup Selection
S * |        |          |When tamper function is disabled, TAMPER pin can be used as GPIO function.
S * |        |          |User can program CTLSEL bit to decide PF.2 I/O function is controlled by system power domain GPIO module or VBAT power domain RTC_TAMPCTL control register.
S * |        |          |0 =TAMPER (PF.2) I/O function is controlled by GPIO module.
S * |        |          |It becomes floating state when system power is turned off.
S * |        |          |1 =TAMPER (PF.2) I/O function is controlled by VBAT power domain.
S * |        |          |PF.2 function and I/O status are controlled by OPMODE[1:0] and DOUT after CTLSEL it set to 1.
S * |        |          |I/O pin state keeps previous state after system power is turned off.
S */
S
S    __IO uint32_t INIT;          /* Offset: 0x00  RTC Initiation Register                                            */
S    __O  uint32_t RWEN;          /* Offset: 0x04  RTC Access Enable Register                                         */
S    __IO uint32_t FREQADJ;       /* Offset: 0x08  RTC Frequency Compensation Register                                */
S    __IO uint32_t TIME;          /* Offset: 0x0C  Time Loading Register                                              */
S    __IO uint32_t CAL;           /* Offset: 0x10  RTC Calendar Loading Register                                      */
S    __IO uint32_t CLKFMT;        /* Offset: 0x14  Time Scale Selection Register                                      */
S    __IO uint32_t WEEKDAY;       /* Offset: 0x18  Day of the Week Register                                           */
S    __IO uint32_t TALM;          /* Offset: 0x1C  Time Alarm Register                                                */
S    __IO uint32_t CALM;          /* Offset: 0x20  Calendar Alarm Register                                            */
S    __I  uint32_t LEAPYEAR;      /* Offset: 0x24  RTC Leap Year Indicator Register                                   */
S    __IO uint32_t INTEN;         /* Offset: 0x28  RTC Interrupt Enable Register                                      */
S    __IO uint32_t INTSTS;        /* Offset: 0x2C  RTC Interrupt Indicator Register                                   */
S    __IO uint32_t TICK;          /* Offset: 0x30  RTC Time Tick Register                                             */
S    __IO uint32_t TAMSK;         /* Offset: 0x34  Time Alarm Mask Register                                           */
S    __IO uint32_t CAMSK;         /* Offset: 0x38  Calendar Alarm Mask Register                                       */
S    __IO uint32_t SPRCTL;        /* Offset: 0x3C  RTC Spare Functional Control Register                              */
S    __IO uint32_t SPR[20];       /* Offset: 0x40 ~ 0x8C  RTC Spare Register 0 ~ 19                                   */
S    __I  uint32_t RESERVE0[28]; 
S    __IO uint32_t LXTCTL;        /* Offset: 0x100  RTC 32.768 kHz Oscillator Control Register                        */
S    __IO uint32_t LXTOCTL;       /* Offset: 0x104  X32KO Pin Control Register                                        */
S    __IO uint32_t LXTICTL;       /* Offset: 0x108  X32KI Pin Control Register                                        */
S    __IO uint32_t TAMPCTL;       /* Offset: 0x10C  TAMPER Pin Control Register                                       */
S
S} RTC_T;
S
S
S
S/**
S    @addtogroup RTC_CONST RTC Bit Field Definition
S    Constant Definitions for RTC Controller
S@{ */
S
S#define RTC_INIT_ACTIVE_Pos              (0)                                               /*!< RTC_T::INIT: ACTIVE Position              */
S#define RTC_INIT_ACTIVE_Msk              (0x1ul << RTC_INIT_ACTIVE_Pos)                    /*!< RTC_T::INIT: ACTIVE Mask                  */
S
S#define RTC_INIT_INIT_Pos                (0)                                               /*!< RTC_T::INIT: INIT Position                */
S#define RTC_INIT_INIT_Msk                (0xfffffffful << RTC_INIT_INIT_Pos)               /*!< RTC_T::INIT: INIT Mask                    */
S
S#define RTC_RWEN_RWEN_Pos                (0)                                               /*!< RTC_T::RWEN: RWEN Position                */
S#define RTC_RWEN_RWEN_Msk                (0xfffful << RTC_RWEN_RWEN_Pos)                   /*!< RTC_T::RWEN: RWEN Mask                    */
S
S#define RTC_RWEN_RWENF_Pos               (16)                                              /*!< RTC_T::RWEN: RWENF Position               */
S#define RTC_RWEN_RWENF_Msk               (0x1ul << RTC_RWEN_RWENF_Pos)                     /*!< RTC_T::RWEN: RWENF Mask                   */
S
S#define RTC_FREQADJ_FRACTION_Pos         (0)                                               /*!< RTC_T::FREQADJ: FRACTION Position         */
S#define RTC_FREQADJ_FRACTION_Msk         (0x3ful << RTC_FREQADJ_FRACTION_Pos)              /*!< RTC_T::FREQADJ: FRACTION Mask             */
S
S#define RTC_FREQADJ_INTEGER_Pos          (8)                                               /*!< RTC_T::FREQADJ: INTEGER Position          */
S#define RTC_FREQADJ_INTEGER_Msk          (0xful << RTC_FREQADJ_INTEGER_Pos)                /*!< RTC_T::FREQADJ: INTEGER Mask              */
S
S#define RTC_TIME_SEC_Pos                 (0)                                               /*!< RTC_T::TIME: SEC Position                 */
S#define RTC_TIME_SEC_Msk                 (0xful << RTC_TIME_SEC_Pos)                       /*!< RTC_T::TIME: SEC Mask                     */
S
S#define RTC_TIME_TENSEC_Pos              (4)                                               /*!< RTC_T::TIME: TENSEC Position              */
S#define RTC_TIME_TENSEC_Msk              (0x7ul << RTC_TIME_TENSEC_Pos)                    /*!< RTC_T::TIME: TENSEC Mask                  */
S
S#define RTC_TIME_MIN_Pos                 (8)                                               /*!< RTC_T::TIME: MIN Position                 */
S#define RTC_TIME_MIN_Msk                 (0xful << RTC_TIME_MIN_Pos)                       /*!< RTC_T::TIME: MIN Mask                     */
S
S#define RTC_TIME_TENMIN_Pos              (12)                                              /*!< RTC_T::TIME: TENMIN Position              */
S#define RTC_TIME_TENMIN_Msk              (0x7ul << RTC_TIME_TENMIN_Pos)                    /*!< RTC_T::TIME: TENMIN Mask                  */
S
S#define RTC_TIME_HR_Pos                  (16)                                              /*!< RTC_T::TIME: HR Position                  */
S#define RTC_TIME_HR_Msk                  (0xful << RTC_TIME_HR_Pos)                        /*!< RTC_T::TIME: HR Mask                      */
S
S#define RTC_TIME_TENHR_Pos               (20)                                              /*!< RTC_T::TIME: TENHR Position               */
S#define RTC_TIME_TENHR_Msk               (0x3ul << RTC_TIME_TENHR_Pos)                     /*!< RTC_T::TIME: TENHR Mask                   */
S
S#define RTC_CAL_DAY_Pos                  (0)                                               /*!< RTC_T::CAL: DAY Position                  */
S#define RTC_CAL_DAY_Msk                  (0xful << RTC_CAL_DAY_Pos)                        /*!< RTC_T::CAL: DAY Mask                      */
S
S#define RTC_CAL_TENDAY_Pos               (4)                                               /*!< RTC_T::CAL: TENDAY Position               */
S#define RTC_CAL_TENDAY_Msk               (0x3ul << RTC_CAL_TENDAY_Pos)                     /*!< RTC_T::CAL: TENDAY Mask                   */
S
S#define RTC_CAL_MON_Pos                  (8)                                               /*!< RTC_T::CAL: MON Position                  */
S#define RTC_CAL_MON_Msk                  (0xful << RTC_CAL_MON_Pos)                        /*!< RTC_T::CAL: MON Mask                      */
S
S#define RTC_CAL_TENMON_Pos               (12)                                              /*!< RTC_T::CAL: TENMON Position               */
S#define RTC_CAL_TENMON_Msk               (0x1ul << RTC_CAL_TENMON_Pos)                     /*!< RTC_T::CAL: TENMON Mask                   */
S
S#define RTC_CAL_YEAR_Pos                 (16)                                              /*!< RTC_T::CAL: YEAR Position                 */
S#define RTC_CAL_YEAR_Msk                 (0xful << RTC_CAL_YEAR_Pos)                       /*!< RTC_T::CAL: YEAR Mask                     */
S
S#define RTC_CAL_TENYEAR_Pos              (20)                                              /*!< RTC_T::CAL: TENYEAR Position              */
S#define RTC_CAL_TENYEAR_Msk              (0xful << RTC_CAL_TENYEAR_Pos)                    /*!< RTC_T::CAL: TENYEAR Mask                  */
S
S#define RTC_CLKFMT_24HEN_Pos             (0)                                               /*!< RTC_T::CLKFMT: 24HEN Position             */
S#define RTC_CLKFMT_24HEN_Msk             (0x1ul << RTC_CLKFMT_24HEN_Pos)                   /*!< RTC_T::CLKFMT: 24HEN Mask                 */
S
S#define RTC_WEEKDAY_WEEKDAY_Pos          (0)                                               /*!< RTC_T::WEEKDAY: WEEKDAY Position          */
S#define RTC_WEEKDAY_WEEKDAY_Msk          (0x7ul << RTC_WEEKDAY_WEEKDAY_Pos)                /*!< RTC_T::WEEKDAY: WEEKDAY Mask              */
S
S#define RTC_TALM_SEC_Pos                 (0)                                               /*!< RTC_T::TALM: SEC Position                 */
S#define RTC_TALM_SEC_Msk                 (0xful << RTC_TALM_SEC_Pos)                       /*!< RTC_T::TALM: SEC Mask                     */
S
S#define RTC_TALM_TENSEC_Pos              (4)                                               /*!< RTC_T::TALM: TENSEC Position              */
S#define RTC_TALM_TENSEC_Msk              (0x7ul << RTC_TALM_TENSEC_Pos)                    /*!< RTC_T::TALM: TENSEC Mask                  */
S
S#define RTC_TALM_MIN_Pos                 (8)                                               /*!< RTC_T::TALM: MIN Position                 */
S#define RTC_TALM_MIN_Msk                 (0xful << RTC_TALM_MIN_Pos)                       /*!< RTC_T::TALM: MIN Mask                     */
S
S#define RTC_TALM_TENMIN_Pos              (12)                                              /*!< RTC_T::TALM: TENMIN Position              */
S#define RTC_TALM_TENMIN_Msk              (0x7ul << RTC_TALM_TENMIN_Pos)                    /*!< RTC_T::TALM: TENMIN Mask                  */
S
S#define RTC_TALM_HR_Pos                  (16)                                              /*!< RTC_T::TALM: HR Position                  */
S#define RTC_TALM_HR_Msk                  (0xful << RTC_TALM_HR_Pos)                        /*!< RTC_T::TALM: HR Mask                      */
S
S#define RTC_TALM_TENHR_Pos               (20)                                              /*!< RTC_T::TALM: TENHR Position               */
S#define RTC_TALM_TENHR_Msk               (0x3ul << RTC_TALM_TENHR_Pos)                     /*!< RTC_T::TALM: TENHR Mask                   */
S
S#define RTC_CALM_DAY_Pos                 (0)                                               /*!< RTC_T::CALM: DAY Position                 */
S#define RTC_CALM_DAY_Msk                 (0xful << RTC_CALM_DAY_Pos)                       /*!< RTC_T::CALM: DAY Mask                     */
S
S#define RTC_CALM_TENDAY_Pos              (4)                                               /*!< RTC_T::CALM: TENDAY Position              */
S#define RTC_CALM_TENDAY_Msk              (0x3ul << RTC_CALM_TENDAY_Pos)                    /*!< RTC_T::CALM: TENDAY Mask                  */
S
S#define RTC_CALM_MON_Pos                 (8)                                               /*!< RTC_T::CALM: MON Position                 */
S#define RTC_CALM_MON_Msk                 (0xful << RTC_CALM_MON_Pos)                       /*!< RTC_T::CALM: MON Mask                     */
S
S#define RTC_CALM_TENMON_Pos              (12)                                              /*!< RTC_T::CALM: TENMON Position              */
S#define RTC_CALM_TENMON_Msk              (0x1ul << RTC_CALM_TENMON_Pos)                    /*!< RTC_T::CALM: TENMON Mask                  */
S
S#define RTC_CALM_YEAR_Pos                (16)                                              /*!< RTC_T::CALM: YEAR Position                */
S#define RTC_CALM_YEAR_Msk                (0xful << RTC_CALM_YEAR_Pos)                      /*!< RTC_T::CALM: YEAR Mask                    */
S
S#define RTC_CALM_TENYEAR_Pos             (20)                                              /*!< RTC_T::CALM: TENYEAR Position             */
S#define RTC_CALM_TENYEAR_Msk             (0xful << RTC_CALM_TENYEAR_Pos)                   /*!< RTC_T::CALM: TENYEAR Mask                 */
S
S#define RTC_LEAPYEAR_LEAPYEAR_Pos        (0)                                               /*!< RTC_T::LEAPYEAR: LEAPYEAR Position        */
S#define RTC_LEAPYEAR_LEAPYEAR_Msk        (0x1ul << RTC_LEAPYEAR_LEAPYEAR_Pos)              /*!< RTC_T::LEAPYEAR: LEAPYEAR Mask            */
S
S#define RTC_INTEN_ALMIEN_Pos             (0)                                               /*!< RTC_T::INTEN: ALMIEN Position             */
S#define RTC_INTEN_ALMIEN_Msk             (0x1ul << RTC_INTEN_ALMIEN_Pos)                   /*!< RTC_T::INTEN: ALMIEN Mask                 */
S
S#define RTC_INTEN_TICKIEN_Pos            (1)                                               /*!< RTC_T::INTEN: TICKIEN Position            */
S#define RTC_INTEN_TICKIEN_Msk            (0x1ul << RTC_INTEN_TICKIEN_Pos)                  /*!< RTC_T::INTEN: TICKIEN Mask                */
S
S#define RTC_INTEN_SNPDIEN_Pos            (2)                                               /*!< RTC_T::INTEN: SNPDIEN Position            */
S#define RTC_INTEN_SNPDIEN_Msk            (0x1ul << RTC_INTEN_SNPDIEN_Pos)                  /*!< RTC_T::INTEN: SNPDIEN Mask                */
S
S#define RTC_INTSTS_ALMIF_Pos             (0)                                               /*!< RTC_T::INTSTS: ALMIF Position             */
S#define RTC_INTSTS_ALMIF_Msk             (0x1ul << RTC_INTSTS_ALMIF_Pos)                   /*!< RTC_T::INTSTS: ALMIF Mask                 */
S
S#define RTC_INTSTS_TICKIF_Pos            (1)                                               /*!< RTC_T::INTSTS: TICKIF Position            */
S#define RTC_INTSTS_TICKIF_Msk            (0x1ul << RTC_INTSTS_TICKIF_Pos)                  /*!< RTC_T::INTSTS: TICKIF Mask                */
S
S#define RTC_INTSTS_SNPDIF_Pos            (2)                                               /*!< RTC_T::INTSTS: SNPDIF Position            */
S#define RTC_INTSTS_SNPDIF_Msk            (0x1ul << RTC_INTSTS_SNPDIF_Pos)                  /*!< RTC_T::INTSTS: SNPDIF Mask                */
S
S#define RTC_TICK_TICK_Pos                (0)                                               /*!< RTC_T::TICK: TICK Position                */
S#define RTC_TICK_TICK_Msk                (0x7ul << RTC_TICK_TICK_Pos)                      /*!< RTC_T::TICK: TICK Mask                    */
S
S#define RTC_TAMSK_MSEC_Pos               (0)                                               /*!< RTC_T::TAMSK: MSEC Position               */
S#define RTC_TAMSK_MSEC_Msk               (0x1ul << RTC_TAMSK_MSEC_Pos)                     /*!< RTC_T::TAMSK: MSEC Mask                   */
S
S#define RTC_TAMSK_MTENSEC_Pos            (1)                                               /*!< RTC_T::TAMSK: MTENSEC Position            */
S#define RTC_TAMSK_MTENSEC_Msk            (0x1ul << RTC_TAMSK_MTENSEC_Pos)                  /*!< RTC_T::TAMSK: MTENSEC Mask                */
S
S#define RTC_TAMSK_MMIN_Pos               (2)                                               /*!< RTC_T::TAMSK: MMIN Position               */
S#define RTC_TAMSK_MMIN_Msk               (0x1ul << RTC_TAMSK_MMIN_Pos)                     /*!< RTC_T::TAMSK: MMIN Mask                   */
S
S#define RTC_TAMSK_MTENMIN_Pos            (3)                                               /*!< RTC_T::TAMSK: MTENMIN Position            */
S#define RTC_TAMSK_MTENMIN_Msk            (0x1ul << RTC_TAMSK_MTENMIN_Pos)                  /*!< RTC_T::TAMSK: MTENMIN Mask                */
S
S#define RTC_TAMSK_MHR_Pos                (4)                                               /*!< RTC_T::TAMSK: MHR Position                */
S#define RTC_TAMSK_MHR_Msk                (0x1ul << RTC_TAMSK_MHR_Pos)                      /*!< RTC_T::TAMSK: MHR Mask                    */
S
S#define RTC_TAMSK_MTENHR_Pos             (5)                                               /*!< RTC_T::TAMSK: MTENHR Position             */
S#define RTC_TAMSK_MTENHR_Msk             (0x1ul << RTC_TAMSK_MTENHR_Pos)                   /*!< RTC_T::TAMSK: MTENHR Mask                 */
S
S#define RTC_CAMSK_MDAY_Pos               (0)                                               /*!< RTC_T::CAMSK: MDAY Position               */
S#define RTC_CAMSK_MDAY_Msk               (0x1ul << RTC_CAMSK_MDAY_Pos)                     /*!< RTC_T::CAMSK: MDAY Mask                   */
S
S#define RTC_CAMSK_MTENDAY_Pos            (1)                                               /*!< RTC_T::CAMSK: MTENDAY Position            */
S#define RTC_CAMSK_MTENDAY_Msk            (0x1ul << RTC_CAMSK_MTENDAY_Pos)                  /*!< RTC_T::CAMSK: MTENDAY Mask                */
S
S#define RTC_CAMSK_MMON_Pos               (2)                                               /*!< RTC_T::CAMSK: MMON Position               */
S#define RTC_CAMSK_MMON_Msk               (0x1ul << RTC_CAMSK_MMON_Pos)                     /*!< RTC_T::CAMSK: MMON Mask                   */
S
S#define RTC_CAMSK_MTENMON_Pos            (3)                                               /*!< RTC_T::CAMSK: MTENMON Position            */
S#define RTC_CAMSK_MTENMON_Msk            (0x1ul << RTC_CAMSK_MTENMON_Pos)                  /*!< RTC_T::CAMSK: MTENMON Mask                */
S
S#define RTC_CAMSK_MYEAR_Pos              (4)                                               /*!< RTC_T::CAMSK: MYEAR Position              */
S#define RTC_CAMSK_MYEAR_Msk              (0x1ul << RTC_CAMSK_MYEAR_Pos)                    /*!< RTC_T::CAMSK: MYEAR Mask                  */
S
S#define RTC_CAMSK_MTENYEAR_Pos           (5)                                               /*!< RTC_T::CAMSK: MTENYEAR Position           */
S#define RTC_CAMSK_MTENYEAR_Msk           (0x1ul << RTC_CAMSK_MTENYEAR_Pos)                 /*!< RTC_T::CAMSK: MTENYEAR Mask               */
S
S#define RTC_SPRCTL_SNPDEN_Pos            (0)                                               /*!< RTC_T::SPRCTL: SNPDEN Position            */
S#define RTC_SPRCTL_SNPDEN_Msk            (0x1ul << RTC_SPRCTL_SNPDEN_Pos)                  /*!< RTC_T::SPRCTL: SNPDEN Mask                */
S
S#define RTC_SPRCTL_SNPTYPE0_Pos          (1)                                               /*!< RTC_T::SPRCTL: SNPTYPE0 Position          */
S#define RTC_SPRCTL_SNPTYPE0_Msk          (0x1ul << RTC_SPRCTL_SNPTYPE0_Pos)                /*!< RTC_T::SPRCTL: SNPTYPE0 Mask              */
S
S#define RTC_SPRCTL_SPRRWEN_Pos           (2)                                               /*!< RTC_T::SPRCTL: SPRRWEN Position           */
S#define RTC_SPRCTL_SPRRWEN_Msk           (0x1ul << RTC_SPRCTL_SPRRWEN_Pos)                 /*!< RTC_T::SPRCTL: SPRRWEN Mask               */
S
S#define RTC_SPRCTL_SNPTYPE1_Pos          (3)                                               /*!< RTC_T::SPRCTL: SNPTYPE1 Position          */
S#define RTC_SPRCTL_SNPTYPE1_Msk          (0x1ul << RTC_SPRCTL_SNPTYPE1_Pos)                /*!< RTC_T::SPRCTL: SNPTYPE1 Mask              */
S
S#define RTC_SPRCTL_SPRCSTS_Pos           (5)                                               /*!< RTC_T::SPRCTL: SPRCSTS Position           */
S#define RTC_SPRCTL_SPRCSTS_Msk           (0x1ul << RTC_SPRCTL_SPRCSTS_Pos)                 /*!< RTC_T::SPRCTL: SPRCSTS Mask               */
S
S#define RTC_SPRCTL_SPRRWRDY_Pos          (7)                                               /*!< RTC_T::SPRCTL: SPRRWRDY Position          */
S#define RTC_SPRCTL_SPRRWRDY_Msk          (0x1ul << RTC_SPRCTL_SPRRWRDY_Pos)                /*!< RTC_T::SPRCTL: SPRRWRDY Mask              */
S
S#define RTC_SPR_SPARE_Pos                (0)                                               /*!< RTC_T::SPR: SPARE Position                */
S#define RTC_SPR_SPARE_Msk                (0xfffffffful << RTC_SPR_SPARE_Pos)               /*!< RTC_T::SPR: SPARE Mask                    */
S
S#define RTC_LXTCTL_LXTEN_Pos             (0)                                               /*!< RTC_T::LXTCTL: LXTEN Position             */
S#define RTC_LXTCTL_LXTEN_Msk             (0x1ul << RTC_LXTCTL_LXTEN_Pos)                   /*!< RTC_T::LXTCTL: LXTEN Mask                 */
S
S#define RTC_LXTCTL_GAIN_Pos              (1)                                               /*!< RTC_T::LXTCTL: GAIN Position              */
S#define RTC_LXTCTL_GAIN_Msk              (0x7ul << RTC_LXTCTL_GAIN_Pos)                    /*!< RTC_T::LXTCTL: GAIN Mask                  */
S
S#define RTC_LXTOCTL_OPMODE_Pos           (0)                                               /*!< RTC_T::LXTOCTL: OPMODE Position           */
S#define RTC_LXTOCTL_OPMODE_Msk           (0x3ul << RTC_LXTOCTL_OPMODE_Pos)                 /*!< RTC_T::LXTOCTL: OPMODE Mask               */
S
S#define RTC_LXTOCTL_DOUT_Pos             (2)                                               /*!< RTC_T::LXTOCTL: DOUT Position             */
S#define RTC_LXTOCTL_DOUT_Msk             (0x1ul << RTC_LXTOCTL_DOUT_Pos)                   /*!< RTC_T::LXTOCTL: DOUT Mask                 */
S
S#define RTC_LXTOCTL_CTLSEL_Pos           (3)                                               /*!< RTC_T::LXTOCTL: CTLSEL Position           */
S#define RTC_LXTOCTL_CTLSEL_Msk           (0x1ul << RTC_LXTOCTL_CTLSEL_Pos)                 /*!< RTC_T::LXTOCTL: CTLSEL Mask               */
S
S#define RTC_LXTICTL_OPMODE_Pos           (0)                                               /*!< RTC_T::LXTICTL: OPMODE Position           */
S#define RTC_LXTICTL_OPMODE_Msk           (0x3ul << RTC_LXTICTL_OPMODE_Pos)                 /*!< RTC_T::LXTICTL: OPMODE Mask               */
S
S#define RTC_LXTICTL_DOUT_Pos             (2)                                               /*!< RTC_T::LXTICTL: DOUT Position             */
S#define RTC_LXTICTL_DOUT_Msk             (0x1ul << RTC_LXTICTL_DOUT_Pos)                   /*!< RTC_T::LXTICTL: DOUT Mask                 */
S
S#define RTC_LXTICTL_CTLSEL_Pos           (3)                                               /*!< RTC_T::LXTICTL: CTLSEL Position           */
S#define RTC_LXTICTL_CTLSEL_Msk           (0x1ul << RTC_LXTICTL_CTLSEL_Pos)                 /*!< RTC_T::LXTICTL: CTLSEL Mask               */
S
S#define RTC_TAMPCTL_OPMODE_Pos           (0)                                               /*!< RTC_T::TAMPCTL: OPMODE Position           */
S#define RTC_TAMPCTL_OPMODE_Msk           (0x3ul << RTC_TAMPCTL_OPMODE_Pos)                 /*!< RTC_T::TAMPCTL: OPMODE Mask               */
S
S#define RTC_TAMPCTL_DOUT_Pos             (2)                                               /*!< RTC_T::TAMPCTL: DOUT Position             */
S#define RTC_TAMPCTL_DOUT_Msk             (0x1ul << RTC_TAMPCTL_DOUT_Pos)                   /*!< RTC_T::TAMPCTL: DOUT Mask                 */
S
S#define RTC_TAMPCTL_CTLSEL_Pos           (3)                                               /*!< RTC_T::TAMPCTL: CTLSEL Position           */
S#define RTC_TAMPCTL_CTLSEL_Msk           (0x1ul << RTC_TAMPCTL_CTLSEL_Pos)                 /*!< RTC_T::TAMPCTL: CTLSEL Mask               */
S
S/**@}*/ /* RTC_CONST */
S/**@}*/ /* end of RTC register group */
S
S
S/*---------------------- Smart Card Host Interface Controller -------------------------*/
S/**
S    @addtogroup SC Smart Card Host Interface Controller(SC)
S    Memory Mapped Structure for SC Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S/**
S * @var SC_T::DAT
S * Offset: 0x00  SC Receiving/Transmit Holding Buffer Register.
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |DAT       |Receiving/ Transmit Holding Buffer
S * |        |          |Write Operation:
S * |        |          |By writing data to DAT, the SC will send out an 8-bit data.
S * |        |          |Note: If SCEN(SC_CTL[0]) is not enabled, DAT cannot be programmed.
S * |        |          |Read Operation:
S * |        |          |By reading DAT, the SC will return an 8-bit received data.
S * @var SC_T::CTL
S * Offset: 0x04  SC Control Register.
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |SCEN      |SC Engine Enable Bit
S * |        |          |Set this bit to 1 to enable SC operation.
S * |        |          |If this bit is cleared, SC will force all transition to IDLE state.
S * |[1]     |RXOFF     |RX Transition Disable Control
S * |        |          |0 = The receiver Enabled.
S * |        |          |1 = The receiver Disabled.
S * |        |          |Note:
S * |        |          |If AUTOCEN (SC_CTL[3])is enabled, these fields must be ignored.
S * |[2]     |TXOFF     |TX Transition Disable Control
S * |        |          |0 = The transceiver Enabled.
S * |        |          |1 = The transceiver Disabled.
S * |[3]     |AUTOCEN   |Auto Convention Enable Bit
S * |        |          |0 = Auto-convention Disabled.
S * |        |          |1 = Auto-convention Enabled.
S * |        |          |When hardware receives TS in answer to reset state and the TS is direct convention, CONSEL(SC_CTL[5:4]) will be set to 00 automatically, otherwise if the TS is inverse convention, and CONSEL (SC_CTL[5:4]) will be set to 11.
S * |        |          |If software enables auto convention function, the setting step must be done before Answer to Reset state and the first data must be 0x3B or 0x3F.
S * |        |          |After hardware received first data and stored it at buffer, 
S * |        |          |hardware will decided the convention and change the CONSEL (SC_CTL[5:4]) bits automatically.
S * |        |          |If the first data is not 0x3B or 0x3F, hardware will generate an interrupt if ACERRIEN (SC_INTEN[10]) = 1 to CPU.
S * |[5:4]   |CONSEL    |Convention Selection
S * |        |          |00 = Direct convention.
S * |        |          |01 = Reserved.
S * |        |          |10 = Reserved.
S * |        |          |11 = Inverse convention.
S * |        |          |Note:
S * |        |          |If AUTOCEN(SC_CTL[3]) enabled, this fields are ignored.
S * |[7:6]   |RXTRGLV   |Rx Buffer Trigger Level
S * |        |          |When the number of bytes in the receiving buffer equals the RXTRGLV, the RDAIF will be set (if SC_INTEN [RDAIEN] is enabled, an interrupt will be generated).
S * |        |          |00 = INTR_RDA Trigger Level with 01 Bytes.
S * |        |          |01 = INTR_RDA Trigger Level with 02 Bytes.
S * |        |          |10 = INTR_RDA Trigger Level with 03 Bytes.
S * |        |          |11 = Reserved.
S * |[12:8]  |BGT       |Block Guard Time (BGT)
S * |        |          |Block guard time means the minimum bit length between the leading edges of two consecutive characters between different transfer directions.
S * |        |          |This field indicates the counter for the bit length of block guard time.
S * |        |          |According to ISO7816-3, in T = 0 mode, software must fill 15 (real block guard time = 16.5) to this field; in T = 1 mode, software must fill 21 (real block guard time = 22.5) to it.
S * |        |          |Note:
S * |        |          |The real block guard time is BGT + 1.
S * |[14:13] |TMRSEL    |Timer Selection
S * |        |          |00 = All internal timer function Disabled.
S * |        |          |01 = Internal 24 bit timer Enabled.
S * |        |          |Software can configure it by setting SC_TMRCTL0 [23:0].
S * |        |          |SC_TMRCTL1 and SC_TMRCTL2 will be ignored in this mode.
S * |        |          |10 = internal 24 bit timer and 8 bit internal timer Enabled.
S * |        |          |Software can configure the 24 bit timer by setting SC_TMRCTL0 [23:0] and configure the 8 bit timer by setting SC_TMRCTL1[7:0].
S * |        |          |SC_TMRCTL2 will be ignored in this mode.
S * |        |          |11 = Internal 24 bit timer and two 8 bit timers Enabled.
S * |        |          |Software can configure them by setting SC_TMRCTL0 [23:0], SC_TMRCTL1 [7:0] and SC_TMRCTL2 [7:0].
S * |[15]    |NSB       |Stop Bit Length
S * |        |          |This field indicates the length of stop bit.
S * |        |          |0 = The stop bit length is 2 ETU.
S * |        |          |1= The stop bit length is 1 ETU.
S * |        |          |Note:
S * |        |          |The default stop bit length is 2. SMC and UART adopts NSB to program the stop bit length
S * |[18:16] |RXRTY     |RX Error Retry Count Number
S * |        |          |This field indicates the maximum number of receiver retries that are allowed when parity error has occurred
S * |        |          |Note1: The real retry number is RXRTY + 1, so 8 is the maximum retry number.
S * |        |          |Note2: This field cannot be changed when RXRTYEN enabled.
S * |        |          |The change flow is to disable RXRTYEN first and then fill in new retry value.
S * |[19]    |RXRTYEN   |RX Error Retry Enable Bit
S * |        |          |This bit enables receiver retry function when parity error has occurred.
S * |        |          |0 = RX error retry function Disabled.
S * |        |          |1 = RX error retry function Enabled.
S * |        |          |Note:
S * |        |          |Software must fill in the RXRTY value before enabling this bit.
S * |[22:20] |TXRTY     |TX Error Retry Count Number
S * |        |          |This field indicates the maximum number of transmitter retries that are allowed when parity error has occurred.
S * |        |          |Note1: The real retry number is TXRTY + 1, so 8 is the maximum retry number.
S * |        |          |Note2: This field cannot be changed when TXRTYEN enabled.
S * |        |          |The change flow is to disable TXRTYEN first and then fill in new retry value.
S * |[23]    |TXRTYEN   |TX Error Retry Enable Bit
S * |        |          |This bit enables transmitter retry function when parity error has occurred.
S * |        |          |0 = TX error retry function Disabled.
S * |        |          |1 = TX error retry function Enabled.
S * |[25:24] |CDDBSEL   |Card Detect De-Bounce Selection
S * |        |          |This field indicates the card detect de-bounce selection.
S * |        |          |00 = De-bounce sample card insert once per 384 (128 * 3) peripheral clocks and de-bounce sample card removal once per 128 peripheral clocks.
S * |        |          |01 = De-bounce sample card insert once per 192 (64 * 3) peripheral clocks and de-bounce sample card removal once per 64 peripheral clocks.
S * |        |          |10 = De-bounce sample card insert once per 96 (32 * 3) peripheral clocks and de-bounce sample card removal once per 32 peripheral clocks.
S * |        |          |11 = De-bounce sample card insert once per 48 (16 * 3) peripheral clocks and de-bounce sample card removal once per 16 peripheral clocks.
S * |[26]    |CDLV      |Card Detect Level
S * |        |          |0 = When hardware detects the card detect pin (SC_CD) from high to low, it indicates a card is detected.
S * |        |          |1 = When hardware detects the card detect pin from low to high, it indicates a card is detected.
S * |        |          |Note: Software must select card detect level before Smart Card engine enabled.
S * |[30]    |SYNC      |SYNC Flag Indicator
S * |        |          |Due to synchronization, software should check this bit before writing a new value to RXRTY and TXRTY.
S * |        |          |0 = Synchronizing is completion, user can write new data to RXRTY and TXRTY.
S * |        |          |1 = Last value is synchronizing.
S * |        |          |Note: This bit is read only.
S * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable Control
S * |        |          |0 = ICE debug mode acknowledgement affects SC counting.
S * |        |          |SC internal counter will be held while CPU is held by ICE.
S * |        |          |1 = ICE debug mode acknowledgement Disabled.
S * |        |          |SC internal counter will keep going no matter CPU is held by ICE or not.
S * @var SC_T::ALTCTL
S * Offset: 0x08  SC Alternate Control Register.
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |TXRST     |TX Software Reset
S * |        |          |When TXRST is set, all the bytes in the transmit buffer and TX internal state machine will be cleared.
S * |        |          |0 = No effect.
S * |        |          |1 = Reset the TX internal state machine and pointers.
S * |        |          |Note:
S * |        |          |This bit will be auto cleared after reset is complete.
S * |[1]     |RXRST     |Rx Software Reset
S * |        |          |When RXRST is set, all the bytes in the receiver buffer and Rx internal state machine will be cleared.
S * |        |          |0 = No effect.
S * |        |          |1 = Reset the Rx internal state machine and pointers.
S * |        |          |Note:
S * |        |          |This bit will be auto cleared after reset is complete.
S * |[2]     |DACTEN    |Deactivation Sequence Generator Enable Bit
S * |        |          |This bit enables SC controller to initiate the card by deactivation sequence
S * |        |          |0 = No effect.
S * |        |          |1 = Deactivation sequence generator Enabled.
S * |        |          |Note1:
S * |        |          |When the deactivation sequence completed, this bit will be cleared automatically and the INITIF(SC_INTSTS[8]) will be set to 1.
S * |        |          |Note2:
S * |        |          |This field will be cleared by TXRST (SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]).
S * |        |          |So don't fill this bit, TXRST, and RXRST at the same time.
S * |        |          |Note3:
S * |        |          |If SCEN (SC_CTL[0]) is not enabled, this filed cannot be programmed.
S * |[3]     |ACTEN     |Activation Sequence Generator Enable Bit
S * |        |          |This bit enables SC controller to initiate the card by activation sequence
S * |        |          |0 = No effect.
S * |        |          |1 = Activation sequence generator Enabled.
S * |        |          |Note1:
S * |        |          |When the activation sequence completed, this bit will be cleared automatically and the INITIF(SC_INTSTS[8]) will be set to 1.
S * |        |          |Note2:
S * |        |          |This field will be cleared by TXRST(SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]), so don't fill this bit, TXRST(SC_ALTCTL[0]), and RXRST(SC_ALTCTL[1]) at the same time.
S * |        |          |Note3:
S * |        |          |If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
S * |[4]     |WARSTEN   |Warm Reset Sequence Generator Enable Bit
S * |        |          |This bit enables SC controller to initiate the card by warm reset sequence
S * |        |          |0 = No effect.
S * |        |          |1 = Warm reset sequence generator Enabled.
S * |        |          |Note1:
S * |        |          |When the warm reset sequence completed, this bit will be cleared automatically and the INITIF(SC_INTSTS[8]) will be set to 1.
S * |        |          |Note2:
S * |        |          |This field will be cleared by TXRST(SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]), so don't fill this bit, TXRST, and RXRST at the same time.
S * |        |          |Note3:
S * |        |          |If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
S * |[5]     |CNTEN0    |Internal Timer0 Start Enable Bit
S * |        |          |This bit enables Timer 0 to start counting.
S * |        |          |Software can fill 0 to stop it and set 1 to reload and count.
S * |        |          |0 = Stops counting.
S * |        |          |1 = Start counting.
S * |        |          |Note1:
S * |        |          |This field is used for internal 24 bit timer when TMRSEL (SC_CTL[14:13]) = 01.
S * |        |          |Note2:
S * |        |          |If the operation mode is not in auto-reload mode (SC_TMRCTL0[26] = 0), this bit will be auto-cleared by hardware.
S * |        |          |Note3:
S * |        |          |This field will be cleared by TXRST(SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]).
S * |        |          |So don't fill this bit, TXRST and RXRST at the same time.
S * |        |          |Note4: If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
S * |[6]     |CNTEN1    |Internal Timer1 Start Enable Bit
S * |        |          |This bit enables Timer 1 to start counting.
S * |        |          |Software can fill 0 to stop it and set 1 to reload and count.
S * |        |          |0 = Stops counting.
S * |        |          |1 = Start counting.
S * |        |          |Note1:
S * |        |          |This field is used for internal 8 bit timer when TMRSEL(SC_CTL[14:13]) = 10 or TMRSEL(SC_CTL[14:13]) = 11.
S * |        |          |Don't filled CNTEN1 when TMRSEL(SC_CTL[14:13]) = 00 or TMRSEL(SC_CTL[14:13]) = 01.
S * |        |          |Note2:
S * |        |          |If the operation mode is not in auto-reload mode (SC_TMRCTL1[26] = 0), this bit will be auto-cleared by hardware.
S * |        |          |Note3:
S * |        |          |This field will be cleared by TXRST(SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]), so don't fill this bit, TXRST(SC_ALTCTL[0]), and RXRST(SC_ALTCTL[1]) at the same time.
S * |        |          |Note4:
S * |        |          |If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
S * |[7]     |CNTEN2    |Internal Timer2 Start Enable Bit
S * |        |          |This bit enables Timer 2 to start counting.
S * |        |          |Software can fill 0 to stop it and set 1 to reload and count.
S * |        |          |0 = Stops counting.
S * |        |          |1 = Start counting.
S * |        |          |Note1:
S * |        |          |This field is used for internal 8 bit timer when TMRSEL(SC_CTL[14:13]) = 11.
S * |        |          |Don't filled CNTEN2 when TMRSEL(SC_CTL[14:13]) = 00 or TMRSEL(SC_CTL[14:13]) = 01 or TMRSEL(SC_CTL[14:13]) = 10.
S * |        |          |Note2:
S * |        |          |If the operation mode is not in auto-reload mode (SC_TMRCTL2[26] = 0), this bit will be auto-cleared by hardware.
S * |        |          |Note3:
S * |        |          |This field will be cleared by TXRST(SC_ALTCTL[0]) and RXRST(SC_ALTCTL[1]).
S * |        |          |So don't fill this bit, TXRST(SC_ALTCTL[0]), and RXRST(SC_ALTCTL[1]) at the same time.
S * |        |          |Note4:
S * |        |          |If SCEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
S * |[9:8]   |INITSEL   |Initial Timing Selection
S * |        |          |This fields indicates the timing of hardware initial state (activation or warm-reset or deactivation).
S * |        |          |Unit: SC clock
S * |        |          |Activation: refer to SC Activation Sequence in Figure 6.17-4
S * |        |          |Warm-reset: refer to Warm-Reset Sequence in Figure 6.17-5
S * |        |          |Deactivation: refer to Deactivation Sequence in Figure 6.17-6
S * |[12]    |RXBGTEN   |Receiver Block Guard Time Function Enable Bit
S * |        |          |0 = Receiver block guard time function Disabled.
S * |        |          |1 = Receiver block guard time function Enabled.
S * |[13]    |ACTSTS0   |Internal Timer0 Active State (Read Only)
S * |        |          |This bit indicates the timer counter status of timer0.
S * |        |          |0 = Timer0 is not active.
S * |        |          |1 = Timer0 is active.
S * |[14]    |ACTSTS1   |Internal Timer1 Active State (Read Only)
S * |        |          |This bit indicates the timer counter status of timer1.
S * |        |          |0 = Timer1 is not active.
S * |        |          |1 = Timer1 is active.
S * |[15]    |ACTSTS2   |Internal Timer2 Active State (Read Only)
S * |        |          |This bit indicates the timer counter status of timer2.
S * |        |          |0 = Timer2 is not active.
S * |        |          |1 = Timer2 is active.
S * @var SC_T::EGT
S * Offset: 0x0C  SC Extend Guard Time Register.
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |EGT       |Extended Guard Time
S * |        |          |This field indicates the extended guard timer value.
S * |        |          |Note:
S * |        |          |The counter is ETU base and the real extended guard time is EGT.
S * @var SC_T::RXTOUT
S * Offset: 0x10  SC Receive buffer Time-out Register.
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[8:0]   |RFTM      |SC Receiver FIFO Time-out (ETU Base)
S * |        |          |The time-out counter resets and starts counting whenever the RX buffer received a new data word.
S * |        |          |Once the counter decrease to 1 and no new data is received or CPU does not read data by reading SC_DAT buffer, a receiver time-out interrupt INT_RTMR will be generated(if RXTOIF(SC_INTEN[9]) = 1 ).
S * |        |          |Note1: The counter unit is ETU based and the interval of time-out is RFTM + 0.5.
S * |        |          |Note2:
S * |        |          |Filling all 0 to this field indicates to disable this function.
S * @var SC_T::ETUCTL
S * Offset: 0x14  SC ETU Control Register.
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[11:0]  |ETURDIV   |ETU Rate Divider
S * |        |          |The field indicates the clock rate divider.
S * |        |          |The real ETU is ETURDIV + 1.
S * |        |          |Note:
S * |        |          |Software can configure this field, but this field must be greater than 0x004.
S * |[15]    |CMPEN     |Compensation Mode Enable Bit
S * |        |          |This bit enables clock compensation function.
S * |        |          |When this bit enabled, hardware will alternate between n clock cycles and n-1 clock cycles, where n is the value to be written into the ETURDIV .
S * |        |          |0 = Compensation function Disabled.
S * |        |          |1 = Compensation function Enabled.
S * @var SC_T::INTEN
S * Offset: 0x18  SC Interrupt Enable Control Register.
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |RDAIEN    |Receive Data Reach Interrupt Enable Bit
S * |        |          |This field is used for received data reaching trigger level RXTRGLV (SC_CTL[7:6]) interrupt enable.
S * |        |          |0 = Receive data reach trigger level interrupt Disabled.
S * |        |          |1 = Receive data reach trigger level interrupt Enabled.
S * |[1]     |TBEIEN    |Transmit Buffer Empty Interrupt Enable Bit
S * |        |          |This field is used for transmit buffer empty interrupt enable.
S * |        |          |0 = Transmit buffer empty interrupt Disabled.
S * |        |          |1 = Transmit buffer empty interrupt Enabled.
S * |[2]     |TERRIEN   |Transfer Error Interrupt Enable Bit
S * |        |          |This field is used for transfer error interrupt enable.
S * |        |          |The transfer error states is at SC_STATUS register which includes receiver break error BEF(SC_STATUS[6]), frame error FEF(SC_STATUS[5]), parity error PEF(SC_STATUS[4]), receiver buffer overflow error RXOV(SC_STATUS[0]), transmit buffer overflow error TXOV(SC_STATUS[8]), receiver retry over limit error RXOVERR(SC_STATUS[22]) and transmitter retry over limit error TXOVERR (SC_STATUS[30]).
S * |        |          |0 = Transfer error interrupt Disabled.
S * |        |          |1 = Transfer error interrupt Enabled.
S * |[3]     |TMR0IEN   |Timer0 Interrupt Enable Bit
S * |        |          |This field is used to enable TMR0 interrupt enable.
S * |        |          |0 = Timer0 interrupt Disabled.
S * |        |          |1 = Timer0 interrupt Enabled.
S * |[4]     |TMR1IEN   |Timer1 Interrupt Enable Bit
S * |        |          |This field is used to enable the TMR1 interrupt.
S * |        |          |0 = Timer1 interrupt Disabled.
S * |        |          |1 = Timer1 interrupt Enabled.
S * |[5]     |TMR2IEN   |Timer2 Interrupt Enable Bit
S * |        |          |This field is used for TMR2 interrupt enable.
S * |        |          |0 = Timer2 interrupt Disabled.
S * |        |          |1 = Timer2 interrupt Enabled.
S * |[6]     |BGTIEN    |Block Guard Time Interrupt Enable Bit
S * |        |          |This field is used for block guard time interrupt enable.
S * |        |          |0 = Block guard time Disabled.
S * |        |          |1 = Block guard time Enabled.
S * |[7]     |CDIEN     |Card Detect Interrupt Enable Bit
S * |        |          |This field is used for card detect interrupt enable. The card detect status is CINSERT(SC_STATUS[12])
S * |        |          |0 = Card detect interrupt Disabled.
S * |        |          |1 = Card detect interrupt Enabled.
S * |[8]     |INITIEN   |Initial End Interrupt Enable Bit
S * |        |          |This field is used for activation (ACTEN(SC_ALTCTL[3] = 1)), deactivation ((DACTEN SC_ALTCTL[2]) = 1) and warm reset (WARSTEN (SC_ALTCTL [4])) sequence interrupt enable.
S * |        |          |0 = Initial end interrupt Disabled.
S * |        |          |1 = Initial end interrupt Enabled.
S * |[9]     |RXTOIF    |Receiver Buffer Time-Out Interrupt Enable Bit
S * |        |          |This field is used for receiver buffer time-out interrupt enable.
S * |        |          |0 = Receiver buffer time-out interrupt Disabled.
S * |        |          |1 = Receiver buffer time-out interrupt Enabled.
S * |[10]    |ACERRIEN  |Auto Convention Error Interrupt Enable Bit
S * |        |          |This field is used for auto-convention error interrupt enable.
S * |        |          |0 = Auto-convention error interrupt Disabled.
S * |        |          |1 = Auto-convention error interrupt Enabled.
S * @var SC_T::INTSTS
S * Offset: 0x1C  SC Interrupt Status Register.
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |RDAIF     |Receive Data Reach Interrupt Status Flag (Read Only)
S * |        |          |This field is used for received data reaching trigger level RXTRGLV (SC_CTL[7:6]) interrupt status flag.
S * |        |          |Note: This field is the status flag of received data reaching RXTRGLV (SC_CTL[7:6]).
S * |        |          |If software reads data from SC_DAT and receiver buffer data byte number is less than RXTRGLV (SC_CTL[7:6]), this bit will be cleared automatically.
S * |[1]     |TBEIF     |Transmit Buffer Empty Interrupt Status Flag (Read Only)
S * |        |          |This field is used for transmit buffer empty interrupt status flag.
S * |        |          |Note: This field is the status flag of transmit buffer empty state.
S * |        |          |If software wants to clear this bit, software must write data to DAT(SC_DAT[7:0]) buffer and then this bit will be cleared automatically.
S * |[2]     |TERRIF    |Transfer Error Interrupt Status Flag (Read Only)
S * |        |          |This field is used for transfer error interrupt status flag.
S * |        |          |The transfer error states is at SC_STATUS register which includes receiver break error BEF(SC_STATUS[6]), frame error FEF(SC_STATUS[5]), parity error PEF(SC_STATUS[4]) and receiver buffer overflow error RXOV(SC_STATUS[0]), transmit buffer overflow error TXOV(SC_STATUS[8]), receiver retry over limit error RXOVERR(SC_STATUS[22]) and transmitter retry over limit error TXOVERR(SC_STATUS[30]).
S * |        |          |Note: This field is the status flag of
S * |        |          |BEF(SC_STATUS[6]), FEF(SC_STATUS[5]), PEF(SC_STATUS[4]), RXOV(SC_STATUS[0]), TXOV(SC_STATUS[8]), RXOVERR(SC_STATUS[22]) or TXOVERR(SC_STATUS[30]).
S * |        |          |So, if software wants to clear this bit, software must write 1 to each field.
S * |[3]     |TMR0IF    |Timer0 Interrupt Status Flag (Read Only)
S * |        |          |This field is used for TMR0 interrupt status flag.
S * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
S * |[4]     |TMR1IF    |Timer1 Interrupt Status Flag (Read Only)
S * |        |          |This field is used for TMR1 interrupt status flag.
S * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
S * |[5]     |TMR2IF    |Timer2 Interrupt Status Flag (Read Only)
S * |        |          |This field is used for TMR2 interrupt status flag.
S * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
S * |[6]     |BGTIF     |Block   Guard Time Interrupt Status Flag (Read Only)
S * |        |          |This field   is used for block guard time interrupt status flag.
S * |        |          |Note1: This bit is valid when RXBGTEN   (SC_ALTCTL[12]) is enabled.
S * |        |          |Note2: This bit is read only, but it can be cleared by   writing "1" to it.
S * |[7]     |CDIF      |Card Detect Interrupt Status Flag (Read Only)
S * |        |          |This field is used for card detect interrupt status flag.
S * |        |          |The card detect status is CINSERT (SC_STATUS[12]) and CREMOVE(SC_STATUS[11]).
S * |        |          |Note:
S * |        |          |This field is the status flag of CINSERT(SC_STATUS[12]) or CREMOVE(SC_STATUS[11])].
S * |        |          |So if software wants to clear this bit, software must write 1 to this field.
S * |[8]     |INITIF    |Initial End Interrupt Status Flag (Read Only)
S * |        |          |This field is used for activation (ACTEN(SC_ALTCTL[3])), deactivation (DACTEN (SC_ALTCTL[2])) and warm reset (WARSTEN (SC_ALTCTL[4])) sequence interrupt status flag.
S * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
S * |[9]     |RBTOIF    |Receiver Buffer Time-Out Interrupt Status Flag (Read Only)
S * |        |          |This field is used for receiver buffer time-out interrupt status flag.
S * |        |          |Note: This field is the status flag of receiver buffer time-out state.
S * |        |          |If software wants to clear this bit, software must read all receiver buffer remaining data by reading SC_DAT buffer,.
S * |[10]    |ACERRIF   |Auto Convention Error Interrupt Status Flag (Read Only)
S * |        |          |This field indicates auto convention sequence error.
S * |        |          |If the received TS at ATR state is neither 0x3B nor 0x3F, this bit will be set.
S * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
S * @var SC_T::STATUS
S * Offset: 0x20  SC Status Register.
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |RXOV      |RX Overflow Error Status Flag (Read Only)
S * |        |          |This bit is set when RX buffer overflow.
S * |        |          |If the number of received bytes is greater than Rx Buffer size (4 bytes), this bit will be set.
S * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
S * |[1]     |RXEMPTY   |Receiver Buffer Empty Status Flag(Read Only)
S * |        |          |This bit indicates RX buffer empty or not.
S * |        |          |When the last byte of Rx buffer has been read by CPU, hardware sets this bit high.
S * |        |          |It will be cleared when SC receives any new data.
S * |[2]     |RXFULL    |Receiver Buffer Full Status Flag (Read Only)
S * |        |          |This bit indicates RX buffer full or not.
S * |        |          |This bit is set when RX pointer is equal to 4, otherwise it is cleared by hardware.
S * |[4]     |PEF       |Receiver Parity Error Status Flag (Read Only)
S * |        |          |This bit is set to logic 1 whenever the received character does not have a valid
S * |        |          |"parity bit".
S * |        |          |Note1:
S * |        |          |This bit is read only, but it can be cleared by writing 1 to it.
S * |        |          |Note2:
S * |        |          |If CPU sets receiver retries function by setting RXRTYEN(SC_CTL[19]) , hardware will not set this flag.
S * |[5]     |FEF       |Receiver Frame Error Status Flag (Read Only)
S * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as logic 0).
S * |        |          |Note1:
S * |        |          |This bit is read only, but it can be cleared by writing 1 to it.
S * |        |          |Note2:
S * |        |          |If CPU sets receiver retries function by setting RXRTYEN(SC_CTL[19]) , hardware will not set this flag.
S * |[6]     |BEF       |Receiver Break Error Status Flag (Read Only)
S * |        |          |This bit is set to logic 1 whenever the received data input (RX) held in the "spacing state" (logic 0) is longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits).
S * |        |          |.
S * |        |          |Note1:
S * |        |          |This bit is read only, but it can be cleared by writing 1 to it.
S * |        |          |Note2:
S * |        |          |If CPU sets receiver retries function by setting RXRTYEN(SC_CTL[19]) , hardware will not set this flag.
S * |[8]     |TXOV      |TX Overflow Error Interrupt Status Flag (Read Only)
S * |        |          |If TX buffer is full, an additional write to DAT(SC_DAT[7:0]) will cause this bit be set to "1" by hardware.
S * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
S * |[9]     |TXEMPTY   |Transmit Buffer Empty Status Flag (Read Only)
S * |        |          |This bit indicates TX buffer empty or not.
S * |        |          |When the last byte of TX buffer has been transferred to Transmitter Shift Register, hardware sets this bit high.
S * |        |          |It will be cleared when writing data into DAT(SC_DAT[7:0]) (TX buffer not empty).
S * |[10]    |TXFULL    |Transmit Buffer Full Status Flag (Read Only)
S * |        |          |This bit indicates TX buffer full or not.This bit is set when TX pointer is equal to 4, otherwise is cleared by hardware.
S * |[11]    |CREMOVE   |Card Detect Removal Status Of SC_CD Pin (Read Only)
S * |        |          |This bit is set whenever card has been removal.
S * |        |          |0 = No effect.
S * |        |          |1 = Card removed.
S * |        |          |Note1: This bit is read only, but it can be cleared by writing "1" to it.
S * |        |          |Note2: Card detect engine will start after SCEN (SC_CTL[0])set.
S * |[12]    |CINSERT   |Card Detect Insert Status Of SC_CD Pin (Read Only)
S * |        |          |This bit is set whenever card has been inserted.
S * |        |          |0 = No effect.
S * |        |          |1 = Card insert.
S * |        |          |Note1: This bit is read only, but it can be cleared by writing "1" to it.
S * |        |          |Note2: The
S * |        |          |card detect engine will start after SCEN (SC_CTL[0]) set.
S * |[13]    |CDPINSTS  |Card Detect Status Of SC_CD Pin Status (Read Only)
S * |        |          |This bit is the pin status flag of SC_CD
S * |        |          |0 = The SC_CD pin state at low.
S * |        |          |1 = The SC_CD pin state at high.
S * |[17:16] |RXPOINT   |Receiver Buffer Pointer Status Flag (Read Only)
S * |        |          |This field indicates the RX buffer pointer status flag.
S * |        |          |When SC receives one byte from external device, RXPOINT(SC_STATUS[17:16]) increases one.
S * |        |          |When one byte of RX buffer is read by CPU, RXPOINT(SC_STATUS[17:16]) decreases one.
S * |[21]    |RXRERR    |Receiver Retry Error (Read Only)
S * |        |          |This bit is set by hardware when RX has any error and retries transfer.
S * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
S * |        |          |Note2 This bit is a flag and cannot generate any interrupt to CPU.
S * |        |          |Note3: If CPU enables receiver retry function by setting RXRTYEN (SC_CTL[19]) , the PEF(SC_STATUS[4]) flag will be ignored (hardware will not set PEF(SC_STATUS[4])).
S * |[22]    |RXOVERR   |Receiver Over Retry Error (Read Only)
S * |        |          |This bit is set by hardware when RX transfer error retry over retry number limit.
S * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
S * |        |          |Note2: If CPU enables receiver retries function by setting RXRTYEN (SC_CTL[19]), the PEF(SC_STATUS[4]) flag will be ignored (hardware will not set PEF(SC_STATUS[4])).
S * |[23]    |RXACT     |Receiver In Active Status Flag (Read Only)
S * |        |          |This bit is set by hardware when RX transfer is in active.
S * |        |          |This bit is cleared automatically when RX transfer is finished.
S * |[25:24] |TXPOINT   |Transmit Buffer Pointer Status Flag (Read Only)
S * |        |          |This field indicates the TX buffer pointer status flag.
S * |        |          |When CPU writes data into SC_DAT, TXPOINT increases one.
S * |        |          |When one byte of TX Buffer is transferred to transmitter shift register, TXPOINT decreases one.
S * |[29]    |TXRERR    |Transmitter Retry Error (Read Only)
S * |        |          |This bit is set by hardware when transmitter re-transmits.
S * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
S * |        |          |Note2 This bit is a flag and cannot generate any interrupt to CPU.
S * |[30]    |TXOVERR   |Transmitter Over Retry Error (Read Only)
S * |        |          |This bit is set by hardware when transmitter re-transmits over retry number limitation.
S * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
S * |[31]    |TXACT     |Transmit In Active Status Flag (Read Only)
S * |        |          |0 = This bit is cleared automatically when TX transfer is finished or the last byte transmission has completed.
S * |        |          |1 = This bit is set by hardware when TX transfer is in active and the STOP bit of the last byte has been transmitted.
S * @var SC_T::PINCTL
S * Offset: 0x24  SC Pin Control State Register.
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |PWREN     |SC_PWREN Pin Signal
S * |        |          |Software can set PWREN (SC_PINCTL[0]) and PWRINV (SC_PINCTL[11])to decide SC_PWR pin is in high or low level.
S * |        |          |Write this field to drive SC_PWR pin
S * |        |          |Refer PWRINV (SC_PINCTL[11]) description for programming SC_PWR pin voltage level.
S * |        |          |Read this field to get SC_PWR pin status.
S * |        |          |0 = SC_PWR pin status is low.
S * |        |          |1 = SC_PWR pin status is high.
S * |        |          |Note: When operating at activation, warm reset or deactivation mode, this bit will be changed automatically.
S * |        |          |So don't fill this field when operating in these modes.
S * |[1]     |SCRST     |SC_RST Pin Signal
S * |        |          |This bit is the pin status of SC_RST but user can drive SC_RST pin to high or low by setting this bit.
S * |        |          |Write this field to drive SC_RST pin.
S * |        |          |0 = Drive SC_RST pin to low.
S * |        |          |1 = Drive SC_RST pin to high.
S * |        |          |Read this field to get SC_RST pin status.
S * |        |          |0 = SC_RST pin status is low.
S * |        |          |1 = SC_RST pin status is high.
S * |        |          |Note: When operating at activation, warm reset or deactivation mode, this bit will be changed automatically.
S * |        |          |So don't fill this field when operating in these modes.
S * |[5]     |CSTOPLV   |SC Clock Stop Level
S * |        |          |This field indicates the clock polarity control in clock stop mode.
S * |        |          |0 = SC_CLK stopped in low level.
S * |        |          |1 = SC_CLK stopped in high level.
S * |[6]     |CLKKEEP   |SC Clock Enable Bit
S * |        |          |0 = SC clock generation Disabled.
S * |        |          |1 = SC clock always keeps free running.
S * |        |          |Note: When operating in activation, warm reset or deactivation mode, this bit will be changed automatically.
S * |        |          |So don't fill this field when operating in these modes.
S * |[9]     |SCDOUT    |SC Data Output Pin
S * |        |          |This bit is the pin status of SCDATOUT but user can drive SCDATOUT pin to high or low by setting this bit.
S * |        |          |0 = Drive SCDATOUT pin to low.
S * |        |          |1 = Drive SCDATOUT pin to high.
S * |        |          |Note: When SC is at activation, warm reset or deactivation mode, this bit will be changed automatically.
S * |        |          |So don't fill this field when SC is in these modes.
S * |[11]    |PWRINV    |SC_POW Pin Inverse
S * |        |          |This bit is used for inverse the SC_POW pin.
S * |        |          |There are four kinds of combination for SC_POW pin setting by PWRINV(SC_PINCTL[11]) and PWREN(SC_PINCTL[0]).
S * |        |          |PWRINV (SC_PINCTL[11]) is bit 1 and PWREN(SC_PINCTL[0]) is bit 0 for SC_POW_Pin as high or low voltage selection.
S * |        |          |00 = SC_POW_ Pin is 0.
S * |        |          |01 = SC_POW _Pin is 1.
S * |        |          |10 = SC_POW _Pin is 1.
S * |        |          |11 = SC_POW_ Pin is 0.
S * |        |          |Note: Software must select PWRINV (SC_PINCTL[11]) before Smart Card is enabled by SCEN (SC_CTL[0]).
S * |[12]    |SCDOSTS   |SC Data Pin Output Status
S * |        |          |This bit is the pin status of SCDATOUT
S * |        |          |0 = SCDATOUT pin to low.
S * |        |          |1 = SCDATOUT pin to high.
S * |        |          |Note: When SC is operated at activation, warm reset or deactivation mode, this bit will be changed automatically.
S * |        |          |This bit is not allowed to program when SC is operated at these modes.
S * |[16]    |DATSTS    |This bit   is the pin status of SC_DAT
S * |        |          |0 = The   SC_DAT pin is low.
S * |        |          |1 = The   SC_DAT pin is high.
S * |[17]    |PWRSTS    |SC_PWR   Pin Signal
S * |        |          |This bit   is the pin status of SC_PWR
S * |        |          |0 = SC_PWR   pin to low.
S * |        |          |1 = SC_PWR   pin to high.
S * |        |          |Note: When SC is operated at activation, warm reset or deactivation mode, this bit will be changed automatically.
S * |        |          |This bit is not allowed to program when SC is operated at these modes.
S * |[18]    |RSTSTS    |SCRST Pin Signals
S * |        |          |This bit is the pin status of SC_RST
S * |        |          |0 = SC_RST pin is low.
S * |        |          |1 = SC_RST pin is high.
S * |        |          |Note: When SC is operated at activation, warm reset or deactivation mode, this bit will be changed automatically.
S * |        |          |This bit is not allowed to program when SC is operated at these modes.
S * |[30]    |SYNC      |SYNC Flag Indicator
S * |        |          |Due to synchronization, software should check this bit when writing a new value to SC_PINCTL register.
S * |        |          |0 = Synchronizing is completion, user can write new data to SC_PINCTL register.
S * |        |          |1 = Last value is synchronizing.
S * |        |          |Note: This bit is read only.
S * |[31]    |LOOPBK    |Loop Back Test
S * |        |          |0 = loop back test Disabled.
S * |        |          |1 = Enabling loop back test and the internal SCDATOUT will connect to internal SC_DATA_I.
S * @var SC_T::TMRCTL0
S * Offset: 0x28  SC Internal Timer Control Register 0.
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[23:0]  |CNT       |Timer 0 Counter Value (ETU Base)
S * |        |          |This field indicates the internal timer operation values.
S * |[27:24] |OPMODE    |Timer 0 Operation Mode Selection
S * |        |          |This field indicates the internal 24-bit timer operation selection.
S * |        |          |Refer to 6.17.5.4 for programming Timer0
S * @var SC_T::TMRCTL1
S * Offset: 0x2C  SC Internal Timer Control Register 1.
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |CNT       |Timer 1 Counter Value (ETU Base)
S * |        |          |This field indicates the internal timer operation values.
S * |[27:24] |OPMODE    |Timer 1 Operation Mode Selection
S * |        |          |This field indicates the internal 8-bit timer operation selection.
S * |        |          |Refer to 6.17.5.4 for programming Timer1
S * @var SC_T::TMRCTL2
S * Offset: 0x30  SC Internal Timer Control Register 2.
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |CNT       |Timer 2 Counter Value (ETU Base)
S * |        |          |This field indicates the internal timer operation values.
S * |[27:24] |OPMODE    |Timer 2 Operation Mode Selection
S * |        |          |This field indicates the internal 8-bit timer operation selection
S * |        |          |Refer to 6.17.5.4 for programming Timer2
S * @var SC_T::UARTCTL
S * Offset: 0x34  SC UART Mode Control Register.
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |UARTEN    |UART Mode Enable Bit
S * |        |          |0 = Smart Card mode.
S * |        |          |1 = UART mode.
S * |        |          |Note1: When operating in UART mode, user must set CONSEL (SC_CTL[5:4]) = 00 and AUTOCEN(SC_CTL[3]) = 0.
S * |        |          |Note2: When operating in Smart Card mode, user must set UARTEN(SC_UARTCTL [0]) = 00.
S * |        |          |Note3: When UART is enabled, hardware will generate a reset to reset FIFO and internal state machine.
S * |[5:4]   |WLS10     |Word Length Selection
S * |        |          |00 = Word length is 8 bits.
S * |        |          |01 = Word length is 7 bits.
S * |        |          |10 = Word length is 6 bits.
S * |        |          |11 = Word length is 5 bits.
S * |        |          |Note: In smart card mode, this WLS must be '00'
S * |[6]     |PBOFF     |Parity Bit Disable Control
S * |        |          |0 = Parity bit is generated or checked between the "last data word bit" and "stop bit" of the serial data.
S * |        |          |1 = Parity bit is not generated (transmitting data) or checked (receiving data) during transfer.
S * |        |          |Note: In smart card mode, this field must be '0' (default setting is with parity bit)
S * |[7]     |OPE       |Odd Parity Enable Bit
S * |        |          |0 = Even number of logic 1's are transmitted or check the data word and parity bits in receiving mode.
S * |        |          |1 = Odd number of logic 1's are transmitted or check the data word and parity bits in receiving mode.
S * |        |          |Note: This bit has effect only when PBOFF bit is '0'.
S * @var SC_T::TMRDAT0
S * Offset: 0x38  SC Timer Current Data Register A.
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[23:0]  |CNT0      |Timer0 Current Data Value (Read Only)
S * |        |          |This field indicates the current count values of timer0.
S * @var SC_T::TMRDAT1_2
S * Offset: 0x3C  SC Timer Current Data Register B.
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |CNT1      |Timer1 Current Data Value (Read Only)
S * |        |          |This field indicates the current count values of timer1.
S * |[15:8]  |CNT2      |Timer2 Current Data Value (Read Only)
S * |        |          |This field indicates the current count values of timer2.
S */
S
S    __IO uint32_t DAT;           /* Offset: 0x00  SC Receiving/Transmit Holding Buffer Register.                     */
S    __IO uint32_t CTL;           /* Offset: 0x04  SC Control Register.                                               */
S    __IO uint32_t ALTCTL;        /* Offset: 0x08  SC Alternate Control Register.                                     */
S    __IO uint32_t EGT;           /* Offset: 0x0C  SC Extend Guard Time Register.                                     */
S    __IO uint32_t RXTOUT;        /* Offset: 0x10  SC Receive buffer Time-out Register.                               */
S    __IO uint32_t ETUCTL;        /* Offset: 0x14  SC ETU Control Register.                                           */
S    __IO uint32_t INTEN;         /* Offset: 0x18  SC Interrupt Enable Control Register.                              */
S    __IO uint32_t INTSTS;        /* Offset: 0x1C  SC Interrupt Status Register.                                      */
S    __IO uint32_t STATUS;        /* Offset: 0x20  SC Status Register.                                                */
S    __IO uint32_t PINCTL;        /* Offset: 0x24  SC Pin Control State Register.                                     */
S    __IO uint32_t TMRCTL0;       /* Offset: 0x28  SC Internal Timer Control Register 0.                              */
S    __IO uint32_t TMRCTL1;       /* Offset: 0x2C  SC Internal Timer Control Register 1.                              */
S    __IO uint32_t TMRCTL2;       /* Offset: 0x30  SC Internal Timer Control Register 2.                              */
S    __IO uint32_t UARTCTL;       /* Offset: 0x34  SC UART Mode Control Register.                                     */
S    __I  uint32_t TMRDAT0;       /* Offset: 0x38  SC Timer Current Data Register A.                                  */
S    __I  uint32_t TMRDAT1_2;     /* Offset: 0x3C  SC Timer Current Data Register B.                                  */
S
S} SC_T;
S
S
S
S/**
S    @addtogroup SC_CONST SC Bit Field Definition
S    Constant Definitions for SC Controller
S@{ */
S
S#define SC_DAT_DAT_Pos                   (0)                                        /*!< SC_T::DAT: DAT Position   */
S#define SC_DAT_DAT_Msk                   (0xfful << SC_DAT_DAT_Pos)                 /*!< SC_T::DAT: DAT Mask       */
S
S#define SC_CTL_SCEN_Pos                  (0)                                        /*!< SC_T::CTL: SCEN Position  */
S#define SC_CTL_SCEN_Msk                  (0x1ul << SC_CTL_SCEN_Pos)                 /*!< SC_T::CTL: SCEN Mask      */
S
S#define SC_CTL_RXOFF_Pos                 (1)                                        /*!< SC_T::CTL: RXOFF Position */
S#define SC_CTL_RXOFF_Msk                 (0x1ul << SC_CTL_RXOFF_Pos)                /*!< SC_T::CTL: RXOFF Mask     */
S
S#define SC_CTL_TXOFF_Pos                 (2)                                        /*!< SC_T::CTL: TXOFF Position */
S#define SC_CTL_TXOFF_Msk                 (0x1ul << SC_CTL_TXOFF_Pos)                /*!< SC_T::CTL: TXOFF Mask     */
S
S#define SC_CTL_AUTOCEN_Pos               (3)                                        /*!< SC_T::CTL: AUTOCEN Position   */
S#define SC_CTL_AUTOCEN_Msk               (0x1ul << SC_CTL_AUTOCEN_Pos)              /*!< SC_T::CTL: AUTOCEN Mask       */
S
S#define SC_CTL_CONSEL_Pos                (4)                                        /*!< SC_T::CTL: CONSEL Position    */
S#define SC_CTL_CONSEL_Msk                (0x3ul << SC_CTL_CONSEL_Pos)               /*!< SC_T::CTL: CONSEL Mask        */
S
S#define SC_CTL_RXTRGLV_Pos               (6)                                        /*!< SC_T::CTL: RXTRGLV Position   */
S#define SC_CTL_RXTRGLV_Msk               (0x3ul << SC_CTL_RXTRGLV_Pos)              /*!< SC_T::CTL: RXTRGLV Mask       */
S
S#define SC_CTL_BGT_Pos                   (8)                                        /*!< SC_T::CTL: BGT Position   */
S#define SC_CTL_BGT_Msk                   (0x1ful << SC_CTL_BGT_Pos)                 /*!< SC_T::CTL: BGT Mask       */
S
S#define SC_CTL_TMRSEL_Pos                (13)                                       /*!< SC_T::CTL: TMRSEL Position    */
S#define SC_CTL_TMRSEL_Msk                (0x3ul << SC_CTL_TMRSEL_Pos)               /*!< SC_T::CTL: TMRSEL Mask        */
S
S#define SC_CTL_NSB_Pos                   (15)                                       /*!< SC_T::CTL: NSB Position   */
S#define SC_CTL_NSB_Msk                   (0x1ul << SC_CTL_NSB_Pos)                  /*!< SC_T::CTL: NSB Mask       */
S
S#define SC_CTL_RXRTY_Pos                 (16)                                       /*!< SC_T::CTL: RXRTY Position */
S#define SC_CTL_RXRTY_Msk                 (0x7ul << SC_CTL_RXRTY_Pos)                /*!< SC_T::CTL: RXRTY Mask     */
S
S#define SC_CTL_RXRTYEN_Pos               (19)                                       /*!< SC_T::CTL: RXRTYEN Position   */
S#define SC_CTL_RXRTYEN_Msk               (0x1ul << SC_CTL_RXRTYEN_Pos)              /*!< SC_T::CTL: RXRTYEN Mask       */
S
S#define SC_CTL_TXRTY_Pos                 (20)                                       /*!< SC_T::CTL: TXRTY Position */
S#define SC_CTL_TXRTY_Msk                 (0x7ul << SC_CTL_TXRTY_Pos)                /*!< SC_T::CTL: TXRTY Mask     */
S
S#define SC_CTL_TXRTYEN_Pos               (23)                                       /*!< SC_T::CTL: TXRTYEN Position   */
S#define SC_CTL_TXRTYEN_Msk               (0x1ul << SC_CTL_TXRTYEN_Pos)              /*!< SC_T::CTL: TXRTYEN Mask       */
S
S#define SC_CTL_CDDBSEL_Pos               (24)                                       /*!< SC_T::CTL: CDDBSEL Position   */
S#define SC_CTL_CDDBSEL_Msk               (0x3ul << SC_CTL_CDDBSEL_Pos)              /*!< SC_T::CTL: CDDBSEL Mask       */
S
S#define SC_CTL_CDLV_Pos                  (26)                                       /*!< SC_T::CTL: CDLV Position  */
S#define SC_CTL_CDLV_Msk                  (0x1ul << SC_CTL_CDLV_Pos)                 /*!< SC_T::CTL: CDLV Mask      */
S
S#define SC_CTL_SYNC_Pos                  (30)                                       /*!< SC_T::CTL: SYNC Position  */
S#define SC_CTL_SYNC_Msk                  (0x1ul << SC_CTL_SYNC_Pos)                 /*!< SC_T::CTL: SYNC Mask      */
S
S#define SC_CTL_ICEDEBUG_Pos              (31)                                       /*!< SC_T::CTL: ICEDEBUG Position  */
S#define SC_CTL_ICEDEBUG_Msk              (0x1ul << SC_CTL_ICEDEBUG_Pos)             /*!< SC_T::CTL: ICEDEBUG Mask      */
S
S#define SC_ALTCTL_TXRST_Pos              (0)                                        /*!< SC_T::ALTCTL: TXRST Position  */
S#define SC_ALTCTL_TXRST_Msk              (0x1ul << SC_ALTCTL_TXRST_Pos)             /*!< SC_T::ALTCTL: TXRST Mask      */
S
S#define SC_ALTCTL_RXRST_Pos              (1)                                        /*!< SC_T::ALTCTL: RXRST Position  */
S#define SC_ALTCTL_RXRST_Msk              (0x1ul << SC_ALTCTL_RXRST_Pos)             /*!< SC_T::ALTCTL: RXRST Mask      */
S
S#define SC_ALTCTL_DACTEN_Pos             (2)                                        /*!< SC_T::ALTCTL: DACTEN Position */
S#define SC_ALTCTL_DACTEN_Msk             (0x1ul << SC_ALTCTL_DACTEN_Pos)            /*!< SC_T::ALTCTL: DACTEN Mask     */
S
S#define SC_ALTCTL_ACTEN_Pos              (3)                                        /*!< SC_T::ALTCTL: ACTEN Position  */
S#define SC_ALTCTL_ACTEN_Msk              (0x1ul << SC_ALTCTL_ACTEN_Pos)             /*!< SC_T::ALTCTL: ACTEN Mask      */
S
S#define SC_ALTCTL_WARSTEN_Pos            (4)                                        /*!< SC_T::ALTCTL: WARSTEN Position    */
S#define SC_ALTCTL_WARSTEN_Msk            (0x1ul << SC_ALTCTL_WARSTEN_Pos)           /*!< SC_T::ALTCTL: WARSTEN Mask        */
S
S#define SC_ALTCTL_CNTEN0_Pos             (5)                                        /*!< SC_T::ALTCTL: CNTEN0 Position */
S#define SC_ALTCTL_CNTEN0_Msk             (0x1ul << SC_ALTCTL_CNTEN0_Pos)            /*!< SC_T::ALTCTL: CNTEN0 Mask     */
S
S#define SC_ALTCTL_CNTEN1_Pos             (6)                                        /*!< SC_T::ALTCTL: CNTEN1 Position */
S#define SC_ALTCTL_CNTEN1_Msk             (0x1ul << SC_ALTCTL_CNTEN1_Pos)            /*!< SC_T::ALTCTL: CNTEN1 Mask     */
S
S#define SC_ALTCTL_CNTEN2_Pos             (7)                                        /*!< SC_T::ALTCTL: CNTEN2 Position */
S#define SC_ALTCTL_CNTEN2_Msk             (0x1ul << SC_ALTCTL_CNTEN2_Pos)            /*!< SC_T::ALTCTL: CNTEN2 Mask     */
S
S#define SC_ALTCTL_INITSEL_Pos            (8)                                        /*!< SC_T::ALTCTL: INITSEL Position    */
S#define SC_ALTCTL_INITSEL_Msk            (0x3ul << SC_ALTCTL_INITSEL_Pos)           /*!< SC_T::ALTCTL: INITSEL Mask        */
S
S#define SC_ALTCTL_ADACEN_Pos             (11)                                       /*!< SC_T::ALTCTL: ADACEN Position    */
S#define SC_ALTCTL_ADACEN_Msk             (0x1ul << SC_ALTCTL_ADACEN_Pos)            /*!< SC_T::ALTCTL: ADACEN Mask        */
S
S#define SC_ALTCTL_RXBGTEN_Pos            (12)                                       /*!< SC_T::ALTCTL: RXBGTEN Position    */
S#define SC_ALTCTL_RXBGTEN_Msk            (0x1ul << SC_ALTCTL_RXBGTEN_Pos)           /*!< SC_T::ALTCTL: RXBGTEN Mask        */
S
S#define SC_ALTCTL_ACTSTS0_Pos            (13)                                       /*!< SC_T::ALTCTL: ACTSTS0 Position    */
S#define SC_ALTCTL_ACTSTS0_Msk            (0x1ul << SC_ALTCTL_ACTSTS0_Pos)           /*!< SC_T::ALTCTL: ACTSTS0 Mask        */
S
S#define SC_ALTCTL_ACTSTS1_Pos            (14)                                       /*!< SC_T::ALTCTL: ACTSTS1 Position    */
S#define SC_ALTCTL_ACTSTS1_Msk            (0x1ul << SC_ALTCTL_ACTSTS1_Pos)           /*!< SC_T::ALTCTL: ACTSTS1 Mask        */
S
S#define SC_ALTCTL_ACTSTS2_Pos            (15)                                       /*!< SC_T::ALTCTL: ACTSTS2 Position    */
S#define SC_ALTCTL_ACTSTS2_Msk            (0x1ul << SC_ALTCTL_ACTSTS2_Pos)           /*!< SC_T::ALTCTL: ACTSTS2 Mask        */
S
S#define SC_ALTCTL_OUTSEL_Pos             (16)                                       /*!< SC_T::ALTCTL: OUTSEL Position */
S#define SC_ALTCTL_OUTSEL_Msk             (0x1ul << SC_ALTCTL_OUTSEL_Pos)            /*!< SC_T::ALTCTL: OUTSEL Mask     */
S
S#define SC_EGT_EGT_Pos                   (0)                                        /*!< SC_T::EGT: EGT Position   */
S#define SC_EGT_EGT_Msk                   (0xfful << SC_EGT_EGT_Pos)                 /*!< SC_T::EGT: EGT Mask       */
S
S#define SC_RXTOUT_RFTM_Pos               (0)                                        /*!< SC_T::RXTOUT: RFTM Position   */
S#define SC_RXTOUT_RFTM_Msk               (0x1fful << SC_RXTOUT_RFTM_Pos)            /*!< SC_T::RXTOUT: RFTM Mask       */
S
S#define SC_ETUCTL_ETURDIV_Pos            (0)                                        /*!< SC_T::ETUCTL: ETURDIV_ Position   */
S#define SC_ETUCTL_ETURDIV_Msk            (0xffful << SC_ETUCTL_ETURDIV_Pos)         /*!< SC_T::ETUCTL: ETURDIV_ Mask       */
S
S#define SC_ETUCTL_CMPEN_Pos              (15)                                       /*!< SC_T::ETUCTL: CMPEN_ Position */
S#define SC_ETUCTL_CMPEN_Msk              (0x1ul << SC_ETUCTL_CMPEN_Pos)             /*!< SC_T::ETUCTL: CMPEN_ Mask     */
S
S#define SC_INTEN_RDAIEN_Pos              (0)                                        /*!< SC_T::INTEN: RDAIEN Position  */
S#define SC_INTEN_RDAIEN_Msk              (0x1ul << SC_INTEN_RDAIEN_Pos)             /*!< SC_T::INTEN: RDAIEN Mask      */
S
S#define SC_INTEN_TBEIEN_Pos              (1)                                        /*!< SC_T::INTEN: TBEIEN Position  */
S#define SC_INTEN_TBEIEN_Msk              (0x1ul << SC_INTEN_TBEIEN_Pos)             /*!< SC_T::INTEN: TBEIEN Mask      */
S
S#define SC_INTEN_TERRIEN_Pos             (2)                                        /*!< SC_T::INTEN: TERRIEN Position */
S#define SC_INTEN_TERRIEN_Msk             (0x1ul << SC_INTEN_TERRIEN_Pos)            /*!< SC_T::INTEN: TERRIEN Mask     */
S
S#define SC_INTEN_TMR0IEN_Pos             (3)                                        /*!< SC_T::INTEN: TMR0IEN_Position */
S#define SC_INTEN_TMR0IEN_Msk             (0x1ul << SC_INTEN_TMR0IEN_Pos)            /*!< SC_T::INTEN: TMR0IEN Mask     */
S
S#define SC_INTEN_TMR1IEN_Pos             (4)                                        /*!< SC_T::INTEN: TMR1IEN Position */
S#define SC_INTEN_TMR1IEN_Msk             (0x1ul << SC_INTEN_TMR1IEN_Pos)            /*!< SC_T::INTEN: TMR1IEN Mask     */
S
S#define SC_INTEN_TMR2IEN_Pos             (5)                                        /*!< SC_T::INTEN: TMR2IEN Position */
S#define SC_INTEN_TMR2IEN_Msk             (0x1ul << SC_INTEN_TMR2IEN_Pos)            /*!< SC_T::INTEN: TMR2IEN Mask     */
S
S#define SC_INTEN_BGTIEN_Pos              (6)                                        /*!< SC_T::INTEN: BGTIEN Position  */
S#define SC_INTEN_BGTIEN_Msk              (0x1ul << SC_INTEN_BGTIEN_Pos)             /*!< SC_T::INTEN: BGTIEN Mask      */
S
S#define SC_INTEN_CDIEN_Pos               (7)                                        /*!< SC_T::INTEN: CDIEN Position   */
S#define SC_INTEN_CDIEN_Msk               (0x1ul << SC_INTEN_CDIEN_Pos)              /*!< SC_T::INTEN: CDIEN Mask       */
S
S#define SC_INTEN_INITIEN_Pos             (8)                                        /*!< SC_T::INTEN: INITIEN Position */
S#define SC_INTEN_INITIEN_Msk             (0x1ul << SC_INTEN_INITIEN_Pos)            /*!< SC_T::INTEN: INITIEN Mask     */
S
S#define SC_INTEN_RXTOIF_Pos              (9)                                        /*!< SC_T::INTEN: RXTOIF Position  */
S#define SC_INTEN_RXTOIF_Msk              (0x1ul << SC_INTEN_RXTOIF_Pos)             /*!< SC_T::INTEN: RXTOIF Mask      */
S
S#define SC_INTEN_ACERRIEN_Pos            (10)                                       /*!< SC_T::INTEN: ACERRIEN Position    */
S#define SC_INTEN_ACERRIEN_Msk            (0x1ul << SC_INTEN_ACERRIEN_Pos)           /*!< SC_T::INTEN: ACERRIEN Mask        */
S
S#define SC_INTSTS_RDAIF_Pos              (0)                                        /*!< SC_T::INTSTS: RDAIF Position  */
S#define SC_INTSTS_RDAIF_Msk              (0x1ul << SC_INTSTS_RDAIF_Pos)             /*!< SC_T::INTSTS: RDAIF Mask      */
S
S#define SC_INTSTS_TBEIF_Pos              (1)                                        /*!< SC_T::INTSTS: TBEIF Position  */
S#define SC_INTSTS_TBEIF_Msk              (0x1ul << SC_INTSTS_TBEIF_Pos)             /*!< SC_T::INTSTS: TBEIF Mask      */
S
S#define SC_INTSTS_TERRIF_Pos             (2)                                        /*!< SC_T::INTSTS: TERRIF Position */
S#define SC_INTSTS_TERRIF_Msk             (0x1ul << SC_INTSTS_TERRIF_Pos)            /*!< SC_T::INTSTS: TERRIF Mask     */
S
S#define SC_INTSTS_TMR0IF_Pos             (3)                                        /*!< SC_T::INTSTS: TMR0IF Position */
S#define SC_INTSTS_TMR0IF_Msk             (0x1ul << SC_INTSTS_TMR0IF_Pos)            /*!< SC_T::INTSTS: TMR0IF Mask     */
S
S#define SC_INTSTS_TMR1IF_Pos             (4)                                        /*!< SC_T::INTSTS: TMR1IF Position */
S#define SC_INTSTS_TMR1IF_Msk             (0x1ul << SC_INTSTS_TMR1IF_Pos)            /*!< SC_T::INTSTS: TMR1IF Mask     */
S
S#define SC_INTSTS_TMR2IF_Pos             (5)                                        /*!< SC_T::INTSTS: TMR2IF Position */
S#define SC_INTSTS_TMR2IF_Msk             (0x1ul << SC_INTSTS_TMR2IF_Pos)            /*!< SC_T::INTSTS: TMR2IF Mask     */
S
S#define SC_INTSTS_BGTIF_Pos              (6)                                        /*!< SC_T::INTSTS: BGTIF Position  */
S#define SC_INTSTS_BGTIF_Msk              (0x1ul << SC_INTSTS_BGTIF_Pos)             /*!< SC_T::INTSTS: BGTIF Mask      */
S
S#define SC_INTSTS_CDIF_Pos               (7)                                        /*!< SC_T::INTSTS: CDIF Position   */
S#define SC_INTSTS_CDIF_Msk               (0x1ul << SC_INTSTS_CDIF_Pos)              /*!< SC_T::INTSTS: CDIF Mask       */
S
S#define SC_INTSTS_INITIF_Pos             (8)                                        /*!< SC_T::INTSTS: INITIF Position */
S#define SC_INTSTS_INITIF_Msk             (0x1ul << SC_INTSTS_INITIF_Pos)            /*!< SC_T::INTSTS: INITIF Mask     */
S
S#define SC_INTSTS_RBTOIF_Pos             (9)                                        /*!< SC_T::INTSTS: RBTOIF Position */
S#define SC_INTSTS_RBTOIF_Msk             (0x1ul << SC_INTSTS_RBTOIF_Pos)            /*!< SC_T::INTSTS: RBTOIF Mask     */
S
S#define SC_INTSTS_ACERRIF_Pos            (10)                                       /*!< SC_T::INTSTS: ACERRIF Position    */
S#define SC_INTSTS_ACERRIF_Msk            (0x1ul << SC_INTSTS_ACERRIF_Pos)           /*!< SC_T::INTSTS: ACERRIF Mask        */
S
S#define SC_STATUS_RXOV_Pos               (0)                                        /*!< SC_T::STATUS: RXO Position    */
S#define SC_STATUS_RXOV_Msk               (0x1ul << SC_STATUS_RXOV_Pos)              /*!< SC_T::STATUS: RXO Mask        */
S
S#define SC_STATUS_RXEMPTY_Pos            (1)                                        /*!< SC_T::STATUS: RXEMPTY Position    */
S#define SC_STATUS_RXEMPTY_Msk            (0x1ul << SC_STATUS_RXEMPTY_Pos)           /*!< SC_T::STATUS: RXEMPTY Mask        */
S
S#define SC_STATUS_RXFULL_Pos             (2)                                        /*!< SC_T::STATUS: RXFULL Position */
S#define SC_STATUS_RXFULL_Msk             (0x1ul << SC_STATUS_RXFULL_Pos)            /*!< SC_T::STATUS: RXFULL Mask     */
S
S#define SC_STATUS_PEF_Pos                (4)                                        /*!< SC_T::STATUS: PEF Position    */
S#define SC_STATUS_PEF_Msk                (0x1ul << SC_STATUS_PEF_Pos)               /*!< SC_T::STATUS: PEF Mask        */
S
S#define SC_STATUS_FEF_Pos                (5)                                        /*!< SC_T::STATUS: FEF Position    */
S#define SC_STATUS_FEF_Msk                (0x1ul << SC_STATUS_FEF_Pos)               /*!< SC_T::STATUS: FEF Mask        */
S
S#define SC_STATUS_BEF_Pos                (6)                                        /*!< SC_T::STATUS: BEF Position    */
S#define SC_STATUS_BEF_Msk                (0x1ul << SC_STATUS_BEF_Pos)               /*!< SC_T::STATUS: BEF Mask        */
S
S#define SC_STATUS_TXOV_Pos               (8)                                        /*!< SC_T::STATUS: TXOV Position   */
S#define SC_STATUS_TXOV_Msk               (0x1ul << SC_STATUS_TXOV_Pos)              /*!< SC_T::STATUS: TXOV Mask       */
S
S#define SC_STATUS_TXEMPTY_Pos            (9)                                        /*!< SC_T::STATUS: TXEMPTY Position    */
S#define SC_STATUS_TXEMPTY_Msk            (0x1ul << SC_STATUS_TXEMPTY_Pos)           /*!< SC_T::STATUS: TXEMPTY Mask        */
S
S#define SC_STATUS_TXFULL_Pos             (10)                                       /*!< SC_T::STATUS: TXFULL Position */
S#define SC_STATUS_TXFULL_Msk             (0x1ul << SC_STATUS_TXFULL_Pos)            /*!< SC_T::STATUS: TXFULL Mask     */
S
S#define SC_STATUS_CREMOVE_Pos            (11)                                       /*!< SC_T::STATUS: CREMOVE Position    */
S#define SC_STATUS_CREMOVE_Msk            (0x1ul << SC_STATUS_CREMOVE_Pos)           /*!< SC_T::STATUS: CREMOVE Mask        */
S
S#define SC_STATUS_CINSERT_Pos            (12)                                       /*!< SC_T::STATUS: CINSERT Position    */
S#define SC_STATUS_CINSERT_Msk            (0x1ul << SC_STATUS_CINSERT_Pos)           /*!< SC_T::STATUS: CINSERT Mask        */
S
S#define SC_STATUS_CDPINSTS_Pos           (13)                                       /*!< SC_T::STATUS: CDPINSTS Position   */
S#define SC_STATUS_CDPINSTS_Msk           (0x1ul << SC_STATUS_CDPINSTS_Pos)          /*!< SC_T::STATUS: CDPINSTS Mask       */
S
S#define SC_STATUS_RXPOINT_Pos            (16)                                       /*!< SC_T::STATUS: RXPOINT Position    */
S#define SC_STATUS_RXPOINT_Msk            (0x3ul << SC_STATUS_RXPOINT_Pos)           /*!< SC_T::STATUS: RXPOINT Mask        */
S
S#define SC_STATUS_RXRERR_Pos             (21)                                       /*!< SC_T::STATUS: RXRERR Position     */
S#define SC_STATUS_RXRERR_Msk             (0x1ul << SC_STATUS_RXRERR_Pos)            /*!< SC_T::STATUS: RXRERR Mask         */
S
S#define SC_STATUS_RXOVERR_Pos            (22)                                       /*!< SC_T::STATUS: RXOVERR Position    */
S#define SC_STATUS_RXOVERR_Msk            (0x1ul << SC_STATUS_RXOVERR_Pos)           /*!< SC_T::STATUS: RXOVERR Mask        */
S
S#define SC_STATUS_RXACT_Pos              (23)                                       /*!< SC_T::STATUS: RXACT Position      */
S#define SC_STATUS_RXACT_Msk              (0x1ul << SC_STATUS_RXACT_Pos)             /*!< SC_T::STATUS: RXACT Msk           */
S
S#define SC_STATUS_TXPOINT_Pos            (24)                                       /*!< SC_T::STATUS: TXPOINT Position    */
S#define SC_STATUS_TXPOINT_Msk            (0x3ul << SC_STATUS_TXPOINT_Pos)           /*!< SC_T::STATUS: TXPOINT Msk         */
S
S#define SC_STATUS_TXRERR_Pos             (29)                                       /*!< SC_T::STATUS: TXRERR Position     */
S#define SC_STATUS_TXRERR_Msk             (0x1ul << SC_STATUS_TXRERR_Pos)            /*!< SC_T::STATUS: TXRERR Msk          */
S
S#define SC_STATUS_TXOVERR_Pos            (30)                                       /*!< SC_T::STATUS: TXOVERR_ Position   */
S#define SC_STATUS_TXOVERR_Msk            (0x1ul << SC_STATUS_TXOVERR_Pos)           /*!< SC_T::STATUS: TXOVERR_ Msk        */
S
S#define SC_STATUS_TXACT_Pos              (31)                                       /*!< SC_T::STATUS: TXACT Position      */
S#define SC_STATUS_TXACT_Msk              (0x1ul << SC_STATUS_TXACT_Pos)             /*!< SC_T::STATUS: TXACT Msk           */
S
S#define SC_PINCTL_PWREN_Pos              (0)                                        /*!< SC_T::PINCTL: PWREN Position  */
S#define SC_PINCTL_PWREN_Msk              (0x1ul << SC_PINCTL_PWREN_Pos)             /*!< SC_T::PINCTL: PWREN Msk       */
S
S#define SC_PINCTL_SCRST_Pos              (1)                                        /*!< SC_T::PINCTL: SCRST Position  */
S#define SC_PINCTL_SCRST_Msk              (0x1ul << SC_PINCTL_SCRST_Pos)             /*!< SC_T::PINCTL: SCRST Msk       */
S
S#define SC_PINCTL_CSTOPLV_Pos            (5)                                        /*!< SC_T::PINCTL: CSTOPLV Position    */
S#define SC_PINCTL_CSTOPLV_Msk            (0x1ul << SC_PINCTL_CSTOPLV_Pos)           /*!< SC_T::PINCTL: CSTOPLV Msk         */
S
S#define SC_PINCTL_CLKKEEP_Pos            (6)                                        /*!< SC_T::PINCTL: CLKKEEP Position    */
S#define SC_PINCTL_CLKKEEP_Msk            (0x1ul << SC_PINCTL_CLKKEEP_Pos)           /*!< SC_T::PINCTL: CLKKEEP Msk         */
S
S#define SC_PINCTL_SCDOUT_Pos             (9)                                        /*!< SC_T::PINCTL: SCDOUT Position */
S#define SC_PINCTL_SCDOUT_Msk             (0x1ul << SC_PINCTL_SCDOUT_Pos)            /*!< SC_T::PINCTL: SCDOUT Msk      */
S
S#define SC_PINCTL_PWRINV_Pos             (11)                                       /*!< SC_T::PINCTL: PWRINV Position */
S#define SC_PINCTL_PWRINV_Msk             (0x1ul << SC_PINCTL_PWRINV_Pos)            /*!< SC_T::PINCTL: PWRINV Msk      */
S
S#define SC_PINCTL_SCDOSTS_Pos            (12)                                       /*!< SC_T::PINCTL: SCDOSTS Position    */
S#define SC_PINCTL_SCDOSTS_Msk            (0x1ul << SC_PINCTL_SCDOSTS_Pos)           /*!< SC_T::PINCTL: SCDOSTS Msk         */
S
S#define SC_PINCTL_DATSTS_Pos             (16)                                       /*!< SC_T::PINCTL: DATSTS Position */
S#define SC_PINCTL_DATSTS_Msk             (0x1ul << SC_PINCTL_DATSTS_Pos)            /*!< SC_T::PINCTL: DATSTS Msk      */
S
S#define SC_PINCTL_PWRSTS_Pos             (17)                                       /*!< SC_T::PINCTL: PWRSTS Position */
S#define SC_PINCTL_PWRSTS_Msk             (0x1ul << SC_PINCTL_PWRSTS_Pos)            /*!< SC_T::PINCTL: PWRSTS Msk      */
S
S#define SC_PINCTL_RSTSTS_Pos             (18)                                       /*!< SC_T::PINCTL: RSTSTS Position */
S#define SC_PINCTL_RSTSTS_Msk             (0x1ul << SC_PINCTL_RSTSTS_Pos)            /*!< SC_T::PINCTL: RSTSTS Msk      */
S
S#define SC_PINCTL_SYNC_Pos               (30)                                       /*!< SC_T::PINCTL: SYNC Position   */
S#define SC_PINCTL_SYNC_Msk               (0x1ul << SC_PINCTL_SYNC_Pos)              /*!< SC_T::PINCTL: SYNC Msk        */
S
S#define SC_PINCTL_LOOPBK_Pos             (31)                                       /*!< SC_T::PINCTL: LOOPBK Position */
S#define SC_PINCTL_LOOPBK_Msk             (0x1ul << SC_PINCTL_LOOPBK_Pos)            /*!< SC_T::PINCTL: LOOPBK Msk      */
S
S#define SC_TMRCTL0_CNT_Pos               (0)                                        /*!< SC_T::TMRCTL0: CNT Position   */
S#define SC_TMRCTL0_CNT_Msk               (0xfffffful << SC_TMRCTL0_CNT_Pos)         /*!< SC_T::TMRCTL0: CNT Msk        */
S
S#define SC_TMRCTL0_OPMODE_Pos            (24)                                       /*!< SC_T::TMRCTL0: OPMODE Position    */
S#define SC_TMRCTL0_OPMODE_Msk            (0xful << SC_TMRCTL0_OPMODE_Pos)           /*!< SC_T::TMRCTL0: OPMODE Msk         */
S
S#define SC_TMRCTL1_CNT_Pos               (0)                                        /*!< SC_T::TMRCTL1: CNT Position   */
S#define SC_TMRCTL1_CNT_Msk               (0xfful << SC_TMRCTL1_CNT_Pos)             /*!< SC_T::TMRCTL1: CNT Msk        */
S
S#define SC_TMRCTL1_OPMODE_Pos            (24)                                       /*!< SC_T::TMRCTL1: OPMODE Position    */
S#define SC_TMRCTL1_OPMODE_Msk            (0xful << SC_TMRCTL1_OPMODE_Pos)           /*!< SC_T::TMRCTL1: OPMODE Msk         */
S
S#define SC_TMRCTL2_CNT_Pos               (0)                                        /*!< SC_T::TMRCTL2: CNT Position   */
S#define SC_TMRCTL2_CNT_Msk               (0xfful << SC_TMRCTL2_CNT_Pos)             /*!< SC_T::TMRCTL2: CNT Msk        */
S
S#define SC_TMRCTL2_OPMODE_Pos            (24)                                       /*!< SC_T::TMRCTL2: OPMODE Position    */
S#define SC_TMRCTL2_OPMODE_Msk            (0xful << SC_TMRCTL2_OPMODE_Pos)           /*!< SC_T::TMRCTL2: OPMODE Msk         */
S
S#define SC_UARTCTL_UARTEN_Pos            (0)                                        /*!< SC_T::UARTCTL: UARTEN Position    */
S#define SC_UARTCTL_UARTEN_Msk            (0x1ul << SC_UARTCTL_UARTEN_Pos)           /*!< SC_T::UARTCTL: UARTEN Msk         */
S
S#define SC_UARTCTL_WLS_Pos               (4)                                        /*!< SC_T::UARTCTL: WLS Position   */
S#define SC_UARTCTL_WLS_Msk               (0x3ul << SC_UARTCTL_WLS10_Pos)            /*!< SC_T::UARTCTL: WLS Msk        */
S
S#define SC_UARTCTL_PBOFF_Pos             (6)                                        /*!< SC_T::UARTCTL: PBOFF Position */
S#define SC_UARTCTL_PBOFF_Msk             (0x1ul << SC_UARTCTL_PBOFF_Pos)            /*!< SC_T::UARTCTL: PBOFF Msk      */
S
S#define SC_UARTCTL_OPE_Pos               (7)                                        /*!< SC_T::UARTCTL: OPE Position   */
S#define SC_UARTCTL_OPE_Msk               (0x1ul << SC_UARTCTL_OPE_Pos)              /*!< SC_T::UARTCTL: OPE Msk        */
S
S#define SC_TMRDAT0_CNT0_Pos              (0)                                        /*!< SC_T::TMRDAT0: CNT0 Position  */
S#define SC_TMRDAT0_CNT0_Msk              (0xfffffful << SC_TMRDAT0_CNT0_Pos)        /*!< SC_T::TMRDAT0: CNT0 Msk       */
S
S#define SC_TMRDAT1_2_CNT1_Pos            (0)                                        /*!< SC_T::TMRDAT1_2: CNT1 Position    */
S#define SC_TMRDAT1_2_CNT1_Msk            (0xfful << SC_TMRDAT1_2_CNT1_Pos)          /*!< SC_T::TMRDAT1_2: CNT1 Msk         */
S
S#define SC_TMRDAT1_2_CNT2_Pos            (8)                                        /*!< SC_T::TMRDAT1_2: CNT2 Position    */
S#define SC_TMRDAT1_2_CNT2_Msk            (0xfful << SC_TMRDAT1_2_CNT2_Pos)          /*!< SC_T::TMRDAT1_2: CNT2 Msk         */
S
S/**@}*/ /* SC_CONST */
S/**@}*/ /* end of SC register group */
S
S
S/*---------------------- Serial Peripheral Interface Controller -------------------------*/
S/**
S    @addtogroup SPI Serial Peripheral Interface Controller(SPI)
S    Memory Mapped Structure for SPI Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S/**
S * @var SPI_T::CTL
S * Offset: 0x00  Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |SPIEN     |SPI Transfer Control Enable Bit
S * |        |          |In Master mode, the transfer will start when there is data in the FIFO buffer after this is set to 1.
S * |        |          |In Slave mode, this device is ready to receive data when this bit is set to 1.
S * |        |          |0 = Transfer control Disabled.
S * |        |          |1 = Transfer control Enabled.
S * |        |          |Note: Before changing the configurations of SPI_CTL, SPI_CLKDIV, SPI_SSCTL and SPI_FIFOCTL registers, user shall clear the SPIEN (SPI_CTL[0]) and confirm the SPIENSTS (SPI_STATUS[15]) is 0.
S * |[1]     |RXNEG     |Receive On Negative Edge
S * |        |          |0 = Received data input signal is latched on the rising edge of SPI bus clock.
S * |        |          |1 = Received data input signal is latched on the falling edge of SPI bus clock.
S * |[2]     |TXNEG     |Transmit On Negative Edge
S * |        |          |0 = Transmitted data output signal is changed on the rising edge of SPI bus clock.
S * |        |          |1 = Transmitted data output signal is changed on the falling edge of SP bus clock.
S * |[3]     |CLKPOL    |Clock Polarity
S * |        |          |0 = SPI bus clock is idle low.
S * |        |          |1 = SPI bus clock is idle high.
S * |[7:4]   |SUSPITV   |Suspend Interval (Master Only)
S * |        |          |The four bits provide configurable suspend interval between two successive transmit/receive transaction in a transfer.
S * |        |          |The definition of the suspend interval is the interval between the last clock edge of the preceding transaction word and the first clock edge of the following transaction word.
S * |        |          |The default value is 0x3.
S * |        |          |The period of the suspend interval is obtained according to the following equation.
S * |        |          |(SUSPITV[3:0] + 0.5) * period of SPICLK clock cycle
S * |        |          |Example:
S * |        |          |SUSPITV = 0x0 ... 0.5 SPICLK clock cycle.
S * |        |          |SUSPITV = 0x1 ... 1.5 SPICLK clock cycle.
S * |        |          |...
S * |        |          |SUSPITV = 0xE ... 14.5 SPICLK clock cycle.
S * |        |          |SUSPITV = 0xF ... 15.5 SPICLK clock cycle.
S * |[12:8]  |DWIDTH    |Data Width
S * |        |          |This field specifies how many bits can be transmitted / received in one transaction.
S * |        |          |The minimum bit length is 8 bits and can up to 32 bits.
S * |        |          |DWIDTH = 0x08 ... 8 bits.
S * |        |          |DWIDTH = 0x09 ... 9 bits.
S * |        |          |...
S * |        |          |DWIDTH = 0x1F ... 31 bits.
S * |        |          |DWIDTH = 0x00 ... 32 bits.
S * |[13]    |LSB       |Send LSB First
S * |        |          |0 = The MSB, which bit of transmit/receive register depends on the setting of DWIDTH, is transmitted/received first.
S * |        |          |1 = The LSB, bit 0 of the SPI TX register, is sent first to the SPI data output pin, and the first bit received from the SPI data input pin will be put in the LSB position of the RX register (bit 0 of SPI_RX).
S * |[16]    |TWOBIT    |2-Bit Transfer Mode Enable Bit (Only Supported in SPI0)
S * |        |          |0 = 2-Bit Transfer mode Disabled.
S * |        |          |1 = 2-Bit Transfer mode Enabled.
S * |        |          |Note: When 2-Bit Transfer mode is enabled, the first serial transmitted bit data is from the first FIFO buffer data, and the 2nd
S * |        |          |serial transmitted bit data is from the second FIFO buffer data.
S * |        |          |As the same as transmitted function, the first received bit data is stored into the first FIFO buffer and the 2nd received bit data is stored into the second FIFO buffer at the same time.
S * |[17]    |UNITIEN   |Unit Transfer Interrupt Enable Bit
S * |        |          |0 = SPI unit transfer interrupt Disabled.
S * |        |          |1 = SPI unit transfer interrupt Enabled.
S * |[18]    |SLAVE     |Slave Mode Control
S * |        |          |0 = Master mode.
S * |        |          |1 = Slave mode.
S * |[19]    |REORDER   |Byte Reorder Function Enable Bit
S * |        |          |0 = Byte Reorder function Disabled.
S * |        |          |1 = Byte Reorder function Enabled. A byte suspend interval will be inserted among each byte.
S * |        |          |The period of the byte suspend interval depends on the setting of SUSPITV.
S * |        |          |Note:
S * |        |          |1. Byte Reorder function is only available if DWIDTH is defined as 16, 24, and 32 bits.
S * |        |          |2. Byte Reorder function is not supported when the Quad or Dual I/O mode is enabled.
S * |[20]    |QDIODIR   |Quad Or Dual I/O Mode Direction Control (Only Supported in SPI0)
S * |        |          |0 = Quad or Dual Input mode.
S * |        |          |1 = Quad or Dual Output mode.
S * |[21]    |DUALIOEN  |Dual I/O Mode Enable Bit (Only Supported in SPI0)
S * |        |          |0 = Dual I/O mode Disabled.
S * |        |          |1 = Dual I/O mode Enabled.
S * |[22]    |QUADIOEN  |Quad I/O Mode Enable Bit (Only Supported in SPI0)
S * |        |          |0 = Quad I/O mode Disabled.
S * |        |          |1 = Quad I/O mode Enabled.
S * @var SPI_T::CLKDIV
S * Offset: 0x04  Clock Divider Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |DIVIDER   |Clock Divider
S * |        |          |The value in this field is the frequency divider for generating the peripheral clock, fspi_eclk, and the SPI bus clock of SPI master.
S * |        |          |The frequency is obtained according to the following equation.
S * |        |          | fspi_eclk = fspi_clock_src / (DIVIDER + 1)
S * |        |          |where fspi_clock_src is the peripheral clock source, which is defined in the clock control register CLK_CLKSEL2.
S * @var SPI_T::SSCTL
S * Offset: 0x08  Slave Select Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |SS        |Slave Selection Control (Master Only)
S * |        |          |If AUTOSS bit is cleared to 0,
S * |        |          |0 = set the SPIn_SS line to inactive state.
S * |        |          |1 = set the SPIn_SS line to active state
S * |        |          |If the AUTOSS bit is set to 1,
S * |        |          |0 = Keep the SPIn_SS line at inactive state.
S * |        |          |1 = SPIn_SS line will be automatically driven to active state for the duration of data transfer, and will be driven to inactive state for the rest of the time.
S * |        |          |The active state of SPIn_SS is specified in SSACTPOL (SPI_SSCTL[2]).
S * |[2]     |SSACTPOL  |Slave Selection Active Polarity
S * |        |          |This bit defines the active polarity of slave selection signal (SPIn_SS).
S * |        |          |0 = The slave selection signal SPIn_SS is active low.
S * |        |          |1 = The slave selection signal SPIn_SS is active high.
S * |[3]     |AUTOSS    |Automatic Slave Selection Function Enable Bit (Master Only)
S * |        |          |0 = Automatic slave selection function Disabled.
S * |        |          |Slave selection signal will be asserted/de-asserted according to SS (SPI_SSCTL[0]).
S * |        |          |1 = Automatic slave selection function Enabled.
S * |[4]     |SLV3WIRE  |Slave 3-Wire Mode Enable Bit
S * |        |          |Slave 3-wire mode is only available in SPI0.
S * |        |          |In Slave 3-wire mode, the SPI controller can work with 3-wire interface including SPI0_CLK, SPI0_MISO, and SPI0_MOSI.
S * |        |          |0 = 4-wire bi-direction interface.
S * |        |          |1 = 3-wire bi-direction interface.
S * |[5]     |SLVTOIEN  |Slave Mode Time-Out Interrupt Enable Bit (Only Supported in SPI0)
S * |        |          |0 = Slave mode time-out interrupt Disabled.
S * |        |          |1 = Slave mode time-out interrupt Enabled.
S * |[6]     |SLVTORST  |Slave Mode Time-Out Reset Control (Only Supported in SPI0)
S * |        |          |0 = When Slave mode time-out event occurs, the TX and RX control circuit will not be reset.
S * |        |          |1 = When Slave mode time-out event occurs, the TX and RX control circuit will be reset by hardware.
S * |[8]     |SLVBEIEN  |Slave Mode Bit Count Error Interrupt Enable Bit
S * |        |          |0 = Slave mode bit count error interrupt Disabled.
S * |        |          |1 = Slave mode bit count error interrupt Enabled.
S * |[9]     |SLVURIEN  |Slave Mode TX Under Run Interrupt Enable Bit
S * |        |          |0 = Slave mode TX under run interrupt Disabled.
S * |        |          |1 = Slave mode TX under run interrupt Enabled.
S * |[12]    |SSACTIEN  |Slave Select Active Interrupt Enable Bit
S * |        |          |0 = Slave select active interrupt Disabled.
S * |        |          |1 = Slave select active interrupt Enabled.
S * |[13]    |SSINAIEN  |Slave Select Inactive Interrupt Enable Bit
S * |        |          |0 = Slave select inactive interrupt Disabled.
S * |        |          |1 = Slave select inactive interrupt Enabled.
S * |[31:16] |SLVTOCNT  |Slave Mode Time-Out Period (Only Supported in SPI0)
S * |        |          |In Slave mode, these bits indicate the time-out period when there is bus clock input during slave select active.
S * |        |          |The clock source of the time-out counter is Slave peripheral clock.
S * |        |          |If the value is 0, it indicates the slave mode time-out function is disabled.
S * @var SPI_T::PDMACTL
S * Offset: 0x0C  SPI PDMA Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |TXPDMAEN  |Transmit PDMA Enable Bit
S * |        |          |0 = Transmit PDMA function Disabled.
S * |        |          |1 = Transmit PDMA function Enabled.
S * |        |          |Note: In SPI master mode with full duplex transfer, if both TX and RX PDMA functions are enabled, RX PDMA function cannot be enabled prior to TX PDMA function.
S * |        |          |User can enable TX PDMA function firstly or enable both functions simultaneously.
S * |[1]     |RXPDMAEN  |Receive PDMA Enable Bit
S * |        |          |0 = Receiver PDMA function Disabled.
S * |        |          |1 = Receiver PDMA function Enabled.
S * |[2]     |PDMARST   |PDMA Reset
S * |        |          |0 = No effect.
S * |        |          |1 = Reset the PDMA control logic of the SPI controller. This bit will be automatically cleared to 0.
S * @var SPI_T::FIFOCTL
S * Offset: 0x10  SPI FIFO Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |RXRST     |Receive Reset
S * |        |          |0 = No effect.
S * |        |          |1 = Reset receive FIFO pointer and receive circuit. The RXFULL bit will be cleared to 0 and the RXEMPTY bit will be set to 1.
S * |        |          |This bit will be cleared to 0 by hardware about 3 system clock cycles + 3 peripheral clock cycles after it is set to 1.
S * |        |          |User can read TXRXRST (SPI_STATUS[23]) to check if reset is accomplished or not.
S * |        |          |Note: If there is slave receive time-out event, the RXRST will be set 1 when the SLVTORST (SPI_SSCTL[6]) is enabled.
S * |[1]     |TXRST     |Transmit Reset
S * |        |          |0 = No effect.
S * |        |          |1 = Reset transmit FIFO pointer and transmit circuit. The TXFULL bit will be cleared to 0 and the TXEMPTY bit will be set to 1.
S * |        |          |This bit will be cleared to 0 by hardware about 3 system clock cycles + 3 peripheral clock cycles after it is set to 1.
S * |        |          |User can read TXRXRST (SPI_STATUS[23]) to check if reset is accomplished or not.
S * |        |          |Note: If there is slave receive time-out event, the TXRST will be set to 1 when the SLVTORST (SPI_SSCTL[6]) is enabled.
S * |[2]     |RXTHIEN   |Receive FIFO Threshold Interrupt Enable Bit
S * |        |          |0 = RX FIFO threshold interrupt Disabled.
S * |        |          |1 = RX FIFO threshold interrupt Enabled.
S * |[3]     |TXTHIEN   |Transmit FIFO Threshold Interrupt Enable Bit
S * |        |          |0 = TX FIFO threshold interrupt Disabled.
S * |        |          |1 = TX FIFO threshold interrupt Enabled.
S * |[4]     |RXTOIEN   |Slave Receive Time-Out Interrupt Enable Bit
S * |        |          |0 = Receive time-out interrupt Disabled.
S * |        |          |1 = Receive time-out interrupt Enabled.
S * |[5]     |RXOVIEN   |Receive FIFO Overrun Interrupt Enable Bit
S * |        |          |0 = Receive FIFO overrun interrupt Disabled.
S * |        |          |1 = Receive FIFO overrun interrupt Enabled.
S * |[6]     |TXUFPOL   |TX Underflow Data Polarity
S * |        |          |0 = The SPI data out is keep 0 if there is TX underflow event in Slave mode.
S * |        |          |1 = The SPI data out is keep 1 if there is TX underflow event in Slave mode.
S * |        |          |Note: The TX underflow event occurs if there is not any data in TX FIFO when the slave selection signal is active.
S * |[7]     |TXUFIEN   |TX Underflow Interrupt Enable Bit
S * |        |          |In Slave mode, when TX underflow event occurs, this interrupt flag will be set to 1.
S * |        |          |0 = Slave TX underflow interrupt Disabled.
S * |        |          |1 = Slave TX underflow interrupt Enabled.
S * |[8]     |RXFBCLR   |Receive FIFO Buffer Clear
S * |        |          |0 = No effect.
S * |        |          |1 = Clear receive FIFO pointer. The RXFULL bit will be cleared to 0 and the RXEMPTY bit will be set to 1.
S * |        |          |This bit will be cleared to 0 by hardware about 1 system clock after it is set to 1.
S * |        |          |Note: The RX shift register will not be cleared.
S * |[9]     |TXFBCLR   |Transmit FIFO Buffer Clear
S * |        |          |0 = No effect.
S * |        |          |1 = Clear transmit FIFO pointer. The TXFULL bit will be cleared to 0 and the TXEMPTY bit will be set to 1.
S * |        |          |This bit will be cleared to 0 by hardware about 1 system clock after it is set to 1.
S * |        |          |Note: The TX shift register will not be cleared.
S * |[26:24] |RXTH      |Receive FIFO Threshold
S * |        |          |If the valid data count of the receive FIFO buffer is larger than the RXTH setting, the RXTHIF bit will be set to 1, else the RXTHIF bit will be cleared to 0.
S * |        |          |In SPI0, RXTH is a 3-bit wide configuration; in SPI1 and SPI2, 2-bit wide only (SPI_FIFOCTL[25:24]).
S * |[30:28] |TXTH      |Transmit FIFO Threshold
S * |        |          |If the valid data count of the transmit FIFO buffer is less than or equal to the TXTH setting, the TXTHIF bit will be set to 1, else the TXTHIF bit will be cleared to 0.
S * |        |          |In SPI0, TXTH is a 3-bit wide configuration; in SPI1 and SPI2, 2-bit wide only (SPI_FIFOCTL[29:28]).
S * @var SPI_T::STATUS
S * Offset: 0x14  SPI Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |BUSY      |Busy Status (Read Only)
S * |        |          |0 = SPI controller is in idle state.
S * |        |          |1 = SPI controller is in busy state.
S * |        |          |The following listing are the bus busy conditions:
S * |        |          |a. SPI_CTL[0] = 1 and the TXEMPTY = 0.
S * |        |          |b. For SPI Master mode, the TXEMPTY = 1 but the current transaction is not finished yet.
S * |        |          |c. For SPI Slave mode, the SPI_CTL[0] = 1 and there is serial clock input into the SPI core logic when slave select is active.
S * |        |          |d. For SPI Slave mode, the SPI_CTL[0] = 1 and the transmit buffer or transmit shift register is not empty even if the slave select is inactive.
S * |[1]     |UNITIF    |Unit Transfer Interrupt Flag
S * |        |          |0 = No transaction has been finished since this bit was cleared to 0.
S * |        |          |1 = SPI controller has finished one unit transfer.
S * |        |          |Note: This bit will be cleared by writing 1 to it.
S * |[2]     |SSACTIF   |Slave Select Active Interrupt Flag
S * |        |          |0 = Slave select active interrupt was cleared or not occurred.
S * |        |          |1 = Slave select active interrupt event occurred.
S * |        |          |Note: Only available in Slave mode. This bit will be cleared by writing 1 to it.
S * |[3]     |SSINAIF   |Slave Select Inactive Interrupt Flag
S * |        |          |0 = Slave select inactive interrupt was cleared or not occurred.
S * |        |          |1 = Slave select inactive interrupt event occurred.
S * |        |          |Note: Only available in Slave mode. This bit will be cleared by writing 1 to it.
S * |[4]     |SSLINE    |Slave Select Line Bus Status (Read Only)
S * |        |          |0 = The slave select line status is 0.
S * |        |          |1 = The slave select line status is 1.
S * |        |          |Note: This bit is only available in Slave mode.
S * |        |          |If SSACTPOL (SPI_SSCTL[2]) is set 0, and the SSLINE is 1, the SPI slave select is in inactive status.
S * |[5]     |SLVTOIF   |Slave Time-Out Interrupt Flag (Only Supported in SPI0)
S * |        |          |When the Slave Select is active and the value of SLVTOCNT is not 0, as the bus clock is detected, the slave time-out counter in SPI controller logic will be started.
S * |        |          |When the value of time-out counter is greater than or equal to the value of SLVTOCNT (SPI_SSCTL[31:16]) before one transaction is done, the slave time-out interrupt event will be asserted.
S * |        |          |0 = Slave time-out is not active.
S * |        |          |1 = Slave time-out is active.
S * |        |          |Note: This bit will be cleared by writing 1 to it.
S * |[6]     |SLVBEIF   |Slave Mode Bit Count Error Interrupt Flag
S * |        |          |In Slave mode, when the slave select line goes to inactive state, if bit counter is mismatch with DWIDTH, this interrupt flag will be set to 1.
S * |        |          |0 = No Slave mode bit count error event.
S * |        |          |1 = Slave mode bit count error event occurs.
S * |        |          |Note: If the slave select active but there is no any bus clock input, the SLVBCEIF also active when the slave select goes to inactive state.
S * |        |          |This bit will be cleared by writing 1 to it.
S * |[7]     |SLVURIF   |Slave Mode TX Under Run Interrupt Flag
S * |        |          |In Slave mode, if TX underflow event occurs and the slave select line goes to inactive state, this interrupt flag will be set to 1.
S * |        |          |0 = No Slave TX under run event.
S * |        |          |1 = Slave TX under run occurs.
S * |        |          |Note: This bit will be cleared by writing 1 to it.
S * |[8]     |RXEMPTY   |Receive FIFO Buffer Empty Indicator (Read Only)
S * |        |          |0 = Receive FIFO buffer is not empty.
S * |        |          |1 = Receive FIFO buffer is empty.
S * |[9]     |RXFULL    |Receive FIFO Buffer Full Indicator (Read Only)
S * |        |          |0 = Receive FIFO buffer is not full.
S * |        |          |1 = Receive FIFO buffer is full.
S * |[10]    |RXTHIF    |Receive FIFO Threshold Interrupt Flag (Read Only)
S * |        |          |0 = The valid data count within the RX FIFO buffer is smaller than or equal to the setting value of RXTH.
S * |        |          |1 = The valid data count within the receive FIFO buffer is larger than the setting value of RXTH.
S * |[11]    |RXOVIF    |Receive FIFO Overrun Interrupt Flag
S * |        |          |When the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.
S * |        |          |0 = No FIFO is over run.
S * |        |          |1 = Receive FIFO over run.
S * |        |          |Note: This bit will be cleared by writing 1 to it.
S * |[12]    |RXTOIF    |Receive Time-Out Interrupt Flag
S * |        |          |0 = No receive FIFO time-out event.
S * |        |          |1 = Receive FIFO buffer is not empty and no read operation on receive FIFO buffer over 64 SPI clock period in Master mode or over 576 peripheral clock period in Slave mode.
S * |        |          |When the received FIFO buffer is read by software, the time-out status will be cleared automatically.
S * |        |          |Note: This bit will be cleared by writing 1 to it.
S * |[15]    |SPIENSTS  |SPI Enable Status (Read Only)
S * |        |          |0 = The SPI controller is disabled.
S * |        |          |1 = The SPI controller is enabled.
S * |        |          |Note: The SPI peripheral clock is asynchronous with the system clock.
S * |        |          |In order to make sure the SPI control logic is disabled, this bit indicates the real status of SPI controller.
S * |[16]    |TXEMPTY   |Transmit FIFO Buffer Empty Indicator (Read Only)
S * |        |          |0 = Transmit FIFO buffer is not empty.
S * |        |          |1 = Transmit FIFO buffer is empty.
S * |[17]    |TXFULL    |Transmit FIFO Buffer Full Indicator (Read Only)
S * |        |          |0 = Transmit FIFO buffer is not full.
S * |        |          |1 = Transmit FIFO buffer is full.
S * |[18]    |TXTHIF    |Transmit FIFO Threshold Interrupt Flag (Read Only)
S * |        |          |0 = The valid data count within the transmit FIFO buffer is larger than the setting value of TXTH.
S * |        |          |1 = The valid data count within the transmit FIFO buffer is less than or equal to the setting value of TXTH.
S * |[19]    |TXUFIF    |TX Underflow Interrupt Flag
S * |        |          |When the TX underflow event occurs, this bit will be set to 1, the state of data output pin depends on the setting of TXUFPOL.
S * |        |          |0 = No effect.
S * |        |          |1 = No data in Transmit FIFO and TX shift register when the slave selection signal is active.
S * |        |          |Note 1: This bit will be cleared by writing 1 to it.
S * |        |          |Note 2: If reset slave's transmission circuit when slave selection signal is active, this flag will be set to 1 after 2 peripheral clock cycles + 3 system clock cycles since the reset operation is done.
S * |[23]    |TXRXRST   |TX or RX Reset Status (Read Only)
S * |        |          |0 = The reset function of TXRST or RXRST is done.
S * |        |          |1 = Doing the reset function of TXRST or RXRST.
S * |        |          |Note: Both the reset operations of TXRST and RXRST need 3 system clock cycles + 2 peripheral clock cycles.
S * |        |          |User can check the status of this bit to monitor the reset function is doing or done.
S * |[27:24] |RXCNT     |Receive FIFO Data Count (Read Only)
S * |        |          |This bit field indicates the valid data count of receive FIFO buffer.
S * |[31:28] |TXCNT     |Transmit FIFO Data Count (Read Only)
S * |        |          |This bit field indicates the valid data count of transmit FIFO buffer.
S * @var SPI_T::TX
S * Offset: 0x20  Data Transmit Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |TX        |Data Transmit Register
S * |        |          |The data transmit registers pass through the transmitted data into the 8-/4-level transmit FIFO buffer.
S * |        |          |The number of valid bits depends on the setting of DWIDTH (SPI_CTL[12:8]).
S * |        |          |For example, if DWIDTH is set to 0x08, the bits TX[7:0] will be transmitted.
S * |        |          |If DWIDTH is set to 0x00, the SPI controller will perform a 32-bit transfer.
S * |        |          |Note: In Master mode, SPI controller will start to transfer after 5 peripheral clock cycles after user writes to this register.
S * @var SPI_T::RX
S * Offset: 0x30  Data Receive Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |RX        |Data Receive Register
S * |        |          |There are 8-/4-level FIFO buffers in this controller.
S * |        |          |The data receive register holds the data received from SPI data input pin.
S * |        |          |If the RXEMPTY (SPI_STATUS[8]) is not set to 1, the receive FIFO buffers can be accessed through software by reading this register.
S * |        |          |This is a read only register.
S * @var SPI_T::I2SCTL
S * Offset: 0x60  I2S Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |I2SEN     |I2S Controller Enable Bit
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |        |          |Note: If enable this bit, I2Sn_BCLK will start to output in master mode.
S * |[1]     |TXEN      |Transmit Enable Bit
S * |        |          |0 = Data transmit Disabled.
S * |        |          |1 = Data transmit Enabled.
S * |[2]     |RXEN      |Receive Enable Bit
S * |        |          |0 = Data receiving Disabled.
S * |        |          |1 = Data receiving Enabled.
S * |[3]     |MUTE      |Transmit Mute Enable Bit
S * |        |          |0 = Transmit data is shifted from buffer.
S * |        |          |1= Transmit channel zero.
S * |[5:4]   |WDWIDTH   |Word Width
S * |        |          |00 = data is 8-bit.
S * |        |          |01 = data is 16-bit.
S * |        |          |10 = data is 24-bit.
S * |        |          |11 = data is 32-bit.
S * |[6]     |MONO      |Monaural Data
S * |        |          |0 = Data is stereo format.
S * |        |          |1 = Data is monaural format.
S * |[7]     |ORDER     |Stereo Data Order In FIFO
S * |        |          |0 = Left channel data at high byte.
S * |        |          |1 = Left channel data at low byte.
S * |[8]     |SLAVE     |Slave Mode
S * |        |          |I2S can operate as master or slave.
S * |        |          |For Master mode, I2Sn_BCLK and I2Sn_LRCLK pins are output mode and send bit clock from NuMicro M451 series to Audio CODEC chip.
S * |        |          |In Slave mode, I2Sn_BCLK and I2Sn_LRCLK pins are input mode and I2Sn_BCLK and I2Sn_LRCLK signals are received from outer Audio CODEC chip.
S * |        |          |0 = Master mode.
S * |        |          |1 = Slave mode.
S * |[15]    |MCLKEN    |Master Clock Enable Bit
S * |        |          |If MCLKEN is set to 1, I2S controller will generate master clock on I2Sn_MCLK pin for external audio devices.
S * |        |          |0 = Master clock Disabled.
S * |        |          |1 = Master clock Enabled.
S * |[16]    |RZCEN     |Right Channel Zero Cross Detection Enable Bit
S * |        |          |If this bit is set to 1, when right channel data sign bit change or next shift data bits are all 0 then RZCIF flag in SPI_I2SSTS register is set to 1.
S * |        |          |This function is only available in transmit operation.
S * |        |          |0 = Right channel zero cross detection Disabled.
S * |        |          |1 = Right channel zero cross detection Enabled.
S * |[17]    |LZCEN     |Left Channel Zero Cross Detection Enable Bit
S * |        |          |If this bit is set to 1, when left channel data sign bit changes or next shift data bits are all 0 then LZCIF flag in SPI_I2SSTS register is set to 1.
S * |        |          |This function is only available in transmit operation.
S * |        |          |0 = Left channel zero cross detection Disabled.
S * |        |          |1 = Left channel zero cross detection Enabled.
S * |[23]    |RXLCH     |Receive Left Channel Enable Bit
S * |        |          |When monaural format is selected (MONO = 1), I2S controller will receive right channel data if RXLCH is set to 0, and receive left channel data if RXLCH is set to 1.
S * |        |          |0 = Receive right channel data in Mono mode.
S * |        |          |1 = Receive left channel data in Mono mode.
S * |[24]    |RZCIEN    |Right Channel Zero-Cross Interrupt Enable Bit
S * |        |          |Interrupt occurs if this bit is set to 1 and right channel zero-cross event occurs.
S * |        |          |0 = Interrupt Disabled.
S * |        |          |1 = Interrupt Enabled.
S * |[25]    |LZCIEN    |Left Channel Zero-Cross Interrupt Enable Bit
S * |        |          |Interrupt occurs if this bit is set to 1 and left channel zero-cross event occurs.
S * |        |          |0 = Interrupt Disabled.
S * |        |          |1 = Interrupt Enabled.
S * |[29:28] |FORMAT    |Data Format Selection
S * |        |          |00 = I2S data format.
S * |        |          |01 = MSB justified data format.
S * |        |          |10 = PCM mode A.
S * |        |          |11 = PCM mode B.
S * @var SPI_T::I2SCLK
S * Offset: 0x64  I2S Clock Divider Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |MCLKDIV   |Master Clock Divider
S * |        |          |If MCLKEN is set to 1, I2S controller will generate master clock for external audio devices.
S * |        |          |The master clock rate, F_MCLK, is determined by the following expressions.
S * |        |          |If MCLKDIV >= 1, F_MCLK = F_I2SCLK/(2x(MCLKDIV)).
S * |        |          |If MCLKDIV = 0, F_MCLK = F_I2SCLK.
S * |        |          |F_I2SCLK is the frequency of I2S peripheral clock.
S * |        |          |In general, the master clock rate is 256 times sampling clock rate.
S * |[16:8]  |BCLKDIV   |Bit Clock Divider
S * |        |          |The I2S controller will generate bit clock in Master mode.
S * |        |          |The bit clock rate, F_BCLK, is determined by the following expression.
S * |        |          |F_BCLK = F_I2SCLK /(2x(BCLKDIV + 1)) , where F_I2SCLK is the frequency of I2S peripheral clock.
S * @var SPI_T::I2SSTS
S * Offset: 0x68  I2S Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[4]     |RIGHT     |Right Channel (Read Only)
S * |        |          |This bit indicates the current transmit data is belong to which channel.
S * |        |          |0 = Left channel.
S * |        |          |1 = Right channel.
S * |[8]     |RXEMPTY   |Receive FIFO Buffer Empty Indicator (Read Only)
S * |        |          |0 = Receive FIFO buffer is not empty.
S * |        |          |1 = Receive FIFO buffer is empty.
S * |[9]     |RXFULL    |Receive FIFO Buffer Full Indicator (Read Only)
S * |        |          |0 = Receive FIFO buffer is not full.
S * |        |          |1 = Receive FIFO buffer is full.
S * |[10]    |RXTHIF    |Receive FIFO Threshold Interrupt Flag (Read Only)
S * |        |          |0 = The valid data count within the Rx FIFO buffer is smaller than or equal to the setting value of RXTH.
S * |        |          |1 = The valid data count within the receive FIFO buffer is larger than the setting value of RXTH.
S * |        |          |Note: If RXTHIEN = 1 and RXTHIF = 1, the SPI/I2S controller will generate a SPI interrupt request.
S * |[11]    |RXOVIF    |Receive FIFO Overrun Interrupt Flag
S * |        |          |When the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.
S * |        |          |Note: This bit will be cleared by writing 1 to it.
S * |[12]    |RXTOIF    |Receive Time-Out Interrupt Flag
S * |        |          |0 = No receive FIFO time-out event.
S * |        |          |1 = Receive FIFO buffer is not empty and no read operation on receive FIFO buffer over 64 SPI clock period in Master mode or over 576 peripheral clock period in Slave mode.
S * |        |          |When the received FIFO buffer is read by software, the time-out status will be cleared automatically.
S * |        |          |Note: This bit will be cleared by writing 1 to it.
S * |[15]    |I2SENSTS  |I2S Enable Status (Read Only)
S * |        |          |0 = The SPI/I2S control logic is disabled.
S * |        |          |1 = The SPI/I2S control logic is enabled.
S * |        |          |Note: The SPI peripheral clock is asynchronous with the system clock.
S * |        |          |In order to make sure the SPI/I2S controller logic is disabled, this bit indicates the real status of SPI/I2S controller logic for user.
S * |[16]    |TXEMPTY   |Transmit FIFO Buffer Empty Indicator (Read Only)
S * |        |          |0 = Transmit FIFO buffer is not empty.
S * |        |          |1 = Transmit FIFO buffer is empty.
S * |[17]    |TXFULL    |Transmit FIFO Buffer Full Indicator (Read Only)
S * |        |          |0 = Transmit FIFO buffer is not full.
S * |        |          |1 = Transmit FIFO buffer is full.
S * |[18]    |TXTHIF    |Transmit FIFO Threshold Interrupt Flag (Read Only)
S * |        |          |0 = The valid data count within the transmit FIFO buffer is larger than the setting value of TXTH.
S * |        |          |1 = The valid data count within the transmit FIFO buffer is less than or equal to the setting value of TXTH.
S * |        |          |Note: If TXTHIEN = 1 and TXTHIF = 1, the SPI controller will generate a SPI interrupt request.
S * |[19]    |TXUFIF    |Transmit FIFO Underflow Interrupt Flag
S * |        |          |When the transmit FIFO buffer is empty and there is no datum written into the FIFO buffer, if there is more bus clock input,
S * |        |          | the output data depends on the setting of TXUFPOL and this bit will be set to 1.
S * |        |          |Note: This bit will be cleared by writing 1 to it.
S * |[20]    |RZCIF     |Right Channel Zero Cross Interrupt Flag
S * |        |          |0 = No zero cross event occurred on right channel.
S * |        |          |1 = Zero cross event occurred on right channel.
S * |[21]    |LZCIF     |Left Channel Zero Cross Interrupt Flag
S * |        |          |0 = No zero cross event occurred on left channel.
S * |        |          |1 = Zero cross event occurred on left channel.
S * |[23]    |TXRXRST   |TX or RX Reset Status (Read Only)
S * |        |          |0 = The reset function of TXRST or RXRST is done.
S * |        |          |1 = Doing the reset function of TXRST or RXRST.
S * |        |          |Note: Both the reset operations of TXRST and RXRST need 3 system clock cycles + 3 peripheral clock cycles.
S * |        |          |User can check the status of this bit to monitor the reset function is doing or done.
S * |[26:24] |RXCNT     |Receive FIFO Data Count (Read Only)
S * |        |          |This bit field indicates the valid data count of receive FIFO buffer.
S * |[30:28] |TXCNT     |Transmit FIFO Data Count (Read Only)
S * |        |          |This bit field indicates the valid data count of transmit FIFO buffer.
S */
S
S    __IO uint32_t CTL;           /* Offset: 0x00  Control Register                                                   */
S    __IO uint32_t CLKDIV;        /* Offset: 0x04  Clock Divider Register                                             */
S    __IO uint32_t SSCTL;         /* Offset: 0x08  Slave Select Control Register                                      */
S    __IO uint32_t PDMACTL;       /* Offset: 0x0C  SPI PDMA Control Register                                          */
S    __IO uint32_t FIFOCTL;       /* Offset: 0x10  SPI FIFO Control Register                                          */
S    __IO uint32_t STATUS;        /* Offset: 0x14  SPI Status Register                                                */
S    __I  uint32_t RESERVE0[2];  
S    __O  uint32_t TX;            /* Offset: 0x20  Data Transmit Register                                             */
S    __I  uint32_t RESERVE1[3];  
S    __I  uint32_t RX;            /* Offset: 0x30  Data Receive Register                                              */
S    __I  uint32_t RESERVE2[11]; 
S    __IO uint32_t I2SCTL;        /* Offset: 0x60  I2S Control Register                                               */
S    __IO uint32_t I2SCLK;        /* Offset: 0x64  I2S Clock Divider Control Register                                 */
S    __IO uint32_t I2SSTS;        /* Offset: 0x68  I2S Status Register                                                */
S
S} SPI_T;
S
S
S
S/**
S    @addtogroup SPI_CONST SPI Bit Field Definition
S    Constant Definitions for SPI Controller
S@{ */
S
S#define SPI_CTL_SPIEN_Pos                (0)                                               /*!< SPI_T::CTL: SPIEN Position                */
S#define SPI_CTL_SPIEN_Msk                (0x1ul << SPI_CTL_SPIEN_Pos)                      /*!< SPI_T::CTL: SPIEN Mask                    */
S
S#define SPI_CTL_RXNEG_Pos                (1)                                               /*!< SPI_T::CTL: RXNEG Position                */
S#define SPI_CTL_RXNEG_Msk                (0x1ul << SPI_CTL_RXNEG_Pos)                      /*!< SPI_T::CTL: RXNEG Mask                    */
S
S#define SPI_CTL_TXNEG_Pos                (2)                                               /*!< SPI_T::CTL: TXNEG Position                */
S#define SPI_CTL_TXNEG_Msk                (0x1ul << SPI_CTL_TXNEG_Pos)                      /*!< SPI_T::CTL: TXNEG Mask                    */
S
S#define SPI_CTL_CLKPOL_Pos               (3)                                               /*!< SPI_T::CTL: CLKPOL Position               */
S#define SPI_CTL_CLKPOL_Msk               (0x1ul << SPI_CTL_CLKPOL_Pos)                     /*!< SPI_T::CTL: CLKPOL Mask                   */
S
S#define SPI_CTL_SUSPITV_Pos              (4)                                               /*!< SPI_T::CTL: SUSPITV Position              */
S#define SPI_CTL_SUSPITV_Msk              (0xful << SPI_CTL_SUSPITV_Pos)                    /*!< SPI_T::CTL: SUSPITV Mask                  */
S
S#define SPI_CTL_DWIDTH_Pos               (8)                                               /*!< SPI_T::CTL: DWIDTH Position               */
S#define SPI_CTL_DWIDTH_Msk               (0x1ful << SPI_CTL_DWIDTH_Pos)                    /*!< SPI_T::CTL: DWIDTH Mask                   */
S
S#define SPI_CTL_LSB_Pos                  (13)                                              /*!< SPI_T::CTL: LSB Position                  */
S#define SPI_CTL_LSB_Msk                  (0x1ul << SPI_CTL_LSB_Pos)                        /*!< SPI_T::CTL: LSB Mask                      */
S
S#define SPI_CTL_TWOBIT_Pos               (16)                                              /*!< SPI_T::CTL: TWOBIT Position               */
S#define SPI_CTL_TWOBIT_Msk               (0x1ul << SPI_CTL_TWOBIT_Pos)                     /*!< SPI_T::CTL: TWOBIT Mask                   */
S
S#define SPI_CTL_UNITIEN_Pos              (17)                                              /*!< SPI_T::CTL: UNITIEN Position              */
S#define SPI_CTL_UNITIEN_Msk              (0x1ul << SPI_CTL_UNITIEN_Pos)                    /*!< SPI_T::CTL: UNITIEN Mask                  */
S
S#define SPI_CTL_SLAVE_Pos                (18)                                              /*!< SPI_T::CTL: SLAVE Position                */
S#define SPI_CTL_SLAVE_Msk                (0x1ul << SPI_CTL_SLAVE_Pos)                      /*!< SPI_T::CTL: SLAVE Mask                    */
S
S#define SPI_CTL_REORDER_Pos              (19)                                              /*!< SPI_T::CTL: REORDER Position              */
S#define SPI_CTL_REORDER_Msk              (0x1ul << SPI_CTL_REORDER_Pos)                    /*!< SPI_T::CTL: REORDER Mask                  */
S
S#define SPI_CTL_QDIODIR_Pos              (20)                                              /*!< SPI_T::CTL: QDIODIR Position              */
S#define SPI_CTL_QDIODIR_Msk              (0x1ul << SPI_CTL_QDIODIR_Pos)                    /*!< SPI_T::CTL: QDIODIR Mask                  */
S
S#define SPI_CTL_DUALIOEN_Pos             (21)                                              /*!< SPI_T::CTL: DUALIOEN Position             */
S#define SPI_CTL_DUALIOEN_Msk             (0x1ul << SPI_CTL_DUALIOEN_Pos)                   /*!< SPI_T::CTL: DUALIOEN Mask                 */
S
S#define SPI_CTL_QUADIOEN_Pos             (22)                                              /*!< SPI_T::CTL: QUADIOEN Position             */
S#define SPI_CTL_QUADIOEN_Msk             (0x1ul << SPI_CTL_QUADIOEN_Pos)                   /*!< SPI_T::CTL: QUADIOEN Mask                 */
S
S#define SPI_CLKDIV_DIVIDER_Pos           (0)                                               /*!< SPI_T::CLKDIV: DIVIDER Position           */
S#define SPI_CLKDIV_DIVIDER_Msk           (0xfful << SPI_CLKDIV_DIVIDER_Pos)                /*!< SPI_T::CLKDIV: DIVIDER Mask               */
S
S#define SPI_SSCTL_SS_Pos                 (0)                                               /*!< SPI_T::SSCTL: SS Position                 */
S#define SPI_SSCTL_SS_Msk                 (0x1ul << SPI_SSCTL_SS_Pos)                       /*!< SPI_T::SSCTL: SS Mask                     */
S
S#define SPI_SSCTL_SSACTPOL_Pos           (2)                                               /*!< SPI_T::SSCTL: SSACTPOL Position           */
S#define SPI_SSCTL_SSACTPOL_Msk           (0x1ul << SPI_SSCTL_SSACTPOL_Pos)                 /*!< SPI_T::SSCTL: SSACTPOL Mask               */
S
S#define SPI_SSCTL_AUTOSS_Pos             (3)                                               /*!< SPI_T::SSCTL: AUTOSS Position             */
S#define SPI_SSCTL_AUTOSS_Msk             (0x1ul << SPI_SSCTL_AUTOSS_Pos)                   /*!< SPI_T::SSCTL: AUTOSS Mask                 */
S
S#define SPI_SSCTL_SLV3WIRE_Pos           (4)                                               /*!< SPI_T::SSCTL: SLV3WIRE Position           */
S#define SPI_SSCTL_SLV3WIRE_Msk           (0x1ul << SPI_SSCTL_SLV3WIRE_Pos)                 /*!< SPI_T::SSCTL: SLV3WIRE Mask               */
S
S#define SPI_SSCTL_SLVTOIEN_Pos           (5)                                               /*!< SPI_T::SSCTL: SLVTOIEN Position           */
S#define SPI_SSCTL_SLVTOIEN_Msk           (0x1ul << SPI_SSCTL_SLVTOIEN_Pos)                 /*!< SPI_T::SSCTL: SLVTOIEN Mask               */
S
S#define SPI_SSCTL_SLVTORST_Pos           (6)                                               /*!< SPI_T::SSCTL: SLVTORST Position           */
S#define SPI_SSCTL_SLVTORST_Msk           (0x1ul << SPI_SSCTL_SLVTORST_Pos)                 /*!< SPI_T::SSCTL: SLVTORST Mask               */
S
S#define SPI_SSCTL_SLVBEIEN_Pos           (8)                                               /*!< SPI_T::SSCTL: SLVBEIEN Position           */
S#define SPI_SSCTL_SLVBEIEN_Msk           (0x1ul << SPI_SSCTL_SLVBEIEN_Pos)                 /*!< SPI_T::SSCTL: SLVBEIEN Mask               */
S
S#define SPI_SSCTL_SLVURIEN_Pos           (9)                                               /*!< SPI_T::SSCTL: SLVURIEN Position           */
S#define SPI_SSCTL_SLVURIEN_Msk           (0x1ul << SPI_SSCTL_SLVURIEN_Pos)                 /*!< SPI_T::SSCTL: SLVURIEN Mask               */
S
S#define SPI_SSCTL_SSACTIEN_Pos           (12)                                              /*!< SPI_T::SSCTL: SSACTIEN Position           */
S#define SPI_SSCTL_SSACTIEN_Msk           (0x1ul << SPI_SSCTL_SSACTIEN_Pos)                 /*!< SPI_T::SSCTL: SSACTIEN Mask               */
S
S#define SPI_SSCTL_SSINAIEN_Pos           (13)                                              /*!< SPI_T::SSCTL: SSINAIEN Position           */
S#define SPI_SSCTL_SSINAIEN_Msk           (0x1ul << SPI_SSCTL_SSINAIEN_Pos)                 /*!< SPI_T::SSCTL: SSINAIEN Mask               */
S
S#define SPI_SSCTL_SLVTOCNT_Pos           (16)                                              /*!< SPI_T::SSCTL: SLVTOCNT Position           */
S#define SPI_SSCTL_SLVTOCNT_Msk           (0xfffful << SPI_SSCTL_SLVTOCNT_Pos)              /*!< SPI_T::SSCTL: SLVTOCNT Mask               */
S
S#define SPI_PDMACTL_TXPDMAEN_Pos         (0)                                               /*!< SPI_T::PDMACTL: TXPDMAEN Position         */
S#define SPI_PDMACTL_TXPDMAEN_Msk         (0x1ul << SPI_PDMACTL_TXPDMAEN_Pos)               /*!< SPI_T::PDMACTL: TXPDMAEN Mask             */
S
S#define SPI_PDMACTL_RXPDMAEN_Pos         (1)                                               /*!< SPI_T::PDMACTL: RXPDMAEN Position         */
S#define SPI_PDMACTL_RXPDMAEN_Msk         (0x1ul << SPI_PDMACTL_RXPDMAEN_Pos)               /*!< SPI_T::PDMACTL: RXPDMAEN Mask             */
S
S#define SPI_PDMACTL_PDMARST_Pos          (2)                                               /*!< SPI_T::PDMACTL: PDMARST Position          */
S#define SPI_PDMACTL_PDMARST_Msk          (0x1ul << SPI_PDMACTL_PDMARST_Pos)                /*!< SPI_T::PDMACTL: PDMARST Mask              */
S
S#define SPI_FIFOCTL_RXRST_Pos            (0)                                               /*!< SPI_T::FIFOCTL: RXRST Position            */
S#define SPI_FIFOCTL_RXRST_Msk            (0x1ul << SPI_FIFOCTL_RXRST_Pos)                  /*!< SPI_T::FIFOCTL: RXRST Mask                */
S
S#define SPI_FIFOCTL_TXRST_Pos            (1)                                               /*!< SPI_T::FIFOCTL: TXRST Position            */
S#define SPI_FIFOCTL_TXRST_Msk            (0x1ul << SPI_FIFOCTL_TXRST_Pos)                  /*!< SPI_T::FIFOCTL: TXRST Mask                */
S
S#define SPI_FIFOCTL_RXTHIEN_Pos          (2)                                               /*!< SPI_T::FIFOCTL: RXTHIEN Position          */
S#define SPI_FIFOCTL_RXTHIEN_Msk          (0x1ul << SPI_FIFOCTL_RXTHIEN_Pos)                /*!< SPI_T::FIFOCTL: RXTHIEN Mask              */
S
S#define SPI_FIFOCTL_TXTHIEN_Pos          (3)                                               /*!< SPI_T::FIFOCTL: TXTHIEN Position          */
S#define SPI_FIFOCTL_TXTHIEN_Msk          (0x1ul << SPI_FIFOCTL_TXTHIEN_Pos)                /*!< SPI_T::FIFOCTL: TXTHIEN Mask              */
S
S#define SPI_FIFOCTL_RXTOIEN_Pos          (4)                                               /*!< SPI_T::FIFOCTL: RXTOIEN Position          */
S#define SPI_FIFOCTL_RXTOIEN_Msk          (0x1ul << SPI_FIFOCTL_RXTOIEN_Pos)                /*!< SPI_T::FIFOCTL: RXTOIEN Mask              */
S
S#define SPI_FIFOCTL_RXOVIEN_Pos          (5)                                               /*!< SPI_T::FIFOCTL: RXOVIEN Position          */
S#define SPI_FIFOCTL_RXOVIEN_Msk          (0x1ul << SPI_FIFOCTL_RXOVIEN_Pos)                /*!< SPI_T::FIFOCTL: RXOVIEN Mask              */
S
S#define SPI_FIFOCTL_TXUFPOL_Pos          (6)                                               /*!< SPI_T::FIFOCTL: TXUFPOL Position          */
S#define SPI_FIFOCTL_TXUFPOL_Msk          (0x1ul << SPI_FIFOCTL_TXUFPOL_Pos)                /*!< SPI_T::FIFOCTL: TXUFPOL Mask              */
S
S#define SPI_FIFOCTL_TXUFIEN_Pos          (7)                                               /*!< SPI_T::FIFOCTL: TXUFIEN Position          */
S#define SPI_FIFOCTL_TXUFIEN_Msk          (0x1ul << SPI_FIFOCTL_TXUFIEN_Pos)                /*!< SPI_T::FIFOCTL: TXUFIEN Mask              */
S
S#define SPI_FIFOCTL_RXFBCLR_Pos          (8)                                               /*!< SPI_T::FIFOCTL: RXFBCLR Position          */
S#define SPI_FIFOCTL_RXFBCLR_Msk          (0x1ul << SPI_FIFOCTL_RXFBCLR_Pos)                /*!< SPI_T::FIFOCTL: RXFBCLR Mask              */
S
S#define SPI_FIFOCTL_TXFBCLR_Pos          (9)                                               /*!< SPI_T::FIFOCTL: TXFBCLR Position          */
S#define SPI_FIFOCTL_TXFBCLR_Msk          (0x1ul << SPI_FIFOCTL_TXFBCLR_Pos)                /*!< SPI_T::FIFOCTL: TXFBCLR Mask              */
S
S#define SPI_FIFOCTL_RXTH_Pos             (24)                                              /*!< SPI_T::FIFOCTL: RXTH Position             */
S#define SPI_FIFOCTL_RXTH_Msk             (0x7ul << SPI_FIFOCTL_RXTH_Pos)                   /*!< SPI_T::FIFOCTL: RXTH Mask                 */
S
S#define SPI_FIFOCTL_TXTH_Pos             (28)                                              /*!< SPI_T::FIFOCTL: TXTH Position             */
S#define SPI_FIFOCTL_TXTH_Msk             (0x7ul << SPI_FIFOCTL_TXTH_Pos)                   /*!< SPI_T::FIFOCTL: TXTH Mask                 */
S
S#define SPI_STATUS_BUSY_Pos              (0)                                               /*!< SPI_T::STATUS: BUSY Position              */
S#define SPI_STATUS_BUSY_Msk              (0x1ul << SPI_STATUS_BUSY_Pos)                    /*!< SPI_T::STATUS: BUSY Mask                  */
S
S#define SPI_STATUS_UNITIF_Pos            (1)                                               /*!< SPI_T::STATUS: UNITIF Position            */
S#define SPI_STATUS_UNITIF_Msk            (0x1ul << SPI_STATUS_UNITIF_Pos)                  /*!< SPI_T::STATUS: UNITIF Mask                */
S
S#define SPI_STATUS_SSACTIF_Pos           (2)                                               /*!< SPI_T::STATUS: SSACTIF Position           */
S#define SPI_STATUS_SSACTIF_Msk           (0x1ul << SPI_STATUS_SSACTIF_Pos)                 /*!< SPI_T::STATUS: SSACTIF Mask               */
S
S#define SPI_STATUS_SSINAIF_Pos           (3)                                               /*!< SPI_T::STATUS: SSINAIF Position           */
S#define SPI_STATUS_SSINAIF_Msk           (0x1ul << SPI_STATUS_SSINAIF_Pos)                 /*!< SPI_T::STATUS: SSINAIF Mask               */
S
S#define SPI_STATUS_SSLINE_Pos            (4)                                               /*!< SPI_T::STATUS: SSLINE Position            */
S#define SPI_STATUS_SSLINE_Msk            (0x1ul << SPI_STATUS_SSLINE_Pos)                  /*!< SPI_T::STATUS: SSLINE Mask                */
S
S#define SPI_STATUS_SLVTOIF_Pos           (5)                                               /*!< SPI_T::STATUS: SLVTOIF Position           */
S#define SPI_STATUS_SLVTOIF_Msk           (0x1ul << SPI_STATUS_SLVTOIF_Pos)                 /*!< SPI_T::STATUS: SLVTOIF Mask               */
S
S#define SPI_STATUS_SLVBEIF_Pos           (6)                                               /*!< SPI_T::STATUS: SLVBEIF Position           */
S#define SPI_STATUS_SLVBEIF_Msk           (0x1ul << SPI_STATUS_SLVBEIF_Pos)                 /*!< SPI_T::STATUS: SLVBEIF Mask               */
S
S#define SPI_STATUS_SLVURIF_Pos           (7)                                               /*!< SPI_T::STATUS: SLVURIF Position           */
S#define SPI_STATUS_SLVURIF_Msk           (0x1ul << SPI_STATUS_SLVURIF_Pos)                 /*!< SPI_T::STATUS: SLVURIF Mask               */
S
S#define SPI_STATUS_RXEMPTY_Pos           (8)                                               /*!< SPI_T::STATUS: RXEMPTY Position           */
S#define SPI_STATUS_RXEMPTY_Msk           (0x1ul << SPI_STATUS_RXEMPTY_Pos)                 /*!< SPI_T::STATUS: RXEMPTY Mask               */
S
S#define SPI_STATUS_RXFULL_Pos            (9)                                               /*!< SPI_T::STATUS: RXFULL Position            */
S#define SPI_STATUS_RXFULL_Msk            (0x1ul << SPI_STATUS_RXFULL_Pos)                  /*!< SPI_T::STATUS: RXFULL Mask                */
S
S#define SPI_STATUS_RXTHIF_Pos            (10)                                              /*!< SPI_T::STATUS: RXTHIF Position            */
S#define SPI_STATUS_RXTHIF_Msk            (0x1ul << SPI_STATUS_RXTHIF_Pos)                  /*!< SPI_T::STATUS: RXTHIF Mask                */
S
S#define SPI_STATUS_RXOVIF_Pos            (11)                                              /*!< SPI_T::STATUS: RXOVIF Position            */
S#define SPI_STATUS_RXOVIF_Msk            (0x1ul << SPI_STATUS_RXOVIF_Pos)                  /*!< SPI_T::STATUS: RXOVIF Mask                */
S
S#define SPI_STATUS_RXTOIF_Pos            (12)                                              /*!< SPI_T::STATUS: RXTOIF Position            */
S#define SPI_STATUS_RXTOIF_Msk            (0x1ul << SPI_STATUS_RXTOIF_Pos)                  /*!< SPI_T::STATUS: RXTOIF Mask                */
S
S#define SPI_STATUS_SPIENSTS_Pos          (15)                                              /*!< SPI_T::STATUS: SPIENSTS Position          */
S#define SPI_STATUS_SPIENSTS_Msk          (0x1ul << SPI_STATUS_SPIENSTS_Pos)                /*!< SPI_T::STATUS: SPIENSTS Mask              */
S
S#define SPI_STATUS_TXEMPTY_Pos           (16)                                              /*!< SPI_T::STATUS: TXEMPTY Position           */
S#define SPI_STATUS_TXEMPTY_Msk           (0x1ul << SPI_STATUS_TXEMPTY_Pos)                 /*!< SPI_T::STATUS: TXEMPTY Mask               */
S
S#define SPI_STATUS_TXFULL_Pos            (17)                                              /*!< SPI_T::STATUS: TXFULL Position            */
S#define SPI_STATUS_TXFULL_Msk            (0x1ul << SPI_STATUS_TXFULL_Pos)                  /*!< SPI_T::STATUS: TXFULL Mask                */
S
S#define SPI_STATUS_TXTHIF_Pos            (18)                                              /*!< SPI_T::STATUS: TXTHIF Position            */
S#define SPI_STATUS_TXTHIF_Msk            (0x1ul << SPI_STATUS_TXTHIF_Pos)                  /*!< SPI_T::STATUS: TXTHIF Mask                */
S
S#define SPI_STATUS_TXUFIF_Pos            (19)                                              /*!< SPI_T::STATUS: TXUFIF Position            */
S#define SPI_STATUS_TXUFIF_Msk            (0x1ul << SPI_STATUS_TXUFIF_Pos)                  /*!< SPI_T::STATUS: TXUFIF Mask                */
S
S#define SPI_STATUS_TXRXRST_Pos           (23)                                              /*!< SPI_T::STATUS: TXRXRST Position           */
S#define SPI_STATUS_TXRXRST_Msk           (0x1ul << SPI_STATUS_TXRXRST_Pos)                 /*!< SPI_T::STATUS: TXRXRST Mask               */
S
S#define SPI_STATUS_RXCNT_Pos             (24)                                              /*!< SPI_T::STATUS: RXCNT Position             */
S#define SPI_STATUS_RXCNT_Msk             (0xful << SPI_STATUS_RXCNT_Pos)                   /*!< SPI_T::STATUS: RXCNT Mask                 */
S
S#define SPI_STATUS_TXCNT_Pos             (28)                                              /*!< SPI_T::STATUS: TXCNT Position             */
S#define SPI_STATUS_TXCNT_Msk             (0xful << SPI_STATUS_TXCNT_Pos)                   /*!< SPI_T::STATUS: TXCNT Mask                 */
S
S#define SPI_TX_TX_Pos                    (0)                                               /*!< SPI_T::TX: TX Position                    */
S#define SPI_TX_TX_Msk                    (0xfffffffful << SPI_TX_TX_Pos)                   /*!< SPI_T::TX: TX Mask                        */
S
S#define SPI_RX_RX_Pos                    (0)                                               /*!< SPI_T::RX: RX Position                    */
S#define SPI_RX_RX_Msk                    (0xfffffffful << SPI_RX_RX_Pos)                   /*!< SPI_T::RX: RX Mask                        */
S
S#define SPI_I2SCTL_I2SEN_Pos             (0)                                               /*!< SPI_T::I2SCTL: I2SEN Position             */
S#define SPI_I2SCTL_I2SEN_Msk             (0x1ul << SPI_I2SCTL_I2SEN_Pos)                   /*!< SPI_T::I2SCTL: I2SEN Mask                 */
S
S#define SPI_I2SCTL_TXEN_Pos              (1)                                               /*!< SPI_T::I2SCTL: TXEN Position              */
S#define SPI_I2SCTL_TXEN_Msk              (0x1ul << SPI_I2SCTL_TXEN_Pos)                    /*!< SPI_T::I2SCTL: TXEN Mask                  */
S
S#define SPI_I2SCTL_RXEN_Pos              (2)                                               /*!< SPI_T::I2SCTL: RXEN Position              */
S#define SPI_I2SCTL_RXEN_Msk              (0x1ul << SPI_I2SCTL_RXEN_Pos)                    /*!< SPI_T::I2SCTL: RXEN Mask                  */
S
S#define SPI_I2SCTL_MUTE_Pos              (3)                                               /*!< SPI_T::I2SCTL: MUTE Position              */
S#define SPI_I2SCTL_MUTE_Msk              (0x1ul << SPI_I2SCTL_MUTE_Pos)                    /*!< SPI_T::I2SCTL: MUTE Mask                  */
S
S#define SPI_I2SCTL_WDWIDTH_Pos           (4)                                               /*!< SPI_T::I2SCTL: WDWIDTH Position           */
S#define SPI_I2SCTL_WDWIDTH_Msk           (0x3ul << SPI_I2SCTL_WDWIDTH_Pos)                 /*!< SPI_T::I2SCTL: WDWIDTH Mask               */
S
S#define SPI_I2SCTL_MONO_Pos              (6)                                               /*!< SPI_T::I2SCTL: MONO Position              */
S#define SPI_I2SCTL_MONO_Msk              (0x1ul << SPI_I2SCTL_MONO_Pos)                    /*!< SPI_T::I2SCTL: MONO Mask                  */
S
S#define SPI_I2SCTL_ORDER_Pos             (7)                                               /*!< SPI_T::I2SCTL: ORDER Position             */
S#define SPI_I2SCTL_ORDER_Msk             (0x1ul << SPI_I2SCTL_ORDER_Pos)                   /*!< SPI_T::I2SCTL: ORDER Mask                 */
S
S#define SPI_I2SCTL_SLAVE_Pos             (8)                                               /*!< SPI_T::I2SCTL: SLAVE Position             */
S#define SPI_I2SCTL_SLAVE_Msk             (0x1ul << SPI_I2SCTL_SLAVE_Pos)                   /*!< SPI_T::I2SCTL: SLAVE Mask                 */
S
S#define SPI_I2SCTL_MCLKEN_Pos            (15)                                              /*!< SPI_T::I2SCTL: MCLKEN Position            */
S#define SPI_I2SCTL_MCLKEN_Msk            (0x1ul << SPI_I2SCTL_MCLKEN_Pos)                  /*!< SPI_T::I2SCTL: MCLKEN Mask                */
S
S#define SPI_I2SCTL_RZCEN_Pos             (16)                                              /*!< SPI_T::I2SCTL: RZCEN Position             */
S#define SPI_I2SCTL_RZCEN_Msk             (0x1ul << SPI_I2SCTL_RZCEN_Pos)                   /*!< SPI_T::I2SCTL: RZCEN Mask                 */
S
S#define SPI_I2SCTL_LZCEN_Pos             (17)                                              /*!< SPI_T::I2SCTL: LZCEN Position             */
S#define SPI_I2SCTL_LZCEN_Msk             (0x1ul << SPI_I2SCTL_LZCEN_Pos)                   /*!< SPI_T::I2SCTL: LZCEN Mask                 */
S
S#define SPI_I2SCTL_RXLCH_Pos             (23)                                              /*!< SPI_T::I2SCTL: RXLCH Position             */
S#define SPI_I2SCTL_RXLCH_Msk             (0x1ul << SPI_I2SCTL_RXLCH_Pos)                   /*!< SPI_T::I2SCTL: RXLCH Mask                 */
S
S#define SPI_I2SCTL_RZCIEN_Pos            (24)                                              /*!< SPI_T::I2SCTL: RZCIEN Position            */
S#define SPI_I2SCTL_RZCIEN_Msk            (0x1ul << SPI_I2SCTL_RZCIEN_Pos)                  /*!< SPI_T::I2SCTL: RZCIEN Mask                */
S
S#define SPI_I2SCTL_LZCIEN_Pos            (25)                                              /*!< SPI_T::I2SCTL: LZCIEN Position            */
S#define SPI_I2SCTL_LZCIEN_Msk            (0x1ul << SPI_I2SCTL_LZCIEN_Pos)                  /*!< SPI_T::I2SCTL: LZCIEN Mask                */
S
S#define SPI_I2SCTL_FORMAT_Pos            (28)                                              /*!< SPI_T::I2SCTL: FORMAT Position            */
S#define SPI_I2SCTL_FORMAT_Msk            (0x3ul << SPI_I2SCTL_FORMAT_Pos)                  /*!< SPI_T::I2SCTL: FORMAT Mask                */
S
S#define SPI_I2SCLK_MCLKDIV_Pos           (0)                                               /*!< SPI_T::I2SCLK: MCLKDIV Position           */
S#define SPI_I2SCLK_MCLKDIV_Msk           (0x3ful << SPI_I2SCLK_MCLKDIV_Pos)                /*!< SPI_T::I2SCLK: MCLKDIV Mask               */
S
S#define SPI_I2SCLK_BCLKDIV_Pos           (8)                                               /*!< SPI_T::I2SCLK: BCLKDIV Position           */
S#define SPI_I2SCLK_BCLKDIV_Msk           (0x1fful << SPI_I2SCLK_BCLKDIV_Pos)               /*!< SPI_T::I2SCLK: BCLKDIV Mask               */
S
S#define SPI_I2SSTS_RIGHT_Pos             (4)                                               /*!< SPI_T::I2SSTS: RIGHT Position             */
S#define SPI_I2SSTS_RIGHT_Msk             (0x1ul << SPI_I2SSTS_RIGHT_Pos)                   /*!< SPI_T::I2SSTS: RIGHT Mask                 */
S
S#define SPI_I2SSTS_RXEMPTY_Pos           (8)                                               /*!< SPI_T::I2SSTS: RXEMPTY Position           */
S#define SPI_I2SSTS_RXEMPTY_Msk           (0x1ul << SPI_I2SSTS_RXEMPTY_Pos)                 /*!< SPI_T::I2SSTS: RXEMPTY Mask               */
S
S#define SPI_I2SSTS_RXFULL_Pos            (9)                                               /*!< SPI_T::I2SSTS: RXFULL Position            */
S#define SPI_I2SSTS_RXFULL_Msk            (0x1ul << SPI_I2SSTS_RXFULL_Pos)                  /*!< SPI_T::I2SSTS: RXFULL Mask                */
S
S#define SPI_I2SSTS_RXTHIF_Pos            (10)                                              /*!< SPI_T::I2SSTS: RXTHIF Position            */
S#define SPI_I2SSTS_RXTHIF_Msk            (0x1ul << SPI_I2SSTS_RXTHIF_Pos)                  /*!< SPI_T::I2SSTS: RXTHIF Mask                */
S
S#define SPI_I2SSTS_RXOVIF_Pos            (11)                                              /*!< SPI_T::I2SSTS: RXOVIF Position            */
S#define SPI_I2SSTS_RXOVIF_Msk            (0x1ul << SPI_I2SSTS_RXOVIF_Pos)                  /*!< SPI_T::I2SSTS: RXOVIF Mask                */
S
S#define SPI_I2SSTS_RXTOIF_Pos            (12)                                              /*!< SPI_T::I2SSTS: RXTOIF Position            */
S#define SPI_I2SSTS_RXTOIF_Msk            (0x1ul << SPI_I2SSTS_RXTOIF_Pos)                  /*!< SPI_T::I2SSTS: RXTOIF Mask                */
S
S#define SPI_I2SSTS_I2SENSTS_Pos          (15)                                              /*!< SPI_T::I2SSTS: I2SENSTS Position          */
S#define SPI_I2SSTS_I2SENSTS_Msk          (0x1ul << SPI_I2SSTS_I2SENSTS_Pos)                /*!< SPI_T::I2SSTS: I2SENSTS Mask              */
S
S#define SPI_I2SSTS_TXEMPTY_Pos           (16)                                              /*!< SPI_T::I2SSTS: TXEMPTY Position           */
S#define SPI_I2SSTS_TXEMPTY_Msk           (0x1ul << SPI_I2SSTS_TXEMPTY_Pos)                 /*!< SPI_T::I2SSTS: TXEMPTY Mask               */
S
S#define SPI_I2SSTS_TXFULL_Pos            (17)                                              /*!< SPI_T::I2SSTS: TXFULL Position            */
S#define SPI_I2SSTS_TXFULL_Msk            (0x1ul << SPI_I2SSTS_TXFULL_Pos)                  /*!< SPI_T::I2SSTS: TXFULL Mask                */
S
S#define SPI_I2SSTS_TXTHIF_Pos            (18)                                              /*!< SPI_T::I2SSTS: TXTHIF Position            */
S#define SPI_I2SSTS_TXTHIF_Msk            (0x1ul << SPI_I2SSTS_TXTHIF_Pos)                  /*!< SPI_T::I2SSTS: TXTHIF Mask                */
S
S#define SPI_I2SSTS_TXUFIF_Pos            (19)                                              /*!< SPI_T::I2SSTS: TXUFIF Position            */
S#define SPI_I2SSTS_TXUFIF_Msk            (0x1ul << SPI_I2SSTS_TXUFIF_Pos)                  /*!< SPI_T::I2SSTS: TXUFIF Mask                */
S
S#define SPI_I2SSTS_RZCIF_Pos             (20)                                              /*!< SPI_T::I2SSTS: RZCIF Position             */
S#define SPI_I2SSTS_RZCIF_Msk             (0x1ul << SPI_I2SSTS_RZCIF_Pos)                   /*!< SPI_T::I2SSTS: RZCIF Mask                 */
S
S#define SPI_I2SSTS_LZCIF_Pos             (21)                                              /*!< SPI_T::I2SSTS: LZCIF Position             */
S#define SPI_I2SSTS_LZCIF_Msk             (0x1ul << SPI_I2SSTS_LZCIF_Pos)                   /*!< SPI_T::I2SSTS: LZCIF Mask                 */
S
S#define SPI_I2SSTS_TXRXRST_Pos           (23)                                              /*!< SPI_T::I2SSTS: TXRXRST Position           */
S#define SPI_I2SSTS_TXRXRST_Msk           (0x1ul << SPI_I2SSTS_TXRXRST_Pos)                 /*!< SPI_T::I2SSTS: TXRXRST Mask               */
S
S#define SPI_I2SSTS_RXCNT_Pos             (24)                                              /*!< SPI_T::I2SSTS: RXCNT Position             */
S#define SPI_I2SSTS_RXCNT_Msk             (0x7ul << SPI_I2SSTS_RXCNT_Pos)                   /*!< SPI_T::I2SSTS: RXCNT Mask                 */
S
S#define SPI_I2SSTS_TXCNT_Pos             (28)                                              /*!< SPI_T::I2SSTS: TXCNT Position             */
S#define SPI_I2SSTS_TXCNT_Msk             (0x7ul << SPI_I2SSTS_TXCNT_Pos)                   /*!< SPI_T::I2SSTS: TXCNT Mask                 */
S
S/**@}*/ /* SPI_CONST */
S/**@}*/ /* end of SPI register group */
S
S
S/*---------------------- System Manger Controller -------------------------*/
S/**
S    @addtogroup SYS System Manger Controller(SYS)
S    Memory Mapped Structure for SYS Controller
S@{ */
S
S
Stypedef struct
S{
S
S/**
S * @var SYS_T::PDID
S * Offset: 0x00  Part Device Identification Number Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |PDID      |Part Device Identification Number (Read Only)
S * |        |          |This register reflects device part number code.
S * |        |          |Software can read this register to identify which device is used.
S * @var SYS_T::RSTSTS
S * Offset: 0x04  System Reset Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |PORF      |POR Reset Flag
S * |        |          |The POR reset flag is set by the "Reset Signal" from the Power-On Reset (POR) Controller or bit CHIPRST (SYS_IPRST0[0]) to indicate the previous reset source.
S * |        |          |0 = No reset from POR or CHIPRST.
S * |        |          |1 = Power-On Reset (POR) or CHIPRST had issued the reset signal to reset the system.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[1]     |PINRF     |nRESET Pin Reset Flag
S * |        |          |The nRESET pin reset flag is set by the "Reset Signal" from the nRESET Pin to indicate the previous reset source.
S * |        |          |0 = No reset from nRESET pin.
S * |        |          |1 = Pin nRESET had issued the reset signal to reset the system.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[2]     |WDTRF     |WDT Reset Flag
S * |        |          |The WDT reset flag is set by the "Reset Signal" from the Watchdog Timer or Window Watchdog Timer to indicate the previous reset source.
S * |        |          |0 = No reset from watchdog timer or window watchdog timer.
S * |        |          |1 = The watchdog timer or window watchdog timer had issued the reset signal to reset the system.
S * |        |          |Note1:
S * |        |          |Write 1 to clear this bit to 0.
S * |        |          |Note2: Watchdog Timer register RSTF(WDT_CTL[2]) bit is set if the system has been reset by WDT time-out reset.
S * |        |          |Window Watchdog Timer register WWDTRF(WWDT_STATUS[1]) bit is set if the system has been reset by WWDT time-out reset.
S * |[3]     |LVRF      |LVR Reset Flag
S * |        |          |The LVR reset flag is set by the "Reset Signal" from the Low-Voltage-Reset Controller to indicate the previous reset source.
S * |        |          |0 = No reset from LVR.
S * |        |          |1 = LVR controller had issued the reset signal to reset the system.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[4]     |BODRF     |BOD Reset Flag
S * |        |          |The BOD reset flag is set by the "Reset Signal" from the Brown-Out-Detector to indicate the previous reset source.
S * |        |          |0 = No reset from BOD.
S * |        |          |1 = The BOD had issued the reset signal to reset the system.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[5]     |SYSRF     |System Reset Flag
S * |        |          |The system reset flag is set by the "Reset Signal" from the Cortex-M4 Core to indicate the previous reset source.
S * |        |          |0 = No reset from Cortex-M4.
S * |        |          |1 = The Cortex-M4 had issued the reset signal to reset the system by writing 1 to the bit SYSRESETREQ(AIRCR[2], Application Interrupt and Reset Control Register, address = 0xE000ED0C) in system control registers of Cortex-M4 core.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[7]     |CPURF     |CPU Reset Flag
S * |        |          |The CPU reset flag is set by hardware if software writes CPURST (SYS_IPRST0[1]) 1 to reset Cortex-M4 Core and Flash Memory Controller (FMC).
S * |        |          |0 = No reset from CPU.
S * |        |          |1 = The Cortex-M4 Core and FMC are reset by software setting CPURST to 1.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[8]     |CPULKRF   |CPU Lockup Reset Flag
S * |        |          |The CPU reset flag is set by hardware if Cortex-M4 lockup happened.
S * |        |          |0 = No reset from CPU lockup happened.
S * |        |          |1 = The Cortex-M4 lockup happened and chip is reset.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * @var SYS_T::IPRST0
S * Offset: 0x08  Peripheral  Reset Control Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |CHIPRST   |Chip One-Shot Reset (Write Protect)
S * |        |          |Setting this bit will reset the whole chip, including Processor core and all peripherals, and this bit will automatically return to 0 after the 2 clock cycles.
S * |        |          |The CHIPRST is same as the POR reset, all the chip controllers is reset and the chip setting from flash are also reload.
S * |        |          |About the difference between CHIPRST and SYSRESETREQ, please refer to section 5.2.2
S * |        |          |0 = Chip normal operation.
S * |        |          |1 = Chip one shot reset.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[1]     |CPURST    |Processor Core One-Shot Reset (Write Protect)
S * |        |          |Setting this bit will only reset the processor core and Flash Memory Controller(FMC), and this bit will automatically return to 0 after the 2 clock cycles.
S * |        |          |0 = Processor core normal operation.
S * |        |          |1 = Processor core one-shot reset.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[2]     |PDMARST   |PDMA Controller Reset (Write Protect)
S * |        |          |Setting this bit to 1 will generate a reset signal to the PDMA.
S * |        |          |User needs to set this bit to 0 to release from reset state.
S * |        |          |0 = PDMA controller normal operation.
S * |        |          |1 = PDMA controller reset.
S * |[3]     |EBIRST    |EBI Controller Reset (Write Protect)
S * |        |          |Set this bit to 1 will generate a reset signal to the EBI.
S * |        |          |User needs to set this bit to 0 to release from the reset state.
S * |        |          |0 = EBI controller normal operation.
S * |        |          |1 = EBI controller reset.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[4]     |USBHRST   |USBH Controller Reset (Write Protect)
S * |        |          |Set this bit to 1 will generate a reset signal to the USB host controller.
S * |        |          |User needs to set this bit to 0 to release from the reset state.
S * |        |          |0 = USBH controller normal operation.
S * |        |          |1 = USBH controller reset.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[7]     |CRCRST    |CRC Calculation Unit Reset (Write Protect)
S * |        |          |Set this bit to 1 will generate a reset signal to the CRC calculation module.
S * |        |          |User needs to set this bit to 0 to release from the reset state.
S * |        |          |0 = CRC Calculation unit normal operation.
S * |        |          |1 = CRC Calculation unit reset.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * @var SYS_T::IPRST1
S * Offset: 0x0C  Peripheral Reset Control Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1]     |GPIORST   |GPIO Controller Reset
S * |        |          |0 = GPIO controller normal operation.
S * |        |          |1 = GPIO controller reset.
S * |[2]     |TMR0RST   |Timer0 Controller Reset
S * |        |          |0 = Timer0 controller normal operation.
S * |        |          |1 = Timer0 controller reset.
S * |[3]     |TMR1RST   |Timer1 Controller Reset
S * |        |          |0 = Timer1 controller normal operation.
S * |        |          |1 = Timer1 controller reset.
S * |[4]     |TMR2RST   |Timer2 Controller Reset
S * |        |          |0 = Timer2 controller normal operation.
S * |        |          |1 = Timer2 controller reset.
S * |[5]     |TMR3RST   |Timer3 Controller Reset
S * |        |          |0 = Timer3 controller normal operation.
S * |        |          |1 = Timer3 controller reset.
S * |[7]     |ACMP01RST |Analog Comparator 0/1 Controller Reset
S * |        |          |0 = Analog Comparator 0/1 controller normal operation.
S * |        |          |1 = Analog Comparator 0/1 controller reset.
S * |[8]     |I2C0RST   |I2C0 Controller Reset
S * |        |          |0 = I2C0 controller normal operation.
S * |        |          |1 = I2C0 controller reset.
S * |[9]     |I2C1RST   |I2C1 Controller Reset
S * |        |          |0 = I2C1 controller normal operation.
S * |        |          |1 = I2C1 controller reset.
S * |[12]    |SPI0RST   |SPI0 Controller Reset
S * |        |          |0 = SPI0 controller normal operation.
S * |        |          |1 = SPI0 controller reset.
S * |[13]    |SPI1RST   |SPI1 Controller Reset
S * |        |          |0 = SPI1 controller normal operation.
S * |        |          |1 = SPI1 controller reset.
S * |[14]    |SPI2RST   |SPI2 Controller Reset
S * |        |          |0 = SPI2 controller normal operation.
S * |        |          |1 = SPI2 controller reset.
S * |[16]    |UART0RST  |UART0 Controller Reset
S * |        |          |0 = UART0 controller normal operation.
S * |        |          |1 = UART0 controller reset.
S * |[17]    |UART1RST  |UART1 Controller Reset
S * |        |          |0 = UART1 controller normal operation.
S * |        |          |1 = UART1 controller reset.
S * |[18]    |UART2RST  |UART2 Controller Reset
S * |        |          |0 = UART2 controller normal operation.
S * |        |          |1 = UART2 controller reset.
S * |[19]    |UART3RST  |UART3 Controller Reset
S * |        |          |0 = UART3 controller normal operation.
S * |        |          |1 = UART3 controller reset.
S * |[24]    |CAN0RST   |CAN0 Controller Reset
S * |        |          |0 = CAN0 controller normal operation.
S * |        |          |1 = CAN0 controller reset.
S * |[26]    |OTGRST    |OTG Controller Reset
S * |        |          |0 = OTG controller normal operation.
S * |        |          |1 = OTG controller reset.
S * |[27]    |USBDRST   |USB Device Controller Reset
S * |        |          |0 = USB device controller normal operation.
S * |        |          |1 = USB device controller reset.
S * |[28]    |EADCRST   |EADC Controller Reset
S * |        |          |0 = EADC controller normal operation.
S * |        |          |1 = EADC controller reset.
S * @var SYS_T::IPRST2
S * Offset: 0x10  Peripheral Reset Control Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |SC0RST    |SC0 Controller Reset
S * |        |          |0 = SC0 controller normal operation.
S * |        |          |1 = SC0 controller reset.
S * |[12]    |DACRST    |DAC Controller Reset
S * |        |          |0 = DAC controller normal operation.
S * |        |          |1 = DAC controller reset.
S * |[16]    |PWM0RST   |PWM0 Controller Reset
S * |        |          |0 = PWM0 controller normal operation.
S * |        |          |1 = PWM0 controller reset.
S * |[17]    |PWM1RST   |PWM1 Controller Reset
S * |        |          |0 = PWM1 controller normal operation.
S * |        |          |1 = PWM1 controller reset.
S * |[25]    |TKRST     |Touch Key Controller Reset
S * |        |          |0 = Touch Key controller normal operation.
S * |        |          |1 = Touch Key controller reset.
S * @var SYS_T::BODCTL
S * Offset: 0x18  Brown-Out Detector Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |BODEN     |Brown-Out Detector Enable Bit (Write Protect)
S * |        |          |The default value is set by flash controller user configuration register CBODEN (CONFIG0 [23]).
S * |        |          |0 = Brown-out Detector function Disabled.
S * |        |          |1 = Brown-out Detector function Enabled.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[2:1]   |BODVL     |Brown-Out Detector Threshold Voltage Selection (Write Protect)
S * |        |          |The default value is set by flash controller user configuration register CBOV (CONFIG0 [22:21]).
S * |        |          |00 = Brown-Out Detector Threshold Voltage is 2.2V
S * |        |          |01 = Brown-Out Detector Threshold Voltage is 2.7V
S * |        |          |10 = Brown-Out Detector Threshold Voltage is 3.7V
S * |        |          |11 = Brown-Out Detector Threshold Voltage is 4.5V
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[3]     |BODRSTEN  |Brown-Out Reset Enable Bit (Write Protect)
S * |        |          |The default value is set by flash controller user configuration register CBORST(CONFIG0[20]) bit .
S * |        |          |0 = Brown-out "INTERRUPT" function Enabled.
S * |        |          |1 = Brown-out "RESET" function Enabled.
S * |        |          |Note1:
S * |        |          |While the Brown-out Detector function is enabled (BODEN high) and BOD reset function is enabled (BODRSTEN high), BOD will assert a signal to reset chip when the detected voltage is lower than the threshold (BODOUT high).
S * |        |          |While the BOD function is enabled (BODEN high) and BOD interrupt function is enabled (BODRSTEN low), BOD will assert an interrupt if BODOUT is high.
S * |        |          |BOD interrupt will keep till to the BODEN set to 0.
S * |        |          |BOD interrupt can be blocked by disabling the NVIC BOD interrupt or disabling BOD function (set BODEN low).
S * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[4]     |BODIF     |Brown-Out Detector Interrupt Flag
S * |        |          |0 = Brown-out Detector does not detect any voltage draft at VDD down through or up through the voltage of BODVL setting.
S * |        |          |1 = When Brown-out Detector detects the VDD is dropped down through the voltage of BODVL setting or the VDD is raised up through the voltage of BODVL setting, this bit is set to 1 and the brown-out interrupt is requested if brown-out interrupt is enabled.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[5]     |BODLPM    |Brown-Out Detector Low Power Mode (Write Protect)
S * |        |          |0 = BOD operate in normal mode (default).
S * |        |          |1 = BOD Low Power mode Enabled.
S * |        |          |Note1: The BOD consumes about 100uA in normal mode, the low power mode can reduce the current to about 1/10 but slow the BOD response.
S * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[6]     |BODOUT    |Brown-Out Detector Output Status
S * |        |          |0 = Brown-out Detector output status is 0.
S * |        |          |It means the detected voltage is higher than BODVL setting or BODEN is 0.
S * |        |          |1 = Brown-out Detector output status is 1.
S * |        |          |It means the detected voltage is lower than BODVL setting.
S * |        |          |If the BODEN is 0, BOD function disabled , this bit always responds 0000.
S * |[7]     |LVREN     |Low Voltage Reset Enable Bit (Write Protect)
S * |        |          |The LVR function resets the chip when the input power voltage is lower than LVR circuit setting.
S * |        |          |LVR function is enabled by default.
S * |        |          |0 = Low Voltage Reset function Disabled.
S * |        |          |1 = Low Voltage Reset function Enabled
S * |        |          |Note1: After enabling the bit, the LVR function will be active with 100us delay for LVR output stable (default).
S * |        |          |Note2: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[10:8]  |BODDGSEL  |Brown-Out Detector Output De-Glitch Time Select (Write Protect)
S * |        |          |000 = BOD output is sampled by RC10K clock.
S * |        |          |001 = 4 system clock (HCLK).
S * |        |          |010 = 8 system clock (HCLK).
S * |        |          |011 = 16 system clock (HCLK).
S * |        |          |100 = 32 system clock (HCLK).
S * |        |          |101 = 64 system clock (HCLK).
S * |        |          |110 = 128 system clock (HCLK).
S * |        |          |111 = 256 system clock (HCLK).
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[14:12] |LVRDGSEL  |LVR Output De-Glitch Time Select (Write Protect)
S * |        |          |000 = Without de-glitch function.
S * |        |          |001 = 4 system clock (HCLK).
S * |        |          |010 = 8 system clock (HCLK).
S * |        |          |011 = 16 system clock (HCLK).
S * |        |          |100 = 32 system clock (HCLK).
S * |        |          |101 = 64 system clock (HCLK).
S * |        |          |110 = 128 system clock (HCLK).
S * |        |          |111 = 256 system clock (HCLK).
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * @var SYS_T::IVSCTL
S * Offset: 0x1C  Internal Voltage Source Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |VTEMPEN   |Temperature Sensor Enable Bit
S * |        |          |This bit is used to enable/disable temperature sensor function.
S * |        |          |0 = Temperature sensor function Disabled (default).
S * |        |          |1 = Temperature sensor function Enabled.
S * |        |          |Note: After this bit is set to 1, the value of temperature sensor output can be obtained from ADC conversion result.
S * |        |          |Please refer to ADC function chapter for details.
S * |[1]     |VBATUGEN  |VBAT Unity Gain Buffer Enable Bit
S * |        |          |This bit is used to enable/disable VBAT unity gain buffer function.
S * |        |          |0 = VBAT unity gain buffer function Disabled (default).
S * |        |          |1 = VBAT unity gain buffer function Enabled.
S * |        |          |Note: After this bit is set to 1, the value of VBAT unity gain buffer output voltage can be obtained from ADC conversion result
S * @var SYS_T::PORCTL
S * Offset: 0x24  Power-On-Reset Controller Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |POROFF    |Power-On-Reset Enable Bit (Write Protect)
S * |        |          |When powered on, the POR circuit generates a reset signal to reset the whole chip function, but noise on the power may cause the POR active again.
S * |        |          |User can disable internal POR circuit to avoid unpredictable noise to cause chip reset by writing 0x5AA5 to this field.
S * |        |          |The POR function will be active again when this field is set to another value or chip is reset by other reset source, including:
S * |        |          |nRESET, Watchdog, LVR reset, BOD reset, ICE reset command and the software-chip reset function
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * @var SYS_T::VREFCTL
S * Offset: 0x28  VREF Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[4:0]   |VREFCTL   |VREF Control Bits (Write Protect)
S * |        |          |00011 = VREF is internal 2.65V.
S * |        |          |00111 = VREF is internal 2.048V.
S * |        |          |01011 = VREF is internal 3.072V.
S * |        |          |01111 = VREF is internal 4.096V.
S * |        |          |Others = Reserved.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * @var SYS_T::USBPHY
S * Offset: 0x2C  USB PHY Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |USBROLE   |USB Role Option (Write Protect)
S * |        |          |These two bits are used to select the role of USB.
S * |        |          |00 = Standard USB Device mode.
S * |        |          |01 = Standard USB Host mode.
S * |        |          |10 = ID dependent mode.
S * |        |          |11 = On-The-Go device mode.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[8]     |LDO33EN   |USB LDO33 Enable Bit (Write Protect)
S * |        |          |0 = USB LDO33 Disabled.
S * |        |          |1 = USB LDO33 Enabled.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * @var SYS_T::GPA_MFPL
S * Offset: 0x30  GPIOA Low Byte Multiple Function Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |PA0MFP    |PA.0 Multi-function Pin Selection
S * |[7:4]   |PA1MFP    |PA.1 Multi-function Pin Selection
S * |[11:8]  |PA2MFP    |PA.2 Multi-function Pin Selection
S * |[15:12] |PA3MFP    |PA.3 Multi-function Pin Selection
S * |[19:16] |PA4MFP    |PA.4 Multi-function Pin Selection
S * |[23:20] |PA5MFP    |PA.5 Multi-function Pin Selection
S * |[27:24] |PA6MFP    |PA.6 Multi-function Pin Selection
S * |[31:28] |PA7MFP    |PA.7 Multi-function Pin Selection
S * @var SYS_T::GPA_MFPH
S * Offset: 0x34  GPIOA High Byte Multiple Function Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |PA8MFP    |PA.8 Multi-function Pin Selection
S * |[7:4]   |PA9MFP    |PA.9 Multi-function Pin Selection
S * |[11:8]  |PA10MFP   |PA.10 Multi-function Pin Selection
S * |[15:12] |PA11MFP   |PA.11 Multi-function Pin Selection
S * |[19:16] |PA12MFP   |PA.12 Multi-function Pin Selection
S * |[23:20] |PA13MFP   |PA.13 Multi-function Pin Selection
S * |[27:24] |PA14MFP   |PA.14 Multi-function Pin Selection
S * |[31:28] |PA15MFP   |PA.15 Multi-function Pin Selection
S * @var SYS_T::GPB_MFPL
S * Offset: 0x38  GPIOB Low Byte Multiple Function Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |PB0MFP    |PB.0 Multi-function Pin Selection
S * |[7:4]   |PB1MFP    |PB.1 Multi-function Pin Selection
S * |[11:8]  |PB2MFP    |PB.2 Multi-function Pin Selection
S * |[15:12] |PB3MFP    |PB.3 Multi-function Pin Selection
S * |[19:16] |PB4MFP    |PB.4 Multi-function Pin Selection
S * |[23:20] |PB5MFP    |PB.5 Multi-function Pin Selection
S * |[27:24] |PB6MFP    |PB.6 Multi-function Pin Selection
S * |[31:28] |PB7MFP    |PB.7 Multi-function Pin Selection
S * @var SYS_T::GPB_MFPH
S * Offset: 0x3C  GPIOB High Byte Multiple Function Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |PB8MFP    |PB.8 Multi-function Pin Selection
S * |[7:4]   |PB9MFP    |PB.9 Multi-function Pin Selection
S * |[11:8]  |PB10MFP   |PB.10 Multi-function Pin Selection
S * |[15:12] |PB11MFP   |PB.11 Multi-function Pin Selection
S * |[19:16] |PB12MFP   |PB.12 Multi-function Pin Selection
S * |[23:20] |PB13MFP   |PB.13 Multi-function Pin Selection
S * |[27:24] |PB14MFP   |PB.14 Multi-function Pin Selection
S * |[31:28] |PB15MFP   |PB.15 Multi-function Pin Selection
S * @var SYS_T::GPC_MFPL
S * Offset: 0x40  GPIOC Low Byte Multiple Function Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |PC0MFP    |PC.0 Multi-function Pin Selection
S * |[7:4]   |PC1MFP    |PC.1 Multi-function Pin Selection
S * |[11:8]  |PC2MFP    |PC.2 Multi-function Pin Selection
S * |[15:12] |PC3MFP    |PC.3 Multi-function Pin Selection
S * |[19:16] |PC4MFP    |PC.4 Multi-function Pin Selection
S * |[23:20] |PC5MFP    |PC.5 Multi-function Pin Selection
S * |[27:24] |PC6MFP    |PC.6 Multi-function Pin Selection
S * |[31:28] |PC7MFP    |PC.7 Multi-function Pin Selection
S * @var SYS_T::GPC_MFPH
S * Offset: 0x44  GPIOC High Byte Multiple Function Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |PC8MFP    |PC.8 Multi-function Pin Selection
S * |[7:4]   |PC9MFP    |PC.9 Multi-function Pin Selection
S * |[11:8]  |PC10MFP   |PC.10 Multi-function Pin Selection
S * |[15:12] |PC11MFP   |PC.11 Multi-function Pin Selection
S * |[19:16] |PC12MFP   |PC.12 Multi-function Pin Selection
S * |[23:20] |PC13MFP   |PC.13 Multi-function Pin Selection
S * |[27:24] |PC14MFP   |PC.14 Multi-function Pin Selection
S * |[31:28] |PC15MFP   |PC.15 Multi-function Pin Selection
S * @var SYS_T::GPD_MFPL
S * Offset: 0x48  GPIOD Low Byte Multiple Function Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |PD0MFP    |PD.0 Multi-function Pin Selection
S * |[7:4]   |PD1MFP    |PD.1 Multi-function Pin Selection
S * |[11:8]  |PD2MFP    |PD.2 Multi-function Pin Selection
S * |[15:12] |PD3MFP    |PD.3 Multi-function Pin Selection
S * |[19:16] |PD4MFP    |PD.4 Multi-function Pin Selection
S * |[23:20] |PD5MFP    |PD.5 Multi-function Pin Selection
S * |[27:24] |PD6MFP    |PD.6 Multi-function Pin Selection
S * |[31:28] |PD7MFP    |PD.7 Multi-function Pin Selection
S * @var SYS_T::GPD_MFPH
S * Offset: 0x4C  GPIOD High Byte Multiple Function Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |PD8MFP    |PD.8 Multi-function Pin Selection
S * |[7:4]   |PD9MFP    |PD.9 Multi-function Pin Selection
S * |[11:8]  |PD10MFP   |PD.10 Multi-function Pin Selection
S * |[15:12] |PD11MFP   |PD.11 Multi-function Pin Selection
S * |[19:16] |PD12MFP   |PD.12 Multi-function Pin Selection
S * |[23:20] |PD13MFP   |PD.13 Multi-function Pin Selection
S * |[27:24] |PD14MFP   |PD.14 Multi-function Pin Selection
S * |[31:28] |PD15MFP   |PD.15 Multi-function Pin Selection
S * @var SYS_T::GPE_MFPL
S * Offset: 0x50  GPIOE Low Byte Multiple Function Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |PE0MFP    |PE.0 Multi-function Pin Selection
S * |[7:4]   |PE1MFP    |PE.1 Multi-function Pin Selection
S * |[11:8]  |PE2MFP    |PE.2 Multi-function Pin Selection
S * |[15:12] |PE3MFP    |PE.3 Multi-function Pin Selection
S * |[19:16] |PE4MFP    |PE.4 Multi-function Pin Selection
S * |[23:20] |PE5MFP    |PE.5 Multi-function Pin Selection
S * |[27:24] |PE6MFP    |PE.6 Multi-function Pin Selection
S * |[31:28] |PE7MFP    |PE.7 Multi-function Pin Selection
S * @var SYS_T::GPE_MFPH
S * Offset: 0x54  GPIOE High Byte Multiple Function Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |PE8MFP    |PE.8 Multi-function Pin Selection
S * |[7:4]   |PE9MFP    |PE.9 Multi-function Pin Selection
S * |[11:8]  |PE10MFP   |PE.10 Multi-function Pin Selection
S * |[15:12] |PE11MFP   |PE.11 Multi-function Pin Selection
S * |[19:16] |PE12MFP   |PE.12 Multi-function Pin Selection
S * |[23:20] |PE13MFP   |PE.13 Multi-function Pin Selection
S * |[27:24] |PE14_MFP  |PE.14 Multi-function Pin Selection
S * @var SYS_T::GPF_MFPL
S * Offset: 0x58  GPIOF Low Byte Multiple Function Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |PF0MFP    |PF.0 Multi-function Pin Selection
S * |[7:4]   |PF1MFP    |PF.1 Multi-function Pin Selection
S * |[11:8]  |PF2MFP    |PF.2 Multi-function Pin Selection
S * |[15:12] |PF3MFP    |PF.3 Multi-function Pin Selection
S * |[19:16] |PF4MFP    |PF.4 Multi-function Pin Selection
S * |[23:20] |PF5MFP    |PF.5 Multi-function Pin Selection
S * |[27:24] |PF6MFP    |PF.6 Multi-function Pin Selection
S * |[31:28] |PF7MFP    |PF.7 Multi-function Pin Selection
S * @var SYS_T::SRAM_INTCTL
S * Offset: 0xC0  System SRAM Interrupt Enable Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |PERRIEN   |SRAM Parity Check Error Interrupt Enable Bit
S * |        |          |0 = SRAM parity check error interrupt Disabled.
S * |        |          |1 = SRAM parity check error interrupt Enabled.
S * @var SYS_T::SRAM_STATUS
S * Offset: 0xC4  System SRAM Parity Error Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |PERRIF    |SRAM Parity Check Error Flag
S * |        |          |0 = No System SRAM parity error.
S * |        |          |1 = System SRAM parity error occur.
S * @var SYS_T::SRAM_ERRADDR
S * Offset: 0xC8  System SRAM Parity Check Error Address Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |ERRADDR   |System SRAM Parity Error Address
S * |        |          |This register shows system SRAM parity error byte address.
S * @var SYS_T::SRAM_BISTCTL
S * Offset: 0xD0  System SRAM BIST Test Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |SRBIST0   |1st
S * |        |          |SRAM BIST Enable Bit
S * |        |          |This bit enables BIST test for SRAM located in address 0x2000_0000 ~0x2000_3FFF
S * |        |          |0 = system SRAM BIST Disabled.
S * |        |          |1 = system SRAM BIST Enabled.
S * |[1]     |SRBIST1   |2nd
S * |        |          |SRAM BIST Enable Bit
S * |        |          |This bit enables BIST test for SRAM located in address 0x2000_4000 ~0x2000_7FFF
S * |        |          |0 = system SRAM BIST Disabled.
S * |        |          |1 = system SRAM BIST Enabled.
S * |[2]     |CRBIST    |CACHE BIST Enable Bit
S * |        |          |This bit enables BIST test for CACHE RAM
S * |        |          |0 = system CACHE BIST Disabled.
S * |        |          |1 = system CACHE BIST Enabled.
S * |[3]     |CANBIST   |CAN BIST Enable Bit
S * |        |          |This bit enables BIST test for CAN RAM
S * |        |          |0 = system CAN BIST Disabled.
S * |        |          |1 = system CAN BIST Enabled.
S * |[4]     |USBBIST   |USB BIST Enable Bit
S * |        |          |This bit enables BIST test for USB RAM
S * |        |          |0 = system USB BIST Disabled.
S * |        |          |1 = system USB BIST Enabled.
S * @var SYS_T::SRAM_BISTSTS
S * Offset: 0xD4  System SRAM BIST Test Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |SRBISTEF0 |1st System SRAM BIST Fail Flag
S * |        |          |0 = 1st system SRAM BIST test pass.
S * |        |          |1 = 1st system SRAM BIST test fail.
S * |[1]     |SRBISTEF1 |2nd System SRAM BIST Fail Flag
S * |        |          |0 = 2nd system SRAM BIST test pass.
S * |        |          |1 = 2nd system SRAM BIST test fail.
S * |[2]     |CRBISTEF  |CACHE SRAM BIST Fail Flag
S * |        |          |0 = System CACHE RAM BIST test pass.
S * |        |          |1 = System CACHE RAM BIST test fail.
S * |[3]     |CANBEF    |CAN SRAM BIST Fail Flag
S * |        |          |0 = CAN SRAM BIST test pass.
S * |        |          |1 = CAN SRAM BIST test fail.
S * |[4]     |USBBEF    |USB SRAM BIST Fail Flag
S * |        |          |0 = USB SRAM BIST test pass.
S * |        |          |1 = USB SRAM BIST test fail.
S * |[16]    |SRBEND0   |1st SRAM BIST Test Finish
S * |        |          |0 = 1st system SRAM BIST active.
S * |        |          |1 = 1st system SRAM BIST finish.
S * |[17]    |SRBEND1   |2nd SRAM BIST Test Finish
S * |        |          |0 = 2nd system SRAM BIST is active.
S * |        |          |1 = 2nd system SRAM BIST finish.
S * |[18]    |CRBEND    |CACHE SRAM BIST Test Finish
S * |        |          |0 = System CACHE RAM BIST is active.
S * |        |          |1 = System CACHE RAM BIST test finish.
S * |[19]    |CANBEND   |CAN SRAM BIST Test Finish
S * |        |          |0 = CAN SRAM BIST is active.
S * |        |          |1 = CAN SRAM BIST test finish.
S * |[20]    |USBBEND   |USB SRAM BIST Test Finish
S * |        |          |0 = USB SRAM BIST is active.
S * |        |          |1 = USB SRAM BIST test finish.
S * @var SYS_T::IRCTCTL
S * Offset: 0xF0  IRC Trim Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |FREQSEL   |Trim Frequency Selection
S * |        |          |This field indicates the target frequency of internal 22.1184 MHz high-speed oscillator auto trim.
S * |        |          |During auto trim operation, if clock error detected with CESTOPEN is set to 1 or trim retry limitation count reached, this field will be cleared to 00 automatically.
S * |        |          |00 = Disable HIRC auto trim function.
S * |        |          |01 = Enable HIRC auto trim function and trim HIRC to 22.1184 MHz.
S * |        |          |10 = Enable HIRC auto trim function and trim HIRC to 24 MHz.
S * |        |          |11 = Reserved.
S * |[5:4]   |LOOPSEL   |Trim Calculation Loop Selection
S * |        |          |This field defines that trim value calculation is based on how many 32.768 kHz clock.
S * |        |          |00 = Trim value calculation is based on average difference in 4 32.768 kHz clock.
S * |        |          |01 = Trim value calculation is based on average difference in 8 32.768 kHz clock.
S * |        |          |10 = Trim value calculation is based on average difference in 16 32.768 kHz clock.
S * |        |          |11 = Trim value calculation is based on average difference in 32 32.768 kHz clock.
S * |        |          |Note: For example, if LOOPSEL is set as 00, auto trim circuit will calculate trim value based on the average frequency difference in 4 32.768 kHz clock.
S * |[7:6]   |RETRYCNT  |Trim Value Update Limitation Count
S * |        |          |This field defines that how many times the auto trim circuit will try to update the HIRC trim value before the frequency of HIRC locked.
S * |        |          |Once the HIRC locked, the internal trim value update counter will be reset.
S * |        |          |If the trim value update counter reached this limitation value and frequency of HIRC still doesn't lock, the auto trim operation will be disabled and FREQSEL will be cleared to 00.
S * |        |          |00 = Trim retry count limitation is 64 loops.
S * |        |          |01 = Trim retry count limitation is 128 loops.
S * |        |          |10 = Trim retry count limitation is 256 loops.
S * |        |          |11 = Trim retry count limitation is 512 loops.
S * |[8]     |CESTOPEN  |Clock Error Stop Enable Bit
S * |        |          |0 = The trim operation is keep going if clock is inaccuracy.
S * |        |          |1 = The trim operation is stopped if clock is inaccuracy.
S * @var SYS_T::IRCTIEN
S * Offset: 0xF4  IRC Trim Interrupt Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1]     |TFAILIEN  |Trim Failure Interrupt Enable Bit
S * |        |          |This bit controls if an interrupt will be triggered while HIRC trim value update limitation count reached and HIRC frequency still not locked on target frequency set by FREQSEL(SYS_IRCTCTL[1:0]).
S * |        |          |If this bit is high and TFAILIF(SYS_IRCTSTS[1]) is set during auto trim operation, an interrupt will be triggered to notify that HIRC trim value update limitation count was reached.
S * |        |          |0 = Disable TFAILIF(SYS_IRCTSTS[1]) status to trigger an interrupt to CPU.
S * |        |          |1 = Enable TFAILIF(SYS_IRCTSTS[1]) status to trigger an interrupt to CPU.
S * |[2]     |CLKEIEN   |Clock Error Interrupt Enable Bit
S * |        |          |This bit controls if CPU would get an interrupt while clock is inaccuracy during auto trim operation.
S * |        |          |If this bit is set to1, and CLKERRIF(SYS_IRCTSTS[2]) is set during auto trim operation, an interrupt will be triggered to notify the clock frequency is inaccuracy.
S * |        |          |0 = Disable CLKERRIF(SYS_IRCTSTS[2]) status to trigger an interrupt to CPU.
S * |        |          |1 = Enable CLKERRIF(SYS_IRCTSTS[2]) status to trigger an interrupt to CPU.
S * @var SYS_T::IRCTISTS
S * Offset: 0xF8  IRC Trim Interrupt Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |FREQLOCK  |HIRC Frequency Lock Status
S * |        |          |This bit indicates the internal 22.1184 MHz high-speed oscillator frequency is locked.
S * |        |          |This is a status bit and doesn't trigger any interrupt.
S * |[1]     |TFAILIF   |Trim Failure Interrupt Status
S * |        |          |This bit indicates that internal 22.1184 MHz high-speed oscillator trim value update limitation count reached and the internal 22.1184 MHz high-speed oscillator clock frequency still doesn't be locked.
S * |        |          |Once this bit is set, the auto trim operation stopped and FREQSEL(SYS_iRCTCTL[1:0]) will be cleared to 00 by hardware automatically.
S * |        |          |If this bit is set and TFAILIEN(SYS_IRCTIEN[1]) is high, an interrupt will be triggered to notify that HIRC trim value update limitation count was reached.
S * |        |          |Write 1 to clear this to 0.
S * |        |          |0 = Trim value update limitation count does not reach.
S * |        |          |1 = Trim value update limitation count reached and internal 22.1184 MHz high-speed oscillator frequency still not locked.
S * |[2]     |CLKERRIF  |Clock Error Interrupt Status
S * |        |          |When the frequency of external 32.768 kHz low-speed crystal or internal 22.1184 MHz high-speed oscillator is shift larger to unreasonable value, this bit will be set and to be an indicate that clock frequency is inaccuracy
S * |        |          |Once this bit is set to 1, the auto trim operation stopped and FREQSEL(SYS_IRCTCL[1:0]) will be cleared to 00 by hardware automatically if CESTOPEN(SYS_IRCTCTL[8]) is set to 1.
S * |        |          |If this bit is set and CLKEIEN(SYS_IRCTIEN[2]) is high, an interrupt will be triggered to notify the clock frequency is inaccuracy.
S * |        |          |Write 1 to clear this to 0.
S * |        |          |0 = Clock frequency is accuracy.
S * |        |          |1 = Clock frequency is inaccuracy.
S * @var SYS_T::REGLCTL
S * Offset: 0x100  Register Lock Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |REGLCTL   |Register Lock Control Code
S * |        |          |Write operation:
S * |        |          |Some registers have write-protection function.
S * |        |          |Writing these registers have to disable the protected function by writing the sequence value "59h", "16h", "88h" to this field.
S * |        |          |After this sequence is completed, the REGLCTL bit will be set to 1 and write-protection registers can be normal write.
S * |        |          |Read operation:
S * |        |          |0 = Write-protection Enabled for writing protected registers.
S * |        |          |Any write to the protected register is ignored.
S * |        |          |1 = Write-protection Disabled for writing protected registers.
S * |        |          |The Protected registers are:
S * |        |          |SYS_IPRST0: address 0x4000_0008
S * |        |          |SYS_BODCTL: address 0x4000_0018
S * |        |          |SYS_PORCTL: address 0x4000_0024
S * |        |          |SYS_VREFCTL: address 0x4000_0028
S * |        |          |SYS_USBPHY: address 0x4000_002C
S * |        |          |CLK_PWRCTL: address 0x4000_0200 (bit[6] is not protected for power wake-up interrupt clear)
S * |        |          |SYS_SRAM_BISTCTL: address 0x4000_00D0
S * |        |          |CLK_APBCLK0 [0]: address 0x4000_0208 (bit[0] is watchdog clock enable)
S * |        |          |CLK_CLKSEL0: address 0x4000_0210 (for HCLK and CPU STCLK clock source select)
S * |        |          |CLK_CLKSEL1 [1:0]: address 0x4000_0214 (for watchdog clock source select)
S * |        |          |CLK_CLKSEL1 [31:30]: address 0x4000_0214 (for window watchdog clock source select)
S * |        |          |CLK_CLKDSTS: address 0x4000_0274
S * |        |          |NMIEN: address 0x4000_0300
S * |        |          |FMC_ISPCTL: address 0x4000_C000 (Flash ISP Control register)
S * |        |          |FMC_ISPTRG: address 0x4000_C010 (ISP Trigger Control register)
S * |        |          |FMC_ISPSTS: address 0x4000_C040
S * |        |          |WDT_CTL: address 0x4004_0000
S * |        |          |FMC_FTCTL: address 0x4000_5018
S * |        |          |FMC_ICPCMD: address 0x4000_501C
S * |        |          |CLK_PLLCTL: address 0x40000240
S * |        |          |PWM_CTL0: address 0x4005_8000
S * |        |          |PWM_CTL0: address 0x4005_9000
S * |        |          |PWM_DTCTL0_1: address 0x4005_8070
S * |        |          |PWM_DTCTL0_1: address 0x4005_9070
S * |        |          |PWM_DTCTL2_3: address 0x4005_8074
S * |        |          |PWM_DTCTL2_3: address 0x4005_9074
S * |        |          |PWM_DTCTL4_5: address 0x4005_8078
S * |        |          |PWM_DTCTL4_5: address 0x4005_9078
S * |        |          |PWM_BRKCTL0_1: address 0x4005_80C8
S * |        |          |PWM_BRKCTL0_1: address 0x4005_90C8
S * |        |          |PWM_BRKCTL2_3: address0x4005_80CC
S * |        |          |PWM_BRKCTL2_3: address0x4005_90CC
S * |        |          |PWM_BRKCTL4_5: address0x4005_80D0
S * |        |          |PWM_BRKCTL4_5: address0x4005_90D0
S * |        |          |PWM_INTEN1: address0x4005_80E4
S * |        |          |PWM_INTEN1: address0x4005_90E4
S * |        |          |PWM_INTSTS1: address0x4005_80EC
S * |        |          |PWM_INTSTS1: address0x4005_90EC
S */
S
S    __I  uint32_t PDID;          /* Offset: 0x00  Part Device Identification Number Register                         */
S    __IO uint32_t RSTSTS;        /* Offset: 0x04  System Reset Status Register                                       */
S    __IO uint32_t IPRST0;        /* Offset: 0x08  Peripheral  Reset Control Register 0                               */
S    __IO uint32_t IPRST1;        /* Offset: 0x0C  Peripheral Reset Control Register 1                                */
S    __IO uint32_t IPRST2;        /* Offset: 0x10  Peripheral Reset Control Register 2                                */
S    __I  uint32_t RESERVE0[1];  
S    __IO uint32_t BODCTL;        /* Offset: 0x18  Brown-Out Detector Control Register                                */
S    __IO uint32_t IVSCTL;        /* Offset: 0x1C  Internal Voltage Source Control Register                           */
S    __I  uint32_t RESERVE1[1];  
S    __IO uint32_t PORCTL;        /* Offset: 0x24  Power-On-Reset Controller Register                                 */
S    __IO uint32_t VREFCTL;       /* Offset: 0x28  VREF Control Register                                              */
S    __IO uint32_t USBPHY;        /* Offset: 0x2C  USB PHY Control Register                                           */
S    __IO uint32_t GPA_MFPL;      /* Offset: 0x30  GPIOA Low Byte Multiple Function Control Register                  */
S    __IO uint32_t GPA_MFPH;      /* Offset: 0x34  GPIOA High Byte Multiple Function Control Register                 */
S    __IO uint32_t GPB_MFPL;      /* Offset: 0x38  GPIOB Low Byte Multiple Function Control Register                  */
S    __IO uint32_t GPB_MFPH;      /* Offset: 0x3C  GPIOB High Byte Multiple Function Control Register                 */
S    __IO uint32_t GPC_MFPL;      /* Offset: 0x40  GPIOC Low Byte Multiple Function Control Register                  */
S    __IO uint32_t GPC_MFPH;      /* Offset: 0x44  GPIOC High Byte Multiple Function Control Register                 */
S    __IO uint32_t GPD_MFPL;      /* Offset: 0x48  GPIOD Low Byte Multiple Function Control Register                  */
S    __IO uint32_t GPD_MFPH;      /* Offset: 0x4C  GPIOD High Byte Multiple Function Control Register                 */
S    __IO uint32_t GPE_MFPL;      /* Offset: 0x50  GPIOE Low Byte Multiple Function Control Register                  */
S    __IO uint32_t GPE_MFPH;      /* Offset: 0x54  GPIOE High Byte Multiple Function Control Register                 */
S    __IO uint32_t GPF_MFPL;      /* Offset: 0x58  GPIOF Low Byte Multiple Function Control Register                  */
S    __I  uint32_t RESERVE2[25]; 
S    __IO uint32_t SRAM_INTCTL;   /* Offset: 0xC0  System SRAM Interrupt Enable Control Register                      */
S    __I  uint32_t SRAM_STATUS;   /* Offset: 0xC4  System SRAM Parity Error Status Register                           */
S    __I  uint32_t SRAM_ERRADDR;  /* Offset: 0xC8  System SRAM Parity Check Error Address Register                    */
S    __I  uint32_t RESERVE3[1];  
S    __IO uint32_t SRAM_BISTCTL;  /* Offset: 0xD0  System SRAM BIST Test Control Register                             */
S    __I  uint32_t SRAM_BISTSTS;  /* Offset: 0xD4  System SRAM BIST Test Status Register                              */
S    __I  uint32_t RESERVE4[6];  
S    __IO uint32_t IRCTCTL;       /* Offset: 0xF0  IRC Trim Control Register                                          */
S    __IO uint32_t IRCTIEN;       /* Offset: 0xF4  IRC Trim Interrupt Enable Register                                 */
S    __IO uint32_t IRCTISTS;      /* Offset: 0xF8  IRC Trim Interrupt Status Register                                 */
S    __I  uint32_t RESERVE5[1];  
S    __IO uint32_t REGLCTL;       /* Offset: 0x100  Register Lock Control Register                                    */
S
S} SYS_T;
S
S
S
S/**
S    @addtogroup SYS_CONST SYS Bit Field Definition
S    Constant Definitions for SYS Controller
S@{ */
S
S#define SYS_PDID_PDID_Pos                (0)                                               /*!< SYS_T::PDID: PDID Position                */
S#define SYS_PDID_PDID_Msk                (0xfffffffful << SYS_PDID_PDID_Pos)               /*!< SYS_T::PDID: PDID Mask                    */
S
S#define SYS_RSTSTS_PORF_Pos              (0)                                               /*!< SYS_T::RSTSTS: PORF Position              */
S#define SYS_RSTSTS_PORF_Msk              (0x1ul << SYS_RSTSTS_PORF_Pos)                    /*!< SYS_T::RSTSTS: PORF Mask                  */
S
S#define SYS_RSTSTS_PINRF_Pos             (1)                                               /*!< SYS_T::RSTSTS: PINRF Position             */
S#define SYS_RSTSTS_PINRF_Msk             (0x1ul << SYS_RSTSTS_PINRF_Pos)                   /*!< SYS_T::RSTSTS: PINRF Mask                 */
S
S#define SYS_RSTSTS_WDTRF_Pos             (2)                                               /*!< SYS_T::RSTSTS: WDTRF Position             */
S#define SYS_RSTSTS_WDTRF_Msk             (0x1ul << SYS_RSTSTS_WDTRF_Pos)                   /*!< SYS_T::RSTSTS: WDTRF Mask                 */
S
S#define SYS_RSTSTS_LVRF_Pos              (3)                                               /*!< SYS_T::RSTSTS: LVRF Position              */
S#define SYS_RSTSTS_LVRF_Msk              (0x1ul << SYS_RSTSTS_LVRF_Pos)                    /*!< SYS_T::RSTSTS: LVRF Mask                  */
S
S#define SYS_RSTSTS_BODRF_Pos             (4)                                               /*!< SYS_T::RSTSTS: BODRF Position             */
S#define SYS_RSTSTS_BODRF_Msk             (0x1ul << SYS_RSTSTS_BODRF_Pos)                   /*!< SYS_T::RSTSTS: BODRF Mask                 */
S
S#define SYS_RSTSTS_SYSRF_Pos             (5)                                               /*!< SYS_T::RSTSTS: SYSRF Position             */
S#define SYS_RSTSTS_SYSRF_Msk             (0x1ul << SYS_RSTSTS_SYSRF_Pos)                   /*!< SYS_T::RSTSTS: SYSRF Mask                 */
S
S#define SYS_RSTSTS_CPURF_Pos             (7)                                               /*!< SYS_T::RSTSTS: CPURF Position             */
S#define SYS_RSTSTS_CPURF_Msk             (0x1ul << SYS_RSTSTS_CPURF_Pos)                   /*!< SYS_T::RSTSTS: CPURF Mask                 */
S
S#define SYS_RSTSTS_CPULKRF_Pos           (8)                                               /*!< SYS_T::RSTSTS: CPULKRF Position           */
S#define SYS_RSTSTS_CPULKRF_Msk           (0x1ul << SYS_RSTSTS_CPULKRF_Pos)                 /*!< SYS_T::RSTSTS: CPULKRF Mask               */
S
S#define SYS_IPRST0_CHIPRST_Pos           (0)                                               /*!< SYS_T::IPRST0: CHIPRST Position           */
S#define SYS_IPRST0_CHIPRST_Msk           (0x1ul << SYS_IPRST0_CHIPRST_Pos)                 /*!< SYS_T::IPRST0: CHIPRST Mask               */
S
S#define SYS_IPRST0_CPURST_Pos            (1)                                               /*!< SYS_T::IPRST0: CPURST Position            */
S#define SYS_IPRST0_CPURST_Msk            (0x1ul << SYS_IPRST0_CPURST_Pos)                  /*!< SYS_T::IPRST0: CPURST Mask                */
S
S#define SYS_IPRST0_PDMARST_Pos           (2)                                               /*!< SYS_T::IPRST0: PDMARST Position           */
S#define SYS_IPRST0_PDMARST_Msk           (0x1ul << SYS_IPRST0_PDMARST_Pos)                 /*!< SYS_T::IPRST0: PDMARST Mask               */
S
S#define SYS_IPRST0_EBIRST_Pos            (3)                                               /*!< SYS_T::IPRST0: EBIRST Position            */
S#define SYS_IPRST0_EBIRST_Msk            (0x1ul << SYS_IPRST0_EBIRST_Pos)                  /*!< SYS_T::IPRST0: EBIRST Mask                */
S
S#define SYS_IPRST0_USBHRST_Pos           (4)                                               /*!< SYS_T::IPRST0: USBHRST Position           */
S#define SYS_IPRST0_USBHRST_Msk           (0x1ul << SYS_IPRST0_USBHRST_Pos)                 /*!< SYS_T::IPRST0: USBHRST Mask               */
S
S#define SYS_IPRST0_CRCRST_Pos            (7)                                               /*!< SYS_T::IPRST0: CRCRST Position            */
S#define SYS_IPRST0_CRCRST_Msk            (0x1ul << SYS_IPRST0_CRCRST_Pos)                  /*!< SYS_T::IPRST0: CRCRST Mask                */
S
S#define SYS_IPRST1_GPIORST_Pos           (1)                                               /*!< SYS_T::IPRST1: GPIORST Position           */
S#define SYS_IPRST1_GPIORST_Msk           (0x1ul << SYS_IPRST1_GPIORST_Pos)                 /*!< SYS_T::IPRST1: GPIORST Mask               */
S
S#define SYS_IPRST1_TMR0RST_Pos           (2)                                               /*!< SYS_T::IPRST1: TMR0RST Position           */
S#define SYS_IPRST1_TMR0RST_Msk           (0x1ul << SYS_IPRST1_TMR0RST_Pos)                 /*!< SYS_T::IPRST1: TMR0RST Mask               */
S
S#define SYS_IPRST1_TMR1RST_Pos           (3)                                               /*!< SYS_T::IPRST1: TMR1RST Position           */
S#define SYS_IPRST1_TMR1RST_Msk           (0x1ul << SYS_IPRST1_TMR1RST_Pos)                 /*!< SYS_T::IPRST1: TMR1RST Mask               */
S
S#define SYS_IPRST1_TMR2RST_Pos           (4)                                               /*!< SYS_T::IPRST1: TMR2RST Position           */
S#define SYS_IPRST1_TMR2RST_Msk           (0x1ul << SYS_IPRST1_TMR2RST_Pos)                 /*!< SYS_T::IPRST1: TMR2RST Mask               */
S
S#define SYS_IPRST1_TMR3RST_Pos           (5)                                               /*!< SYS_T::IPRST1: TMR3RST Position           */
S#define SYS_IPRST1_TMR3RST_Msk           (0x1ul << SYS_IPRST1_TMR3RST_Pos)                 /*!< SYS_T::IPRST1: TMR3RST Mask               */
S
S#define SYS_IPRST1_ACMP01RST_Pos         (7)                                               /*!< SYS_T::IPRST1: ACMP01RST Position         */
S#define SYS_IPRST1_ACMP01RST_Msk         (0x1ul << SYS_IPRST1_ACMP01RST_Pos)               /*!< SYS_T::IPRST1: ACMP01RST Mask             */
S
S#define SYS_IPRST1_I2C0RST_Pos           (8)                                               /*!< SYS_T::IPRST1: I2C0RST Position           */
S#define SYS_IPRST1_I2C0RST_Msk           (0x1ul << SYS_IPRST1_I2C0RST_Pos)                 /*!< SYS_T::IPRST1: I2C0RST Mask               */
S
S#define SYS_IPRST1_I2C1RST_Pos           (9)                                               /*!< SYS_T::IPRST1: I2C1RST Position           */
S#define SYS_IPRST1_I2C1RST_Msk           (0x1ul << SYS_IPRST1_I2C1RST_Pos)                 /*!< SYS_T::IPRST1: I2C1RST Mask               */
S
S#define SYS_IPRST1_SPI0RST_Pos           (12)                                              /*!< SYS_T::IPRST1: SPI0RST Position           */
S#define SYS_IPRST1_SPI0RST_Msk           (0x1ul << SYS_IPRST1_SPI0RST_Pos)                 /*!< SYS_T::IPRST1: SPI0RST Mask               */
S
S#define SYS_IPRST1_SPI1RST_Pos           (13)                                              /*!< SYS_T::IPRST1: SPI1RST Position           */
S#define SYS_IPRST1_SPI1RST_Msk           (0x1ul << SYS_IPRST1_SPI1RST_Pos)                 /*!< SYS_T::IPRST1: SPI1RST Mask               */
S
S#define SYS_IPRST1_SPI2RST_Pos           (14)                                              /*!< SYS_T::IPRST1: SPI2RST Position           */
S#define SYS_IPRST1_SPI2RST_Msk           (0x1ul << SYS_IPRST1_SPI2RST_Pos)                 /*!< SYS_T::IPRST1: SPI2RST Mask               */
S
S#define SYS_IPRST1_UART0RST_Pos          (16)                                              /*!< SYS_T::IPRST1: UART0RST Position          */
S#define SYS_IPRST1_UART0RST_Msk          (0x1ul << SYS_IPRST1_UART0RST_Pos)                /*!< SYS_T::IPRST1: UART0RST Mask              */
S
S#define SYS_IPRST1_UART1RST_Pos          (17)                                              /*!< SYS_T::IPRST1: UART1RST Position          */
S#define SYS_IPRST1_UART1RST_Msk          (0x1ul << SYS_IPRST1_UART1RST_Pos)                /*!< SYS_T::IPRST1: UART1RST Mask              */
S
S#define SYS_IPRST1_UART2RST_Pos          (18)                                              /*!< SYS_T::IPRST1: UART2RST Position          */
S#define SYS_IPRST1_UART2RST_Msk          (0x1ul << SYS_IPRST1_UART2RST_Pos)                /*!< SYS_T::IPRST1: UART2RST Mask              */
S
S#define SYS_IPRST1_UART3RST_Pos          (19)                                              /*!< SYS_T::IPRST1: UART3RST Position          */
S#define SYS_IPRST1_UART3RST_Msk          (0x1ul << SYS_IPRST1_UART3RST_Pos)                /*!< SYS_T::IPRST1: UART3RST Mask              */
S
S#define SYS_IPRST1_CAN0RST_Pos           (24)                                              /*!< SYS_T::IPRST1: CAN0RST Position           */
S#define SYS_IPRST1_CAN0RST_Msk           (0x1ul << SYS_IPRST1_CAN0RST_Pos)                 /*!< SYS_T::IPRST1: CAN0RST Mask               */
S
S#define SYS_IPRST1_OTGRST_Pos            (26)                                              /*!< SYS_T::IPRST1: OTGRST Position            */
S#define SYS_IPRST1_OTGRST_Msk            (0x1ul << SYS_IPRST1_OTGRST_Pos)                  /*!< SYS_T::IPRST1: OTGRST Mask                */
S
S#define SYS_IPRST1_USBDRST_Pos           (27)                                              /*!< SYS_T::IPRST1: USBDRST Position           */
S#define SYS_IPRST1_USBDRST_Msk           (0x1ul << SYS_IPRST1_USBDRST_Pos)                 /*!< SYS_T::IPRST1: USBDRST Mask               */
S
S#define SYS_IPRST1_EADCRST_Pos           (28)                                              /*!< SYS_T::IPRST1: EADCRST Position           */
S#define SYS_IPRST1_EADCRST_Msk           (0x1ul << SYS_IPRST1_EADCRST_Pos)                 /*!< SYS_T::IPRST1: EADCRST Mask               */
S
S#define SYS_IPRST2_SC0RST_Pos            (0)                                               /*!< SYS_T::IPRST2: SC0RST Position            */
S#define SYS_IPRST2_SC0RST_Msk            (0x1ul << SYS_IPRST2_SC0RST_Pos)                  /*!< SYS_T::IPRST2: SC0RST Mask                */
S
S#define SYS_IPRST2_DACRST_Pos            (12)                                              /*!< SYS_T::IPRST2: DACRST Position            */
S#define SYS_IPRST2_DACRST_Msk            (0x1ul << SYS_IPRST2_DACRST_Pos)                  /*!< SYS_T::IPRST2: DACRST Mask                */
S
S#define SYS_IPRST2_PWM0RST_Pos           (16)                                              /*!< SYS_T::IPRST2: PWM0RST Position           */
S#define SYS_IPRST2_PWM0RST_Msk           (0x1ul << SYS_IPRST2_PWM0RST_Pos)                 /*!< SYS_T::IPRST2: PWM0RST Mask               */
S
S#define SYS_IPRST2_PWM1RST_Pos           (17)                                              /*!< SYS_T::IPRST2: PWM1RST Position           */
S#define SYS_IPRST2_PWM1RST_Msk           (0x1ul << SYS_IPRST2_PWM1RST_Pos)                 /*!< SYS_T::IPRST2: PWM1RST Mask               */
S
S#define SYS_IPRST2_TKRST_Pos             (25)                                              /*!< SYS_T::IPRST2: TKRST Position             */
S#define SYS_IPRST2_TKRST_Msk             (0x1ul << SYS_IPRST2_TKRST_Pos)                   /*!< SYS_T::IPRST2: TKRST Mask                 */
S
S#define SYS_BODCTL_BODEN_Pos             (0)                                               /*!< SYS_T::BODCTL: BODEN Position             */
S#define SYS_BODCTL_BODEN_Msk             (0x1ul << SYS_BODCTL_BODEN_Pos)                   /*!< SYS_T::BODCTL: BODEN Mask                 */
S
S#define SYS_BODCTL_BODVL_Pos             (1)                                               /*!< SYS_T::BODCTL: BODVL Position             */
S#define SYS_BODCTL_BODVL_Msk             (0x3ul << SYS_BODCTL_BODVL_Pos)                   /*!< SYS_T::BODCTL: BODVL Mask                 */
S
S#define SYS_BODCTL_BODRSTEN_Pos          (3)                                               /*!< SYS_T::BODCTL: BODRSTEN Position          */
S#define SYS_BODCTL_BODRSTEN_Msk          (0x1ul << SYS_BODCTL_BODRSTEN_Pos)                /*!< SYS_T::BODCTL: BODRSTEN Mask              */
S
S#define SYS_BODCTL_BODIF_Pos             (4)                                               /*!< SYS_T::BODCTL: BODIF Position             */
S#define SYS_BODCTL_BODIF_Msk             (0x1ul << SYS_BODCTL_BODIF_Pos)                   /*!< SYS_T::BODCTL: BODIF Mask                 */
S
S#define SYS_BODCTL_BODLPM_Pos            (5)                                               /*!< SYS_T::BODCTL: BODLPM Position            */
S#define SYS_BODCTL_BODLPM_Msk            (0x1ul << SYS_BODCTL_BODLPM_Pos)                  /*!< SYS_T::BODCTL: BODLPM Mask                */
S
S#define SYS_BODCTL_BODOUT_Pos            (6)                                               /*!< SYS_T::BODCTL: BODOUT Position            */
S#define SYS_BODCTL_BODOUT_Msk            (0x1ul << SYS_BODCTL_BODOUT_Pos)                  /*!< SYS_T::BODCTL: BODOUT Mask                */
S
S#define SYS_BODCTL_LVREN_Pos             (7)                                               /*!< SYS_T::BODCTL: LVREN Position             */
S#define SYS_BODCTL_LVREN_Msk             (0x1ul << SYS_BODCTL_LVREN_Pos)                   /*!< SYS_T::BODCTL: LVREN Mask                 */
S
S#define SYS_BODCTL_BODDGSEL_Pos          (8)                                               /*!< SYS_T::BODCTL: BODDGSEL Position          */
S#define SYS_BODCTL_BODDGSEL_Msk          (0x7ul << SYS_BODCTL_BODDGSEL_Pos)                /*!< SYS_T::BODCTL: BODDGSEL Mask              */
S
S#define SYS_BODCTL_LVRDGSEL_Pos          (12)                                              /*!< SYS_T::BODCTL: LVRDGSEL Position          */
S#define SYS_BODCTL_LVRDGSEL_Msk          (0x7ul << SYS_BODCTL_LVRDGSEL_Pos)                /*!< SYS_T::BODCTL: LVRDGSEL Mask              */
S
S#define SYS_IVSCTL_VTEMPEN_Pos           (0)                                               /*!< SYS_T::IVSCTL: VTEMPEN Position           */
S#define SYS_IVSCTL_VTEMPEN_Msk           (0x1ul << SYS_IVSCTL_VTEMPEN_Pos)                 /*!< SYS_T::IVSCTL: VTEMPEN Mask               */
S
S#define SYS_IVSCTL_VBATUGEN_Pos          (1)                                               /*!< SYS_T::IVSCTL: VBATUGEN Position          */
S#define SYS_IVSCTL_VBATUGEN_Msk          (0x1ul << SYS_IVSCTL_VBATUGEN_Pos)                /*!< SYS_T::IVSCTL: VBATUGEN Mask              */
S
S#define SYS_PORCTL_POROFF_Pos            (0)                                               /*!< SYS_T::PORCTL: POROFF Position            */
S#define SYS_PORCTL_POROFF_Msk            (0xfffful << SYS_PORCTL_POROFF_Pos)               /*!< SYS_T::PORCTL: POROFF Mask                */
S
S#define SYS_VREFCTL_VREFCTL_Pos          (0)                                               /*!< SYS_T::VREFCTL: VREFCTL Position          */
S#define SYS_VREFCTL_VREFCTL_Msk          (0x1ful << SYS_VREFCTL_VREFCTL_Pos)               /*!< SYS_T::VREFCTL: VREFCTL Mask              */
S
S#define SYS_USBPHY_USBROLE_Pos           (0)                                               /*!< SYS_T::USBPHY: USBROLE Position           */
S#define SYS_USBPHY_USBROLE_Msk           (0x3ul << SYS_USBPHY_USBROLE_Pos)                 /*!< SYS_T::USBPHY: USBROLE Mask               */
S
S#define SYS_USBPHY_LDO33EN_Pos           (8)                                               /*!< SYS_T::USBPHY: LDO33EN Position           */
S#define SYS_USBPHY_LDO33EN_Msk           (0x1ul << SYS_USBPHY_LDO33EN_Pos)                 /*!< SYS_T::USBPHY: LDO33EN Mask               */
S
S#define SYS_GPA_MFPL_PA0MFP_Pos          (0)                                               /*!< SYS_T::GPA_MFPL: PA0MFP Position          */
S#define SYS_GPA_MFPL_PA0MFP_Msk          (0xful << SYS_GPA_MFPL_PA0MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA0MFP Mask              */
S
S#define SYS_GPA_MFPL_PA1MFP_Pos          (4)                                               /*!< SYS_T::GPA_MFPL: PA1MFP Position          */
S#define SYS_GPA_MFPL_PA1MFP_Msk          (0xful << SYS_GPA_MFPL_PA1MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA1MFP Mask              */
S
S#define SYS_GPA_MFPL_PA2MFP_Pos          (8)                                               /*!< SYS_T::GPA_MFPL: PA2MFP Position          */
S#define SYS_GPA_MFPL_PA2MFP_Msk          (0xful << SYS_GPA_MFPL_PA2MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA2MFP Mask              */
S
S#define SYS_GPA_MFPL_PA3MFP_Pos          (12)                                              /*!< SYS_T::GPA_MFPL: PA3MFP Position          */
S#define SYS_GPA_MFPL_PA3MFP_Msk          (0xful << SYS_GPA_MFPL_PA3MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA3MFP Mask              */
S
S#define SYS_GPA_MFPL_PA4MFP_Pos          (16)                                              /*!< SYS_T::GPA_MFPL: PA4MFP Position          */
S#define SYS_GPA_MFPL_PA4MFP_Msk          (0xful << SYS_GPA_MFPL_PA4MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA4MFP Mask              */
S
S#define SYS_GPA_MFPL_PA5MFP_Pos          (20)                                              /*!< SYS_T::GPA_MFPL: PA5MFP Position          */
S#define SYS_GPA_MFPL_PA5MFP_Msk          (0xful << SYS_GPA_MFPL_PA5MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA5MFP Mask              */
S
S#define SYS_GPA_MFPL_PA6MFP_Pos          (24)                                              /*!< SYS_T::GPA_MFPL: PA6MFP Position          */
S#define SYS_GPA_MFPL_PA6MFP_Msk          (0xful << SYS_GPA_MFPL_PA6MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA6MFP Mask              */
S
S#define SYS_GPA_MFPL_PA7MFP_Pos          (28)                                              /*!< SYS_T::GPA_MFPL: PA7MFP Position          */
S#define SYS_GPA_MFPL_PA7MFP_Msk          (0xful << SYS_GPA_MFPL_PA7MFP_Pos)                /*!< SYS_T::GPA_MFPL: PA7MFP Mask              */
S
S#define SYS_GPA_MFPH_PA8MFP_Pos          (0)                                               /*!< SYS_T::GPA_MFPH: PA8MFP Position          */
S#define SYS_GPA_MFPH_PA8MFP_Msk          (0xful << SYS_GPA_MFPH_PA8MFP_Pos)                /*!< SYS_T::GPA_MFPH: PA8MFP Mask              */
S
S#define SYS_GPA_MFPH_PA9MFP_Pos          (4)                                               /*!< SYS_T::GPA_MFPH: PA9MFP Position          */
S#define SYS_GPA_MFPH_PA9MFP_Msk          (0xful << SYS_GPA_MFPH_PA9MFP_Pos)                /*!< SYS_T::GPA_MFPH: PA9MFP Mask              */
S
S#define SYS_GPA_MFPH_PA10MFP_Pos         (8)                                               /*!< SYS_T::GPA_MFPH: PA10MFP Position         */
S#define SYS_GPA_MFPH_PA10MFP_Msk         (0xful << SYS_GPA_MFPH_PA10MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA10MFP Mask             */
S
S#define SYS_GPA_MFPH_PA11MFP_Pos         (12)                                              /*!< SYS_T::GPA_MFPH: PA11MFP Position         */
S#define SYS_GPA_MFPH_PA11MFP_Msk         (0xful << SYS_GPA_MFPH_PA11MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA11MFP Mask             */
S
S#define SYS_GPA_MFPH_PA12MFP_Pos         (16)                                              /*!< SYS_T::GPA_MFPH: PA12MFP Position         */
S#define SYS_GPA_MFPH_PA12MFP_Msk         (0xful << SYS_GPA_MFPH_PA12MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA12MFP Mask             */
S
S#define SYS_GPA_MFPH_PA13MFP_Pos         (20)                                              /*!< SYS_T::GPA_MFPH: PA13MFP Position         */
S#define SYS_GPA_MFPH_PA13MFP_Msk         (0xful << SYS_GPA_MFPH_PA13MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA13MFP Mask             */
S
S#define SYS_GPA_MFPH_PA14MFP_Pos         (24)                                              /*!< SYS_T::GPA_MFPH: PA14MFP Position         */
S#define SYS_GPA_MFPH_PA14MFP_Msk         (0xful << SYS_GPA_MFPH_PA14MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA14MFP Mask             */
S
S#define SYS_GPA_MFPH_PA15MFP_Pos         (28)                                              /*!< SYS_T::GPA_MFPH: PA15MFP Position         */
S#define SYS_GPA_MFPH_PA15MFP_Msk         (0xful << SYS_GPA_MFPH_PA15MFP_Pos)               /*!< SYS_T::GPA_MFPH: PA15MFP Mask             */
S
S#define SYS_GPB_MFPL_PB0MFP_Pos          (0)                                               /*!< SYS_T::GPB_MFPL: PB0MFP Position          */
S#define SYS_GPB_MFPL_PB0MFP_Msk          (0xful << SYS_GPB_MFPL_PB0MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB0MFP Mask              */
S
S#define SYS_GPB_MFPL_PB1MFP_Pos          (4)                                               /*!< SYS_T::GPB_MFPL: PB1MFP Position          */
S#define SYS_GPB_MFPL_PB1MFP_Msk          (0xful << SYS_GPB_MFPL_PB1MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB1MFP Mask              */
S
S#define SYS_GPB_MFPL_PB2MFP_Pos          (8)                                               /*!< SYS_T::GPB_MFPL: PB2MFP Position          */
S#define SYS_GPB_MFPL_PB2MFP_Msk          (0xful << SYS_GPB_MFPL_PB2MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB2MFP Mask              */
S
S#define SYS_GPB_MFPL_PB3MFP_Pos          (12)                                              /*!< SYS_T::GPB_MFPL: PB3MFP Position          */
S#define SYS_GPB_MFPL_PB3MFP_Msk          (0xful << SYS_GPB_MFPL_PB3MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB3MFP Mask              */
S
S#define SYS_GPB_MFPL_PB4MFP_Pos          (16)                                              /*!< SYS_T::GPB_MFPL: PB4MFP Position          */
S#define SYS_GPB_MFPL_PB4MFP_Msk          (0xful << SYS_GPB_MFPL_PB4MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB4MFP Mask              */
S
S#define SYS_GPB_MFPL_PB5MFP_Pos          (20)                                              /*!< SYS_T::GPB_MFPL: PB5MFP Position          */
S#define SYS_GPB_MFPL_PB5MFP_Msk          (0xful << SYS_GPB_MFPL_PB5MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB5MFP Mask              */
S
S#define SYS_GPB_MFPL_PB6MFP_Pos          (24)                                              /*!< SYS_T::GPB_MFPL: PB6MFP Position          */
S#define SYS_GPB_MFPL_PB6MFP_Msk          (0xful << SYS_GPB_MFPL_PB6MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB6MFP Mask              */
S
S#define SYS_GPB_MFPL_PB7MFP_Pos          (28)                                              /*!< SYS_T::GPB_MFPL: PB7MFP Position          */
S#define SYS_GPB_MFPL_PB7MFP_Msk          (0xful << SYS_GPB_MFPL_PB7MFP_Pos)                /*!< SYS_T::GPB_MFPL: PB7MFP Mask              */
S
S#define SYS_GPB_MFPH_PB8MFP_Pos          (0)                                               /*!< SYS_T::GPB_MFPH: PB8MFP Position          */
S#define SYS_GPB_MFPH_PB8MFP_Msk          (0xful << SYS_GPB_MFPH_PB8MFP_Pos)                /*!< SYS_T::GPB_MFPH: PB8MFP Mask              */
S
S#define SYS_GPB_MFPH_PB9MFP_Pos          (4)                                               /*!< SYS_T::GPB_MFPH: PB9MFP Position          */
S#define SYS_GPB_MFPH_PB9MFP_Msk          (0xful << SYS_GPB_MFPH_PB9MFP_Pos)                /*!< SYS_T::GPB_MFPH: PB9MFP Mask              */
S
S#define SYS_GPB_MFPH_PB10MFP_Pos         (8)                                               /*!< SYS_T::GPB_MFPH: PB10MFP Position         */
S#define SYS_GPB_MFPH_PB10MFP_Msk         (0xful << SYS_GPB_MFPH_PB10MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB10MFP Mask             */
S
S#define SYS_GPB_MFPH_PB11MFP_Pos         (12)                                              /*!< SYS_T::GPB_MFPH: PB11MFP Position         */
S#define SYS_GPB_MFPH_PB11MFP_Msk         (0xful << SYS_GPB_MFPH_PB11MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB11MFP Mask             */
S
S#define SYS_GPB_MFPH_PB12MFP_Pos         (16)                                              /*!< SYS_T::GPB_MFPH: PB12MFP Position         */
S#define SYS_GPB_MFPH_PB12MFP_Msk         (0xful << SYS_GPB_MFPH_PB12MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB12MFP Mask             */
S
S#define SYS_GPB_MFPH_PB13MFP_Pos         (20)                                              /*!< SYS_T::GPB_MFPH: PB13MFP Position         */
S#define SYS_GPB_MFPH_PB13MFP_Msk         (0xful << SYS_GPB_MFPH_PB13MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB13MFP Mask             */
S
S#define SYS_GPB_MFPH_PB14MFP_Pos         (24)                                              /*!< SYS_T::GPB_MFPH: PB14MFP Position         */
S#define SYS_GPB_MFPH_PB14MFP_Msk         (0xful << SYS_GPB_MFPH_PB14MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB14MFP Mask             */
S
S#define SYS_GPB_MFPH_PB15MFP_Pos         (28)                                              /*!< SYS_T::GPB_MFPH: PB15MFP Position         */
S#define SYS_GPB_MFPH_PB15MFP_Msk         (0xful << SYS_GPB_MFPH_PB15MFP_Pos)               /*!< SYS_T::GPB_MFPH: PB15MFP Mask             */
S
S#define SYS_GPC_MFPL_PC0MFP_Pos          (0)                                               /*!< SYS_T::GPC_MFPL: PC0MFP Position          */
S#define SYS_GPC_MFPL_PC0MFP_Msk          (0xful << SYS_GPC_MFPL_PC0MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC0MFP Mask              */
S
S#define SYS_GPC_MFPL_PC1MFP_Pos          (4)                                               /*!< SYS_T::GPC_MFPL: PC1MFP Position          */
S#define SYS_GPC_MFPL_PC1MFP_Msk          (0xful << SYS_GPC_MFPL_PC1MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC1MFP Mask              */
S
S#define SYS_GPC_MFPL_PC2MFP_Pos          (8)                                               /*!< SYS_T::GPC_MFPL: PC2MFP Position          */
S#define SYS_GPC_MFPL_PC2MFP_Msk          (0xful << SYS_GPC_MFPL_PC2MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC2MFP Mask              */
S
S#define SYS_GPC_MFPL_PC3MFP_Pos          (12)                                              /*!< SYS_T::GPC_MFPL: PC3MFP Position          */
S#define SYS_GPC_MFPL_PC3MFP_Msk          (0xful << SYS_GPC_MFPL_PC3MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC3MFP Mask              */
S
S#define SYS_GPC_MFPL_PC4MFP_Pos          (16)                                              /*!< SYS_T::GPC_MFPL: PC4MFP Position          */
S#define SYS_GPC_MFPL_PC4MFP_Msk          (0xful << SYS_GPC_MFPL_PC4MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC4MFP Mask              */
S
S#define SYS_GPC_MFPL_PC5MFP_Pos          (20)                                              /*!< SYS_T::GPC_MFPL: PC5MFP Position          */
S#define SYS_GPC_MFPL_PC5MFP_Msk          (0xful << SYS_GPC_MFPL_PC5MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC5MFP Mask              */
S
S#define SYS_GPC_MFPL_PC6MFP_Pos          (24)                                              /*!< SYS_T::GPC_MFPL: PC6MFP Position          */
S#define SYS_GPC_MFPL_PC6MFP_Msk          (0xful << SYS_GPC_MFPL_PC6MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC6MFP Mask              */
S
S#define SYS_GPC_MFPL_PC7MFP_Pos          (28)                                              /*!< SYS_T::GPC_MFPL: PC7MFP Position          */
S#define SYS_GPC_MFPL_PC7MFP_Msk          (0xful << SYS_GPC_MFPL_PC7MFP_Pos)                /*!< SYS_T::GPC_MFPL: PC7MFP Mask              */
S
S#define SYS_GPC_MFPH_PC8MFP_Pos          (0)                                               /*!< SYS_T::GPC_MFPH: PC8MFP Position          */
S#define SYS_GPC_MFPH_PC8MFP_Msk          (0xful << SYS_GPC_MFPH_PC8MFP_Pos)                /*!< SYS_T::GPC_MFPH: PC8MFP Mask              */
S
S#define SYS_GPC_MFPH_PC9MFP_Pos          (4)                                               /*!< SYS_T::GPC_MFPH: PC9MFP Position          */
S#define SYS_GPC_MFPH_PC9MFP_Msk          (0xful << SYS_GPC_MFPH_PC9MFP_Pos)                /*!< SYS_T::GPC_MFPH: PC9MFP Mask              */
S
S#define SYS_GPC_MFPH_PC10MFP_Pos         (8)                                               /*!< SYS_T::GPC_MFPH: PC10MFP Position         */
S#define SYS_GPC_MFPH_PC10MFP_Msk         (0xful << SYS_GPC_MFPH_PC10MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC10MFP Mask             */
S
S#define SYS_GPC_MFPH_PC11MFP_Pos         (12)                                              /*!< SYS_T::GPC_MFPH: PC11MFP Position         */
S#define SYS_GPC_MFPH_PC11MFP_Msk         (0xful << SYS_GPC_MFPH_PC11MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC11MFP Mask             */
S
S#define SYS_GPC_MFPH_PC12MFP_Pos         (16)                                              /*!< SYS_T::GPC_MFPH: PC12MFP Position         */
S#define SYS_GPC_MFPH_PC12MFP_Msk         (0xful << SYS_GPC_MFPH_PC12MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC12MFP Mask             */
S
S#define SYS_GPC_MFPH_PC13MFP_Pos         (20)                                              /*!< SYS_T::GPC_MFPH: PC13MFP Position         */
S#define SYS_GPC_MFPH_PC13MFP_Msk         (0xful << SYS_GPC_MFPH_PC13MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC13MFP Mask             */
S
S#define SYS_GPC_MFPH_PC14MFP_Pos         (24)                                              /*!< SYS_T::GPC_MFPH: PC14MFP Position         */
S#define SYS_GPC_MFPH_PC14MFP_Msk         (0xful << SYS_GPC_MFPH_PC14MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC14MFP Mask             */
S
S#define SYS_GPC_MFPH_PC15MFP_Pos         (28)                                              /*!< SYS_T::GPC_MFPH: PC15MFP Position         */
S#define SYS_GPC_MFPH_PC15MFP_Msk         (0xful << SYS_GPC_MFPH_PC15MFP_Pos)               /*!< SYS_T::GPC_MFPH: PC15MFP Mask             */
S
S#define SYS_GPD_MFPL_PD0MFP_Pos          (0)                                               /*!< SYS_T::GPD_MFPL: PD0MFP Position          */
S#define SYS_GPD_MFPL_PD0MFP_Msk          (0xful << SYS_GPD_MFPL_PD0MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD0MFP Mask              */
S
S#define SYS_GPD_MFPL_PD1MFP_Pos          (4)                                               /*!< SYS_T::GPD_MFPL: PD1MFP Position          */
S#define SYS_GPD_MFPL_PD1MFP_Msk          (0xful << SYS_GPD_MFPL_PD1MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD1MFP Mask              */
S
S#define SYS_GPD_MFPL_PD2MFP_Pos          (8)                                               /*!< SYS_T::GPD_MFPL: PD2MFP Position          */
S#define SYS_GPD_MFPL_PD2MFP_Msk          (0xful << SYS_GPD_MFPL_PD2MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD2MFP Mask              */
S
S#define SYS_GPD_MFPL_PD3MFP_Pos          (12)                                              /*!< SYS_T::GPD_MFPL: PD3MFP Position          */
S#define SYS_GPD_MFPL_PD3MFP_Msk          (0xful << SYS_GPD_MFPL_PD3MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD3MFP Mask              */
S
S#define SYS_GPD_MFPL_PD4MFP_Pos          (16)                                              /*!< SYS_T::GPD_MFPL: PD4MFP Position          */
S#define SYS_GPD_MFPL_PD4MFP_Msk          (0xful << SYS_GPD_MFPL_PD4MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD4MFP Mask              */
S
S#define SYS_GPD_MFPL_PD5MFP_Pos          (20)                                              /*!< SYS_T::GPD_MFPL: PD5MFP Position          */
S#define SYS_GPD_MFPL_PD5MFP_Msk          (0xful << SYS_GPD_MFPL_PD5MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD5MFP Mask              */
S
S#define SYS_GPD_MFPL_PD6MFP_Pos          (24)                                              /*!< SYS_T::GPD_MFPL: PD6MFP Position          */
S#define SYS_GPD_MFPL_PD6MFP_Msk          (0xful << SYS_GPD_MFPL_PD6MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD6MFP Mask              */
S
S#define SYS_GPD_MFPL_PD7MFP_Pos          (28)                                              /*!< SYS_T::GPD_MFPL: PD7MFP Position          */
S#define SYS_GPD_MFPL_PD7MFP_Msk          (0xful << SYS_GPD_MFPL_PD7MFP_Pos)                /*!< SYS_T::GPD_MFPL: PD7MFP Mask              */
S
S#define SYS_GPD_MFPH_PD8MFP_Pos          (0)                                               /*!< SYS_T::GPD_MFPH: PD8MFP Position          */
S#define SYS_GPD_MFPH_PD8MFP_Msk          (0xful << SYS_GPD_MFPH_PD8MFP_Pos)                /*!< SYS_T::GPD_MFPH: PD8MFP Mask              */
S
S#define SYS_GPD_MFPH_PD9MFP_Pos          (4)                                               /*!< SYS_T::GPD_MFPH: PD9MFP Position          */
S#define SYS_GPD_MFPH_PD9MFP_Msk          (0xful << SYS_GPD_MFPH_PD9MFP_Pos)                /*!< SYS_T::GPD_MFPH: PD9MFP Mask              */
S
S#define SYS_GPD_MFPH_PD10MFP_Pos         (8)                                               /*!< SYS_T::GPD_MFPH: PD10MFP Position         */
S#define SYS_GPD_MFPH_PD10MFP_Msk         (0xful << SYS_GPD_MFPH_PD10MFP_Pos)              /*!< SYS_T::GPD_MFPH: PD10MFP Mask              */
S
S#define SYS_GPD_MFPH_PD11MFP_Pos         (12)                                              /*!< SYS_T::GPD_MFPH: PD11MFP Position         */
S#define SYS_GPD_MFPH_PD11MFP_Msk         (0xful << SYS_GPD_MFPH_PD11MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD11MFP Mask             */
S
S#define SYS_GPD_MFPH_PD12MFP_Pos         (16)                                              /*!< SYS_T::GPD_MFPH: PD12MFP Position         */
S#define SYS_GPD_MFPH_PD12MFP_Msk         (0xful << SYS_GPD_MFPH_PD12MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD12MFP Mask             */
S
S#define SYS_GPD_MFPH_PD13MFP_Pos         (20)                                              /*!< SYS_T::GPD_MFPH: PD13MFP Position         */
S#define SYS_GPD_MFPH_PD13MFP_Msk         (0xful << SYS_GPD_MFPH_PD13MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD13MFP Mask             */
S
S#define SYS_GPD_MFPH_PD14MFP_Pos         (24)                                              /*!< SYS_T::GPD_MFPH: PD14MFP Position         */
S#define SYS_GPD_MFPH_PD14MFP_Msk         (0xful << SYS_GPD_MFPH_PD14MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD14MFP Mask             */
S
S#define SYS_GPD_MFPH_PD15MFP_Pos         (28)                                              /*!< SYS_T::GPD_MFPH: PD15MFP Position         */
S#define SYS_GPD_MFPH_PD15MFP_Msk         (0xful << SYS_GPD_MFPH_PD15MFP_Pos)               /*!< SYS_T::GPD_MFPH: PD15MFP Mask             */
S
S#define SYS_GPE_MFPL_PE0MFP_Pos          (0)                                               /*!< SYS_T::GPE_MFPL: PE0MFP Position          */
S#define SYS_GPE_MFPL_PE0MFP_Msk          (0xful << SYS_GPE_MFPL_PE0MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE0MFP Mask              */
S
S#define SYS_GPE_MFPL_PE1MFP_Pos          (4)                                               /*!< SYS_T::GPE_MFPL: PE1MFP Position          */
S#define SYS_GPE_MFPL_PE1MFP_Msk          (0xful << SYS_GPE_MFPL_PE1MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE1MFP Mask              */
S
S#define SYS_GPE_MFPL_PE2MFP_Pos          (8)                                               /*!< SYS_T::GPE_MFPL: PE2MFP Position          */
S#define SYS_GPE_MFPL_PE2MFP_Msk          (0xful << SYS_GPE_MFPL_PE2MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE2MFP Mask              */
S
S#define SYS_GPE_MFPL_PE3MFP_Pos          (12)                                              /*!< SYS_T::GPE_MFPL: PE3MFP Position          */
S#define SYS_GPE_MFPL_PE3MFP_Msk          (0xful << SYS_GPE_MFPL_PE3MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE3MFP Mask              */
S
S#define SYS_GPE_MFPL_PE4MFP_Pos          (16)                                              /*!< SYS_T::GPE_MFPL: PE4MFP Position          */
S#define SYS_GPE_MFPL_PE4MFP_Msk          (0xful << SYS_GPE_MFPL_PE4MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE4MFP Mask              */
S
S#define SYS_GPE_MFPL_PE5MFP_Pos          (20)                                              /*!< SYS_T::GPE_MFPL: PE5MFP Position          */
S#define SYS_GPE_MFPL_PE5MFP_Msk          (0xful << SYS_GPE_MFPL_PE5MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE5MFP Mask              */
S
S#define SYS_GPE_MFPL_PE6MFP_Pos          (24)                                              /*!< SYS_T::GPE_MFPL: PE6MFP Position          */
S#define SYS_GPE_MFPL_PE6MFP_Msk          (0xful << SYS_GPE_MFPL_PE6MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE6MFP Mask              */
S
S#define SYS_GPE_MFPL_PE7MFP_Pos          (28)                                              /*!< SYS_T::GPE_MFPL: PE7MFP Position          */
S#define SYS_GPE_MFPL_PE7MFP_Msk          (0xful << SYS_GPE_MFPL_PE7MFP_Pos)                /*!< SYS_T::GPE_MFPL: PE7MFP Mask              */
S
S#define SYS_GPE_MFPH_PE8MFP_Pos          (0)                                               /*!< SYS_T::GPE_MFPH: PE8MFP Position          */
S#define SYS_GPE_MFPH_PE8MFP_Msk          (0xful << SYS_GPE_MFPH_PE8MFP_Pos)                /*!< SYS_T::GPE_MFPH: PE8MFP Mask              */
S
S#define SYS_GPE_MFPH_PE9MFP_Pos          (4)                                               /*!< SYS_T::GPE_MFPH: PE9MFP Position          */
S#define SYS_GPE_MFPH_PE9MFP_Msk          (0xful << SYS_GPE_MFPH_PE9MFP_Pos)                /*!< SYS_T::GPE_MFPH: PE9MFP Mask              */
S
S#define SYS_GPE_MFPH_PE10MFP_Pos         (8)                                               /*!< SYS_T::GPE_MFPH: PE10MFP Position         */
S#define SYS_GPE_MFPH_PE10MFP_Msk         (0xful << SYS_GPE_MFPH_PE10MFP_Pos)               /*!< SYS_T::GPE_MFPH: PE10MFP Mask             */
S
S#define SYS_GPE_MFPH_PE11MFP_Pos         (12)                                              /*!< SYS_T::GPE_MFPH: PE11MFP Position         */
S#define SYS_GPE_MFPH_PE11MFP_Msk         (0xful << SYS_GPE_MFPH_PE11MFP_Pos)               /*!< SYS_T::GPE_MFPH: PE11MFP Mask             */
S
S#define SYS_GPE_MFPH_PE12MFP_Pos         (16)                                              /*!< SYS_T::GPE_MFPH: PE12MFP Position         */
S#define SYS_GPE_MFPH_PE12MFP_Msk         (0xful << SYS_GPE_MFPH_PE12MFP_Pos)               /*!< SYS_T::GPE_MFPH: PE12MFP Mask             */
S
S#define SYS_GPE_MFPH_PE13MFP_Pos         (20)                                              /*!< SYS_T::GPE_MFPH: PE13MFP Position         */
S#define SYS_GPE_MFPH_PE13MFP_Msk         (0xful << SYS_GPE_MFPH_PE13MFP_Pos)               /*!< SYS_T::GPE_MFPH: PE13MFP Mask             */
S
S#define SYS_GPE_MFPH_PE14MFP_Pos         (24)                                              /*!< SYS_T::GPE_MFPH: PE14MFP Position         */
S#define SYS_GPE_MFPH_PE14MFP_Msk         (0xful << SYS_GPE_MFPH_PE14MFP_Pos)               /*!< SYS_T::GPE_MFPH: PE14MFP Mask             */
S
S#define SYS_GPF_MFPL_PF0MFP_Pos          (0)                                               /*!< SYS_T::GPF_MFPL: PF0MFP Position          */
S#define SYS_GPF_MFPL_PF0MFP_Msk          (0xful << SYS_GPF_MFPL_PF0MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF0MFP Mask              */
S
S#define SYS_GPF_MFPL_PF1MFP_Pos          (4)                                               /*!< SYS_T::GPF_MFPL: PF1MFP Position          */
S#define SYS_GPF_MFPL_PF1MFP_Msk          (0xful << SYS_GPF_MFPL_PF1MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF1MFP Mask              */
S
S#define SYS_GPF_MFPL_PF2MFP_Pos          (8)                                               /*!< SYS_T::GPF_MFPL: PF2MFP Position          */
S#define SYS_GPF_MFPL_PF2MFP_Msk          (0xful << SYS_GPF_MFPL_PF2MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF2MFP Mask              */
S
S#define SYS_GPF_MFPL_PF3MFP_Pos          (12)                                              /*!< SYS_T::GPF_MFPL: PF3MFP Position          */
S#define SYS_GPF_MFPL_PF3MFP_Msk          (0xful << SYS_GPF_MFPL_PF3MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF3MFP Mask              */
S
S#define SYS_GPF_MFPL_PF4MFP_Pos          (16)                                              /*!< SYS_T::GPF_MFPL: PF4MFP Position          */
S#define SYS_GPF_MFPL_PF4MFP_Msk          (0xful << SYS_GPF_MFPL_PF4MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF4MFP Mask              */
S
S#define SYS_GPF_MFPL_PF5MFP_Pos          (20)                                              /*!< SYS_T::GPF_MFPL: PF5MFP Position          */
S#define SYS_GPF_MFPL_PF5MFP_Msk          (0xful << SYS_GPF_MFPL_PF5MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF5MFP Mask              */
S
S#define SYS_GPF_MFPL_PF6MFP_Pos          (24)                                              /*!< SYS_T::GPF_MFPL: PF6MFP Position          */
S#define SYS_GPF_MFPL_PF6MFP_Msk          (0xful << SYS_GPF_MFPL_PF6MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF6MFP Mask              */
S
S#define SYS_GPF_MFPL_PF7MFP_Pos          (28)                                              /*!< SYS_T::GPF_MFPL: PF7MFP Position          */
S#define SYS_GPF_MFPL_PF7MFP_Msk          (0xful << SYS_GPF_MFPL_PF7MFP_Pos)                /*!< SYS_T::GPF_MFPL: PF7MFP Mask              */
S
S#define SYS_SRAM_INTCTL_PERRIEN_Pos      (0)                                               /*!< SYS_T::SRAM_INTCTL: PERRIEN Position      */
S#define SYS_SRAM_INTCTL_PERRIEN_Msk      (0x1ul << SYS_SRAM_INTCTL_PERRIEN_Pos)            /*!< SYS_T::SRAM_INTCTL: PERRIEN Mask          */
S
S#define SYS_SRAM_STATUS_PERRIF_Pos       (0)                                               /*!< SYS_T::SRAM_STATUS: PERRIF Position       */
S#define SYS_SRAM_STATUS_PERRIF_Msk       (0x1ul << SYS_SRAM_STATUS_PERRIF_Pos)             /*!< SYS_T::SRAM_STATUS: PERRIF Mask           */
S
S#define SYS_SRAM_ERRADDR_ERRADDR_Pos     (0)                                               /*!< SYS_T::SRAM_ERRADDR: ERRADDR Position     */
S#define SYS_SRAM_ERRADDR_ERRADDR_Msk     (0xfffffffful << SYS_SRAM_ERRADDR_ERRADDR_Pos)    /*!< SYS_T::SRAM_ERRADDR: ERRADDR Mask         */
S
S#define SYS_SRAM_BISTCTL_SRBIST0_Pos     (0)                                               /*!< SYS_T::SRAM_BISTCTL: SRBIST0 Position     */
S#define SYS_SRAM_BISTCTL_SRBIST0_Msk     (0x1ul << SYS_SRAM_BISTCTL_SRBIST0_Pos)           /*!< SYS_T::SRAM_BISTCTL: SRBIST0 Mask         */
S
S#define SYS_SRAM_BISTCTL_SRBIST1_Pos     (1)                                               /*!< SYS_T::SRAM_BISTCTL: SRBIST1 Position     */
S#define SYS_SRAM_BISTCTL_SRBIST1_Msk     (0x1ul << SYS_SRAM_BISTCTL_SRBIST1_Pos)           /*!< SYS_T::SRAM_BISTCTL: SRBIST1 Mask         */
S
S#define SYS_SRAM_BISTCTL_CRBIST_Pos      (2)                                               /*!< SYS_T::SRAM_BISTCTL: CRBIST Position      */
S#define SYS_SRAM_BISTCTL_CRBIST_Msk      (0x1ul << SYS_SRAM_BISTCTL_CRBIST_Pos)            /*!< SYS_T::SRAM_BISTCTL: CRBIST Mask          */
S
S#define SYS_SRAM_BISTCTL_CANBIST_Pos     (3)                                               /*!< SYS_T::SRAM_BISTCTL: CANBIST Position     */
S#define SYS_SRAM_BISTCTL_CANBIST_Msk     (0x1ul << SYS_SRAM_BISTCTL_CANBIST_Pos)           /*!< SYS_T::SRAM_BISTCTL: CANBIST Mask         */
S
S#define SYS_SRAM_BISTCTL_USBBIST_Pos     (4)                                               /*!< SYS_T::SRAM_BISTCTL: USBBIST Position     */
S#define SYS_SRAM_BISTCTL_USBBIST_Msk     (0x1ul << SYS_SRAM_BISTCTL_USBBIST_Pos)           /*!< SYS_T::SRAM_BISTCTL: USBBIST Mask         */
S
S#define SYS_SRAM_BISTSTS_SRBISTEF0_Pos   (0)                                               /*!< SYS_T::SRAM_BISTSTS: SRBISTEF0 Position   */
S#define SYS_SRAM_BISTSTS_SRBISTEF0_Msk   (0x1ul << SYS_SRAM_BISTSTS_SRBISTEF0_Pos)         /*!< SYS_T::SRAM_BISTSTS: SRBISTEF0 Mask       */
S
S#define SYS_SRAM_BISTSTS_SRBISTEF1_Pos   (1)                                               /*!< SYS_T::SRAM_BISTSTS: SRBISTEF1 Position   */
S#define SYS_SRAM_BISTSTS_SRBISTEF1_Msk   (0x1ul << SYS_SRAM_BISTSTS_SRBISTEF1_Pos)         /*!< SYS_T::SRAM_BISTSTS: SRBISTEF1 Mask       */
S
S#define SYS_SRAM_BISTSTS_CRBISTEF_Pos    (2)                                               /*!< SYS_T::SRAM_BISTSTS: CRBISTEF Position    */
S#define SYS_SRAM_BISTSTS_CRBISTEF_Msk    (0x1ul << SYS_SRAM_BISTSTS_CRBISTEF_Pos)          /*!< SYS_T::SRAM_BISTSTS: CRBISTEF Mask        */
S
S#define SYS_SRAM_BISTSTS_CANBEF_Pos      (3)                                               /*!< SYS_T::SRAM_BISTSTS: CANBEF Position      */
S#define SYS_SRAM_BISTSTS_CANBEF_Msk      (0x1ul << SYS_SRAM_BISTSTS_CANBEF_Pos)            /*!< SYS_T::SRAM_BISTSTS: CANBEF Mask          */
S
S#define SYS_SRAM_BISTSTS_USBBEF_Pos      (4)                                               /*!< SYS_T::SRAM_BISTSTS: USBBEF Position      */
S#define SYS_SRAM_BISTSTS_USBBEF_Msk      (0x1ul << SYS_SRAM_BISTSTS_USBBEF_Pos)            /*!< SYS_T::SRAM_BISTSTS: USBBEF Mask          */
S
S#define SYS_SRAM_BISTSTS_SRBEND0_Pos     (16)                                              /*!< SYS_T::SRAM_BISTSTS: SRBEND0 Position     */
S#define SYS_SRAM_BISTSTS_SRBEND0_Msk     (0x1ul << SYS_SRAM_BISTSTS_SRBEND0_Pos)           /*!< SYS_T::SRAM_BISTSTS: SRBEND0 Mask         */
S
S#define SYS_SRAM_BISTSTS_SRBEND1_Pos     (17)                                              /*!< SYS_T::SRAM_BISTSTS: SRBEND1 Position     */
S#define SYS_SRAM_BISTSTS_SRBEND1_Msk     (0x1ul << SYS_SRAM_BISTSTS_SRBEND1_Pos)           /*!< SYS_T::SRAM_BISTSTS: SRBEND1 Mask         */
S
S#define SYS_SRAM_BISTSTS_CRBEND_Pos      (18)                                              /*!< SYS_T::SRAM_BISTSTS: CRBEND Position      */
S#define SYS_SRAM_BISTSTS_CRBEND_Msk      (0x1ul << SYS_SRAM_BISTSTS_CRBEND_Pos)            /*!< SYS_T::SRAM_BISTSTS: CRBEND Mask          */
S
S#define SYS_SRAM_BISTSTS_CANBEND_Pos     (19)                                              /*!< SYS_T::SRAM_BISTSTS: CANBEND Position     */
S#define SYS_SRAM_BISTSTS_CANBEND_Msk     (0x1ul << SYS_SRAM_BISTSTS_CANBEND_Pos)           /*!< SYS_T::SRAM_BISTSTS: CANBEND Mask         */
S
S#define SYS_SRAM_BISTSTS_USBBEND_Pos     (20)                                              /*!< SYS_T::SRAM_BISTSTS: USBBEND Position     */
S#define SYS_SRAM_BISTSTS_USBBEND_Msk     (0x1ul << SYS_SRAM_BISTSTS_USBBEND_Pos)           /*!< SYS_T::SRAM_BISTSTS: USBBEND Mask         */
S
S#define SYS_IRCTCTL_FREQSEL_Pos          (0)                                               /*!< SYS_T::IRCTCTL: FREQSEL Position          */
S#define SYS_IRCTCTL_FREQSEL_Msk          (0x3ul << SYS_IRCTCTL_FREQSEL_Pos)                /*!< SYS_T::IRCTCTL: FREQSEL Mask              */
S
S#define SYS_IRCTCTL_LOOPSEL_Pos          (4)                                               /*!< SYS_T::IRCTCTL: LOOPSEL Position          */
S#define SYS_IRCTCTL_LOOPSEL_Msk          (0x3ul << SYS_IRCTCTL_LOOPSEL_Pos)                /*!< SYS_T::IRCTCTL: LOOPSEL Mask              */
S
S#define SYS_IRCTCTL_RETRYCNT_Pos         (6)                                               /*!< SYS_T::IRCTCTL: RETRYCNT Position         */
S#define SYS_IRCTCTL_RETRYCNT_Msk         (0x3ul << SYS_IRCTCTL_RETRYCNT_Pos)               /*!< SYS_T::IRCTCTL: RETRYCNT Mask             */
S
S#define SYS_IRCTCTL_CESTOPEN_Pos         (8)                                               /*!< SYS_T::IRCTCTL: CESTOPEN Position         */
S#define SYS_IRCTCTL_CESTOPEN_Msk         (0x1ul << SYS_IRCTCTL_CESTOPEN_Pos)               /*!< SYS_T::IRCTCTL: CESTOPEN Mask             */
S
S#define SYS_IRCTIEN_TFAILIEN_Pos         (1)                                               /*!< SYS_T::IRCTIEN: TFAILIEN Position         */
S#define SYS_IRCTIEN_TFAILIEN_Msk         (0x1ul << SYS_IRCTIEN_TFAILIEN_Pos)               /*!< SYS_T::IRCTIEN: TFAILIEN Mask             */
S
S#define SYS_IRCTIEN_CLKEIEN_Pos          (2)                                               /*!< SYS_T::IRCTIEN: CLKEIEN Position          */
S#define SYS_IRCTIEN_CLKEIEN_Msk          (0x1ul << SYS_IRCTIEN_CLKEIEN_Pos)                /*!< SYS_T::IRCTIEN: CLKEIEN Mask              */
S
S#define SYS_IRCTISTS_FREQLOCK_Pos        (0)                                               /*!< SYS_T::IRCTISTS: FREQLOCK Position        */
S#define SYS_IRCTISTS_FREQLOCK_Msk        (0x1ul << SYS_IRCTISTS_FREQLOCK_Pos)              /*!< SYS_T::IRCTISTS: FREQLOCK Mask            */
S
S#define SYS_IRCTISTS_TFAILIF_Pos         (1)                                               /*!< SYS_T::IRCTISTS: TFAILIF Position         */
S#define SYS_IRCTISTS_TFAILIF_Msk         (0x1ul << SYS_IRCTISTS_TFAILIF_Pos)               /*!< SYS_T::IRCTISTS: TFAILIF Mask             */
S
S#define SYS_IRCTISTS_CLKERRIF_Pos        (2)                                               /*!< SYS_T::IRCTISTS: CLKERRIF Position        */
S#define SYS_IRCTISTS_CLKERRIF_Msk        (0x1ul << SYS_IRCTISTS_CLKERRIF_Pos)              /*!< SYS_T::IRCTISTS: CLKERRIF Mask            */
S
S#define SYS_REGLCTL_REGLCTL_Pos          (0)                                               /*!< SYS_T::REGLCTL: REGLCTL Position          */
S#define SYS_REGLCTL_REGLCTL_Msk          (0xfful << SYS_REGLCTL_REGLCTL_Pos)               /*!< SYS_T::REGLCTL: REGLCTL Mask              */
S
S/**@}*/ /* SYS_CONST */
S
S
Stypedef struct
S{
S
S/**
S * @var SYS_INT_T::NMIEN
S * Offset: 0x00  NMI Source Interrupt Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |BODOUT    |BOD NMI Source Enable (Write Protect)
S * |        |          |0 = BOD NMI source Disabled.
S * |        |          |1 = BOD NMI source Enabled.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.    
S * |[1]     |IRC_INT   |IRC TRIM NMI Source Enable (Write Protect)
S * |        |          |0 = IRC TRIM NMI source Disabled.
S * |        |          |1 = IRC TRIM NMI source Enabled.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.   
S * |[2]     |PWRWU_INT |Power-Down Mode Wake-Up NMI Source Enable (Write Protect)
S * |        |          |0 = Power-down mode wake-up NMI source Disabled.
S * |        |          |1 = Power-down mode wake-up NMI source Enabled.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.    
S * |[3]     |SRAM_PERR   |SRAM ParityCheck Error NMI Source Enable (Write Protect)
S * |        |          |0 = SRAM parity check error NMI source Disabled.
S * |        |          |1 = SRAM parity check error NMI source Enabled.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.    
S * |[4]     |CLKFAIL   |Clock Fail Detected NMI Source Enable (Write Protect)
S * |        |          |0 = Clock fail detected interrupt NMI source Disabled.
S * |        |          |1 = Clock fail detected interrupt NMI source Enabled.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.    
S * |[6]     |RTC_INT   |RTC NMI Source Enable (Write Protect)
S * |        |          |0 = RTC NMI source Disabled.
S * |        |          |1 = RTC NMI source Enabled.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.    
S * |[7]     |TAMPER_INT|TAMPER_INT NMI Source Enable (Write Protect)
S * |        |          |0 = Backup register tamper detected interrupt.NMI source Disabled.
S * |        |          |1 = Backup register tamper detected interrupt.NMI source Enabled.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.     
S * |[8]     |EINT0     |External Interrupt From PA.0, PD.2 Or PE.4 Pin NMI Source Enable (Write Protect)
S * |        |          |0 = External interrupt from PA.0, PD.2 or PE.4 pin NMI source Disabled.
S * |        |          |1 = External interrupt from PA.0, PD.2 or PE.4 pin NMI source Enabled.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.        
S * |[9]     |EINT1     |External Interrupt From PB.0, PD.3 Or PE.5 Pin NMI Source Enable (Write Protect)
S * |        |          |0 = External interrupt from PB.0, PD.3 or PE.5 pin NMI source Disabled.
S * |        |          |1 = External interrupt from PB.0, PD.3 or PE.5 pin NMI source Enabled.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[10]    |EINT2     |External Interrupt From PC.0 Pin NMI Source Enable (Write Protect)
S * |        |          |0 = External interrupt from PC.0 pin NMI source Disabled.
S * |        |          |1 = External interrupt from PC.0 pin NMI source Enabled.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.       
S * |[11]    |EINT3     |External Interrupt From PD.0 Pin NMI Source Enable (Write Protect)
S * |        |          |0 = External interrupt from PD.0 pin NMI source Disabled.
S * |        |          |1 = External interrupt from PD.0 pin NMI source Enabled.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.     
S * |[12]    |EINT4     |External Interrupt From PE.0 Pin NMI Source Enable (Write Protect)
S * |        |          |0 = External interrupt from PE.0 pin NMI source Disabled.
S * |        |          |1 = External interrupt from PE.0 pin NMI source Enabled.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.      
S * |[13]    |EINT5     |External Interrupt From PF.0 Pin NMI Source Enable (Write Protect)
S * |        |          |0 = External interrupt from PF.0 pin NMI source Disabled.
S * |        |          |1 = External interrupt from PF.0 pin NMI source Enabled.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.     
S * |[14]    |UART0_INT |UART0 NMI Source Enable (Write Protect)
S * |        |          |0 = UART0 NMI source Disabled.
S * |        |          |1 = UART0 NMI source Enabled.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.    
S * |[15]    |UART1_INT |UART1 NMI Source Enable (Write Protect)
S * |        |          |0 = UART1 NMI source Disabled.
S * |        |          |1 = UART1 NMI source Enabled.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * @var SYS_INT_T::NMISTS
S * Offset: 0x04  NMI source interrupt Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |BODOUT    |BOD Interrupt Flag (Read Only)
S * |        |          |0 = BOD interrupt is deasserted.
S * |        |          |1 = BOD interrupt is asserted. 
S * |[1]     |IRC_INT   |IRC TRIM Interrupt Flag (Read Only)
S * |        |          |0 = HIRC TRIM interrupt is deasserted.
S * |        |          |1 = HIRC TRIM interrupt is asserted. 
S * |[2]     |PWRWU_INT |Power-Down Mode Wake-Up Interrupt Flag (Read Only)
S * |        |          |0 = Power-down mode wake-up interrupt is deasserted.
S * |        |          |1 = Power-down mode wake-up interrupt is asserted. 
S * |[3]     |SRAM_PERR |SRAM ParityCheck Error Interrupt Flag (Read Only)
S * |        |          |0 = SRAM parity check error interrupt is deasserted.
S * |        |          |1 = SRAM parity check error interrupt is asserted. 
S * |[4]     |CLKFAIL   |Clock Fail Detected Interrupt Flag (Read Only)
S * |        |          |0 = Clock fail detected interrupt is deasserted.
S * |        |          |1 = Clock fail detected interrupt is asserted.
S * |[6]     |RTC_INT   |RTC Interrupt Flag (Read Only)
S * |        |          |0 = RTC interrupt is deasserted.
S * |        |          |1 = RTC interrupt is asserted.
S * |[7]     |TAMPER_INT|TAMPER_INT Interrupt Flag (Read Only)
S * |        |          |0 = Backup register tamper detected interrupt is deasserted.
S * |        |          |1 = Backup register tamper detected interrupt is asserted.
S * |[8]     |EINT0     |External Interrupt From PA.0, PD.2 Or PE.4 Pin Interrupt Flag (Read Only)
S * |        |          |0 = External Interrupt from PA.0, PD.2 or PE.4 interrupt is deasserted.
S * |        |          |1 = External Interrupt from PA.0, PD.2 or PE.4 interrupt is asserted. 
S * |[9]     |EINT1     |External Interrupt From PB.0, PD.3 Or PE.5 Pin Interrupt Flag (Read Only)
S * |        |          |0 = External Interrupt from PB.0, PD.3 or PE.5 interrupt is deasserted.
S * |        |          |1 = External Interrupt from PB.0, PD.3 or PE.5 interrupt is asserted. 
S * |[10]    |EINT2     |External Interrupt From PC.0 Pin Interrupt Flag (Read Only)
S * |        |          |0 = External Interrupt from PC.0 interrupt is deasserted.
S * |        |          |1 = External Interrupt from PC.0 interrupt is asserted. 
S * |[11]    |EINT3     |External Interrupt From PD.0 Pin Interrupt Flag (Read Only)
S * |        |          |0 = External Interrupt from PD.0 interrupt is deasserted.
S * |        |          |1 = External Interrupt from PD.0 interrupt is asserted. 
S * |[12]    |EINT4     |External Interrupt From PE.0 Pin Interrupt Flag (Read Only)
S * |        |          |0 = External Interrupt from PE.0 interrupt is deasserted.
S * |        |          |1 = External Interrupt from PE.0 interrupt is asserted. 
S * |[13]    |EINT5     |External Interrupt From PF.0 Pin Interrupt Flag (Read Only)
S * |        |          |0 = External Interrupt from PF.0 interrupt is deasserted.
S * |        |          |1 = External Interrupt from PF.0 interrupt is asserted. 
S * |[14]    |UART0_INT |UART0 Interrupt Flag (Read Only)
S * |        |          |0 = UART1 interrupt is deasserted.
S * |        |          |1 = UART1 interrupt is asserted.
S * |[15]    |UART1_INT |UART1 Interrupt Flag (Read Only)
S * |        |          |0 = UART1 interrupt is deasserted.
S * |        |          |1 = UART1 interrupt is asserted.
S */
S
S    __IO  uint32_t NMIEN;          /* Offset: 0x00  NMI Source Interrupt Enable Register                               */
S    __I   uint32_t NMISTS;         /* Offset: 0x04  NMI source interrupt Status Register                               */
S
S} SYS_INT_T;
S
S
S
S/**
S    @addtogroup INT_CONST INT Bit Field Definition
S    Constant Definitions for SYS Controller
S@{ */
S
S#define SYS_NMIEN_BODOUT_Pos             (0)                                               /*!< SYS_INT_T::NMIEN: BODOUT Position         */
S#define SYS_NMIEN_BODOUT_Msk             (0x1ul << SYS_NMIEN_BODOUT_Pos )                  /*!< SYS_INT_T::NMIEN: BODOUT Mask             */
S
S#define SYS_NMIEN_IRC_INT_Pos            (1)                                               /*!< SYS_INT_T::NMIEN: IRC_INT Position        */
S#define SYS_NMIEN_IRC_INT_Msk            (0x1ul << SYS_NMIEN_IRC_INT_Pos )                 /*!< SYS_INT_T::NMIEN: IRC_INT Mask            */
S
S#define SYS_NMIEN_PWRWU_INT_Pos          (2)                                               /*!< SYS_INT_T::NMIEN: PWRWU_INT Position      */
S#define SYS_NMIEN_PWRWU_INT_Msk          (0x1ul << SYS_NMIEN_PWRWU_INT_Pos )               /*!< SYS_INT_T::NMIEN: PWRWU_INT Mask          */
S
S#define SYS_NMIEN_SRAM_PERR_Pos          (3)                                               /*!< SYS_INT_T::NMIEN: SRAM_PERR Position      */
S#define SYS_NMIEN_SRAM_PERR_Msk          (0x1ul << SYS_NMIEN_SRAM_PERR_Pos )               /*!< SYS_INT_T::NMIEN: SRAM_PERR Mask          */
S
S#define SYS_NMIEN_CLKFAIL_Pos            (4)                                               /*!< SYS_INT_T::NMIEN: CLKFAIL Position        */
S#define SYS_NMIEN_CLKFAIL_Msk            (0x1ul << SYS_NMIEN_CLKFAIL_Pos )                 /*!< SYS_INT_T::NMIEN: CLKFAIL Mask            */
S
S#define SYS_NMIEN_RTC_INT_Pos            (6)                                               /*!< SYS_INT_T::NMIEN: RTC_INT Position        */
S#define SYS_NMIEN_RTC_INT_Msk            (0x1ul << SYS_NMIEN_RTC_INT_Pos )                 /*!< SYS_INT_T::NMIEN: RTC_INT Mask            */
S
S#define SYS_NMIEN_TAMPER_INT_Pos         (7)                                               /*!< SYS_INT_T::NMIEN: TAMPER_INT Position     */
S#define SYS_NMIEN_TAMPER_INT_Msk         (0x1ul << SYS_NMIEN_TAMPER_INT_Pos )              /*!< SYS_INT_T::NMIEN: TAMPER_INT Mask         */
S
S#define SYS_NMIEN_EINT0_Pos              (8)                                               /*!< SYS_INT_T::NMIEN: EINT0 Position          */
S#define SYS_NMIEN_EINT0_Msk              (0x1ul << SYS_NMIEN_EINT0_Pos )                   /*!< SYS_INT_T::NMIEN: EINT0 Mask              */
S
S#define SYS_NMIEN_EINT1_Pos              (9)                                               /*!< SYS_INT_T::NMIEN: EINT1 Position          */
S#define SYS_NMIEN_EINT1_Msk              (0x1ul << SYS_NMIEN_EINT1_Pos )                   /*!< SYS_INT_T::NMIEN: EINT1 Mask              */
S
S#define SYS_NMIEN_EINT2_Pos              (10)                                              /*!< SYS_INT_T::NMIEN: EINT2 Position          */
S#define SYS_NMIEN_EINT2_Msk              (0x1ul << SYS_NMIEN_EINT2_Pos )                   /*!< SYS_INT_T::NMIEN: EINT2 Mask              */
S
S#define SYS_NMIEN_EINT3_Pos              (11)                                              /*!< SYS_INT_T::NMIEN: EINT3 Position          */
S#define SYS_NMIEN_EINT3_Msk              (0x1ul << SYS_NMIEN_EINT3_Pos )                   /*!< SYS_INT_T::NMIEN: EINT3 Mask              */
S
S#define SYS_NMIEN_EINT4_Pos              (12)                                              /*!< SYS_INT_T::NMIEN: EINT4 Position          */
S#define SYS_NMIEN_EINT4_Msk              (0x1ul << SYS_NMIEN_EINT4_Pos )                   /*!< SYS_INT_T::NMIEN: EINT4 Mask              */
S
S#define SYS_NMIEN_EINT5_Pos              (13)                                              /*!< SYS_INT_T::NMIEN: EINT5 Position          */
S#define SYS_NMIEN_EINT5_Msk              (0x1ul << SYS_NMIEN_EINT5_Pos )                   /*!< SYS_INT_T::NMIEN: EINT5 Mask              */
S
S#define SYS_NMIEN_UART0_INT_Pos          (14)                                              /*!< SYS_INT_T::NMIEN: UART0_INT Position      */
S#define SYS_NMIEN_UART0_INT_Msk          (0x1ul << SYS_NMIEN_UART0_INT_Pos )               /*!< SYS_INT_T::NMIEN: UART0_INT Mask          */
S
S#define SYS_NMIEN_UART1_INT_Pos          (15)                                              /*!< SYS_INT_T::NMIEN: UART1_INT Position      */
S#define SYS_NMIEN_UART1_INT_Msk          (0x1ul << SYS_NMIEN_UART1_INT_Pos )               /*!< SYS_INT_T::NMIEN: UART1_INT Mask          */
S
S#define SYS_NMISTS_BODOUT_Pos            (0)                                               /*!< SYS_INT_T::NMISTS: BODOUT Position        */
S#define SYS_NMISTS_BODOUT_Msk            (0x1ul << SYS_NMISTS_BODOUT_Pos )                 /*!< SYS_INT_T::NMISTS: BODOUT Mask            */
S
S#define SYS_NMISTS_IRC_INT_Pos           (1)                                               /*!< SYS_INT_T::NMISTS: IRC_INT Position       */
S#define SYS_NMISTS_IRC_INT_Msk           (0x1ul << SYS_NMISTS_IRC_INT_Pos )                /*!< SYS_INT_T::NMISTS: IRC_INT Mask           */
S
S#define SYS_NMISTS_PWRWU_INT_Pos         (2)                                               /*!< SYS_INT_T::NMISTS: PWRWU_INT Position     */
S#define SYS_NMISTS_PWRWU_INT_Msk         (0x1ul << SYS_NMISTS_PWRWU_INT_Pos )              /*!< SYS_INT_T::NMISTS: PWRWU_INT Mask         */
S
S#define SYS_NMISTS_SRAM_PERR_Pos         (3)                                               /*!< SYS_INT_T::NMISTS: SRAM_PERR Position     */
S#define SYS_NMISTS_SRAM_PERR_Msk         (0x1ul << SYS_NMISTS_SRAM_PERR_Pos )              /*!< SYS_INT_T::NMISTS: SRAM_PERR Mask         */
S
S#define SYS_NMISTS_CLKFAIL_Pos           (4)                                               /*!< SYS_INT_T::NMISTS: CLKFAIL Position       */
S#define SYS_NMISTS_CLKFAIL_Msk           (0x1ul << SYS_NMISTS_CLKFAIL_Pos )                /*!< SYS_INT_T::NMISTS: CLKFAIL Mask           */
S
S#define SYS_NMISTS_RTC_INT_Pos           (6)                                               /*!< SYS_INT_T::NMISTS: RTC_INT Position       */
S#define SYS_NMISTS_RTC_INT_Msk           (0x1ul << SYS_NMISTS_RTC_INT_Pos )                /*!< SYS_INT_T::NMISTS: RTC_INT Mask           */
S
S#define SYS_NMISTS_TAMPER_INT_Pos        (7)                                               /*!< SYS_INT_T::NMISTS: TAMPER_INT Position    */
S#define SYS_NMISTS_TAMPER_INT_Msk        (0x1ul << SYS_NMISTS_TAMPER_INT_Pos )             /*!< SYS_INT_T::NMISTS: TAMPER_INT Mask        */
S
S#define SYS_NMISTS_EINT0_Pos             (8)                                               /*!< SYS_INT_T::NMISTS: EINT0 Position         */
S#define SYS_NMISTS_EINT0_Msk             (0x1ul << SYS_NMISTS_EINT0_Pos )                  /*!< SYS_INT_T::NMISTS: EINT0 Mask             */
S
S#define SYS_NMISTS_EINT1_Pos             (9)                                               /*!< SYS_INT_T::NMISTS: EINT1 Position         */
S#define SYS_NMISTS_EINT1_Msk             (0x1ul << SYS_NMISTS_EINT1_Pos )                  /*!< SYS_INT_T::NMISTS: EINT1 Mask             */
S
S#define SYS_NMISTS_EINT2_Pos             (10)                                              /*!< SYS_INT_T::NMISTS: EINT2 Position         */
S#define SYS_NMISTS_EINT2_Msk             (0x1ul << SYS_NMISTS_EINT2_Pos )                  /*!< SYS_INT_T::NMISTS: EINT2 Mask             */
S
S#define SYS_NMISTS_EINT3_Pos             (11)                                              /*!< SYS_INT_T::NMISTS: EINT3 Position         */
S#define SYS_NMISTS_EINT3_Msk             (0x1ul << SYS_NMISTS_EINT3_Pos )                  /*!< SYS_INT_T::NMISTS: EINT3 Mask             */
S
S#define SYS_NMISTS_EINT4_Pos             (12)                                              /*!< SYS_INT_T::NMISTS: EINT4 Position         */
S#define SYS_NMISTS_EINT4_Msk             (0x1ul << SYS_NMISTS_EINT4_Pos )                  /*!< SYS_INT_T::NMISTS: EINT4 Mask             */
S
S#define SYS_NMISTS_EINT5_Pos             (13)                                              /*!< SYS_INT_T::NMISTS: EINT5 Position         */
S#define SYS_NMISTS_EINT5_Msk             (0x1ul << SYS_NMISTS_EINT5_Pos )                  /*!< SYS_INT_T::NMISTS: EINT5 Mask             */
S
S#define SYS_NMISTS_UART0_INT_Pos         (14)                                              /*!< SYS_INT_T::NMISTS: UART0_INT Position     */
S#define SYS_NMISTS_UART0_INT_Msk         (0x1ul << SYS_NMISTS_UART0_INT_Pos )              /*!< SYS_INT_T::NMISTS: UART0_INT Mask         */
S
S#define SYS_NMISTS_UART1_INT_Pos         (15)                                              /*!< SYS_INT_T::NMISTS: UART1_INT Position     */
S#define SYS_NMISTS_UART1_INT_Msk         (0x1ul << SYS_NMISTS_UART1_INT_Pos )              /*!< SYS_INT_T::NMISTS: UART1_INT Mask         */
S
S/**@}*/ /* INT_CONST */
S/**@}*/ /* end of SYS register group */
S
S
S/*---------------------- Touch Key Controller -------------------------*/
S/**
S    @addtogroup TK Touch Key Controller(TK)
S    Memory Mapped Structure for TK Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S/**
S * @var TK_T::CTL
S * Offset: 0x00  Touch Key Scan Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |TKSEN0    |TK0 Scan Enable Bit
S * |        |          |This bit is ignored if TKREN0 (TK_REFCTL[0]) is "1" except SCANALL (TK_REFCTL[23]) is "1".
S * |        |          |0 = TKDAT0 (TK_DAT0[7:0]) is invalid.
S * |        |          |1 = TK0 is always enable for Touch Key scan. TKDAT0 (TK_DAT0[7:0]) is valid.
S * |[1]     |TKSEN1    |TK1 Scan Enable Bit
S * |        |          |This bit is ignored if TKREN1 (TK_REFCTL[1]) is "1".
S * |        |          |0 = TKDAT1 (TK_DAT0[15:8]) is invalid.
S * |        |          |1 = TK1 is always enable for Touch Key scan. TKDAT1 (TK_DAT0[15:8]) is valid.
S * |[2]     |TKSEN2    |TK2 Scan Enable Bit
S * |        |          |This bit is ignored if TKREN2 (TK_REFCTL[2]) is "1".
S * |        |          |0 = TKDAT2 (TK_DAT0[23:16]) is invalid.
S * |        |          |1 = TK2 is always enable for Touch Key scan. TKDAT2 (TK_DAT0[23:16]) is valid.
S * |[3]     |TKSEN3    |TK3 Scan Enable Bit
S * |        |          |0 = TKDAT3 (TK_DAT0[31:24]) is invalid.
S * |        |          |1 = TK3 is always enable for Touch Key scan. TKDAT3 (TK_DAT0[31:24]) is valid.
S * |        |          |This bit is ignored if TKREN3 (TK_REFCTL[3]) is "1".
S * |[4]     |TKSEN4    |TK4 Scan Enable Bit
S * |        |          |This bit is ignored if TKREN4 (TK_REFCTL[4]) is "1".
S * |        |          |0 = TKDAT4 (TK_DAT1[7:0]) is invalid.
S * |        |          |1 = TK4 is always enable for Touch Key scan. TKDAT4 (TK_DAT1[7:0]) is valid.
S * |[5]     |TKSEN5    |TK5 Scan Enable Bit
S * |        |          |This bit is ignored if TKREN5 (TK_REFCTL[5]) is "1".
S * |        |          |0 = TKDAT5 (TK_DAT1[15:8]) is invalid.
S * |        |          |1 = TK5 is always enable for Touch Key scan. TKDAT5 (TK_DAT1[15:8]) is valid.
S * |[6]     |TKSEN6    |TK6 Scan Enable Bit
S * |        |          |This bit is ignored if TKREN6 (TK_REFCTL[6]) is "1".
S * |        |          |0 = TKDAT6 (TK_DAT1[23:16]) is invalid.
S * |        |          |1 = TK6 is always enable for Touch Key scan. TKDAT6 (TK_DAT1[23:16]) is valid.
S * |[7]     |TKSEN7    |TK7 Scan Enable
S * |        |          |This bit is ignored if TKREN7 (TK_REFCTL[7]) is "1".
S * |        |          |0 = TKDAT7 (TK_DAT1[31:24]) is invalid.
S * |        |          |1 = TK7 is always enable for Touch Key scan. TKDAT7 (TK_DAT1[31:24]) is valid.
S * |[8]     |TKSEN8    |TK8 Scan Enable Bit
S * |        |          |This bit is ignored if TKREN8 (TK_REFCTL[8]) is "1".
S * |        |          |0 = TKDAT8 (TK_DAT2[7:0]) is invalid.
S * |        |          |1 = TK8 is always enable for Touch Key scan. TKDAT8 (TK_DAT2[7:0]) is valid.
S * |[9]     |TKSEN9    |TK9 Scan Enable Bit
S * |        |          |This bit is ignored if TKREN9 (TK_REFCTL[9]) is "1".
S * |        |          |0 = TKDAT9 (TK_DAT2[15:8]) is invalid.
S * |        |          |1 = TK9 is always enable for Touch Key scan. TKDAT9 (TK_DAT2[15:8]) is valid.
S * |[10]    |TKSEN10   |TK10 Scan Enable Bit
S * |        |          |This bit is ignored if TKREN10 (TK_REFCTL[10]) is "1".
S * |        |          |0 = TKDAT10 (TK_DAT2[23:16]) is invalid.
S * |        |          |1 = TK10 is always enable for Touch Key scan. TKDAT10 (TK_DAT2[23:16]) is valid.
S * |[11]    |TKSEN11   |TK11 Scan Enable
S * |        |          |This bit is ignored if TKREN11 (TK_REFCTL[11]) is "1".
S * |        |          |0 = TKDAT11 (TK_DAT2[31:24]) is invalid.
S * |        |          |1 = TK11 is always enable for Touch Key scan. TKDAT11 (TK_DAT2[31:24]) is valid.
S * |[12]    |TKSEN12   |TK12 Scan Enable Bit
S * |        |          |This bit is ignored if TKREN12 (TK_REFCTL[12]) is "1".
S * |        |          |0 = TKDAT12 (TK_DAT3[7:0]) is invalid.
S * |        |          |1 = TK12 is always enable for Touch Key scan. TKDAT12 (TK_DAT3[7:0]) is valid.
S * |[13]    |TKSEN13   |TK13 Scan Enable Bit
S * |        |          |This bit is ignored if TKREN13 (TK_REFCTL[13]) is "1".
S * |        |          |0 = TKDAT13 (TK_DAT3[15:8]) is invalid.
S * |        |          |1 = TK13 is always enable for key scan. TKDAT13 (TK_DAT3[15:8]) is valid.
S * |[14]    |TKSEN14   |TK14 Scan Enable Bit
S * |        |          |This bit is ignored if TKREN14 (TK_REFCTL[14]) is "1".
S * |        |          |0 = TKDAT14 (TK_DAT3[23:16]) is invalid.
S * |        |          |1 = TK14 is always enabled for key scan. TKDAT14 (TK_DAT3[23:16]) is valid.
S * |[15]    |TKSEN15   |TK15 Scan Enable Bit
S * |        |          |This bit is ignored if TKREN15 (TK_REFCTL[15]) is "1".
S * |        |          |0 = TKDAT15 (TK_DAT3[31:24]) is invalid.
S * |        |          |1 = TK15 is always enabled for key scan. TKDAT15 (TK_DAT3[31:24]) is valid.
S * |[16]    |TKSEN16   |TK16 Scan Enable Bit
S * |        |          |This bit is ignored if TKREN16 (TK_REFCTL[16]) is "1".
S * |        |          |0 = TKDAT16 (TK_DAT4[7:0]) is invalid.
S * |        |          |1 = TK16 is always enabled for key scan. TKDAT16 (TK_DAT4[7:0]) is valid.
S * |[22:20] |AVCCHSEL  |AVCCH Voltage Select
S * |        |          |000 = 1/16 VDD.
S * |        |          |001 = 1/8 VDD.
S * |        |          |010 = 3/16 VDD.
S * |        |          |011 = 1/4 VDD.
S * |        |          |100 = 5/16 VDD.
S * |        |          |101 = 3/8 VDD.
S * |        |          |110 = 7/16 VDD.
S * |        |          |111 = 1/2 VDD.
S * |[24]    |SCAN      |Scan
S * |        |          |Write an '1' to this bit will immediately initiate key scan on all channels which are enabled.
S * |        |          |This bit will be self-cleared after key scan started.
S * |[25]    |TMRTRGEN  |Timer Trigger Enable Bit
S * |        |          |0 = Disable timer to trigger key scan.
S * |        |          |1 = Enable timer triggers key scan periodically. Key scan will be initiated by Timer0 periodically.
S * |[31]    |TKEN      |Touch Key Scan Enable Bit
S * |        |          |0 = Disable Touch Key Function.
S * |        |          |1 = Enable Touch Key Function.
S * @var TK_T::REFCTL
S * Offset: 0x04  Touch Key Reference Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |TKREN0    |TK0 Reference Enable Bit
S * |        |          |0 = TK0 is not reference.
S * |        |          |1 = TK0 is set as reference, and TKDAT0 (TK_DAT0[7:0]) is invalid except SCANALL (TK_REFCTL[23]) is "1".
S * |[1]     |TKREN1    |TK1 Reference Enable Bit
S * |        |          |0 = TK1 is not reference.
S * |        |          |1 = TK1 is set as reference, and TKDAT1 (TK_DAT0[15:8]) is invalid.
S * |[2]     |TKREN2    |TK2 Reference Enable Bit
S * |        |          |0 = TK2 is not reference.
S * |        |          |1 = TK2 is set as reference, and TKDAT2 (TK_DAT0[23:16]) is invalid.
S * |[3]     |TKREN3    |TK3 Reference Enable Bit
S * |        |          |0 = TK3 is not reference.
S * |        |          |1 = TK3 is set as reference, and TKDAT3 (TK_DAT0[31:24]) is invalid.
S * |[4]     |TKREN4    |TK4 Reference Enable Bit
S * |        |          |0 = TK4 is not reference.
S * |        |          |1 = TK4 is set as reference, and TKDAT4 (TK_DAT1[7:0]) is invalid.
S * |[5]     |TKREN5    |TK5 Reference Enable Bit
S * |        |          |0 = TK5 is not reference.
S * |        |          |1 = TK5 is set as reference, and TKDAT5 (TK_DAT1[15:8]) is invalid.
S * |[6]     |TKREN6    |TK6 Reference Enable Bit
S * |        |          |0 = TK6 is not reference.
S * |        |          |1 = TK6 is set as reference, and TKDAT6 (TK_DAT1[23:16]) is invalid.
S * |[7]     |TKREN7    |TK7 Reference Enable Bit
S * |        |          |0 = TK7 is not reference.
S * |        |          |1 = TK7 is set as reference, and TKDAT7 (TK_DAT1[31:24]) is invalid.
S * |[8]     |TKREN8    |TK8 Reference Enable Bit
S * |        |          |0 = TK8 is not reference.
S * |        |          |1 = TK8 is set as reference, and TKDAT8 (TK_DAT2[7:0]) is invalid.
S * |[9]     |TKREN9    |TK9 Reference Enable Bit
S * |        |          |0 = TK9 is not reference.
S * |        |          |1 = TK9 is set as reference, and TKDAT9 (TK_DAT2[15:8]) is invalid.
S * |[10]    |TKREN10   |TK10 Reference Enable Bit
S * |        |          |0 = TK10 is not reference.
S * |        |          |1 = TK10 is set as reference, and TKDAT10 (TK_DAT2[23:16]) is invalid.
S * |[11]    |TKREN11   |TK11 Reference Enable Bit
S * |        |          |0 = TK11 is not reference.
S * |        |          |1 = TK11 is set as reference, and TKDAT11 (TK_DAT2[31:24]) is invalid.
S * |[12]    |TKREN12   |TK12 Reference Enable Bit
S * |        |          |0 = TK12 is not reference.
S * |        |          |1 = TK12 is set as reference, and TKDAT12 (TK_DAT3[7:0]) is invalid.
S * |[13]    |TKREN13   |TK13 Reference Enable Bit
S * |        |          |0 = TK13 is not reference.
S * |        |          |1 = TK13 is set as reference, and TKDAT13 (TK_DAT3[15:8]) is invalid.
S * |[14]    |TKREN14   |TK14 Reference Enable Bit
S * |        |          |0 = TK14 is not reference.
S * |        |          |1 = TK14 is set as reference, and TKDAT14 (TK_DAT3[23:16]) is invalid.
S * |[15]    |TKREN15   |TK15 Reference Enable Bit
S * |        |          |0 = TK15 is not reference.
S * |        |          |1 = TK15 is set as reference, and TKDAT15 (TK_DAT3[31:24]) is invalid.
S * |[16]    |TKREN16   |TK16 Reference Enable Bit
S * |        |          |0 = TK16 is not reference.
S * |        |          |1 = TK16 is set as reference, and TKDAT16 (TK_DAT4[7:0]) is invalid.
S * |        |          |Note: This bit is forced to "1" automatically if none is set as reference.
S * |[23]    |SCANALL   |All Key Scan Enable Bit
S * |        |          |This function is used for low power key scanning operation.
S * |        |          |TKDAT0 (TK_DAT0[7:0]) is the only one valid data when key scan is complete.
S * |        |          |0 = Disable All Keys Scan function.
S * |        |          |1 = Enable All Keys Scan function.
S * |[25:24] |SENTCTL   |Touch Key Sensing Time Control
S * |        |          |00 = 128 x SENPTCTL.
S * |        |          |01 = 255 x SENPTCTL.
S * |        |          |10 = 511 x SENPTCTL.
S * |        |          |11 = 1023 x SENPTCTL.
S * |[29:28] |SENPTCTL  |Touch Key Sensing Pulse Width Time Control
S * |        |          |00 = 1us.
S * |        |          |01 = 2us.
S * |        |          |10 = 4us.
S * |        |          |11 = 8us.
S * @var TK_T::CCBDAT0
S * Offset: 0x08  Touch Key Complement Capacitor Bank Data Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |CCBDAT0   |TK0 Complement CB Data
S * |        |          |This is register is used for TK0 sensitivity adjustment.
S * |[15:8]  |CCBDAT1   |TK1 Complement CB Data
S * |        |          |This is register is used for TK1 sensitivity adjustment.
S * |[23:16] |CCBDAT2   |TK2 Complement CB Data
S * |        |          |This is register is used for TK2 sensitivity adjustment.
S * |[31:24] |CCBDAT3   |TK3 Complement CB Data
S * |        |          |This is register is used for TK3 sensitivity adjustment.
S * @var TK_T::CCBDAT1
S * Offset: 0x0C  Touch Key Complement Capacitor Bank Data Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |CCBDAT4   |TK4 Complement CB Data
S * |        |          |This is register is used for TK4 sensitivity adjustment.
S * |[15:8]  |CCBDAT5   |TK5 Complement CB Data
S * |        |          |This is register is used for TK5 sensitivity adjustment.
S * |[23:16] |CCBDAT6   |TK6 Complement CB Data
S * |        |          |This is register is used for TK6 sensitivity adjustment.
S * |[31:24] |CCBDAT7   |TK7 Complement CB Data
S * |        |          |This is register is used for TK7 sensitivity adjustment.
S * @var TK_T::CCBDAT2
S * Offset: 0x10  Touch Key Complement Capacitor Bank Data Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |CCBDAT8   |TK8 Complement CB Data
S * |        |          |This is register is used for TK8 sensitivity adjustment.
S * |[15:8]  |CCBDAT9   |TK9 Complement CB Data
S * |        |          |This is register is used for TK9 sensitivity adjustment.
S * |[23:16] |CCBDAT10  |TK10 Complement CB Data
S * |        |          |This is register is used for TK10 sensitivity adjustment.
S * |[31:24] |CCBDAT11  |TK11 Complement CB Data
S * |        |          |This is register is used for TK11 sensitivity adjustment.
S * @var TK_T::CCBDAT3
S * Offset: 0x14  Touch Key Complement Capacitor Bank Data Register 3
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |CCBDAT12  |TK12 Complement CB Data
S * |        |          |This is register is used for TK12 sensitivity adjustment.
S * |[15:8]  |CCBDAT13  |TK13 Complement CB Data
S * |        |          |This is register is used for TK13 sensitivity adjustment.
S * |[23:16] |CCBDAT14  |TK14 Complement CB Data
S * |        |          |This is register is used for TK14 sensitivity adjustment.
S * |[31:24] |CCBDAT15  |TK15 Complement CB Data
S * |        |          |This is register is used for TK15 sensitivity adjustment.
S * @var TK_T::CCBDAT4
S * Offset: 0x18  Touch Key Complement Capacitor Bank Data Register 4
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |CCBDAT16  |TK16 Complement CB Data
S * |        |          |This is register is used for TK16 sensitivity adjustment.
S * |[31:24] |REFCBDAT  |Reference CB Data
S * @var TK_T::IDLESEL
S * Offset: 0x1C  Touch Key Idle State Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |IDLSn     |TKn Idle State Control
S * |        |          |This register is ignored if both TKSENn (TK_CTL[n]) and POLENn (TK_POLCTL[n+8]) are "0" or TKRENn (TK_REFCTL[n]) is "1".
S * |        |          |00 = TKn connected to GND.
S * |        |          |01 = TKn connected to AVCCH.
S * |        |          |10 = TKn connected to VDD.
S * |        |          |11 = TKn connected to VDD.
S * |        |          |n = 0 to 15.
S * @var TK_T::POLSEL
S * Offset: 0x20  Touch Key Polarity Select Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |POLSELn   |TKn Polarity Select
S * |        |          |This register is ignored if POLENn (TK_POLCTL[n+8]) is "0", or either TKSENn (TK_CTL[n]) or TKRENn (TK_REFCTL[n]) is "1".
S * |        |          |00 = TKn connected to Gnd.
S * |        |          |01 = TKn connected to AVCCH.
S * |        |          |10 = TKn connected to VDD.
S * |        |          |11 = TKn connected to VDD.
S * @var TK_T::POLCTL
S * Offset: 0x24  Touch Key Polarity Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |IDLS16    |TK16 Idle State Control
S * |        |          |This register is ignored if both TKSEN16 (TK_CTL[16]) and POLEN16 (TK_POLCTL[24]) are "0" or TKREN16 (TK_REFCTL[16]) is "1".
S * |        |          |00 = TK16 connected to Gnd.
S * |        |          |01 = TK16 connected to AVCCH.
S * |        |          |10 = TK16 connected to VDD.
S * |        |          |11 = TK16 connected to VDD.
S * |[3:2]   |POLSEL16  |TK16 Polarity Control
S * |        |          |This register is ignored if POLEN16 (TK_POLCTL[24]) is "0", or either TKSEN16 (TK_CTL[16]) or TKREN16 (TK_REFCTL[16]) is "1".
S * |        |          |00 = TK16 connected to Gnd.
S * |        |          |01 = TK16 connected to AVCCH.
S * |        |          |10 = TK16 connected to VDD.
S * |        |          |11 = TK16 connected to VDD.
S * |[5:4]   |CBPOLSEL  |Capacitor Bank Polarity Select
S * |        |          |00 = Gnd.
S * |        |          |01 = AVCCH.
S * |        |          |10 = VDD.
S * |        |          |11 = VDD.
S * |[8]     |POLEN0    |TK0 Polarity Function Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[9]     |POLEN1    |TK1 Polarity Function Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[10]    |POLEN2    |TK2 Polarity Function Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[11]    |POLEN3    |TK3 Polarity Function Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[12]    |POLEN4    |TK4 Polarity Function Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[13]    |POLEN5    |TK5 Polarity Function Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[14]    |POLEN6    |TK6 Polarity Function Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[15]    |POLEN7    |TK7 Polarity Function Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[16]    |POLEN8    |TK8 Polarity Function Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[17]    |POLEN9    |TK9 Polarity Function Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[18]    |POLEN10   |TK10 Polarity Function Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[19]    |POLEN11   |TK11 Polarity Function Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[20]    |POLEN12   |TK12 Polarity Function Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[21]    |POLEN13   |TK13 Polarity Function Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[22]    |POLEN14   |TK14 Polarity Function Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[23]    |POLEN15   |TK15 Polarity Function Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[24]    |POLEN16   |TK16 Polarity Function Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[31]    |SPOTINIT  |Touch Key Sensing Initial Potential Control
S * |        |          |0 = Key pad is connected to Gnd before sensing.
S * |        |          |1 = Key pad is connected to AVCCH before sensing.
S * @var TK_T::STATUS
S * Offset: 0x28  Touch Key Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |BUSY      |Touch Key Busy (Read Only)
S * |        |          |0 = Key scan is complete or stopped.
S * |        |          |1 = Key scan is proceeding.
S * |[1]     |SCIF      |Touch Key Scan Complete Interrupt Flag
S * |        |          |This bit will be cleared by writing a "1" to this bit.
S * |        |          |0 = Key scan is proceeding and data is not ready for read.
S * |        |          |1 = Key scan is complete and data is ready for read in TKDATx registers.
S * |        |          |Note1: The Touch Key interrupt asserts if SCINTEN bit of TK_INTEN register is set.
S * |        |          |Note2: The Touch Key interrupt also asserts if SCTHIEN bit of TK_INTEN register is set and any channel data value is greater/less than its threshold setting
S * |[8]     |TKIF0     |TK0 Interrupt Flag
S * |        |          |This bit will be cleared by writing a "1" to this bit.
S * |        |          |0 = No threshold control event with TK0.
S * |        |          |1 = Threshold control event occurs with TK0.
S * |[9]     |TKIF1     |TK1 Interrupt Flag
S * |        |          |This bit will be cleared by writing a "1" to this bit.
S * |        |          |0 = No threshold control event with TK1.
S * |        |          |1 = Threshold control event occurs with TK1.
S * |[10]    |TKIF2     |TK2 Interrupt Flag
S * |        |          |This bit will be cleared by writing a "1" to this bit.
S * |        |          |0 = No threshold control event with TK2.
S * |        |          |1 = Threshold control event occurs with TK2.
S * |[11]    |TKIF3     |TK3 Interrupt Flag
S * |        |          |This bit will be cleared by writing a "1" to this bit.
S * |        |          |0 = No threshold control event with TK3.
S * |        |          |1 = Threshold control event occurs with TK3.
S * |[12]    |TKIF4     |TK4 Interrupt Flag
S * |        |          |This bit will be cleared by writing a "1" to this bit.
S * |        |          |0 = No threshold control event with TK4.
S * |        |          |1 = Threshold control event occurs with TK4.
S * |[13]    |TKIF5     |TK5 Interrupt Flag
S * |        |          |This bit will be cleared by writing a "1" to this bit.
S * |        |          |0 = No threshold control event with TK5.
S * |        |          |1 = Threshold control event occurs with TK5.
S * |[14]    |TKIF6     |TK6 Interrupt Flag
S * |        |          |This bit will be cleared by writing a "1" to this bit.
S * |        |          |0 = No threshold control event with TK6.
S * |        |          |1 = Threshold control event occurs with TK6.
S * |[15]    |TKIF7     |TK7 Interrupt Flag
S * |        |          |This bit will be cleared by writing a "1" to this bit.
S * |        |          |0 = No threshold control event with TK7.
S * |        |          |1 = Threshold control event occurs with TK7.
S * |[16]    |TKIF8     |TK8 Interrupt Flag
S * |        |          |This bit will be cleared by writing a "1" to this bit.
S * |        |          |0 = No threshold control event with TK8.
S * |        |          |1 = Threshold control event occurs with TK8.
S * |[17]    |TKIF9     |TK9 Interrupt Flag
S * |        |          |This bit will be cleared by writing a "1" to this bit.
S * |        |          |0 = No threshold control event with TK9.
S * |        |          |1 = Threshold control event occurs with TK9.
S * |[18]    |TKIF10    |TK10 Interrupt Flag
S * |        |          |This bit will be cleared by writing a "1" to this bit.
S * |        |          |0 = No threshold control event with TK10.
S * |        |          |1 = Threshold control event occurs with TK10.
S * |[19]    |TKIF11    |TK11 Interrupt Flag
S * |        |          |This bit will be cleared by writing a "1" to this bit.
S * |        |          |0 = No threshold control event with TK11.
S * |        |          |1 = Threshold control event occurs with TK11.
S * |[20]    |TKIF12    |TK12 Interrupt Flag
S * |        |          |This bit will be cleared by writing a "1" to this bit.
S * |        |          |0 = No threshold control event with TK12.
S * |        |          |1 = Threshold control event occurs with TK12.
S * |[21]    |TKIF13    |TK13 Interrupt Flag
S * |        |          |This bit will be cleared by writing a "1" to this bit.
S * |        |          |0 = No threshold control event with TK13.
S * |        |          |1 = Threshold control event occurs with TK13.
S * |[22]    |TKIF14    |TK14 Interrupt Flag
S * |        |          |This bit will be cleared by writing a "1" to this bit.
S * |        |          |0 = No threshold control event with TK14.
S * |        |          |1 = Threshold control event occurs with TK14.
S * |[23]    |TKIF15    |TK15 Interrupt Flag
S * |        |          |This bit will be cleared by writing a "1" to this bit.
S * |        |          |0 = No threshold control event with TK15.
S * |        |          |1 = Threshold control event occurs with TK15.
S * |[24]    |TKIF16    |TK16 Interrupt Flag
S * |        |          |This bit will be cleared by writing a "1" to this bit.
S * |        |          |0 = No threshold control event with TK16.
S * |        |          |1 = Threshold control event occurs with TK16.
S * @var TK_T::DAT0
S * Offset: 0x2C  Touch Key Data Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |TKDAT0    |TK0 Sensing Result Data (Read Only)
S * |        |          |This data is invalid if TKSEN0 (TK_CTL[0]) is "0" or TKREN0 (TK_REFCTL[0]) is "1" except SCANALL (TK_REFCTL[23]) is "1".
S * |[15:8]  |TKDAT1    |TK1 Sensing Result Data (Read Only)
S * |        |          |This data is invalid if TKSEN1 (TK_CTL[1]) is "0" or TKREN1 (TK_REFCTL[1]) is "1".
S * |[23:16] |TKDAT2    |TK2 Sensing Result Data (Read Only)
S * |        |          |This data is invalid if TKSEN2 (TK_CTL[2]) is "0" or TKREN2 (TK_REFCTL[2]) is "1".
S * |[31:24] |TKDAT3    |TK3 Sensing Result Data (Read Only)
S * |        |          |This data is invalid if TKSEN3 (TK_CTL[3]) is "0" or TKREN3 (TK_REFCTL[3]) is "1".
S * @var TK_T::DAT1
S * Offset: 0x30  Touch Key Data Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |TKDAT4    |TK0 Sensing Result Data (Read Only)
S * |        |          |This data is invalid if TKSEN4 (TK_CTL[4]) is "0" or TKREN4 (TK_REFCTL[4]) is "1".
S * |[15:8]  |TKDAT5    |TK5 Sensing Result Data (Read Only)
S * |        |          |This data is invalid if TKSEN5 (TK_CTL[5]) is "0" or TKREN5 (TK_REFCTL[5]) is "1".
S * |[23:16] |TKDAT6    |TK6 Sensing Result Data (Read Only)
S * |        |          |This data is invalid if TKSEN6 (TK_CTL[6]) is "0" or TKREN6 (TK_REFCTL[6]) is "1".
S * |[31:24] |TKDAT7    |TK7 Sensing Result Data (Read Only)
S * |        |          |This data is invalid if TKSEN7 (TK_CTL[7]) is "0" or TKREN7 (TK_REFCTL[7]) is "1".
S * @var TK_T::DAT2
S * Offset: 0x34  Touch Key Data Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |TKDAT8    |TK8 Sensing Result Data (Read Only)
S * |        |          |This data is invalid if TKSEN8 (TK_CTL[8]) is "0" or TKREN8 (TK_REFCTL[8]) is "1".
S * |[15:8]  |TKDAT9    |TK9 Sensing Result Data (Read Only)
S * |        |          |This data is invalid if TKSEN9 (TK_CTL[9]) is "0" or TKREN9 (TK_REFCTL[9]) is "1".
S * |[23:16] |TKDAT10   |TK10 Sensing Result Data (Read Only)
S * |        |          |This data is invalid if TKSEN10 (TK_CTL[10]) is "0" or TKREN10 (TK_REFCTL[10]) is "1".
S * |[31:24] |TKDAT11   |TK11 Sensing Result Data (Read Only)
S * |        |          |This data is invalid if TKSEN11 (TK_CTL[11]) is "0" or TKREN11 (TK_REFCTL[11]) is "1".
S * @var TK_T::DAT3
S * Offset: 0x38  Touch Key Data Register 3
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |TKDAT12   |TK12 Sensing Result Data (Read Only)
S * |        |          |This data is invalid if TKSEN12 (TK_CTL[12]) is "0" or TKREN12 (TK_REFCTL[12]) is "1".
S * |[15:8]  |TKDAT13   |TK13 Sensing Result Data (Read Only)
S * |        |          |This data is invalid if TKSEN13 (TK_CTL[13]) is "0" or TKREN13 (TK_REFCTL[13]) is "1".
S * |[23:16] |TKDAT14   |TK14 Sensing Result Data (Read Only)
S * |        |          |This data is invalid if TKSEN14 (TK_CTL[14]) is "0" or TKREN14 (TK_REFCTL[14]) is "1".
S * |[31:24] |TKDAT15   |TK15 Sensing Result Data (Read Only)
S * |        |          |This data is invalid if TKSEN15 (TK_CTL[15]) is "0" or TKREN15 (TK_REFCTL[15]) is "1".
S * @var TK_T::DAT4
S * Offset: 0x3C  Touch Key Data Register 4
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |TKDAT16   |TK16 Sensing Result Data (Read Only)
S * |        |          |This data is invalid if TKSEN16 (TK_CTL[16]) is "0" or TKREN16 (TK_REFCTL[16]) is "1".
S * @var TK_T::INTEN
S * Offset: 0x40  Touch Key Interrupt Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |SCTHIEN   |Touch Key Scan Complete With High/Low Threshold Control Interrupt Enable Bit
S * |        |          |0 = Key scan complete with threshold control interrupt is disable.
S * |        |          |1 = Key scan complete with threshold control interrupt is enable.
S * |[1]     |SCINTEN   |Touch Key Scan Complete Interrupt Enable
S * |        |          |Bit
S * |        |          |0 = Key scan complete without threshold control interrupt is disable.
S * |        |          |1 = Key scan complete without threshold control interrupt is enable.
S * |[31]    |THIMOD    |Touch Key Threshold Interrupt Mode Select
S * |        |          |0 = Edge trigger mode.
S * |        |          |1 = Level trigger mode.
S * @var TK_T::TH0_1
S * Offset: 0x44  Touch Key TK0/TK1 Threshold Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |LTH0      |Low Threshold Of TK0
S * |        |          |Low level for TK0 threshold control.
S * |[15:8]  |HTH0      |High Threshold Of TK0
S * |        |          |High level for TK0 threshold control.
S * |[23:16] |LTH1      |Low Threshold Of TK1
S * |        |          |Low level for TK1 threshold control.
S * |[31:24] |HTH1      |High Threshold Of TK1
S * |        |          |High level for TK1 threshold control.
S * @var TK_T::TH2_3
S * Offset: 0x48  Touch Key TK2/TK3 Threshold Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |LTH2      |Low Threshold Of TK2
S * |        |          |Low level for TK2 threshold control.
S * |[15:8]  |HTH2      |High Threshold Of TK2
S * |        |          |High level for TK2 threshold control.
S * |[23:16] |LTH3      |Low Threshold Of TK3
S * |        |          |Low level for TK3 threshold control.
S * |[31:24] |HTH3      |High Threshold Of TK3
S * |        |          |High level for TK3 threshold control.
S * @var TK_T::TH4_5
S * Offset: 0x4C  Touch Key TK4/TK5 Threshold Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |LTH4      |Low Threshold Of TK4
S * |        |          |Low level for TK4 threshold control.
S * |[15:8]  |HTH4      |High Threshold Of TK4
S * |        |          |High level for TK4 threshold control.
S * |[23:16] |LTH5      |Low Threshold Of TK5
S * |        |          |Low level for TK5 threshold control.
S * |[31:24] |HTH5      |High Threshold Of TK5
S * |        |          |High level for TK5 threshold control.
S * @var TK_T::TH6_7
S * Offset: 0x50  Touch Key TK6/TK7 Threshold Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |LTH6      |Low Threshold Of TK6
S * |        |          |Low level for TK6 threshold control.
S * |[15:8]  |HTH6      |High Threshold Of TK6
S * |        |          |High level for TK6 threshold control.
S * |[23:16] |LTH7      |Low Threshold Of TK7
S * |        |          |Low level for TK7 threshold control.
S * |[31:24] |HTH7      |High Threshold Of TK7
S * |        |          |High level for TK7 threshold control.
S * @var TK_T::TH8_9
S * Offset: 0x54  Touch Key TK8/TK9 Threshold Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |LTH8      |Low Threshold Of TK8
S * |        |          |Low level for TK8 threshold control.
S * |[15:8]  |HTH8      |High Threshold Of TK8
S * |        |          |High level for TK8 threshold control.
S * |[23:16] |LTH9      |Low Threshold Of TK9
S * |        |          |Low level for TK9 threshold control.
S * |[31:24] |HTH9      |High Threshold Of TK9
S * |        |          |High level for TK9 threshold control.
S * @var TK_T::TH10_11
S * Offset: 0x58  Touch Key TK10/TK11 Threshold Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |LTH10     |Low Threshold Of TK10
S * |        |          |Low level for TK10 threshold control.
S * |[15:8]  |HTH10     |High Threshold Of TK10
S * |        |          |High level for TK10 threshold control.
S * |[23:16] |LTH11     |Low Threshold Of TK11
S * |        |          |Low level for TK11 threshold control.
S * |[31:24] |HTH11     |High Threshold Of TK11
S * |        |          |High level for TK11 threshold control.
S * @var TK_T::TH12_13
S * Offset: 0x5C  Touch Key TK12/TK13 Threshold Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |LTH12     |Low Threshold Of TK12
S * |        |          |Low level for TK12 threshold control.
S * |[15:8]  |HTH12     |High Threshold Of TK12
S * |        |          |High level for TK12 threshold control.
S * |[23:16] |LTH13     |Low Threshold Of TK13
S * |        |          |Low level for TK13 threshold control.
S * |[31:24] |HTH13     |High Threshold Of TK13
S * |        |          |High level for TK13 threshold control.
S * @var TK_T::TH14_15
S * Offset: 0x60  Touch Key TK14/TK15 Threshold Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |LTH14     |Low Threshold Of TK14
S * |        |          |Low level for TK14 threshold control.
S * |[15:8]  |HTH14     |High Threshold Of TK14
S * |        |          |High level for TK14 threshold control.
S * |[23:16] |LTH15     |Low Threshold Of TK15
S * |        |          |Low level for TK15 threshold control.
S * |[31:24] |HTH15     |High Threshold Of TK15
S * |        |          |High level for TK15 threshold control.
S * @var TK_T::TH16
S * Offset: 0x64  Touch Key TK16 Threshold Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |LTH16     |Low Threshold Of TK16
S * |        |          |Low level for TK16 threshold control.
S * |[15:8]  |HTH16     |High Threshold Of TK16
S * |        |          |High level for TK16 threshold control.
S */
S
S    __IO uint32_t CTL;           /* Offset: 0x00  Touch Key Scan Control Register                                    */
S    __IO uint32_t REFCTL;        /* Offset: 0x04  Touch Key Reference Control Register                               */
S    __IO uint32_t CCBDAT0;       /* Offset: 0x08  Touch Key Complement Capacitor Bank Data Register 0                */
S    __IO uint32_t CCBDAT1;       /* Offset: 0x0C  Touch Key Complement Capacitor Bank Data Register 1                */
S    __IO uint32_t CCBDAT2;       /* Offset: 0x10  Touch Key Complement Capacitor Bank Data Register 2                */
S    __IO uint32_t CCBDAT3;       /* Offset: 0x14  Touch Key Complement Capacitor Bank Data Register 3                */
S    __IO uint32_t CCBDAT4;       /* Offset: 0x18  Touch Key Complement Capacitor Bank Data Register 4                */
S    __IO uint32_t IDLESEL;       /* Offset: 0x1C  Touch Key Idle State Control Register                              */
S    __IO uint32_t POLSEL;        /* Offset: 0x20  Touch Key Polarity Select Register                                 */
S    __IO uint32_t POLCTL;        /* Offset: 0x24  Touch Key Polarity Control Register                                */
S    __IO uint32_t STATUS;        /* Offset: 0x28  Touch Key Status Register                                          */
S    __I  uint32_t DAT0;          /* Offset: 0x2C  Touch Key Data Register 0                                          */
S    __I  uint32_t DAT1;          /* Offset: 0x30  Touch Key Data Register 1                                          */
S    __I  uint32_t DAT2;          /* Offset: 0x34  Touch Key Data Register 2                                          */
S    __I  uint32_t DAT3;          /* Offset: 0x38  Touch Key Data Register 3                                          */
S    __I  uint32_t DAT4;          /* Offset: 0x3C  Touch Key Data Register 4                                          */
S    __IO uint32_t INTEN;         /* Offset: 0x40  Touch Key Interrupt Enable Register                                */
S    __IO uint32_t TH0_1;         /* Offset: 0x44  Touch Key TK0/TK1 Threshold Control Register                       */
S    __IO uint32_t TH2_3;         /* Offset: 0x48  Touch Key TK2/TK3 Threshold Control Register                       */
S    __IO uint32_t TH4_5;         /* Offset: 0x4C  Touch Key TK4/TK5 Threshold Control Register                       */
S    __IO uint32_t TH6_7;         /* Offset: 0x50  Touch Key TK6/TK7 Threshold Control Register                       */
S    __IO uint32_t TH8_9;         /* Offset: 0x54  Touch Key TK8/TK9 Threshold Control Register                       */
S    __IO uint32_t TH10_11;       /* Offset: 0x58  Touch Key TK10/TK11 Threshold Control Register                     */
S    __IO uint32_t TH12_13;       /* Offset: 0x5C  Touch Key TK12/TK13 Threshold Control Register                     */
S    __IO uint32_t TH14_15;       /* Offset: 0x60  Touch Key TK14/TK15 Threshold Control Register                     */
S    __IO uint32_t TH16;          /* Offset: 0x64  Touch Key TK16 Threshold Control Register                          */
S
S} TK_T;
S
S
S
S/**
S    @addtogroup TK_CONST TK Bit Field Definition
S    Constant Definitions for TK Controller
S@{ */
S
S
S#define TK_CTL_TKSEN0_Pos                (0)                                               /*!< TK_T::CTL: TKSEN0 Position                */
S#define TK_CTL_TKSEN0_Msk                (0x1ul << TK_CTL_TKSEN0_Pos)                      /*!< TK_T::CTL: TKSEN0 Mask                    */
S
S#define TK_CTL_TKSEN1_Pos                (1)                                               /*!< TK_T::CTL: TKSEN1 Position                */
S#define TK_CTL_TKSEN1_Msk                (0x1ul << TK_CTL_TKSEN1_Pos)                      /*!< TK_T::CTL: TKSEN1 Mask                    */
S
S#define TK_CTL_TKSEN2_Pos                (2)                                               /*!< TK_T::CTL: TKSEN2 Position                */
S#define TK_CTL_TKSEN2_Msk                (0x1ul << TK_CTL_TKSEN2_Pos)                      /*!< TK_T::CTL: TKSEN2 Mask                    */
S
S#define TK_CTL_TKSEN3_Pos                (3)                                               /*!< TK_T::CTL: TKSEN3 Position                */
S#define TK_CTL_TKSEN3_Msk                (0x1ul << TK_CTL_TKSEN3_Pos)                      /*!< TK_T::CTL: TKSEN3 Mask                    */
S
S#define TK_CTL_TKSEN4_Pos                (4)                                               /*!< TK_T::CTL: TKSEN4 Position                */
S#define TK_CTL_TKSEN4_Msk                (0x1ul << TK_CTL_TKSEN4_Pos)                      /*!< TK_T::CTL: TKSEN4 Mask                    */
S
S#define TK_CTL_TKSEN5_Pos                (5)                                               /*!< TK_T::CTL: TKSEN5 Position                */
S#define TK_CTL_TKSEN5_Msk                (0x1ul << TK_CTL_TKSEN5_Pos)                      /*!< TK_T::CTL: TKSEN5 Mask                    */
S
S#define TK_CTL_TKSEN6_Pos                (6)                                               /*!< TK_T::CTL: TKSEN6 Position                */
S#define TK_CTL_TKSEN6_Msk                (0x1ul << TK_CTL_TKSEN6_Pos)                      /*!< TK_T::CTL: TKSEN6 Mask                    */
S
S#define TK_CTL_TKSEN7_Pos                (7)                                               /*!< TK_T::CTL: TKSEN7 Position                */
S#define TK_CTL_TKSEN7_Msk                (0x1ul << TK_CTL_TKSEN7_Pos)                      /*!< TK_T::CTL: TKSEN7 Mask                    */
S
S#define TK_CTL_TKSEN8_Pos                (8)                                               /*!< TK_T::CTL: TKSEN8 Position                */
S#define TK_CTL_TKSEN8_Msk                (0x1ul << TK_CTL_TKSEN8_Pos)                      /*!< TK_T::CTL: TKSEN8 Mask                    */
S
S#define TK_CTL_TKSEN9_Pos                (9)                                               /*!< TK_T::CTL: TKSEN9 Position                */
S#define TK_CTL_TKSEN9_Msk                (0x1ul << TK_CTL_TKSEN9_Pos)                      /*!< TK_T::CTL: TKSEN9 Mask                    */
S
S#define TK_CTL_TKSEN10_Pos               (10)                                              /*!< TK_T::CTL: TKSEN10 Position               */
S#define TK_CTL_TKSEN10_Msk               (0x1ul << TK_CTL_TKSEN10_Pos)                     /*!< TK_T::CTL: TKSEN10 Mask                   */
S
S#define TK_CTL_TKSEN11_Pos               (11)                                              /*!< TK_T::CTL: TKSEN11 Position               */
S#define TK_CTL_TKSEN11_Msk               (0x1ul << TK_CTL_TKSEN11_Pos)                     /*!< TK_T::CTL: TKSEN11 Mask                   */
S
S#define TK_CTL_TKSEN12_Pos               (12)                                              /*!< TK_T::CTL: TKSEN12 Position               */
S#define TK_CTL_TKSEN12_Msk               (0x1ul << TK_CTL_TKSEN12_Pos)                     /*!< TK_T::CTL: TKSEN12 Mask                   */
S
S#define TK_CTL_TKSEN13_Pos               (13)                                              /*!< TK_T::CTL: TKSEN13 Position               */
S#define TK_CTL_TKSEN13_Msk               (0x1ul << TK_CTL_TKSEN13_Pos)                     /*!< TK_T::CTL: TKSEN13 Mask                   */
S
S#define TK_CTL_TKSEN14_Pos               (14)                                              /*!< TK_T::CTL: TKSEN14 Position               */
S#define TK_CTL_TKSEN14_Msk               (0x1ul << TK_CTL_TKSEN14_Pos)                     /*!< TK_T::CTL: TKSEN14 Mask                   */
S
S#define TK_CTL_TKSEN15_Pos               (15)                                              /*!< TK_T::CTL: TKSEN15 Position               */
S#define TK_CTL_TKSEN15_Msk               (0x1ul << TK_CTL_TKSEN15_Pos)                     /*!< TK_T::CTL: TKSEN15 Mask                   */
S
S#define TK_CTL_TKSEN16_Pos               (16)                                              /*!< TK_T::CTL: TKSEN16 Position               */
S#define TK_CTL_TKSEN16_Msk               (0x1ul << TK_CTL_TKSEN16_Pos)                     /*!< TK_T::CTL: TKSEN16 Mask                   */
S
S#define TK_CTL_AVCCHSEL_Pos              (20)                                              /*!< TK_T::CTL: AVCCHSEL Position              */
S#define TK_CTL_AVCCHSEL_Msk              (0x7ul << TK_CTL_AVCCHSEL_Pos)                    /*!< TK_T::CTL: AVCCHSEL Mask                  */
S
S#define TK_CTL_SCAN_Pos                  (24)                                              /*!< TK_T::CTL: SCAN Position                  */
S#define TK_CTL_SCAN_Msk                  (0x1ul << TK_CTL_SCAN_Pos)                        /*!< TK_T::CTL: SCAN Mask                      */
S
S#define TK_CTL_TMRTRGEN_Pos              (25)                                              /*!< TK_T::CTL: TMRTRGEN Position              */
S#define TK_CTL_TMRTRGEN_Msk              (0x1ul << TK_CTL_TMRTRGEN_Pos)                    /*!< TK_T::CTL: TMRTRGEN Mask                  */
S
S#define TK_CTL_TKEN_Pos                  (31)                                              /*!< TK_T::CTL: TKEN Position                  */
S#define TK_CTL_TKEN_Msk                  (0x1ul << TK_CTL_TKEN_Pos)                        /*!< TK_T::CTL: TKEN Mask                      */
S
S#define TK_REFCTL_TKREN0_Pos             (0)                                               /*!< TK_T::REFCTL: TKREN0 Position             */
S#define TK_REFCTL_TKREN0_Msk             (0x1ul << TK_REFCTL_TKREN0_Pos)                   /*!< TK_T::REFCTL: TKREN0 Mask                 */
S
S#define TK_REFCTL_TKREN1_Pos             (1)                                               /*!< TK_T::REFCTL: TKREN1 Position             */
S#define TK_REFCTL_TKREN1_Msk             (0x1ul << TK_REFCTL_TKREN1_Pos)                   /*!< TK_T::REFCTL: TKREN1 Mask                 */
S
S#define TK_REFCTL_TKREN2_Pos             (2)                                               /*!< TK_T::REFCTL: TKREN2 Position             */
S#define TK_REFCTL_TKREN2_Msk             (0x1ul << TK_REFCTL_TKREN2_Pos)                   /*!< TK_T::REFCTL: TKREN2 Mask                 */
S
S#define TK_REFCTL_TKREN3_Pos             (3)                                               /*!< TK_T::REFCTL: TKREN3 Position             */
S#define TK_REFCTL_TKREN3_Msk             (0x1ul << TK_REFCTL_TKREN3_Pos)                   /*!< TK_T::REFCTL: TKREN3 Mask                 */
S
S#define TK_REFCTL_TKREN4_Pos             (4)                                               /*!< TK_T::REFCTL: TKREN4 Position             */
S#define TK_REFCTL_TKREN4_Msk             (0x1ul << TK_REFCTL_TKREN4_Pos)                   /*!< TK_T::REFCTL: TKREN4 Mask                 */
S
S#define TK_REFCTL_TKREN5_Pos             (5)                                               /*!< TK_T::REFCTL: TKREN5 Position             */
S#define TK_REFCTL_TKREN5_Msk             (0x1ul << TK_REFCTL_TKREN5_Pos)                   /*!< TK_T::REFCTL: TKREN5 Mask                 */
S
S#define TK_REFCTL_TKREN6_Pos             (6)                                               /*!< TK_T::REFCTL: TKREN6 Position             */
S#define TK_REFCTL_TKREN6_Msk             (0x1ul << TK_REFCTL_TKREN6_Pos)                   /*!< TK_T::REFCTL: TKREN6 Mask                 */
S
S#define TK_REFCTL_TKREN7_Pos             (7)                                               /*!< TK_T::REFCTL: TKREN7 Position             */
S#define TK_REFCTL_TKREN7_Msk             (0x1ul << TK_REFCTL_TKREN7_Pos)                   /*!< TK_T::REFCTL: TKREN7 Mask                 */
S
S#define TK_REFCTL_TKREN8_Pos             (8)                                               /*!< TK_T::REFCTL: TKREN8 Position             */
S#define TK_REFCTL_TKREN8_Msk             (0x1ul << TK_REFCTL_TKREN8_Pos)                   /*!< TK_T::REFCTL: TKREN8 Mask                 */
S
S#define TK_REFCTL_TKREN9_Pos             (9)                                               /*!< TK_T::REFCTL: TKREN9 Position             */
S#define TK_REFCTL_TKREN9_Msk             (0x1ul << TK_REFCTL_TKREN9_Pos)                   /*!< TK_T::REFCTL: TKREN9 Mask                 */
S
S#define TK_REFCTL_TKREN10_Pos            (10)                                              /*!< TK_T::REFCTL: TKREN10 Position            */
S#define TK_REFCTL_TKREN10_Msk            (0x1ul << TK_REFCTL_TKREN10_Pos)                  /*!< TK_T::REFCTL: TKREN10 Mask                */
S
S#define TK_REFCTL_TKREN11_Pos            (11)                                              /*!< TK_T::REFCTL: TKREN11 Position            */
S#define TK_REFCTL_TKREN11_Msk            (0x1ul << TK_REFCTL_TKREN11_Pos)                  /*!< TK_T::REFCTL: TKREN11 Mask                */
S
S#define TK_REFCTL_TKREN12_Pos            (12)                                              /*!< TK_T::REFCTL: TKREN12 Position            */
S#define TK_REFCTL_TKREN12_Msk            (0x1ul << TK_REFCTL_TKREN12_Pos)                  /*!< TK_T::REFCTL: TKREN12 Mask                */
S
S#define TK_REFCTL_TKREN13_Pos            (13)                                              /*!< TK_T::REFCTL: TKREN13 Position            */
S#define TK_REFCTL_TKREN13_Msk            (0x1ul << TK_REFCTL_TKREN13_Pos)                  /*!< TK_T::REFCTL: TKREN13 Mask                */
S
S#define TK_REFCTL_TKREN14_Pos            (14)                                              /*!< TK_T::REFCTL: TKREN14 Position            */
S#define TK_REFCTL_TKREN14_Msk            (0x1ul << TK_REFCTL_TKREN14_Pos)                  /*!< TK_T::REFCTL: TKREN14 Mask                */
S
S#define TK_REFCTL_TKREN15_Pos            (15)                                              /*!< TK_T::REFCTL: TKREN15 Position            */
S#define TK_REFCTL_TKREN15_Msk            (0x1ul << TK_REFCTL_TKREN15_Pos)                  /*!< TK_T::REFCTL: TKREN15 Mask                */
S
S#define TK_REFCTL_TKREN16_Pos            (16)                                              /*!< TK_T::REFCTL: TKREN16 Position            */
S#define TK_REFCTL_TKREN16_Msk            (0x1ul << TK_REFCTL_TKREN16_Pos)                  /*!< TK_T::REFCTL: TKREN16 Mask                */
S
S#define TK_REFCTL_SCANALL_Pos            (23)                                              /*!< TK_T::REFCTL: SCANALL Position            */
S#define TK_REFCTL_SCANALL_Msk            (0x1ul << TK_REFCTL_SCANALL_Pos)                  /*!< TK_T::REFCTL: SCANALL Mask                */
S
S#define TK_REFCTL_SENTCTL_Pos            (24)                                              /*!< TK_T::REFCTL: SENTCTL Position            */
S#define TK_REFCTL_SENTCTL_Msk            (0x3ul << TK_REFCTL_SENTCTL_Pos)                  /*!< TK_T::REFCTL: SENTCTL Mask                */
S
S#define TK_REFCTL_SENPTCTL_Pos           (28)                                              /*!< TK_T::REFCTL: SENPTCTL Position           */
S#define TK_REFCTL_SENPTCTL_Msk           (0x3ul << TK_REFCTL_SENPTCTL_Pos)                 /*!< TK_T::REFCTL: SENPTCTL Mask               */
S
S#define TK_CCBDAT0_CCBDAT0_Pos           (0)                                               /*!< TK_T::CCBDAT0: CCBDAT0 Position           */
S#define TK_CCBDAT0_CCBDAT0_Msk           (0xfful << TK_CCBDAT0_CCBDAT0_Pos)                /*!< TK_T::CCBDAT0: CCBDAT0 Mask               */
S
S#define TK_CCBDAT0_CCBDAT1_Pos           (8)                                               /*!< TK_T::CCBDAT0: CCBDAT1 Position           */
S#define TK_CCBDAT0_CCBDAT1_Msk           (0xfful << TK_CCBDAT0_CCBDAT1_Pos)                /*!< TK_T::CCBDAT0: CCBDAT1 Mask               */
S
S#define TK_CCBDAT0_CCBDAT2_Pos           (16)                                              /*!< TK_T::CCBDAT0: CCBDAT2 Position           */
S#define TK_CCBDAT0_CCBDAT2_Msk           (0xfful << TK_CCBDAT0_CCBDAT2_Pos)                /*!< TK_T::CCBDAT0: CCBDAT2 Mask               */
S
S#define TK_CCBDAT0_CCBDAT3_Pos           (24)                                              /*!< TK_T::CCBDAT0: CCBDAT3 Position           */
S#define TK_CCBDAT0_CCBDAT3_Msk           (0xfful << TK_CCBDAT0_CCBDAT3_Pos)                /*!< TK_T::CCBDAT0: CCBDAT3 Mask               */
S
S#define TK_CCBDAT1_CCBDAT4_Pos           (0)                                               /*!< TK_T::CCBDAT1: CCBDAT4 Position           */
S#define TK_CCBDAT1_CCBDAT4_Msk           (0xfful << TK_CCBDAT1_CCBDAT4_Pos)                /*!< TK_T::CCBDAT1: CCBDAT4 Mask               */
S
S#define TK_CCBDAT1_CCBDAT5_Pos           (8)                                               /*!< TK_T::CCBDAT1: CCBDAT5 Position           */
S#define TK_CCBDAT1_CCBDAT5_Msk           (0xfful << TK_CCBDAT1_CCBDAT5_Pos)                /*!< TK_T::CCBDAT1: CCBDAT5 Mask               */
S
S#define TK_CCBDAT1_CCBDAT6_Pos           (16)                                              /*!< TK_T::CCBDAT1: CCBDAT6 Position           */
S#define TK_CCBDAT1_CCBDAT6_Msk           (0xfful << TK_CCBDAT1_CCBDAT6_Pos)                /*!< TK_T::CCBDAT1: CCBDAT6 Mask               */
S
S#define TK_CCBDAT1_CCBDAT7_Pos           (24)                                              /*!< TK_T::CCBDAT1: CCBDAT7 Position           */
S#define TK_CCBDAT1_CCBDAT7_Msk           (0xfful << TK_CCBDAT1_CCBDAT7_Pos)                /*!< TK_T::CCBDAT1: CCBDAT7 Mask               */
S
S#define TK_CCBDAT2_CCBDAT8_Pos           (0)                                               /*!< TK_T::CCBDAT2: CCBDAT8 Position           */
S#define TK_CCBDAT2_CCBDAT8_Msk           (0xfful << TK_CCBDAT2_CCBDAT8_Pos)                /*!< TK_T::CCBDAT2: CCBDAT8 Mask               */
S
S#define TK_CCBDAT2_CCBDAT9_Pos           (8)                                               /*!< TK_T::CCBDAT2: CCBDAT9 Position           */
S#define TK_CCBDAT2_CCBDAT9_Msk           (0xfful << TK_CCBDAT2_CCBDAT9_Pos)                /*!< TK_T::CCBDAT2: CCBDAT9 Mask               */
S
S#define TK_CCBDAT2_CCBDAT10_Pos          (16)                                              /*!< TK_T::CCBDAT2: CCBDAT10 Position          */
S#define TK_CCBDAT2_CCBDAT10_Msk          (0xfful << TK_CCBDAT2_CCBDAT10_Pos)               /*!< TK_T::CCBDAT2: CCBDAT10 Mask              */
S
S#define TK_CCBDAT2_CCBDAT11_Pos          (24)                                              /*!< TK_T::CCBDAT2: CCBDAT11 Position          */
S#define TK_CCBDAT2_CCBDAT11_Msk          (0xfful << TK_CCBDAT2_CCBDAT11_Pos)               /*!< TK_T::CCBDAT2: CCBDAT11 Mask              */
S
S#define TK_CCBDAT3_CCBDAT12_Pos          (0)                                               /*!< TK_T::CCBDAT3: CCBDAT12 Position          */
S#define TK_CCBDAT3_CCBDAT12_Msk          (0xfful << TK_CCBDAT3_CCBDAT12_Pos)               /*!< TK_T::CCBDAT3: CCBDAT12 Mask              */
S
S#define TK_CCBDAT3_CCBDAT13_Pos          (8)                                               /*!< TK_T::CCBDAT3: CCBDAT13 Position          */
S#define TK_CCBDAT3_CCBDAT13_Msk          (0xfful << TK_CCBDAT3_CCBDAT13_Pos)               /*!< TK_T::CCBDAT3: CCBDAT13 Mask              */
S
S#define TK_CCBDAT3_CCBDAT14_Pos          (16)                                              /*!< TK_T::CCBDAT3: CCBDAT14 Position          */
S#define TK_CCBDAT3_CCBDAT14_Msk          (0xfful << TK_CCBDAT3_CCBDAT14_Pos)               /*!< TK_T::CCBDAT3: CCBDAT14 Mask              */
S
S#define TK_CCBDAT3_CCBDAT15_Pos          (24)                                              /*!< TK_T::CCBDAT3: CCBDAT15 Position          */
S#define TK_CCBDAT3_CCBDAT15_Msk          (0xfful << TK_CCBDAT3_CCBDAT15_Pos)               /*!< TK_T::CCBDAT3: CCBDAT15 Mask              */
S
S#define TK_CCBDAT4_CCBDAT16_Pos          (0)                                               /*!< TK_T::CCBDAT4: CCBDAT16 Position          */
S#define TK_CCBDAT4_CCBDAT16_Msk          (0xfful << TK_CCBDAT4_CCBDAT16_Pos)               /*!< TK_T::CCBDAT4: CCBDAT16 Mask              */
S
S#define TK_CCBDAT4_REFCBDAT_Pos          (24)                                              /*!< TK_T::CCBDAT4: REFCBDAT Position          */
S#define TK_CCBDAT4_REFCBDAT_Msk          (0xfful << TK_CCBDAT4_REFCBDAT_Pos)               /*!< TK_T::CCBDAT4: REFCBDAT Mask              */
S
S#define TK_IDLESEL_IDLS_Pos              (0)                                               /*!< TK_T::IDLESEL: IDLS Position              */
S#define TK_IDLESEL_IDLS_Msk              (0xfffffffful << TK_IDLESEL_IDLS_Pos)             /*!< TK_T::IDLESEL: IDLS Mask                  */
S
S#define TK_IDLESEL_IDLSn_Pos             (0)                                               /*!< TK_T::IDLESEL: IDLSn Position             */
S#define TK_IDLESEL_IDLSn_Msk             (0x3ul << TK_IDLESEL_IDLSn_Pos)                   /*!< TK_T::IDLESEL: IDLSn Mask                 */
S
S#define TK_POLSEL_POLSEL_Pos             (0)                                               /*!< TK_T::POLSEL: POLSEL Position             */
S#define TK_POLSEL_POLSEL_Msk             (0xfffffffful << TK_POLSEL_POLSEL_Pos)            /*!< TK_T::POLSEL: POLSEL Mask                 */
S
S#define TK_POLSEL_POLSELn_Pos            (0)                                               /*!< TK_T::POLSEL: POLSELn Position            */
S#define TK_POLSEL_POLSELn_Msk            (0x3ul << TK_POLSEL_POLSELn_Pos)                  /*!< TK_T::POLSEL: POLSELn Mask                */
S
S#define TK_POLCTL_IDLS16_Pos             (0)                                               /*!< TK_T::POLCTL: IDLS16 Position             */
S#define TK_POLCTL_IDLS16_Msk             (0x3ul << TK_POLCTL_IDLS16_Pos)                   /*!< TK_T::POLCTL: IDLS16 Mask                 */
S
S#define TK_POLCTL_POLSEL16_Pos           (2)                                               /*!< TK_T::POLCTL: POLSEL16 Position           */
S#define TK_POLCTL_POLSEL16_Msk           (0x3ul << TK_POLCTL_POLSEL16_Pos)                 /*!< TK_T::POLCTL: POLSEL16 Mask               */
S
S#define TK_POLCTL_CBPOLSEL_Pos           (4)                                               /*!< TK_T::POLCTL: CBPOLSEL Position           */
S#define TK_POLCTL_CBPOLSEL_Msk           (0x3ul << TK_POLCTL_CBPOLSEL_Pos)                 /*!< TK_T::POLCTL: CBPOLSEL Mask               */
S
S#define TK_POLCTL_POLEN0_Pos             (8)                                               /*!< TK_T::POLCTL: POLEN0 Position             */
S#define TK_POLCTL_POLEN0_Msk             (0x1ul << TK_POLCTL_POLEN0_Pos)                   /*!< TK_T::POLCTL: POLEN0 Mask                 */
S
S#define TK_POLCTL_POLEN1_Pos             (9)                                               /*!< TK_T::POLCTL: POLEN1 Position             */
S#define TK_POLCTL_POLEN1_Msk             (0x1ul << TK_POLCTL_POLEN1_Pos)                   /*!< TK_T::POLCTL: POLEN1 Mask                 */
S
S#define TK_POLCTL_POLEN2_Pos             (10)                                              /*!< TK_T::POLCTL: POLEN2 Position             */
S#define TK_POLCTL_POLEN2_Msk             (0x1ul << TK_POLCTL_POLEN2_Pos)                   /*!< TK_T::POLCTL: POLEN2 Mask                 */
S
S#define TK_POLCTL_POLEN3_Pos             (11)                                              /*!< TK_T::POLCTL: POLEN3 Position             */
S#define TK_POLCTL_POLEN3_Msk             (0x1ul << TK_POLCTL_POLEN3_Pos)                   /*!< TK_T::POLCTL: POLEN3 Mask                 */
S
S#define TK_POLCTL_POLEN4_Pos             (12)                                              /*!< TK_T::POLCTL: POLEN4 Position             */
S#define TK_POLCTL_POLEN4_Msk             (0x1ul << TK_POLCTL_POLEN4_Pos)                   /*!< TK_T::POLCTL: POLEN4 Mask                 */
S
S#define TK_POLCTL_POLEN5_Pos             (13)                                              /*!< TK_T::POLCTL: POLEN5 Position             */
S#define TK_POLCTL_POLEN5_Msk             (0x1ul << TK_POLCTL_POLEN5_Pos)                   /*!< TK_T::POLCTL: POLEN5 Mask                 */
S
S#define TK_POLCTL_POLEN6_Pos             (14)                                              /*!< TK_T::POLCTL: POLEN6 Position             */
S#define TK_POLCTL_POLEN6_Msk             (0x1ul << TK_POLCTL_POLEN6_Pos)                   /*!< TK_T::POLCTL: POLEN6 Mask                 */
S
S#define TK_POLCTL_POLEN7_Pos             (15)                                              /*!< TK_T::POLCTL: POLEN7 Position             */
S#define TK_POLCTL_POLEN7_Msk             (0x1ul << TK_POLCTL_POLEN7_Pos)                   /*!< TK_T::POLCTL: POLEN7 Mask                 */
S
S#define TK_POLCTL_POLEN8_Pos             (16)                                              /*!< TK_T::POLCTL: POLEN8 Position             */
S#define TK_POLCTL_POLEN8_Msk             (0x1ul << TK_POLCTL_POLEN8_Pos)                   /*!< TK_T::POLCTL: POLEN8 Mask                 */
S
S#define TK_POLCTL_POLEN9_Pos             (17)                                              /*!< TK_T::POLCTL: POLEN9 Position             */
S#define TK_POLCTL_POLEN9_Msk             (0x1ul << TK_POLCTL_POLEN9_Pos)                   /*!< TK_T::POLCTL: POLEN9 Mask                 */
S
S#define TK_POLCTL_POLEN10_Pos            (18)                                              /*!< TK_T::POLCTL: POLEN10 Position            */
S#define TK_POLCTL_POLEN10_Msk            (0x1ul << TK_POLCTL_POLEN10_Pos)                  /*!< TK_T::POLCTL: POLEN10 Mask                */
S
S#define TK_POLCTL_POLEN11_Pos            (19)                                              /*!< TK_T::POLCTL: POLEN11 Position            */
S#define TK_POLCTL_POLEN11_Msk            (0x1ul << TK_POLCTL_POLEN11_Pos)                  /*!< TK_T::POLCTL: POLEN11 Mask                */
S
S#define TK_POLCTL_POLEN12_Pos            (20)                                              /*!< TK_T::POLCTL: POLEN12 Position            */
S#define TK_POLCTL_POLEN12_Msk            (0x1ul << TK_POLCTL_POLEN12_Pos)                  /*!< TK_T::POLCTL: POLEN12 Mask                */
S
S#define TK_POLCTL_POLEN13_Pos            (21)                                              /*!< TK_T::POLCTL: POLEN13 Position            */
S#define TK_POLCTL_POLEN13_Msk            (0x1ul << TK_POLCTL_POLEN13_Pos)                  /*!< TK_T::POLCTL: POLEN13 Mask                */
S
S#define TK_POLCTL_POLEN14_Pos            (22)                                              /*!< TK_T::POLCTL: POLEN14 Position            */
S#define TK_POLCTL_POLEN14_Msk            (0x1ul << TK_POLCTL_POLEN14_Pos)                  /*!< TK_T::POLCTL: POLEN14 Mask                */
S
S#define TK_POLCTL_POLEN15_Pos            (23)                                              /*!< TK_T::POLCTL: POLEN15 Position            */
S#define TK_POLCTL_POLEN15_Msk            (0x1ul << TK_POLCTL_POLEN15_Pos)                  /*!< TK_T::POLCTL: POLEN15 Mask                */
S
S#define TK_POLCTL_POLEN16_Pos            (24)                                              /*!< TK_T::POLCTL: POLEN16 Position            */
S#define TK_POLCTL_POLEN16_Msk            (0x1ul << TK_POLCTL_POLEN16_Pos)                  /*!< TK_T::POLCTL: POLEN16 Mask                */
S
S#define TK_POLCTL_SPOTINIT_Pos           (31)                                              /*!< TK_T::POLCTL: SPOTINIT Position           */
S#define TK_POLCTL_SPOTINIT_Msk           (0x1ul << TK_POLCTL_SPOTINIT_Pos)                 /*!< TK_T::POLCTL: SPOTINIT Mask               */
S
S#define TK_STATUS_BUSY_Pos               (0)                                               /*!< TK_T::STATUS: BUSY Position               */
S#define TK_STATUS_BUSY_Msk               (0x1ul << TK_STATUS_BUSY_Pos)                     /*!< TK_T::STATUS: BUSY Mask                   */
S
S#define TK_STATUS_SCIF_Pos               (1)                                               /*!< TK_T::STATUS: SCIF Position               */
S#define TK_STATUS_SCIF_Msk               (0x1ul << TK_STATUS_SCIF_Pos)                     /*!< TK_T::STATUS: SCIF Mask                   */
S
S#define TK_STATUS_TKIF0_Pos              (8)                                               /*!< TK_T::STATUS: TKIF0 Position              */
S#define TK_STATUS_TKIF0_Msk              (0x1ul << TK_STATUS_TKIF0_Pos)                    /*!< TK_T::STATUS: TKIF0 Mask                  */
S
S#define TK_STATUS_TKIF1_Pos              (9)                                               /*!< TK_T::STATUS: TKIF1 Position              */
S#define TK_STATUS_TKIF1_Msk              (0x1ul << TK_STATUS_TKIF1_Pos)                    /*!< TK_T::STATUS: TKIF1 Mask                  */
S
S#define TK_STATUS_TKIF2_Pos              (10)                                              /*!< TK_T::STATUS: TKIF2 Position              */
S#define TK_STATUS_TKIF2_Msk              (0x1ul << TK_STATUS_TKIF2_Pos)                    /*!< TK_T::STATUS: TKIF2 Mask                  */
S
S#define TK_STATUS_TKIF3_Pos              (11)                                              /*!< TK_T::STATUS: TKIF3 Position              */
S#define TK_STATUS_TKIF3_Msk              (0x1ul << TK_STATUS_TKIF3_Pos)                    /*!< TK_T::STATUS: TKIF3 Mask                  */
S
S#define TK_STATUS_TKIF4_Pos              (12)                                              /*!< TK_T::STATUS: TKIF4 Position              */
S#define TK_STATUS_TKIF4_Msk              (0x1ul << TK_STATUS_TKIF4_Pos)                    /*!< TK_T::STATUS: TKIF4 Mask                  */
S
S#define TK_STATUS_TKIF5_Pos              (13)                                              /*!< TK_T::STATUS: TKIF5 Position              */
S#define TK_STATUS_TKIF5_Msk              (0x1ul << TK_STATUS_TKIF5_Pos)                    /*!< TK_T::STATUS: TKIF5 Mask                  */
S
S#define TK_STATUS_TKIF6_Pos              (14)                                              /*!< TK_T::STATUS: TKIF6 Position              */
S#define TK_STATUS_TKIF6_Msk              (0x1ul << TK_STATUS_TKIF6_Pos)                    /*!< TK_T::STATUS: TKIF6 Mask                  */
S
S#define TK_STATUS_TKIF7_Pos              (15)                                              /*!< TK_T::STATUS: TKIF7 Position              */
S#define TK_STATUS_TKIF7_Msk              (0x1ul << TK_STATUS_TKIF7_Pos)                    /*!< TK_T::STATUS: TKIF7 Mask                  */
S
S#define TK_STATUS_TKIF8_Pos              (16)                                              /*!< TK_T::STATUS: TKIF8 Position              */
S#define TK_STATUS_TKIF8_Msk              (0x1ul << TK_STATUS_TKIF8_Pos)                    /*!< TK_T::STATUS: TKIF8 Mask                  */
S
S#define TK_STATUS_TKIF9_Pos              (17)                                              /*!< TK_T::STATUS: TKIF9 Position              */
S#define TK_STATUS_TKIF9_Msk              (0x1ul << TK_STATUS_TKIF9_Pos)                    /*!< TK_T::STATUS: TKIF9 Mask                  */
S
S#define TK_STATUS_TKIF10_Pos             (18)                                              /*!< TK_T::STATUS: TKIF10 Position             */
S#define TK_STATUS_TKIF10_Msk             (0x1ul << TK_STATUS_TKIF10_Pos)                   /*!< TK_T::STATUS: TKIF10 Mask                 */
S
S#define TK_STATUS_TKIF11_Pos             (19)                                              /*!< TK_T::STATUS: TKIF11 Position             */
S#define TK_STATUS_TKIF11_Msk             (0x1ul << TK_STATUS_TKIF11_Pos)                   /*!< TK_T::STATUS: TKIF11 Mask                 */
S
S#define TK_STATUS_TKIF12_Pos             (20)                                              /*!< TK_T::STATUS: TKIF12 Position             */
S#define TK_STATUS_TKIF12_Msk             (0x1ul << TK_STATUS_TKIF12_Pos)                   /*!< TK_T::STATUS: TKIF12 Mask                 */
S
S#define TK_STATUS_TKIF13_Pos             (21)                                              /*!< TK_T::STATUS: TKIF13 Position             */
S#define TK_STATUS_TKIF13_Msk             (0x1ul << TK_STATUS_TKIF13_Pos)                   /*!< TK_T::STATUS: TKIF13 Mask                 */
S
S#define TK_STATUS_TKIF14_Pos             (22)                                              /*!< TK_T::STATUS: TKIF14 Position             */
S#define TK_STATUS_TKIF14_Msk             (0x1ul << TK_STATUS_TKIF14_Pos)                   /*!< TK_T::STATUS: TKIF14 Mask                 */
S
S#define TK_STATUS_TKIF15_Pos             (23)                                              /*!< TK_T::STATUS: TKIF15 Position             */
S#define TK_STATUS_TKIF15_Msk             (0x1ul << TK_STATUS_TKIF15_Pos)                   /*!< TK_T::STATUS: TKIF15 Mask                 */
S
S#define TK_STATUS_TKIF16_Pos             (24)                                              /*!< TK_T::STATUS: TKIF16 Position             */
S#define TK_STATUS_TKIF16_Msk             (0x1ul << TK_STATUS_TKIF16_Pos)                   /*!< TK_T::STATUS: TKIF16 Mask                 */
S
S#define TK_DAT0_TKDAT0_Pos               (0)                                               /*!< TK_T::DAT0: TKDAT0 Position               */
S#define TK_DAT0_TKDAT0_Msk               (0xfful << TK_DAT0_TKDAT0_Pos)                    /*!< TK_T::DAT0: TKDAT0 Mask                   */
S
S#define TK_DAT0_TKDAT1_Pos               (8)                                               /*!< TK_T::DAT0: TKDAT1 Position               */
S#define TK_DAT0_TKDAT1_Msk               (0xfful << TK_DAT0_TKDAT1_Pos)                    /*!< TK_T::DAT0: TKDAT1 Mask                   */
S
S#define TK_DAT0_TKDAT2_Pos               (16)                                              /*!< TK_T::DAT0: TKDAT2 Position               */
S#define TK_DAT0_TKDAT2_Msk               (0xfful << TK_DAT0_TKDAT2_Pos)                    /*!< TK_T::DAT0: TKDAT2 Mask                   */
S
S#define TK_DAT0_TKDAT3_Pos               (24)                                              /*!< TK_T::DAT0: TKDAT3 Position               */
S#define TK_DAT0_TKDAT3_Msk               (0xfful << TK_DAT0_TKDAT3_Pos)                    /*!< TK_T::DAT0: TKDAT3 Mask                   */
S
S#define TK_DAT1_TKDAT4_Pos               (0)                                               /*!< TK_T::DAT1: TKDAT4 Position               */
S#define TK_DAT1_TKDAT4_Msk               (0xfful << TK_DAT1_TKDAT4_Pos)                    /*!< TK_T::DAT1: TKDAT4 Mask                   */
S
S#define TK_DAT1_TKDAT5_Pos               (8)                                               /*!< TK_T::DAT1: TKDAT5 Position               */
S#define TK_DAT1_TKDAT5_Msk               (0xfful << TK_DAT1_TKDAT5_Pos)                    /*!< TK_T::DAT1: TKDAT5 Mask                   */
S
S#define TK_DAT1_TKDAT6_Pos               (16)                                              /*!< TK_T::DAT1: TKDAT6 Position               */
S#define TK_DAT1_TKDAT6_Msk               (0xfful << TK_DAT1_TKDAT6_Pos)                    /*!< TK_T::DAT1: TKDAT6 Mask                   */
S
S#define TK_DAT1_TKDAT7_Pos               (24)                                              /*!< TK_T::DAT1: TKDAT7 Position               */
S#define TK_DAT1_TKDAT7_Msk               (0xfful << TK_DAT1_TKDAT7_Pos)                    /*!< TK_T::DAT1: TKDAT7 Mask                   */
S
S#define TK_DAT2_TKDAT8_Pos               (0)                                               /*!< TK_T::DAT2: TKDAT8 Position               */
S#define TK_DAT2_TKDAT8_Msk               (0xfful << TK_DAT2_TKDAT8_Pos)                    /*!< TK_T::DAT2: TKDAT8 Mask                   */
S
S#define TK_DAT2_TKDAT9_Pos               (8)                                               /*!< TK_T::DAT2: TKDAT9 Position               */
S#define TK_DAT2_TKDAT9_Msk               (0xfful << TK_DAT2_TKDAT9_Pos)                    /*!< TK_T::DAT2: TKDAT9 Mask                   */
S
S#define TK_DAT2_TKDAT10_Pos              (16)                                              /*!< TK_T::DAT2: TKDAT10 Position              */
S#define TK_DAT2_TKDAT10_Msk              (0xfful << TK_DAT2_TKDAT10_Pos)                   /*!< TK_T::DAT2: TKDAT10 Mask                  */
S
S#define TK_DAT2_TKDAT11_Pos              (24)                                              /*!< TK_T::DAT2: TKDAT11 Position              */
S#define TK_DAT2_TKDAT11_Msk              (0xfful << TK_DAT2_TKDAT11_Pos)                   /*!< TK_T::DAT2: TKDAT11 Mask                  */
S
S#define TK_DAT3_TKDAT12_Pos              (0)                                               /*!< TK_T::DAT3: TKDAT12 Position              */
S#define TK_DAT3_TKDAT12_Msk              (0xfful << TK_DAT3_TKDAT12_Pos)                   /*!< TK_T::DAT3: TKDAT12 Mask                  */
S
S#define TK_DAT3_TKDAT13_Pos              (8)                                               /*!< TK_T::DAT3: TKDAT13 Position              */
S#define TK_DAT3_TKDAT13_Msk              (0xfful << TK_DAT3_TKDAT13_Pos)                   /*!< TK_T::DAT3: TKDAT13 Mask                  */
S
S#define TK_DAT3_TKDAT14_Pos              (16)                                              /*!< TK_T::DAT3: TKDAT14 Position              */
S#define TK_DAT3_TKDAT14_Msk              (0xfful << TK_DAT3_TKDAT14_Pos)                   /*!< TK_T::DAT3: TKDAT14 Mask                  */
S
S#define TK_DAT3_TKDAT15_Pos              (24)                                              /*!< TK_T::DAT3: TKDAT15 Position              */
S#define TK_DAT3_TKDAT15_Msk              (0xfful << TK_DAT3_TKDAT15_Pos)                   /*!< TK_T::DAT3: TKDAT15 Mask                  */
S
S#define TK_DAT4_TKDAT16_Pos              (0)                                               /*!< TK_T::DAT4: TKDAT16 Position              */
S#define TK_DAT4_TKDAT16_Msk              (0xfful << TK_DAT4_TKDAT16_Pos)                   /*!< TK_T::DAT4: TKDAT16 Mask                  */
S
S#define TK_INTEN_SCTHIEN_Pos             (0)                                               /*!< TK_T::INTEN: SCTHIEN Position             */
S#define TK_INTEN_SCTHIEN_Msk             (0x1ul << TK_INTEN_SCTHIEN_Pos)                   /*!< TK_T::INTEN: SCTHIEN Mask                 */
S
S#define TK_INTEN_SCINTEN_Pos             (1)                                               /*!< TK_T::INTEN: SCINTEN Position             */
S#define TK_INTEN_SCINTEN_Msk             (0x1ul << TK_INTEN_SCINTEN_Pos)                   /*!< TK_T::INTEN: SCINTEN Mask                 */
S
S#define TK_INTEN_THIMOD_Pos              (31)                                              /*!< TK_T::INTEN: THIMOD Position              */
S#define TK_INTEN_THIMOD_Msk              (0x1ul << TK_INTEN_THIMOD_Pos)                    /*!< TK_T::INTEN: THIMOD Mask                  */
S
S#define TK_TH0_1_LTH0_Pos                (0)                                               /*!< TK_T::TH0_1: LTH0 Position                */
S#define TK_TH0_1_LTH0_Msk                (0xfful << TK_TH0_1_LTH0_Pos)                     /*!< TK_T::TH0_1: LTH0 Mask                    */
S
S#define TK_TH0_1_HTH0_Pos                (8)                                               /*!< TK_T::TH0_1: HTH0 Position                */
S#define TK_TH0_1_HTH0_Msk                (0xfful << TK_TH0_1_HTH0_Pos)                     /*!< TK_T::TH0_1: HTH0 Mask                    */
S
S#define TK_TH0_1_LTH1_Pos                (16)                                              /*!< TK_T::TH0_1: LTH1 Position                */
S#define TK_TH0_1_LTH1_Msk                (0xfful << TK_TH0_1_LTH1_Pos)                     /*!< TK_T::TH0_1: LTH1 Mask                    */
S
S#define TK_TH0_1_HTH1_Pos                (24)                                              /*!< TK_T::TH0_1: HTH1 Position                */
S#define TK_TH0_1_HTH1_Msk                (0xfful << TK_TH0_1_HTH1_Pos)                     /*!< TK_T::TH0_1: HTH1 Mask                    */
S
S#define TK_TH2_3_LTH2_Pos                (0)                                               /*!< TK_T::TH2_3: LTH2 Position                */
S#define TK_TH2_3_LTH2_Msk                (0xfful << TK_TH2_3_LTH2_Pos)                     /*!< TK_T::TH2_3: LTH2 Mask                    */
S
S#define TK_TH2_3_HTH2_Pos                (8)                                               /*!< TK_T::TH2_3: HTH2 Position                */
S#define TK_TH2_3_HTH2_Msk                (0xfful << TK_TH2_3_HTH2_Pos)                     /*!< TK_T::TH2_3: HTH2 Mask                    */
S
S#define TK_TH2_3_LTH3_Pos                (16)                                              /*!< TK_T::TH2_3: LTH3 Position                */
S#define TK_TH2_3_LTH3_Msk                (0xfful << TK_TH2_3_LTH3_Pos)                     /*!< TK_T::TH2_3: LTH3 Mask                    */
S
S#define TK_TH2_3_HTH3_Pos                (24)                                              /*!< TK_T::TH2_3: HTH3 Position                */
S#define TK_TH2_3_HTH3_Msk                (0xfful << TK_TH2_3_HTH3_Pos)                     /*!< TK_T::TH2_3: HTH3 Mask                    */
S
S#define TK_TH4_5_LTH4_Pos                (0)                                               /*!< TK_T::TH4_5: LTH4 Position                */
S#define TK_TH4_5_LTH4_Msk                (0xfful << TK_TH4_5_LTH4_Pos)                     /*!< TK_T::TH4_5: LTH4 Mask                    */
S
S#define TK_TH4_5_HTH4_Pos                (8)                                               /*!< TK_T::TH4_5: HTH4 Position                */
S#define TK_TH4_5_HTH4_Msk                (0xfful << TK_TH4_5_HTH4_Pos)                     /*!< TK_T::TH4_5: HTH4 Mask                    */
S
S#define TK_TH4_5_LTH5_Pos                (16)                                              /*!< TK_T::TH4_5: LTH5 Position                */
S#define TK_TH4_5_LTH5_Msk                (0xfful << TK_TH4_5_LTH5_Pos)                     /*!< TK_T::TH4_5: LTH5 Mask                    */
S
S#define TK_TH4_5_HTH5_Pos                (24)                                              /*!< TK_T::TH4_5: HTH5 Position                */
S#define TK_TH4_5_HTH5_Msk                (0xfful << TK_TH4_5_HTH5_Pos)                     /*!< TK_T::TH4_5: HTH5 Mask                    */
S
S#define TK_TH6_7_LTH6_Pos                (0)                                               /*!< TK_T::TH6_7: LTH6 Position                */
S#define TK_TH6_7_LTH6_Msk                (0xfful << TK_TH6_7_LTH6_Pos)                     /*!< TK_T::TH6_7: LTH6 Mask                    */
S
S#define TK_TH6_7_HTH6_Pos                (8)                                               /*!< TK_T::TH6_7: HTH6 Position                */
S#define TK_TH6_7_HTH6_Msk                (0xfful << TK_TH6_7_HTH6_Pos)                     /*!< TK_T::TH6_7: HTH6 Mask                    */
S
S#define TK_TH6_7_LTH7_Pos                (16)                                              /*!< TK_T::TH6_7: LTH7 Position                */
S#define TK_TH6_7_LTH7_Msk                (0xfful << TK_TH6_7_LTH7_Pos)                     /*!< TK_T::TH6_7: LTH7 Mask                    */
S
S#define TK_TH6_7_HTH7_Pos                (24)                                              /*!< TK_T::TH6_7: HTH7 Position                */
S#define TK_TH6_7_HTH7_Msk                (0xfful << TK_TH6_7_HTH7_Pos)                     /*!< TK_T::TH6_7: HTH7 Mask                    */
S
S#define TK_TH8_9_LTH8_Pos                (0)                                               /*!< TK_T::TH8_9: LTH8 Position                */
S#define TK_TH8_9_LTH8_Msk                (0xfful << TK_TH8_9_LTH8_Pos)                     /*!< TK_T::TH8_9: LTH8 Mask                    */
S
S#define TK_TH8_9_HTH8_Pos                (8)                                               /*!< TK_T::TH8_9: HTH8 Position                */
S#define TK_TH8_9_HTH8_Msk                (0xfful << TK_TH8_9_HTH8_Pos)                     /*!< TK_T::TH8_9: HTH8 Mask                    */
S
S#define TK_TH8_9_LTH9_Pos                (16)                                              /*!< TK_T::TH8_9: LTH9 Position                */
S#define TK_TH8_9_LTH9_Msk                (0xfful << TK_TH8_9_LTH9_Pos)                     /*!< TK_T::TH8_9: LTH9 Mask                    */
S
S#define TK_TH8_9_HTH9_Pos                (24)                                              /*!< TK_T::TH8_9: HTH9 Position                */
S#define TK_TH8_9_HTH9_Msk                (0xfful << TK_TH8_9_HTH9_Pos)                     /*!< TK_T::TH8_9: HTH9 Mask                    */
S
S#define TK_TH10_11_LTH10_Pos             (0)                                               /*!< TK_T::TH10_11: LTH10 Position             */
S#define TK_TH10_11_LTH10_Msk             (0xfful << TK_TH10_11_LTH10_Pos)                  /*!< TK_T::TH10_11: LTH10 Mask                 */
S
S#define TK_TH10_11_HTH10_Pos             (8)                                               /*!< TK_T::TH10_11: HTH10 Position             */
S#define TK_TH10_11_HTH10_Msk             (0xfful << TK_TH10_11_HTH10_Pos)                  /*!< TK_T::TH10_11: HTH10 Mask                 */
S
S#define TK_TH10_11_LTH11_Pos             (16)                                              /*!< TK_T::TH10_11: LTH11 Position             */
S#define TK_TH10_11_LTH11_Msk             (0xfful << TK_TH10_11_LTH11_Pos)                  /*!< TK_T::TH10_11: LTH11 Mask                 */
S
S#define TK_TH10_11_HTH11_Pos             (24)                                              /*!< TK_T::TH10_11: HTH11 Position             */
S#define TK_TH10_11_HTH11_Msk             (0xfful << TK_TH10_11_HTH11_Pos)                  /*!< TK_T::TH10_11: HTH11 Mask                 */
S
S#define TK_TH12_13_LTH12_Pos             (0)                                               /*!< TK_T::TH12_13: LTH12 Position             */
S#define TK_TH12_13_LTH12_Msk             (0xfful << TK_TH12_13_LTH12_Pos)                  /*!< TK_T::TH12_13: LTH12 Mask                 */
S
S#define TK_TH12_13_HTH12_Pos             (8)                                               /*!< TK_T::TH12_13: HTH12 Position             */
S#define TK_TH12_13_HTH12_Msk             (0xfful << TK_TH12_13_HTH12_Pos)                  /*!< TK_T::TH12_13: HTH12 Mask                 */
S
S#define TK_TH12_13_LTH13_Pos             (16)                                              /*!< TK_T::TH12_13: LTH13 Position             */
S#define TK_TH12_13_LTH13_Msk             (0xfful << TK_TH12_13_LTH13_Pos)                  /*!< TK_T::TH12_13: LTH13 Mask                 */
S
S#define TK_TH12_13_HTH13_Pos             (24)                                              /*!< TK_T::TH12_13: HTH13 Position             */
S#define TK_TH12_13_HTH13_Msk             (0xfful << TK_TH12_13_HTH13_Pos)                  /*!< TK_T::TH12_13: HTH13 Mask                 */
S
S#define TK_TH14_15_LTH14_Pos             (0)                                               /*!< TK_T::TH14_15: LTH14 Position             */
S#define TK_TH14_15_LTH14_Msk             (0xfful << TK_TH14_15_LTH14_Pos)                  /*!< TK_T::TH14_15: LTH14 Mask                 */
S
S#define TK_TH14_15_HTH14_Pos             (8)                                               /*!< TK_T::TH14_15: HTH14 Position             */
S#define TK_TH14_15_HTH14_Msk             (0xfful << TK_TH14_15_HTH14_Pos)                  /*!< TK_T::TH14_15: HTH14 Mask                 */
S
S#define TK_TH14_15_LTH15_Pos             (16)                                              /*!< TK_T::TH14_15: LTH15 Position             */
S#define TK_TH14_15_LTH15_Msk             (0xfful << TK_TH14_15_LTH15_Pos)                  /*!< TK_T::TH14_15: LTH15 Mask                 */
S
S#define TK_TH14_15_HTH15_Pos             (24)                                              /*!< TK_T::TH14_15: HTH15 Position             */
S#define TK_TH14_15_HTH15_Msk             (0xfful << TK_TH14_15_HTH15_Pos)                  /*!< TK_T::TH14_15: HTH15 Mask                 */
S
S#define TK_TH16_LTH16_Pos                (0)                                               /*!< TK_T::TH16: LTH16 Position                */
S#define TK_TH16_LTH16_Msk                (0xfful << TK_TH16_LTH16_Pos)                     /*!< TK_T::TH16: LTH16 Mask                    */
S
S#define TK_TH16_HTH16_Pos                (8)                                               /*!< TK_T::TH16: HTH16 Position                */
S#define TK_TH16_HTH16_Msk                (0xfful << TK_TH16_HTH16_Pos)                     /*!< TK_T::TH16: HTH16 Mask                    */
S
S/**@}*/ /* TK_CONST */
S/**@}*/ /* end of TK register group */
S
S
S/*---------------------- Timer Controller -------------------------*/
S/**
S    @addtogroup TMR Timer Controller(TMR)
S    Memory Mapped Structure for TMR Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S
S
S/**
S * @var TIMER_T::CTL
S * Offset: 0x00  Timer Control and Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |PSC       |Prescale Counter
S * |        |          |Timer input clock or event source is divided by (PSC+1) before it is fed to the timer up counter.
S * |        |          |If this field is 0 (PSC = 0), then there is no scaling.
S * |[17]    |WKTKEN    |Wake-Up Touch-Key Scan Enable Bit
S * |        |          |If this bit is set to 1, timer time-out interrupt in Power-down mode can be triggered Touch-Key start scan.
S * |        |          |0 = Timer time-out interrupt signal trigger Touch-Key start scan Disabled.
S * |        |          |1 = Timer time-out interrupt signal trigger Touch-Key start scan Enabled.
S * |        |          |Note: This bit is only available in TIMER0_CTL.
S * |[18]    |TRGSSEL   |Trigger Source Select Bit
S * |        |          |This bit is used to select trigger source is form Timer time-out interrupt signal or capture interrupt signal.
S * |        |          |0 = Timer time-out interrupt signal is used to trigger PWM, EADC and DAC.
S * |        |          |1 = Capture interrupt signal is used to trigger PWM, EADC and DAC.
S * |[19]    |TRGPWM    |Trigger PWM Enable Bit
S * |        |          |If this bit is set to 1, timer time-out interrupt or capture interrupt can be triggered PWM.
S * |        |          |0 = Timer interrupt trigger PWM Disabled.
S * |        |          |1 = Timer interrupt trigger PWM Enabled.
S * |        |          |Note: If TRGSSEL (TIMERx_CTL[18]) = 0, time-out interrupt signal will trigger PWM.
S * |        |          |If TRGSSEL (TIMERx_CTL[18]) = 1, capture interrupt signal will trigger PWM.
S * |[20]    |TRGDAC    |Trigger DAC Enable Bit
S * |        |          |If this bit is set to 1, timer time-out interrupt or capture interrupt can be triggered DAC.
S * |        |          |0 = Timer interrupt trigger DAC Disabled.
S * |        |          |1 = Timer interrupt trigger DAC Enabled.
S * |        |          |Note: If TRGSSEL (TIMERx_CTL[18]) = 0, time-out interrupt signal will trigger DAC.
S * |        |          |If TRGSSEL (TIMERx_CTL[18]) = 1, capture interrupt signal will trigger DAC.
S * |[21]    |TRGEADC   |Trigger EADC Enable Bit
S * |        |          |If this bit is set to 1, timer time-out interrupt or capture interrupt can be triggered EADC.
S * |        |          |0 = Timer interrupt trigger EADC Disabled.
S * |        |          |1 = Timer interrupt trigger EADC Enabled.
S * |        |          |Note: If TRGSSEL (TIMERx_CTL[18]) = 0, time-out interrupt signal will trigger EADC.
S * |        |          |If TRGSSEL (TIMERx_CTL[18]) = 1, capture interrupt signal will trigger EADC.
S * |[22]    |TGLPINSEL |Toggle-Output Pin Select
S * |        |          |0 = Toggle mode output to Tx_OUT (Timer Event Counter Pin).
S * |        |          |1 = Toggle mode output to Tx_EXT(Timer External Capture Pin).
S * |[23]    |WKEN      |Wake-Up Function Enable Bit
S * |        |          |If this bit is set to 1, while timer interrupt flag TIF (TIMERx_INTSTS[0]) is 1 and INTEN (TIMERx_CTL[29]) is enabled, the timer interrupt signal will generate a wake-up trigger event to CPU.
S * |        |          |0 = Wake-up function Disabled if timer interrupt signal generated.
S * |        |          |1 = Wake-up function Enabled if timer interrupt signal generated.
S * |[24]    |EXTCNTEN  |Event Counter Mode Enable Bit
S * |        |          |This bit is for external counting pin function enabled.
S * |        |          |0 = Event counter mode Disabled.
S * |        |          |1 = Event counter mode Enabled.
S * |        |          |Note: When timer is used as an event counter, this bit should be set to 1 and select HCLK as timer clock source.
S * |[25]    |ACTSTS    |Timer Active Status Bit (Read Only)
S * |        |          |This bit indicates the 24-bit up counter status.
S * |        |          |0 = 24-bit up counter is not active.
S * |        |          |1 = 24-bit up counter is active.
S * |[26]    |RSTCNT    |Timer Counter Reset Bit
S * |        |          |Setting this bit will reset the 24-bit up counter value CNT (TIMERx_CNT[23:0]) and also force CNTEN (TIMERx_CTL[30]) to 0 if ACTSTS (TIMERx_CTL[25]) is 1.
S * |        |          |0 = No effect.
S * |        |          |1 = Reset internal 8-bit prescale counter, 24-bit up counter value and CNTEN bit.
S * |[28:27] |OPMODE    |Timer Counting Mode Select
S * |        |          |00 = The Timer controller is operated in One-shot mode.
S * |        |          |01 = The Timer controller is operated in Periodic mode.
S * |        |          |10 = The Timer controller is operated in Toggle-output mode.
S * |        |          |11 = The Timer controller is operated in Continuous Counting mode.
S * |[29]    |INTEN     |Timer Interrupt Enable Bit
S * |        |          |0 = Timer Interrupt Disabled.
S * |        |          |1 = Timer Interrupt Enabled.
S * |        |          |Note: If this bit is enabled, when the timer interrupt flag TIF is set to 1, the timer interrupt signal is generated and inform to CPU.
S * |[30]    |CNTEN     |Timer Counting Enable Bit
S * |        |          |0 = Stops/Suspends counting.
S * |        |          |1 = Starts counting.
S * |        |          |Note1: In stop status, and then set CNTEN to 1 will enable the 24-bit up counter to keep counting from the last stop counting value.
S * |        |          |Note2: This bit is auto-cleared by hardware in one-shot mode (TIMER_CTL[28:27] = 00) when the timer interrupt flag TIF (TIMERx_INTSTS[0]) is generated.
S * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable
S * |        |          |0 = ICE debug mode acknowledgement effects TIMER counting.
S * |        |          |TIMER counter will be held while CPU is held by ICE.
S * |        |          |1 = ICE debug mode acknowledgement Disabled.
S * |        |          |TIMER counter will keep going no matter CPU is held by ICE or not.
S * @var TIMER_T::CMP
S * Offset: 0x04  Timer Compare Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[23:0]  |CMPDAT    |Timer Compared Value
S * |        |          |CMPDAT is a 24-bit compared value register.
S * |        |          |When the internal 24-bit up counter value is equal to CMPDAT value, the TIF (TIMERx_INTSTS[0] Timer Interrupt Flag) will set to 1.
S * |        |          |Time-out period = (Period of timer clock input) * (8-bit PSC + 1) * (24-bit CMPDAT).
S * |        |          |Note1: Never write 0x0 or 0x1 in CMPDAT field, or the core will run into unknown state.
S * |        |          |Note2: When timer is operating at continuous counting mode, the 24-bit up counter will keep counting continuously even if user writes a new value into CMPDAT field.
S * |        |          |But if timer is operating at other modes, the 24-bit up counter will restart counting from 0 and using newest CMPDAT value to be the timer compared value while user writes a new value into CMPDAT field.
S * @var TIMER_T::INTSTS
S * Offset: 0x08  Timer Interrupt Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |TIF       |Timer Interrupt Flag
S * |        |          |This bit indicates the interrupt flag status of Timer while 24-bit timer up counter CNT (TIMERx_CNT[23:0]) value reaches to CMPDAT (TIMERx_CMP[23:0]) value.
S * |        |          |0 = No effect.
S * |        |          |1 = CNT value matches the CMPDAT value.
S * |        |          |Note: This bit is cleared by writing 1 to it.
S * |[1]     |TWKF      |Timer Wake-Up Flag
S * |        |          |This bit indicates the interrupt wake-up flag status of timer.
S * |        |          |0 = Timer does not cause CPU wake-up.
S * |        |          |1 = CPU wake-up from Idle or Power-down mode if timer time-out interrupt signal generated.
S * |        |          |Note: This bit is cleared by writing 1 to it.
S * @var TIMER_T::CNT
S * Offset: 0x0C  Timer Data Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[23:0]  |CNT       |Timer Data Register
S * |        |          |This field can be reflected the internal 24-bit timer counter value or external event input counter value from Tx_CNT (x=0~3) pin.
S * |        |          |If EXTCNTEN (TIMERx_CTL[24] ) is 0, user can read CNT value for getting current 24- bit counter value .
S * |        |          |If EXTCNTEN (TIMERx_CTL[24] ) is 1, user can read CNT value for getting current 24- bit event input counter value.
S * @var TIMER_T::CAP
S * Offset: 0x10  Timer Capture Data Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[23:0]  |CAPDAT    |Timer Capture Data Register
S * |        |          |When CAPEN (TIMERx_EXTCTL[3]) bit is set, CAPFUNCS (TIMERx_EXTCTL[4]) bit is 0, and a transition on Tx_EXT pin matched the CAPEDGE (TIMERx_EXTCTL[2:1]) setting, CAPIF (TIMERx_EINTSTS[0]) will set to 1 and the current timer counter value CNT (TIMERx_CNT[23:0]) will be auto-loaded into this CAPDAT field.
S * @var TIMER_T::EXTCTL
S * Offset: 0x14  Timer External Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |CNTPHASE  |Timer External Count Phase
S * |        |          |This bit indicates the detection phase of external counting pin Tx_CNT (x= 0~3).
S * |        |          |0 = A Falling edge of external counting pin will be counted.
S * |        |          |1 = A Rising edge of external counting pin will be counted.
S * |[2:1]   |CAPEDGE   |Timer External Capture Pin Edge Detect
S * |        |          |00 = A Falling edge on Tx_EXT (x= 0~3) pin will be detected.
S * |        |          |01 = A Rising edge on Tx_EXT (x= 0~3) pin will be detected.
S * |        |          |10 = Either Rising or Falling edge on Tx_EXT (x= 0~3) pin will be detected.
S * |        |          |11 = Reserved.
S * |[3]     |CAPEN     |Timer External Capture Pin Enable
S * |        |          |This bit enables the Tx_EXT pin.
S * |        |          |0 =Tx_EXT (x= 0~3) pin Disabled.
S * |        |          |1 =Tx_EXT (x= 0~3) pin Enabled.
S * |[4]     |CAPFUNCS  |Capture Function Selection
S * |        |          |0 = External Capture Mode Enabled.
S * |        |          |1 = External Reset Mode Enabled.
S * |        |          |Note1: When CAPFUNCS is 0, transition on Tx_EXT (x= 0~3) pin is using to save the 24-bit timer counter value.
S * |        |          |Note2: When CAPFUNCS is 1, transition on Tx_EXT (x= 0~3) pin is using to reset the 24-bit timer counter value.
S * |[5]     |CAPIEN    |Timer External Capture Interrupt Enable
S * |        |          |0 = Tx_EXT (x= 0~3) pin detection Interrupt Disabled.
S * |        |          |1 = Tx_EXT (x= 0~3) pin detection Interrupt Enabled.
S * |        |          |Note: CAPIEN is used to enable timer external interrupt.
S * |        |          |If CAPIEN enabled, timer will rise an interrupt when CAPIF (TIMERx_EINTSTS[0]) is 1.
S * |        |          |For example, while CAPIEN = 1, CAPEN = 1, and CAPEDGE = 00, a 1 to 0 transition on the Tx_EXT pin will cause the CAPIF to be set then the interrupt signal is generated and sent to NVIC to inform CPU.
S * |[6]     |CAPDBEN   |Timer External Capture Pin De-Bounce Enable
S * |        |          |0 = Tx_EXT (x= 0~3) pin de-bounce Disabled.
S * |        |          |1 = Tx_EXT (x= 0~3) pin de-bounce Enabled.
S * |        |          |Note: If this bit is enabled, the edge detection of Tx_EXT pin is detected with de-bounce circuit.
S * |[7]     |CNTDBEN   |Timer Counter Pin De-Bounce Enable
S * |        |          |0 = Tx_CNT (x= 0~3) pin de-bounce Disabled.
S * |        |          |1 = Tx_CNT (x= 0~3) pin de-bounce Enabled.
S * |        |          |Note: If this bit is enabled, the edge detection of Tx_CNT pin is detected with de-bounce circuit.
S * @var TIMER_T::EINTSTS
S * Offset: 0x18  Timer External Interrupt Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |CAPIF     |Timer External Capture Interrupt Flag
S * |        |          |This bit indicates the timer external capture interrupt flag status.
S * |        |          |0 = Tx_EXT (x= 0~3) pin interrupt did not occur.
S * |        |          |1 = Tx_EXT (x= 0~3) pin interrupt occurred.
S * |        |          |Note1: This bit is cleared by writing 1 to it.
S * |        |          |Note2: When CAPEN (TIMERx_EXTCTL[3]) bit is set, CAPFUNCS (TIMERx_EXTCTL[4]) bit is 0, and a transition on Tx_EXT (x= 0~3) pin matched the CAPEDGE (TIMERx_EXTCTL[2:1]) setting, this bit will set to 1 by hardware.
S * |        |          |Note3: There is a new incoming capture event detected before CPU clearing the CAPIF status.
S * |        |          |If the above condition occurred, the Timer will keep register TIMERx_CAP unchanged and drop the new capture value.
S */
S
S    __IO uint32_t CTL;           /* Offset: 0x00  Timer Control and Status Register                                  */
S    __IO uint32_t CMP;           /* Offset: 0x04  Timer Compare Register                                             */
S    __IO uint32_t INTSTS;        /* Offset: 0x08  Timer Interrupt Status Register                                    */
S    __I  uint32_t CNT;           /* Offset: 0x0C  Timer Data Register                                                */
S    __I  uint32_t CAP;           /* Offset: 0x10  Timer Capture Data Register                                        */
S    __IO uint32_t EXTCTL;        /* Offset: 0x14  Timer External Control Register                                    */
S    __IO uint32_t EINTSTS;       /* Offset: 0x18  Timer External Interrupt Status Register                           */
S
S} TIMER_T;
S
S
S
S/**
S    @addtogroup TMR_CONST TMR Bit Field Definition
S    Constant Definitions for TMR Controller
S@{ */
S
S#define TIMER_CTL_PSC_Pos                  (0)                                             /*!< TIMER_T::CTL: PSC Position                  */
S#define TIMER_CTL_PSC_Msk                  (0xfful << TIMER_CTL_PSC_Pos)                   /*!< TIMER_T::CTL: PSC Mask                      */
S
S#define TIMER_CTL_WKTKEN_Pos               (17)                                            /*!< TIMER_T::CTL: WKTKEN Position               */
S#define TIMER_CTL_WKTKEN_Msk               (0x1ul << TIMER_CTL_WKTKEN_Pos)                 /*!< TIMER_T::CTL: WKTKEN Mask                   */
S
S#define TIMER_CTL_TRGSSEL_Pos              (18)                                            /*!< TIMER_T::CTL: TRGSSEL Position              */
S#define TIMER_CTL_TRGSSEL_Msk              (0x1ul << TIMER_CTL_TRGSSEL_Pos)                /*!< TIMER_T::CTL: TRGSSEL Mask                  */
S
S#define TIMER_CTL_TRGPWM_Pos               (19)                                            /*!< TIMER_T::CTL: TRGPWM Position               */
S#define TIMER_CTL_TRGPWM_Msk               (0x1ul << TIMER_CTL_TRGPWM_Pos)                 /*!< TIMER_T::CTL: TRGPWM Mask                   */
S
S#define TIMER_CTL_TRGDAC_Pos               (20)                                            /*!< TIMER_T::CTL: TRGDAC Position               */
S#define TIMER_CTL_TRGDAC_Msk               (0x1ul << TIMER_CTL_TRGDAC_Pos)                 /*!< TIMER_T::CTL: TRGDAC Mask                   */
S
S#define TIMER_CTL_TRGEADC_Pos              (21)                                            /*!< TIMER_T::CTL: TRGEADC Position              */
S#define TIMER_CTL_TRGEADC_Msk              (0x1ul << TIMER_CTL_TRGEADC_Pos)                /*!< TIMER_T::CTL: TRGEADC Mask                  */
S
S#define TIMER_CTL_TGLPINSEL_Pos            (22)                                            /*!< TIMER_T::CTL: TGLPINSEL Position            */
S#define TIMER_CTL_TGLPINSEL_Msk            (0x1ul << TIMER_CTL_TGLPINSEL_Pos)              /*!< TIMER_T::CTL: TGLPINSEL Mask                */
S
S#define TIMER_CTL_WKEN_Pos                 (23)                                            /*!< TIMER_T::CTL: WKEN Position                 */
S#define TIMER_CTL_WKEN_Msk                 (0x1ul << TIMER_CTL_WKEN_Pos)                   /*!< TIMER_T::CTL: WKEN Mask                     */
S
S#define TIMER_CTL_EXTCNTEN_Pos             (24)                                            /*!< TIMER_T::CTL: EXTCNTEN Position             */
S#define TIMER_CTL_EXTCNTEN_Msk             (0x1ul << TIMER_CTL_EXTCNTEN_Pos)               /*!< TIMER_T::CTL: EXTCNTEN Mask                 */
S
S#define TIMER_CTL_ACTSTS_Pos               (25)                                            /*!< TIMER_T::CTL: ACTSTS Position               */
S#define TIMER_CTL_ACTSTS_Msk               (0x1ul << TIMER_CTL_ACTSTS_Pos)                 /*!< TIMER_T::CTL: ACTSTS Mask                   */
S
S#define TIMER_CTL_RSTCNT_Pos               (26)                                            /*!< TIMER_T::CTL: RSTCNT Position               */
S#define TIMER_CTL_RSTCNT_Msk               (0x1ul << TIMER_CTL_RSTCNT_Pos)                 /*!< TIMER_T::CTL: RSTCNT Mask                   */
S
S#define TIMER_CTL_OPMODE_Pos               (27)                                            /*!< TIMER_T::CTL: OPMODE Position               */
S#define TIMER_CTL_OPMODE_Msk               (0x3ul << TIMER_CTL_OPMODE_Pos)                 /*!< TIMER_T::CTL: OPMODE Mask                   */
S
S#define TIMER_CTL_INTEN_Pos                (29)                                            /*!< TIMER_T::CTL: INTEN Position                */
S#define TIMER_CTL_INTEN_Msk                (0x1ul << TIMER_CTL_INTEN_Pos)                  /*!< TIMER_T::CTL: INTEN Mask                    */
S
S#define TIMER_CTL_CNTEN_Pos                (30)                                            /*!< TIMER_T::CTL: CNTEN Position                */
S#define TIMER_CTL_CNTEN_Msk                (0x1ul << TIMER_CTL_CNTEN_Pos)                  /*!< TIMER_T::CTL: CNTEN Mask                    */
S
S#define TIMER_CTL_ICEDEBUG_Pos             (31)                                            /*!< TIMER_T::CTL: ICEDEBUG Position             */
S#define TIMER_CTL_ICEDEBUG_Msk             (0x1ul << TIMER_CTL_ICEDEBUG_Pos)               /*!< TIMER_T::CTL: ICEDEBUG Mask                 */
S
S#define TIMER_CMP_CMPDAT_Pos               (0)                                             /*!< TIMER_T::CMP: CMPDAT Position               */
S#define TIMER_CMP_CMPDAT_Msk               (0xfffffful << TIMER_CMP_CMPDAT_Pos)            /*!< TIMER_T::CMP: CMPDAT Mask                   */
S
S#define TIMER_INTSTS_TIF_Pos               (0)                                             /*!< TIMER_T::INTSTS: TIF Position               */
S#define TIMER_INTSTS_TIF_Msk               (0x1ul << TIMER_INTSTS_TIF_Pos)                 /*!< TIMER_T::INTSTS: TIF Mask                   */
S
S#define TIMER_INTSTS_TWKF_Pos              (1)                                             /*!< TIMER_T::INTSTS: TWKF Position              */
S#define TIMER_INTSTS_TWKF_Msk              (0x1ul << TIMER_INTSTS_TWKF_Pos)                /*!< TIMER_T::INTSTS: TWKF Mask                  */
S
S#define TIMER_CNT_CNT_Pos                  (0)                                             /*!< TIMER_T::CNT: CNT Position                  */
S#define TIMER_CNT_CNT_Msk                  (0xfffffful << TIMER_CNT_CNT_Pos)               /*!< TIMER_T::CNT: CNT Mask                      */
S
S#define TIMER_CAP_CAPDAT_Pos               (0)                                             /*!< TIMER_T::CAP: CAPDAT Position               */
S#define TIMER_CAP_CAPDAT_Msk               (0xfffffful << TIMER_CAP_CAPDAT_Pos)            /*!< TIMER_T::CAP: CAPDAT Mask                   */
S
S#define TIMER_EXTCTL_CNTPHASE_Pos          (0)                                             /*!< TIMER_T::EXTCTL: CNTPHASE Position          */
S#define TIMER_EXTCTL_CNTPHASE_Msk          (0x1ul << TIMER_EXTCTL_CNTPHASE_Pos)            /*!< TIMER_T::EXTCTL: CNTPHASE Mask              */
S
S#define TIMER_EXTCTL_CAPEDGE_Pos           (1)                                             /*!< TIMER_T::EXTCTL: CAPEDGE Position           */
S#define TIMER_EXTCTL_CAPEDGE_Msk           (0x3ul << TIMER_EXTCTL_CAPEDGE_Pos)             /*!< TIMER_T::EXTCTL: CAPEDGE Mask               */
S
S#define TIMER_EXTCTL_CAPEN_Pos             (3)                                             /*!< TIMER_T::EXTCTL: CAPEN Position             */
S#define TIMER_EXTCTL_CAPEN_Msk             (0x1ul << TIMER_EXTCTL_CAPEN_Pos)               /*!< TIMER_T::EXTCTL: CAPEN Mask                 */
S
S#define TIMER_EXTCTL_CAPFUNCS_Pos          (4)                                             /*!< TIMER_T::EXTCTL: CAPFUNCS Position          */
S#define TIMER_EXTCTL_CAPFUNCS_Msk          (0x1ul << TIMER_EXTCTL_CAPFUNCS_Pos)            /*!< TIMER_T::EXTCTL: CAPFUNCS Mask              */
S
S#define TIMER_EXTCTL_CAPIEN_Pos            (5)                                             /*!< TIMER_T::EXTCTL: CAPIEN Position            */
S#define TIMER_EXTCTL_CAPIEN_Msk            (0x1ul << TIMER_EXTCTL_CAPIEN_Pos)              /*!< TIMER_T::EXTCTL: CAPIEN Mask                */
S
S#define TIMER_EXTCTL_CAPDBEN_Pos           (6)                                             /*!< TIMER_T::EXTCTL: CAPDBEN Position           */
S#define TIMER_EXTCTL_CAPDBEN_Msk           (0x1ul << TIMER_EXTCTL_CAPDBEN_Pos)             /*!< TIMER_T::EXTCTL: CAPDBEN Mask               */
S
S#define TIMER_EXTCTL_CNTDBEN_Pos           (7)                                             /*!< TIMER_T::EXTCTL: CNTDBEN Position           */
S#define TIMER_EXTCTL_CNTDBEN_Msk           (0x1ul << TIMER_EXTCTL_CNTDBEN_Pos)             /*!< TIMER_T::EXTCTL: CNTDBEN Mask               */
S
S#define TIMER_EINTSTS_CAPIF_Pos            (0)                                             /*!< TIMER_T::EINTSTS: CAPIF Position            */
S#define TIMER_EINTSTS_CAPIF_Msk            (0x1ul << TIMER_EINTSTS_CAPIF_Pos)              /*!< TIMER_T::EINTSTS: CAPIF Mask                */
S
S/**@}*/ /* TIMER_CONST */
S/**@}*/ /* end of TIMER register group */
S
S
S/*---------------------- Universal Asynchronous Receiver/Transmitter Controller -------------------------*/
S/**
S    @addtogroup UART Universal Asynchronous Receiver/Transmitter Controller(UART)
S    Memory Mapped Structure for UART Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S
S
S/**
S * @var UART_T::DAT
S * Offset: 0x00  UART Receive/Transmit Buffer Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |DAT       |Receiving/Transmit Buffer
S * |        |          |Write Operation:
S * |        |          |By writing one byte to this register, the data byte will be stored in transmitter FIFO.
S * |        |          |The UART Controller will send out the data stored in transmitter FIFO top location through the UART_TXD.
S * |        |          |Read Operation:
S * |        |          |By reading this register, the UART will return an 8-bit data received from receiving FIFO.
S * @var UART_T::INTEN
S * Offset: 0x04  UART Interrupt Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |RDAIEN    |Receive Data Available Interrupt Enable Bit
S * |        |          |0 = Receive data available interrupt Disabled.
S * |        |          |1 = Receive data available interrupt Enabled.
S * |[1]     |THREIEN   |Transmit Holding Register Empty Interrupt Enable Bit
S * |        |          |0 = Transmit holding register empty interrupt Disabled.
S * |        |          |1 = Transmit holding register empty interrupt Enabled.
S * |[2]     |RLSIEN    |Receive Line Status Interrupt Enable Bit
S * |        |          |0 = Receive Line Status interrupt Disabled.
S * |        |          |1 = Receive Line Status interrupt Enabled.
S * |[3]     |MODEMIEN  |Modem Status Interrupt Enable Bit
S * |        |          |0 = Modem status interrupt Disabled.
S * |        |          |1 = Modem status interrupt Enabled.
S * |[4]     |RXTOIEN   |RX Time-Out Interrupt Enable Bit
S * |        |          |0 = RX time-out interrupt Disabled.
S * |        |          |1 = RX time-out interrupt Enabled.
S * |[5]     |BUFERRIEN |Buffer Error Interrupt Enable Bit
S * |        |          |0 = Buffer error interrupt Disabled.
S * |        |          |1 = Buffer error interrupt Enabled.
S * |[8]     |LINIEN    |LIN Bus Interrupt Enable Bit (Not Available In UART2/UART3)
S * |        |          |0 = LIN bus interrupt Disabled.
S * |        |          |1 = LIN bus interrupt Enabled.
S * |        |          |Note: This bit is used for LIN function mode.
S * |[9]     |WKCTSIEN  |nCTS Wake-Up Interrupt Enable Bit
S * |        |          |0 = nCTS wake-up system function Disabled.
S * |        |          |1 = Wake-up system function Enabled, when the system is in Power-down mode, an external nCTS change will wake-up system from Power-down mode.
S * |[10]    |WKDATIEN  |Incoming Data Wake-Up Interrupt Enable Bit
S * |        |          |0 = Incoming data wake-up system function Disabled.
S * |        |          |1 = Incoming data wake-up system function Enabled, when the system is in Power-down mode, incoming data will wake-up system from Power-down mode.
S * |        |          |Note: Hardware will clear this bit when the incoming data wake-up operation finishes and "system clock" work stable
S * |[11]    |TOCNTEN   |Time-Out Counter Enable Bit
S * |        |          |0 = Time-out counter Disabled.
S * |        |          |1 = Time-out counter Enabled.
S * |[12]    |ATORTSEN  |nRTS Auto-Flow Control Enable Bit
S * |        |          |0 = nRTS auto-flow control Disabled.
S * |        |          |1 = nRTS auto-flow control Enabled.
S * |        |          |Note: When nRTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTSTRGLV (UART_FIFO[19:16]), the UART will de-assert nRTS signal.
S * |[13]    |ATOCTSEN  |nCTS Auto-Flow Control Enable Bit
S * |        |          |0 = nCTS auto-flow control Disabled.
S * |        |          |1 = nCTS auto-flow control Enabled.
S * |        |          |Note: When nCTS auto-flow is enabled, the UART will send data to external device if nCTS input assert (UART will not send data to device until nCTS is asserted).
S * |[14]    |TXPDMAEN  |TX DMA Enable Bit
S * |        |          |This bit can enable or disable TX DMA service.
S * |        |          |0 = TX DMA Disabled.
S * |        |          |1 = TX DMA Enabled.
S * |[15]    |RXPDMAEN  |RX DMA Enable Bit
S * |        |          |This bit can enable or disable RX DMA service.
S * |        |          |0 = RX DMA Disabled.
S * |        |          |1 = RX DMA Enabled.
S * |[18]    |ABRIEN    |Auto-Baud Rate Interrupt Enable Bit
S * |        |          |0 = Auto-baud rate interrupt Disabled.
S * |        |          |1 = Auto-baud rate interrupt Enabled.
S * @var UART_T::FIFO
S * Offset: 0x08  UART FIFO Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1]     |RXRST     |RX Field Software Reset
S * |        |          |When RXRST (UART_FIFO[1]) is set, all the byte in the receiver FIFO and RX internal state machine are cleared.
S * |        |          |0 = No effect.
S * |        |          |1 = Reset the RX internal state machine and pointers.
S * |        |          |Note: This bit will automatically clear at least 3 UART peripheral clock cycles.
S * |[2]     |TXRST     |TX Field Software Reset
S * |        |          |When TXRST (UART_FIFO[2]) is set, all the byte in the transmit FIFO and TX internal state machine are cleared.
S * |        |          |0 = No effect.
S * |        |          |1 = Reset the TX internal state machine and pointers.
S * |        |          |Note: This bit will automatically clear at least 3 UART peripheral clock cycles.
S * |[7:4]   |RFITL     |RX FIFO Interrupt Trigger Level
S * |        |          |When the number of bytes in the receive FIFO equals the RFITL, the RDAIF will be set (if RDAIEN (UART_INTEN [0]) enabled, and an interrupt will be generated).
S * |        |          |0000 = RX FIFO Interrupt Trigger Level is 1 byte.
S * |        |          |0001 = RX FIFO Interrupt Trigger Level is 4 bytes.
S * |        |          |0010 = RX FIFO Interrupt Trigger Level is 8 bytes.
S * |        |          |0011 = RX FIFO Interrupt Trigger Level is 14 bytes.
S * |        |          |Others = Reserved.
S * |[8]     |RXOFF     |Receiver Disable
S * |        |          |The receiver is disabled or not (set 1 to disable receiver)
S * |        |          |0 = Receiver Enabled.
S * |        |          |1 = Receiver Disabled.
S * |        |          |Note: This bit is used for RS-485 Normal Multi-drop mode.
S * |        |          |It should be programmed before RS485NMM (UART_ALTCTL [8]) is programmed.
S * |[19:16] |RTSTRGLV  |nRTS Trigger Level For Auto-Flow Control Use
S * |        |          |0000 = nRTS Trigger Level is 1 bytes.
S * |        |          |0001 = nRTS Trigger Level is 4bytes.
S * |        |          |0010 = nRTS Trigger Level is 8 bytes.
S * |        |          |0011 = nRTS Trigger Level is 14 bytes.
S * |        |          |Others = Reserved.
S * |        |          |Note: This field is used for auto nRTS flow control.
S * @var UART_T::LINE
S * Offset: 0x0C  UART Line Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |WLS       |Word Length Selection
S * |        |          |This field sets UART word length.
S * |        |          |00 = 5 bits.
S * |        |          |01 = 6 bits.
S * |        |          |10 = 7 bits.
S * |        |          |11 = 8 bits.
S * |[2]     |NSB       |Number Of "STOP Bit"
S * |        |          |0 = One "STOP bit" is generated in the transmitted data.
S * |        |          |1 = When select 5-bit word length, 1.5 "STOP bit" is generated in the transmitted data.
S * |        |          |When select 6-, 7- and 8-bit word length, 2 "STOP bit" is generated in the transmitted data.
S * |[3]     |PBE       |Parity Bit Enable Bit
S * |        |          |0 = No parity bit generated Disabled.
S * |        |          |1 = Parity bit generated Enabled.
S * |        |          |Note : Parity bit is generated on each outgoing character and is checked on each incoming data.
S * |[4]     |EPE       |Even Parity Enable Bit
S * |        |          |0 = Odd number of logic 1's is transmitted and checked in each word.
S * |        |          |1 = Even number of logic 1's is transmitted and checked in each word.
S * |        |          |Note:This bit has effect only when PBE (UART_LINE[3]) is set.
S * |[5]     |SPE       |Stick Parity Enable Bit
S * |        |          |0 = Stick parity Disabled.
S * |        |          |1 = Stick parity Enabled.
S * |        |          |Note: If PBE (UART_LINE[3]) and EPE (UART_LINE[4]) are logic 1, the parity bit is transmitted and checked as logic 0.
S * |        |          |If PBE (UART_LINE[3]) is 1 and EPE (UART_LINE[4]) is 0 then the parity bit is transmitted and checked as 1.
S * |[6]     |BCB       |Break Control Bit
S * |        |          |0 = Break Control Disabled.
S * |        |          |1 = Break Control Enabled.
S * |        |          |Note: When this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0).
S * |        |          |This bit acts only on TX line and has no effect on the transmitter logic.
S * @var UART_T::MODEM
S * Offset: 0x10  UART Modem Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1]     |RTS       |nRTS (Request-To-Send) Signal Control
S * |        |          |This bit is direct control internal nRTS signal active or not, and then drive the nRTS pin output with RTSACTLV bit configuration.
S * |        |          |0 = nRTS signal is active.
S * |        |          |1 = nRTS signal is inactive.
S * |        |          |Note1: This nRTS signal control bit is not effective when nRTS auto-flow control is enabled in UART function mode.
S * |        |          |Note2: This nRTS signal control bit is not effective when RS-485 auto direction mode (AUD) is enabled in RS-485 function mode.
S * |[9]     |RTSACTLV  |nRTS Pin Active Level
S * |        |          |This bit defines the active level state of nRTS pin output.
S * |        |          |0 =n RTS pin output is high level active.
S * |        |          |1 = nRTS pin output is low level active. (Default)
S * |        |          |Note1: Refer to Figure 6.21-10 and Figure 6.21-11 for UART function mode.
S * |        |          |Note2: Refer to Figure 6.21-21 and Figure 6.21-22 for RS-485 function mode.
S * |[13]    |RTSSTS    |nRTS Pin Status (Read Only)
S * |        |          |This bit mirror from nRTS pin output of voltage logic status.
S * |        |          |0 = nRTS pin output is low level voltage logic state.
S * |        |          |1 = nRTS pin output is high level voltage logic state.
S * @var UART_T::MODEMSTS
S * Offset: 0x14  UART Modem Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |CTSDETF   |Detect nCTS State Change Flag (Read Only)
S * |        |          |This bit is set whenever nCTS input has change state, and it will generate Modem interrupt to CPU when MODEMIEN (UART_INTEN [3]) is set to 1.
S * |        |          |0 = nCTS input has not change state.
S * |        |          |1 = nCTS input has change state.
S * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
S * |[4]     |CTSSTS    |nCTS Pin Status (Read Only)
S * |        |          |This bit mirror from nCTS pin input of voltage logic status.
S * |        |          |0 = nCTS pin input is low level voltage logic state.
S * |        |          |1 = nCTS pin input is high level voltage logic state.
S * |        |          |Note: This bit echoes when UART Controller peripheral clock is enabled, and nCTS multi-function port is selected.
S * |[8]     |CTSACTLV  |nCTS Pin Active Level
S * |        |          |This bit defines the active level state of nCTS pin input.
S * |        |          |0 = nCTS pin input is high level active.
S * |        |          |1 = nCTS pin input is low level active. (Default)
S * @var UART_T::FIFOSTS
S * Offset: 0x18  UART FIFO Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |RXOVIF    |RX Overflow Error Interrupt Flag (Read Only)
S * |        |          |This bit is set when RX FIFO overflow.
S * |        |          |If the number of bytes of received data is greater than RX_FIFO (UART_DAT) size, 16 bytes this bit will be set.
S * |        |          |0 = RX FIFO is not overflow.
S * |        |          |1 = RX FIFO is overflow.
S * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
S * |[1]     |ABRDIF    |Auto-Baud Rate Detect Interrupt (Read Only)
S * |        |          |0 = Auto-baud rate detect function is not finished.
S * |        |          |1 = Auto-baud rate detect function is finished.
S * |        |          |This bit is set to logic "1" when auto-baud rate detect function is finished.
S * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
S * |[2]     |ABRDTOIF  |Auto-Baud Rate Time-Out Interrupt (Read Only)
S * |        |          |0 = Auto-baud rate counter is underflow.
S * |        |          |1 = Auto-baud rate counter is overflow.
S * |        |          |Note1: This bit is set to logic "1" in Auto-baud Rate Detect mode and the baud rate counter is overflow.
S * |        |          |Note2: This bit is read only, but can be cleared by writing "1" to it.
S * |[3]     |ADDRDETF  |RS-485 Address Byte Detect Flag (Read Only)
S * |        |          |0 = Receiver detects a data that is not an address bit (bit 9 ='0').
S * |        |          |1 = Receiver detects a data that is an address bit (bit 9 ='1').
S * |        |          |Note1: This field is used for RS-485 function mode and ADDRDEN (UART_ALTCTL[15]) is set to 1 to enable Address detection mode .
S * |        |          |Note2: This bit is read only, but can be cleared by writing '1' to it.
S * |[4]     |PEF       |Parity Error Flag (Read Only)
S * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "parity bit".
S * |        |          |0 = No parity error is generated.
S * |        |          |1 = Parity error is generated.
S * |        |          |Note: This bit is read only, but can be cleared by writing '1' to it.
S * |[5]     |FEF       |Framing Error Flag (Read Only)
S * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as logic 0).
S * |        |          |0 = No framing error is generated.
S * |        |          |1 = Framing error is generated.
S * |        |          |Note: This bit is read only, but can be cleared by writing '1' to it.
S * |[6]     |BIF       |Break Interrupt Flag (Read Only)
S * |        |          |This bit is set to logic 1 whenever the received data input (RX) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits).
S * |        |          |0 = No Break interrupt is generated.
S * |        |          |1 = Break interrupt is generated.
S * |        |          |Note: This bit is read only, but can be cleared by writing '1' to it.
S * |[13:8]  |RXPTR     |RX FIFO Pointer (Read Only)
S * |        |          |This field indicates the RX FIFO Buffer Pointer.
S * |        |          |When UART receives one byte from external device, RXPTR increases one.
S * |        |          |When one byte of RX FIFO is read by CPU, RXPTR decreases one.
S * |        |          |The Maximum value shown in RXPTR is 15.
S * |        |          |When the using level of RX FIFO Buffer equal to 16, the RXFULL bit is set to 1 and RXPTR will show 0.
S * |        |          |As one byte of RX FIFO is read by CPU, the RXFULL bit is cleared to 0 and RXPTR will show 15.
S * |[14]    |RXEMPTY   |Receiver FIFO Empty (Read Only)
S * |        |          |This bit initiate RX FIFO empty or not.
S * |        |          |0 = RX FIFO is not empty.
S * |        |          |1 = RX FIFO is empty.
S * |        |          |Note: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high.
S * |        |          |It will be cleared when UART receives any new data.
S * |[15]    |RXFULL    |Receiver FIFO Full (Read Only)
S * |        |          |This bit initiates RX FIFO full or not.
S * |        |          |0 = RX FIFO is not full.
S * |        |          |1 = RX FIFO is full.
S * |        |          |Note: This bit is set when the number of usage in RX FIFO Buffer is equal to 16, otherwise is cleared by hardware.
S * |[21:16] |TXPTR     |TX FIFO Pointer (Read Only)
S * |        |          |This field indicates the TX FIFO Buffer Pointer.
S * |        |          |When CPU writes one byte into UART_DAT, TXPTR increases one.
S * |        |          |When one byte of TX FIFO is transferred to Transmitter Shift Register, TXPTR decreases one.
S * |        |          |The Maximum value shown in TXPTR is 15.
S * |        |          |When the using level of TX FIFO Buffer equal to 16, the TXFULL bit is set to 1 and TXPTR will show 0.
S * |        |          |As one byte of TX FIFO is transferred to Transmitter Shift Register, the TXFULL bit is cleared to 0 and TXPTR will show 15.
S * |[22]    |TXEMPTY   |Transmitter FIFO Empty (Read Only)
S * |        |          |This bit indicates TX FIFO empty or not.
S * |        |          |0 = TX FIFO is not empty.
S * |        |          |1 = TX FIFO is empty.
S * |        |          |Note: When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high.
S * |        |          |It will be cleared when writing data into DAT (TX FIFO not empty).
S * |[23]    |TXFULL    |Transmitter FIFO Full (Read Only)
S * |        |          |This bit indicates TX FIFO full or not.
S * |        |          |0 = TX FIFO is not full.
S * |        |          |1 = TX FIFO is full.
S * |        |          |Note: This bit is set when the number of usage in TX FIFO Buffer is equal to 16, otherwise is cleared by hardware.
S * |[24]    |TXOVIF    |TX Overflow Error Interrupt Flag (Read Only)
S * |        |          |If TX FIFO (UART_DAT) is full, an additional write to UART_DAT will cause this bit to logic 1.
S * |        |          |0 = TX FIFO is not overflow.
S * |        |          |1 = TX FIFO is overflow.
S * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
S * |[28]    |TXEMPTYF  |Transmitter Empty Flag (Read Only)
S * |        |          |This bit is set by hardware when TX FIFO (UART_DAT) is empty and the STOP bit of the last byte has been transmitted.
S * |        |          |0 = TX FIFO is not empty.
S * |        |          |1 = TX FIFO is empty.
S * |        |          |Note: This bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.
S * @var UART_T::INTSTS
S * Offset: 0x1C  UART Interrupt Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |RDAIF     |Receive Data Available Interrupt Flag (Read Only)
S * |        |          |When the number of bytes in the RX FIFO equals the RFITL then the RDAIF(UART_INTSTS[0]) will be set.
S * |        |          |If RDAIEN (UART_INTEN [0]) is enabled, the RDA interrupt will be generated.
S * |        |          |0 = No RDA interrupt flag is generated.
S * |        |          |1 = RDA interrupt flag is generated.
S * |        |          |Note: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL(UART_FIFO[7:4])).
S * |[1]     |THREIF    |Transmit Holding Register Empty Interrupt Flag (Read Only)
S * |        |          |This bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register.
S * |        |          |If THREIEN (UART_INTEN[1]) is enabled, the THRE interrupt will be generated.
S * |        |          |0 = No THRE interrupt flag is generated.
S * |        |          |1 = THRE interrupt flag is generated.
S * |        |          |Note: This bit is read only and it will be cleared when writing data into UART_DAT (TX FIFO not empty).
S * |[2]     |RLSIF     |Receive Line Interrupt Flag (Read Only)
S * |        |          |This bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF(UART_FIFOSTS[6]), FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]), is set).
S * |        |          |If RLSIEN (UART_INTEN [2]) is enabled, the RLS interrupt will be generated.
S * |        |          |0 = No RLS interrupt flag is generated.
S * |        |          |1 = RLS interrupt flag is generated.
S * |        |          |Note1: In RS-485 function mode, this field is set include receiver detect and received address byte character (bit9 = '1') bit.
S * |        |          |At the same time, the bit of ADDRDETF (UART_FIFOSTS[3]) is also set.
S * |        |          |Note2: This bit is read only and reset to 0 when all bits of BIF (UART_FIFOSTS[6]), FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]) are cleared.
S * |        |          |Note3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF (UART_FIFOSTS[6]) , FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]) and ADDRDETF (UART_FIFOSTS[3]) are cleared.
S * |[3]     |MODEMIF   |MODEM Interrupt Flag (Read Only) Channel This bit is set when the nCTS pin has state change (CTSDETF (UART_MODEMSTS[0]) = 1). If MODEMIEN (UART_INTEN [3]) is enabled, the Modem interrupt will be generated.
S * |        |          |0 = No Modem interrupt flag is generated.
S * |        |          |1 = Modem interrupt flag is generated.
S * |        |          |Note: This bit is read only and reset to 0 when bit CTSDETF is cleared by a write 1 on CTSDETF(UART_MODEMSTS[0]).
S * |[4]     |RXTOIF    |Time-Out Interrupt Flag (Read Only)
S * |        |          |This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC.
S * |        |          |If TOUTIEN (UART_INTEN [4]) is enabled, the Tout interrupt will be generated.
S * |        |          |0 = No Time-out interrupt flag is generated.
S * |        |          |1 = Time-out interrupt flag is generated.
S * |        |          |Note: This bit is read only and user can read UART_DAT (RX is in active) to clear it.
S * |[5]     |BUFERRIF  |Buffer Error Interrupt Flag (Read Only)
S * |        |          |This bit is set when the TX FIFO or RX FIFO overflows (TXOVIF (UART_FIFOSTS[24]) or RXOVIF (UART_FIFOSTS[0]) is set).
S * |        |          |When BERRIF (UART_INTSTS[5])is set, the transfer is not correct.
S * |        |          |If BFERRIEN (UART_INTEN [8]) is enabled, the buffer error interrupt will be generated.
S * |        |          |0 = No buffer error interrupt flag is generated.
S * |        |          |1 = Buffer error interrupt flag is generated.
S * |        |          |Note: This bit is read only.
S * |        |          |This bit is cleared if both of RXOVIF(UART_FIFOSTS[0]) and TXOVIF(UART_FIFOSTS[24]) are cleared to 0 by writing 1 to RXOVIF(UART_FIFOSTS[0]) and TXOVIF(UART_FIFOSTS[24]).
S * |[6]     |WKIF      |UART Wake-up Interrupt Flag (Read Only)
S * |        |          |This bit is set when DATWKIF (UART_INTSTS[17]) or CTSWKIF(UART_INTSTS[16]) is set to 1.
S * |        |          |0 = No DATWKIF and CTSWKIF are generated.
S * |        |          |1 = DATWKIF or CTSWKIF.
S * |        |          |Note: This bit is read only.
S * |        |          |This bit is cleared if both of DATWKIF (UART_INTSTS[17]) and CTSWKIF(UART_INTSTS[16]) are cleared to 0 by writing 1 to DATWKIF (UART_INTSTS[17]) and CTSWKIF (UART_INTSTS[17]).
S * |[7]     |LINIF     |LIN Bus Interrupt Flag (Read Only) (Not Available in UART2/UART3 Channel)
S * |        |          |This bit is set when LIN slave header detect (SLVHDETF (UART_LINSTS[0] =1)), LIN break detect (BRKDETF(UART_LINSTS[9])=1), bit error detect (BITEF(UART_LINSTS[9])=1), LIN slave ID parity error (SLVIDPEF(UART_LINSTS[2]) = 1) or LIN slave header error detect (SLVHEF (UART_LINSTS[1])).
S * |        |          |If LIN_ IEN (UART_INTEN [8]) is enabled the LIN interrupt will be generated.
S * |        |          |0 = None of SLVHDETF, BRKDETF, BITEF, SLVIDPEF and SLVHEF is generated.
S * |        |          |1 = At least one of SLVHDETF, BRKDETF, BITEF, SLVIDPEF and SLVHEF is generated.
S * |        |          |Note: This bit is read only.
S * |        |          |This bit is cleared when SLVHDETF(UART_LINSTS[0]), BRKDETF(UART_LINSTS[8]), BITEF(UART_LINSTS[9]), SLVIDPEF (UART_LINSTS[2]), SLVHEF(UART_LINSTS[1]) and SLVSYNCF(UART_LINSTS[3]) all are cleared.
S * |[8]     |RDAINT    |Receive Data Available Interrupt Indicator (Read Only)
S * |        |          |This bit is set if RDAIEN (UART_INTEN[0]) and RDAIF (UART_INTSTS[0]) are both set to 1.
S * |        |          |0 = No RDA interrupt is generated.
S * |        |          |1 = RDA interrupt is generated.
S * |[9]     |THREINT   |Transmit Holding Register Empty Interrupt Indicator (Read Only)
S * |        |          |This bit is set if THREIEN (UART_INTEN[1])and THREIF(UART_INTSTS[1]) are both set to 1.
S * |        |          |0 = No DATE interrupt is generated.
S * |        |          |1 = DATE interrupt is generated.
S * |[10]    |RLSINT    |Receive Line Status Interrupt Indicator (Read Only)
S * |        |          |This bit is set if RLSIEN (UART_INTEN[2]) and RLSIF(UART_INTSTS[2]) are both set to 1.
S * |        |          |0 = No RLS interrupt is generated.
S * |        |          |1 = RLS interrupt is generated.
S * |[11]    |MODEMINT  |MODEM Status Interrupt Indicator (Read Only)
S * |        |          |This bit is set if MODEMIEN(UART_INTEN[3]) and MODEMIF(UART_INTSTS[4]) are both set to 1
S * |        |          |0 = No Modem interrupt is generated.
S * |        |          |1 = Modem interrupt is generated.
S * |[12]    |RXTOINT   |Time-Out Interrupt Indicator (Read Only)
S * |        |          |This bit is set if TOUTIEN(UART_INTEN[4]) and RXTOIF(UART_INTSTS[4]) are both set to 1.
S * |        |          |0 = No Tout interrupt is generated.
S * |        |          |1 = Tout interrupt is generated.
S * |[13]    |BUFERRINT |Buffer Error Interrupt Indicator (Read Only)
S * |        |          |This bit is set if BFERRIEN(UART_INTEN[5]) and BERRIF(UART_INTSTS[5]) are both set to 1.
S * |        |          |0 = No buffer error interrupt is generated.
S * |        |          |1 = Buffer error interrupt is generated.
S * |[15]    |LININT    |LIN Bus Interrupt Indicator (Read Only)(Not Available in UART2/UART3 Channel)
S * |        |          |This bit is set if LINIEN (UART_INTEN[8]) and LIN IF(UART_INTSTS[7]) are both set to 1.
S * |        |          |0 = No LIN Bus interrupt is generated.
S * |        |          |1 = The LIN Bus interrupt is generated.
S * |[16]    |CTSWKIF   |nCTS Wake-Up Interrupt Flag (Read Only)
S * |        |          |0 = Chip stays in power-down state.
S * |        |          |1 = Chip wake-up from power-down state by nCTS wake-up.
S * |        |          |Note1: If WKCTSIEN (UART_INTEN[9])is enabled, the wake-up interrupt is generated.
S * |        |          |Note2: This bit is read only, but can be cleared by writing '1' to it.
S * |[17]    |DATWKIF   |Data Wake-Up Interrupt Flag (Read Only)
S * |        |          |This bit is set if chip wake-up from power-down state by data wake-up.
S * |        |          |0 = Chip stays in power-down state.
S * |        |          |1 = Chip wake-up from power-down state by data wake-up.
S * |        |          |Note1: If WKDATIEN (UART_INTEN[10]) is enabled, the wake-up interrupt is generated.
S * |        |          |Note2: This bit is read only, but can be cleared by writing '1' to it.
S * |[18]    |HWRLSIF   |In DMA Mode, Receive Line Status Flag (Read Only)
S * |        |          |This bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF (UART_FIFOSTS[6]), FEF (UART_FIFOSTS[5]) and PEF (UART_FIFOSTS[4]) is set).
S * |        |          |If RLSIEN (UART_INTEN [2]) is enabled, the RLS interrupt will be generated.
S * |        |          |0 = No RLS interrupt flag is generated.
S * |        |          |1 = RLS interrupt flag is generated.
S * |        |          |Note1: In RS-485 function mode, this field include receiver detect any address byte received address byte character (bit9 = '1') bit.
S * |        |          |Note2: In UART function mode, this bit is read only and reset to 0 when all bits of BIF(UART_FIFOSTS[6]) , FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]) are cleared.
S * |        |          |Note3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UART_FIFOSTS[6]) , FEF(UART_FIFOSTS[5]) and PEF(UART_FIFOSTS[4]) and ADDRDETF (UART_FIFOSTS[3]) are cleared
S * |[19]    |HWMODIF   |In DMA Mode, MODEM Interrupt Flag (Read Only)
S * |        |          |This bit is set when the nCTS pin has state change (CTSDETF (UART_CTSDETF[0] =1)).
S * |        |          |If MODEMIEN (UART_INTEN [3]) is enabled, the Modem interrupt will be generated.
S * |        |          |0 = No Modem interrupt flag is generated.
S * |        |          |1 = Modem interrupt flag is generated.
S * |        |          |Note: This bit is read only and reset to 0 when the bit UART_CTSDETF (US_MSR[0]) is cleared by writing 1 on CTSDETF (UART_CTSDETF [0]).
S * |[20]    |HWTOIF    |In DMA Mode, Time-Out Interrupt Flag (Read Only)
S * |        |          |This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC (UART_TOUT[7:0]).
S * |        |          |If TOUTIEN (UART_INTEN [4]) is enabled, the Tout interrupt will be generated.
S * |        |          |0 = No Time-out interrupt flag is generated.
S * |        |          |1 = Time-out interrupt flag is generated.
S * |        |          |Note: This bit is read only and user can read UART_DAT (RX is in active) to clear it.
S * |[21]    |HWBUFEIF  |In DMA Mode, Buffer Error Interrupt Flag (Read Only)
S * |        |          |This bit is set when the TX or RX FIFO overflows (TXOVIF (UART_FIFOSTS [24]) or RXOVIF (UART_FIFOSTS[0]) is set).
S * |        |          |When BERRIF (UART_INTSTS[5]) is set, the transfer maybe is not correct.
S * |        |          |If BFERRIEN (UART_INTEN [5]) is enabled, the buffer error interrupt will be generated.
S * |        |          |0 = No buffer error interrupt flag is generated.
S * |        |          |1 = Buffer error interrupt flag is generated.
S * |        |          |Note: This bit is cleared when both TXOVIF (UART_FIFOSTS[24]]) and RXOVIF (UART_FIFOSTS[0]) are cleared.
S * |[26]    |HWRLSINT  |In DMA Mode, Receive Line Status Interrupt Indicator (Read Only)
S * |        |          |This bit is set if RLSIEN (UART_INTEN[2])and HWRLSIF(UART_INTSTS[18]) are both set to 1.
S * |        |          |0 = No RLS interrupt is generated in DMA mode.
S * |        |          |1 = RLS interrupt is generated in DMA mode.
S * |[27]    |HWMODINT  |In DMA Mode, MODEM Status Interrupt Indicator (Read Only)
S * |        |          |This bit is set if MODEMIEN(UART_INTEN[3]) and HWMODIF(UART_INTSTS[3]) are both set to 1.
S * |        |          |0 = No Modem interrupt is generated in DMA mode.
S * |        |          |1 = Modem interrupt is generated in DMA mode.
S * |[28]    |HWTOINT   |In DMA Mode, Time-Out Interrupt Indicator (Read Only)
S * |        |          |This bit is set if TOUTIEN (UART_INTEN[4])and HWTOIF(UART_INTSTS[20]) are both set to 1.
S * |        |          |0 = No Tout interrupt is generated in DMA mode.
S * |        |          |1 = Tout interrupt is generated in DMA mode.
S * |[29]    |HWBUFEINT |In DMA Mode, Buffer Error Interrupt Indicator (Read Only)
S * |        |          |This bit is set if BFERRIEN (UART_INTEN[5]) and HWBEIF (UART_INTSTS[5])are both set to 1.
S * |        |          |0 = No buffer error interrupt is generated in DMA mode.
S * |        |          |1 = Buffer error interrupt is generated in DMA mode.
S * @var UART_T::TOUT
S * Offset: 0x20  UART Time-out Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |TOIC      |Time-Out Interrupt Comparator
S * |        |          |The time-out counter resets and starts counting (the counting clock = baud rate) whenever the RX FIFO receives a new data word.
S * |        |          |Once the content of time-out counter is equal to that of time-out interrupt comparator (TOIC (UART_TOUT[7:0])), a receiver time-out interrupt (RXTOINT(UART_INTSTS[12])) is generated if RXTOIEN (UART_INTEN [4]) enabled.
S * |        |          |A new incoming data word or RX FIFO empty will clear RXTOINT(UART_INTSTS[12]).
S * |        |          |In order to avoid receiver time-out interrupt generation immediately during one character is being received, TOIC value should be set between 40 and 255.
S * |        |          |So, for example, if TOIC is set with 40, the time-out interrupt is generated after four characters are not received when 1 stop bit and no parity check is set for UART transfer.
S * |[15:8]  |DLY       |TX Delay Time Value
S * |        |          |This field is used to programming the transfer delay time between the last stop bit and next start bit.
S * |        |          |The unit is bit time.
S * @var UART_T::BAUD
S * Offset: 0x24  UART Baud Rate Divisor Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |BRD       |Baud Rate Divider
S * |        |          |The field indicates the baud rate divider.
S * |        |          |This filed is used in baud rate calculation.
S * |        |          |The detail description is shown in Table 6.21-2.
S * |[27:24] |EDIVM1    |Extra Divider For BAUD Rate Mode 1
S * |        |          |This field is used for baud rate calculation in mode 1 and has no effect for baud rate calculation in mode 0 and mode 2.
S * |        |          |The detail description is shown in Table 6.21-2.
S * |[28]    |BAUDM0    |BAUD Rate Mode Selection Bit 0
S * |        |          |This bit is baud rate mode selection bit 0.
S * |        |          |UART provides three baud rate calculation modes.
S * |        |          |This bit combines with BAUDM1 (UART_BAUD[29]) to select baud rate calculation mode.
S * |        |          |The detail description is shown in Table 6.21-2.
S * |[29]    |BAUDM1    |BAUD Rate Mode Selection Bit 1
S * |        |          |This bit is baud rate mode selection bit 1.
S * |        |          |UART provides three baud rate calculation modes.
S * |        |          |This bit combines with BAUDM0 (UART_BAUD[28]) to select baud rate calculation mode.
S * |        |          |The detail description is shown in Table 6.21-2.
S * |        |          |Note: In IrDA mode must be operated in mode 0.
S * @var UART_T::IRDA
S * Offset: 0x28  UART IrDA Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1]     |TXEN      |IrDA Receiver/Transmitter Selection Enable Bit
S * |        |          |0 = IrDA Transmitter Disabled and Receiver Enabled. (Default)
S * |        |          |1 = IrDA Transmitter Enabled and Receiver Disabled.
S * |        |          |Note: In IrDA function mode (FUNCSEL(UART_FUNCSEL[1:0])=10), the first received data is unreliable and it should be skipped if IrDA receiver is enabled (TXEN(UART_IRDA[1])=0) at the first time.
S * |[5]     |TXINV     |IrDA Inverse Transmitting Output Signal
S * |        |          |0 = None inverse transmitting signal. (Default)
S * |        |          |1 = Inverse transmitting output signal.
S * |[6]     |RXINV     |IrDA Inverse Receive Input Signal
S * |        |          |0 = None inverse receiving input signal.
S * |        |          |1 = Inverse receiving input signal. (Default)
S * @var UART_T::ALTCTL
S * Offset: 0x2C  UART Alternate Control/Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |BRKFL     |UART LIN Break Field Length (Only Available In UART0/UART1 Channel)
S * |        |          |This field indicates a 4-bit LIN TX break field count.
S * |        |          |Note1: This break field length is BRKFL + 1
S * |        |          |Note2: According to LIN spec, the reset value is 0xC (break field length = 13).
S * |[6]     |LINRXEN   |LIN RX Enable Bit (Only Available In UART0/UART1 Channel)
S * |        |          |0 = LIN RX mode Disabled.
S * |        |          |1 = LIN RX mode Enabled.
S * |[7]     |LINTXEN   |LIN TX Break Mode Enable Bit (Only Available In UART0/UART1 Channel)
S * |        |          |0 = LIN TX Break mode Disabled.
S * |        |          |1 = LIN TX Break mode Enabled.
S * |        |          |Note: When TX break field transfer operation finished, this bit will be cleared automatically.
S * |[8]     |RS485NMM  |RS-485 Normal Multi-Drop Operation Mode (NMM)
S * |        |          |0 = RS-485 Normal Multi-drop Operation mode (NMM) Disabled.
S * |        |          |1 = RS-485 Normal Multi-drop Operation mode (NMM) Enabled.
S * |        |          |Note: It cannot be active with RS-485_AAD operation mode.
S * |[9]     |RS485AAD  |RS-485 Auto Address Detection Operation Mode (AAD)
S * |        |          |0 = RS-485 Auto Address Detection Operation mode (AAD) Disabled.
S * |        |          |1 = RS-485 Auto Address Detection Operation mode (AAD) Enabled.
S * |        |          |Note: It cannot be active with RS-485_NMM operation mode.
S * |[10]    |RS485AUD  |RS-485 Auto Direction Function (AUD)
S * |        |          |0 = RS-485 Auto Direction Operation function (AUD) Disabled.
S * |        |          |1 = RS-485 Auto Direction Operation function (AUD) Enabled.
S * |        |          |Note: It can be active with RS-485_AAD or RS-485_NMM operation mode.
S * |[15]    |ADDRDEN   |RS-485 Address Detection Enable Bit
S * |        |          |This bit is used to enable RS-485 Address Detection mode.
S * |        |          |0 = Address detection mode Disabled.
S * |        |          |1 = Address detection mode Enabled.
S * |        |          |Note: This bit is used for RS-485 any operation mode.
S * |[17]    |ABRIF     |Auto-Baud Rate Interrupt Flag (Read Only)
S * |        |          |This bit is set when auto-baud rate detection function finished or the auto-baud rate counter was overflow and if ABRIEN(UART_INTEN [18]) is set then the auto-baud rate interrupt will be generated.
S * |        |          |Note: This bit is read only, but it can be cleared by writing "1" to ABRDTOIF (UART_FIFOSTS[2]) and ABRDIF(UART_FIFOSTS[1])
S * |[18]    |ABRDEN    |Auto-Baud Rate Detect Enable Bit
S * |        |          |0 = Auto-baud rate detect function Disabled.
S * |        |          |1 = Auto-baud rate detect function Enabled.
S * |        |          |This bit is cleared automatically after auto-baud detection is finished.
S * |[20:19] |ABRDBITS  |Auto-Baud Rate Detect Bit Length
S * |        |          |00 = 1-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x01.
S * |        |          |01 = 2-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x02.
S * |        |          |10 = 4-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x08.
S * |        |          |11 = 8-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x80.
S * |        |          |Note : The calculation of bit number includes the START bit.
S * |[31:24] |ADDRMV    |Address Match Value
S * |        |          |This field contains the RS-485 address match values.
S * |        |          |Note: This field is used for RS-485 auto address detection mode.
S * @var UART_T::FUNCSEL
S * Offset: 0x30  UART Function Select Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |FUNCSEL   |Function Select
S * |        |          |00 = UART function.
S * |        |          |01 = LIN function (Only Available in UART0/UART1 Channel).
S * |        |          |10 = IrDA function.
S * |        |          |11 = RS-485 function.
S * |        |          |Note: In IrDA function mode (FUNCSEL(UART_FUNCSEL[1:0])=10), the first received data is unreliable and it should be skipped if IrDA receiver is enabled (TXEN(UART_IRDA[1])=0) at the first time.
S * @var UART_T::LINCTL
S * Offset: 0x34  UART LIN Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |SLVEN     |LIN Slave Mode Enable Bit
S * |        |          |0 = LIN slave mode Disabled.
S * |        |          |1 = LIN slave mode Enabled.
S * |[1]     |SLVHDEN   |LIN Slave Header Detection Enable Bit
S * |        |          |0 = LIN slave header detection Disabled.
S * |        |          |1 = LIN slave header detection Enabled.
S * |        |          |Note1: This bit only valid when in LIN slave mode (SLVEN (UART_LINCTL[0]) = 1).
S * |        |          |Note2: In LIN function mode, when detect header field (break + sync + frame ID), SLVHDETF (UART_LINSTS [0]) flag will be asserted.
S * |        |          |If the LINIEN (UART_INTEN[8]) = 1, an interrupt will be generated.
S * |[2]     |SLVAREN   |LIN Slave Automatic Resynchronization Mode Enable Bit
S * |        |          |0 = LIN automatic resynchronization Disabled.
S * |        |          |1 = LIN automatic resynchronization Enabled.
S * |        |          |Note1: This bit only valid when in LIN slave mode (SLVEN (UART_LINCTL[0]) = 1).
S * |        |          |Note2: When operation in Automatic Resynchronization mode, the baud rate setting must be mode2 (BAUDM1 (UART_BAUD [29]) and BAUDM0 (UART_BAUD [28]) must be 1).
S * |        |          |Note3: The control and interactions of this field are explained in 6.21.5.9(Slave mode with automatic resynchronization).
S * |[3]     |SLVDUEN   |LIN Slave Divider Update Method Enable Bit
S * |        |          |0 = UART_BAUD updated is written by software (if no automatic resynchronization update occurs at the same time).
S * |        |          |1 = UART_BAUD is updated at the next received character.
S * |        |          |User must set the bit before checksum reception.
S * |        |          |Note1: This bit only valid when in LIN slave mode (SLVEN (UART_LINCTL[0]) = 1).
S * |        |          |Note2: This bit used for LIN Slave Automatic Resynchronization mode.
S * |        |          |(for Non-Automatic Resynchronization mode, this bit should be kept cleared).
S * |        |          |Note3: The control and interactions of this field are explained in 6.21.5.9 (Slave mode with automatic resynchronization).
S * |[4]     |MUTE      |LIN Mute Mode Enable Bit
S * |        |          |0 = LIN mute mode Disabled.
S * |        |          |1 = LIN mute mode Enabled.
S * |        |          |Note: The exit from mute mode condition and each control and interactions of this field are explained in 6.21.5.9 (LIN slave mode).
S * |[8]     |SENDH     |LIN TX Send Header Enable Bit
S * |        |          |The LIN TX header can be "break field" or "break and sync field" or "break, sync and frame ID field", it is depend on setting HSEL (UART_LINCTL[23:22]).
S * |        |          |0 = Send LIN TX header Disabled.
S * |        |          |1 = Send LIN TX header Enabled.
S * |        |          |Note1: These registers are shadow registers of SENDH (UART_ALTCTL [7]); user can read/write it by setting SENDH (UART_ALTCTL [7]) or SENDH (UART_LINCTL [8]).
S * |        |          |Note2: When transmitter header field (it may be "break" or "break + sync" or "break + sync + frame ID" selected by HSEL (UART_LINCTL[23:22]) field) transfer operation finished, this bit will be cleared automatically.
S * |[9]     |IDPEN     |LIN ID Parity Enable Bit
S * |        |          |0 = LIN frame ID parity Disabled.
S * |        |          |1 = LIN frame ID parity Enabled.
S * |        |          |Note1: This bit can be used for LIN master to sending header field (SENDH (UART_LINCTL[8]) = 1 and HSEL (UART_LINCTL[23:22]) = 10) or be used for enable LIN slave received frame ID parity checked.
S * |        |          |Note2: This bit is only use when the operation header transmitter is in HSEL (UART_LINCTL[23:22]) = 10
S * |[10]    |BRKDETEN  |LIN Break Detection Enable Bit
S * |        |          |When detect consecutive dominant greater than 11 bits, and are followed by a delimiter character, the BRKDETF (UART_LINSTS[8]) flag is set in UART_LINSTS register at the end of break field.
S * |        |          |If the LINIEN (UART_INTEN [8])=1, an interrupt will be generated.
S * |        |          |0 = LIN break detection Disabled .
S * |        |          |1 = LIN break detection Enabled.
S * |[11]    |RXOFF     |LIN Receiver Disable Bit
S * |        |          |If the receiver is enabled (RXOFF (UART_LINCTL[11] ) = 0), 
S * |        |          |all received byte data will be accepted and stored in the RX-FIFO, 
S * |        |          |and if the receiver is disabled (RXOFF (UART_LINCTL[11]) = 1), all received byte data will be ignore.
S * |        |          |0 = LIN receiver Enabled.
S * |        |          |1 = LIN receiver Disabled.
S * |        |          |Note: This bit is only valid when operating in LIN function mode (FUNCSEL (UART_FUNCSEL[1:0]) = 01).
S * |[12]    |BITERREN  |Bit Error Detect Enable Bit
S * |        |          |0 = Bit error detection function Disabled.
S * |        |          |1 = Bit error detection Enabled.
S * |        |          |Note: In LIN function mode, when occur bit error, the BITEF (UART_LINSTS[9]) flag will be asserted.
S * |        |          |If the LINIEN (UART_INTEN[8]) = 1, an interrupt will be generated.
S * |[19:16] |BRKFL     |LIN Break Field Length
S * |        |          |This field indicates a 4-bit LIN TX break field count.
S * |        |          |Note1: These registers are shadow registers of BRKFL, User can read/write it by setting BRKFL (UART_ALTCTL[3:0]) or BRKFL (UART_LINCTL[19:16]).
S * |        |          |Note2: This break field length is BRKFL + 1.
S * |        |          |Note3: According to LIN spec, the reset value is 12 (break field length = 13).
S * |[21:20] |BSL       |LIN Break/Sync Delimiter Length
S * |        |          |00 = The LIN break/sync delimiter length is 1-bit time.
S * |        |          |01 = The LIN break/sync delimiter length is 2-bit time.
S * |        |          |10 = The LIN break/sync delimiter length is 3-bit time.
S * |        |          |11 = The LIN break/sync delimiter length is 4-bit time.
S * |        |          |Note: This bit used for LIN master to sending header field.
S * |[23:22] |HSEL      |LIN Header Select
S * |        |          |00 = The LIN header includes "break field".
S * |        |          |01 = The LIN header includes "break field" and "sync field".
S * |        |          |10 = The LIN header includes "break field", "sync field" and "frame ID field".
S * |        |          |11 = Reserved.
S * |        |          |Note: This bit is used to master mode for LIN to send header field (SENDH (UART_LINCTL [8]) = 1) or used to slave to indicates exit from mute mode condition (MUTE (UART_LINCTL[4]) = 1).
S * |[31:24] |PID       |LIN PID Bits
S * |        |          |This field contains the LIN frame ID value when in LIN function mode, the frame ID parity can be generated by software or hardware depends on IDPEN (UART_LINCTL[9]) = 1.
S * |        |          |If the parity generated by hardware, user fill ID0~ID5, (PID [29:24] )hardware will calculate P0 (PID[30]) and P1 (PID[31]), otherwise user must filled frame ID and parity in this field.
S * |        |          |Note1: User can fill any 8-bit value to this field and the bit 24 indicates ID0 (LSB first).
S * |        |          |Note2: This field can be used for LIN master mode or slave mode.
S * @var UART_T::LINSTS
S * Offset: 0x38  UART LIN Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |SLVHDETF  |LIN Slave Header Detection Flag (Read Only)
S * |        |          |This bit is set by hardware when a LIN header is detected in LIN slave mode and be cleared by writing 1 to it.
S * |        |          |0 = LIN header not detected.
S * |        |          |1 = LIN header detected (break + sync + frame ID).
S * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
S * |        |          |Note2: This bit is only valid when in LIN slave mode (SLVEN (UART_LINCTL [0]) = 1) and enable LIN slave header detection function (SLVHDEN (UART_LINCTL [1])).
S * |        |          |Note3: When enable ID parity check IDPEN (UART_LINCTL [9]), if hardware detect complete header ("break + sync + frame ID"), the SLVHDETF will be set whether the frame ID correct or not.
S * |[1]     |SLVHEF    |LIN Slave Header Error Flag (Read Only)
S * |        |          |This bit is set by hardware when a LIN header error is detected in LIN slave mode and be cleared by writing 1 to it.
S * |        |          |The header errors include "break delimiter is too short (less than 0.5 bit time)", "frame error in sync field or Identifier field", "sync field data is not 0x55 in Non-Automatic Resynchronization mode", "sync field deviation error with Automatic Resynchronization mode", "sync field measure time-out with Automatic Resynchronization mode" and "LIN header reception time-out".
S * |        |          |0 = LIN header error not detected.
S * |        |          |1 = LIN header error detected.
S * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
S * |        |          |Note2: This bit is only valid when UART is operated in LIN slave mode (SLVEN (UART_LINCTL [0]) = 1) and enables LIN slave header detection function (SLVHDEN (UART_LINCTL [1])).
S * |[2]     |SLVIDPEF  |LIN Slave ID Parity Error Flag
S * |        |          |This bit is set by hardware when receipted frame ID parity is not correct.
S * |        |          |0 = No active.
S * |        |          |1 = Receipted frame ID parity is not correct.
S * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
S * |        |          |Note2: This bit is only valid when in LIN slave mode (SLVEN (UART_LINCTL [0])= 1) and enable LIN frame ID parity check function IDPEN (UART_LINCTL [9]).
S * |[3]     |SLVSYNCF  |LIN Slave Sync Field (Read Only)
S * |        |          |This bit indicates that the LIN sync field is being analyzed in Automatic Resynchronization mode.
S * |        |          |When the receiver header have some error been detect, user must reset the internal circuit to re-search new frame header by writing 1 to this bit.
S * |        |          |0 = The current character is not at LIN sync state.
S * |        |          |1 = The current character is at LIN sync state.
S * |        |          |Note1: This bit is only valid when in LIN Slave mode (SLVEN(UART_LINCTL[0]) = 1).
S * |        |          |Note2: This bit is read only, but it can be cleared by writing 1 to it.
S * |        |          |Note3: When writing 1 to it, hardware will reload the initial baud rate and re-search a new frame header.
S * |[8]     |BRKDETF   |LIN Break Detection Flag (Read Only)
S * |        |          |This bit is set by hardware when a break is detected and be cleared by writing 1 to it through software.
S * |        |          |0 = LIN break not detected.
S * |        |          |1 = LIN break detected.
S * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
S * |        |          |Note2: This bit is only valid when LIN break detection function is enabled (BRKDETEN (UART_LINCTL[10]) =1).
S * |[9]     |BITEF     |Bit Error Detect Status Flag (Read Only)
S * |        |          |At TX transfer state, hardware will monitoring the bus state, if the input pin (SIN) state not equals to the output pin (SOUT) state, BITEF (UART_LINSTS[9]) will be set.
S * |        |          |When occur bit error, if the LINIEN (UART_INTEN[8]) = 1, an interrupt will be generated.
S * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
S * |        |          |Note2: This bit is only valid when enable bit error detection function (BITERREN (UART_LINCTL [12]) = 1).
S */
S
S    __IO uint32_t DAT;           /* Offset: 0x00  UART Receive/Transmit Buffer Register                              */
S    __IO uint32_t INTEN;         /* Offset: 0x04  UART Interrupt Enable Register                                     */
S    __IO uint32_t FIFO;          /* Offset: 0x08  UART FIFO Control Register                                         */
S    __IO uint32_t LINE;          /* Offset: 0x0C  UART Line Control Register                                         */
S    __IO uint32_t MODEM;         /* Offset: 0x10  UART Modem Control Register                                        */
S    __IO uint32_t MODEMSTS;      /* Offset: 0x14  UART Modem Status Register                                         */
S    __IO uint32_t FIFOSTS;       /* Offset: 0x18  UART FIFO Status Register                                          */
S    __IO uint32_t INTSTS;        /* Offset: 0x1C  UART Interrupt Status Register                                     */
S    __IO uint32_t TOUT;          /* Offset: 0x20  UART Time-out Register                                             */
S    __IO uint32_t BAUD;          /* Offset: 0x24  UART Baud Rate Divisor Register                                    */
S    __IO uint32_t IRDA;          /* Offset: 0x28  UART IrDA Control Register                                         */
S    __IO uint32_t ALTCTL;        /* Offset: 0x2C  UART Alternate Control/Status Register                             */
S    __IO uint32_t FUNCSEL;       /* Offset: 0x30  UART Function Select Register                                      */
S    __IO uint32_t LINCTL;        /* Offset: 0x34  UART LIN Control Register                                          */
S    __IO uint32_t LINSTS;        /* Offset: 0x38  UART LIN Status Register                                           */
S
S} UART_T;
S
S
S
S/**
S    @addtogroup UART_CONST UART Bit Field Definition
S    Constant Definitions for UART Controller
S@{ */
S
S#define UART_DAT_DAT_Pos                 (0)                                               /*!< UART_T::DAT: DAT Position                 */
S#define UART_DAT_DAT_Msk                 (0xfful << UART_DAT_DAT_Pos)                      /*!< UART_T::DAT: DAT Mask                     */
S
S#define UART_INTEN_RDAIEN_Pos            (0)                                               /*!< UART_T::INTEN: RDAIEN Position            */
S#define UART_INTEN_RDAIEN_Msk            (0x1ul << UART_INTEN_RDAIEN_Pos)                  /*!< UART_T::INTEN: RDAIEN Mask                */
S
S#define UART_INTEN_THREIEN_Pos           (1)                                               /*!< UART_T::INTEN: THREIEN Position           */
S#define UART_INTEN_THREIEN_Msk           (0x1ul << UART_INTEN_THREIEN_Pos)                 /*!< UART_T::INTEN: THREIEN Mask               */
S
S#define UART_INTEN_RLSIEN_Pos            (2)                                               /*!< UART_T::INTEN: RLSIEN Position            */
S#define UART_INTEN_RLSIEN_Msk            (0x1ul << UART_INTEN_RLSIEN_Pos)                  /*!< UART_T::INTEN: RLSIEN Mask                */
S
S#define UART_INTEN_MODEMIEN_Pos          (3)                                               /*!< UART_T::INTEN: MODEMIEN Position          */
S#define UART_INTEN_MODEMIEN_Msk          (0x1ul << UART_INTEN_MODEMIEN_Pos)                /*!< UART_T::INTEN: MODEMIEN Mask              */
S
S#define UART_INTEN_RXTOIEN_Pos           (4)                                               /*!< UART_T::INTEN: RXTOIEN Position           */
S#define UART_INTEN_RXTOIEN_Msk           (0x1ul << UART_INTEN_RXTOIEN_Pos)                 /*!< UART_T::INTEN: RXTOIEN Mask               */
S
S#define UART_INTEN_BUFERRIEN_Pos         (5)                                               /*!< UART_T::INTEN: BUFERRIEN Position         */
S#define UART_INTEN_BUFERRIEN_Msk         (0x1ul << UART_INTEN_BUFERRIEN_Pos)               /*!< UART_T::INTEN: BUFERRIEN Mask             */
S
S#define UART_INTEN_LINIEN_Pos            (8)                                               /*!< UART_T::INTEN: LINIEN Position            */
S#define UART_INTEN_LINIEN_Msk            (0x1ul << UART_INTEN_LINIEN_Pos)                  /*!< UART_T::INTEN: LINIEN Mask                */
S
S#define UART_INTEN_WKCTSIEN_Pos          (9)                                               /*!< UART_T::INTEN: WKCTSIEN Position          */
S#define UART_INTEN_WKCTSIEN_Msk          (0x1ul << UART_INTEN_WKCTSIEN_Pos)                /*!< UART_T::INTEN: WKCTSIEN Mask              */
S
S#define UART_INTEN_WKDATIEN_Pos          (10)                                              /*!< UART_T::INTEN: WKDATIEN Position          */
S#define UART_INTEN_WKDATIEN_Msk          (0x1ul << UART_INTEN_WKDATIEN_Pos)                /*!< UART_T::INTEN: WKDATIEN Mask              */
S
S#define UART_INTEN_TOCNTEN_Pos           (11)                                              /*!< UART_T::INTEN: TOCNTEN Position           */
S#define UART_INTEN_TOCNTEN_Msk           (0x1ul << UART_INTEN_TOCNTEN_Pos)                 /*!< UART_T::INTEN: TOCNTEN Mask               */
S
S#define UART_INTEN_ATORTSEN_Pos          (12)                                              /*!< UART_T::INTEN: ATORTSEN Position          */
S#define UART_INTEN_ATORTSEN_Msk          (0x1ul << UART_INTEN_ATORTSEN_Pos)                /*!< UART_T::INTEN: ATORTSEN Mask              */
S
S#define UART_INTEN_ATOCTSEN_Pos          (13)                                              /*!< UART_T::INTEN: ATOCTSEN Position          */
S#define UART_INTEN_ATOCTSEN_Msk          (0x1ul << UART_INTEN_ATOCTSEN_Pos)                /*!< UART_T::INTEN: ATOCTSEN Mask              */
S
S#define UART_INTEN_TXPDMAEN_Pos          (14)                                              /*!< UART_T::INTEN: TXPDMAEN Position          */
S#define UART_INTEN_TXPDMAEN_Msk          (0x1ul << UART_INTEN_TXPDMAEN_Pos)                /*!< UART_T::INTEN: TXPDMAEN Mask              */
S
S#define UART_INTEN_RXPDMAEN_Pos          (15)                                              /*!< UART_T::INTEN: RXPDMAEN Position          */
S#define UART_INTEN_RXPDMAEN_Msk          (0x1ul << UART_INTEN_RXPDMAEN_Pos)                /*!< UART_T::INTEN: RXPDMAEN Mask              */
S
S#define UART_INTEN_ABRIEN_Pos            (18)                                              /*!< UART_T::INTEN: ABRIEN Position            */
S#define UART_INTEN_ABRIEN_Msk            (0x1ul << UART_INTEN_ABRIEN_Pos)                  /*!< UART_T::INTEN: ABRIEN Mask                */
S
S#define UART_FIFO_RXRST_Pos              (1)                                               /*!< UART_T::FIFO: RXRST Position              */
S#define UART_FIFO_RXRST_Msk              (0x1ul << UART_FIFO_RXRST_Pos)                    /*!< UART_T::FIFO: RXRST Mask                  */
S
S#define UART_FIFO_TXRST_Pos              (2)                                               /*!< UART_T::FIFO: TXRST Position              */
S#define UART_FIFO_TXRST_Msk              (0x1ul << UART_FIFO_TXRST_Pos)                    /*!< UART_T::FIFO: TXRST Mask                  */
S
S#define UART_FIFO_RFITL_Pos              (4)                                               /*!< UART_T::FIFO: RFITL Position              */
S#define UART_FIFO_RFITL_Msk              (0xful << UART_FIFO_RFITL_Pos)                    /*!< UART_T::FIFO: RFITL Mask                  */
S
S#define UART_FIFO_RXOFF_Pos              (8)                                               /*!< UART_T::FIFO: RXOFF Position              */
S#define UART_FIFO_RXOFF_Msk              (0x1ul << UART_FIFO_RXOFF_Pos)                    /*!< UART_T::FIFO: RXOFF Mask                  */
S
S#define UART_FIFO_RTSTRGLV_Pos           (16)                                              /*!< UART_T::FIFO: RTSTRGLV Position           */
S#define UART_FIFO_RTSTRGLV_Msk           (0xful << UART_FIFO_RTSTRGLV_Pos)                 /*!< UART_T::FIFO: RTSTRGLV Mask               */
S
S#define UART_LINE_WLS_Pos                (0)                                               /*!< UART_T::LINE: WLS Position                */
S#define UART_LINE_WLS_Msk                (0x3ul << UART_LINE_WLS_Pos)                      /*!< UART_T::LINE: WLS Mask                    */
S
S#define UART_LINE_NSB_Pos                (2)                                               /*!< UART_T::LINE: NSB Position                */
S#define UART_LINE_NSB_Msk                (0x1ul << UART_LINE_NSB_Pos)                      /*!< UART_T::LINE: NSB Mask                    */
S
S#define UART_LINE_PBE_Pos                (3)                                               /*!< UART_T::LINE: PBE Position                */
S#define UART_LINE_PBE_Msk                (0x1ul << UART_LINE_PBE_Pos)                      /*!< UART_T::LINE: PBE Mask                    */
S
S#define UART_LINE_EPE_Pos                (4)                                               /*!< UART_T::LINE: EPE Position                */
S#define UART_LINE_EPE_Msk                (0x1ul << UART_LINE_EPE_Pos)                      /*!< UART_T::LINE: EPE Mask                    */
S
S#define UART_LINE_SPE_Pos                (5)                                               /*!< UART_T::LINE: SPE Position                */
S#define UART_LINE_SPE_Msk                (0x1ul << UART_LINE_SPE_Pos)                      /*!< UART_T::LINE: SPE Mask                    */
S
S#define UART_LINE_BCB_Pos                (6)                                               /*!< UART_T::LINE: BCB Position                */
S#define UART_LINE_BCB_Msk                (0x1ul << UART_LINE_BCB_Pos)                      /*!< UART_T::LINE: BCB Mask                    */
S
S#define UART_MODEM_RTS_Pos               (1)                                               /*!< UART_T::MODEM: RTS Position               */
S#define UART_MODEM_RTS_Msk               (0x1ul << UART_MODEM_RTS_Pos)                     /*!< UART_T::MODEM: RTS Mask                   */
S
S#define UART_MODEM_RTSACTLV_Pos          (9)                                               /*!< UART_T::MODEM: RTSACTLV Position          */
S#define UART_MODEM_RTSACTLV_Msk          (0x1ul << UART_MODEM_RTSACTLV_Pos)                /*!< UART_T::MODEM: RTSACTLV Mask              */
S
S#define UART_MODEM_RTSSTS_Pos            (13)                                              /*!< UART_T::MODEM: RTSSTS Position            */
S#define UART_MODEM_RTSSTS_Msk            (0x1ul << UART_MODEM_RTSSTS_Pos)                  /*!< UART_T::MODEM: RTSSTS Mask                */
S
S#define UART_MODEMSTS_CTSDETF_Pos        (0)                                               /*!< UART_T::MODEMSTS: CTSDETF Position        */
S#define UART_MODEMSTS_CTSDETF_Msk        (0x1ul << UART_MODEMSTS_CTSDETF_Pos)              /*!< UART_T::MODEMSTS: CTSDETF Mask            */
S
S#define UART_MODEMSTS_CTSSTS_Pos         (4)                                               /*!< UART_T::MODEMSTS: CTSSTS Position         */
S#define UART_MODEMSTS_CTSSTS_Msk         (0x1ul << UART_MODEMSTS_CTSSTS_Pos)               /*!< UART_T::MODEMSTS: CTSSTS Mask             */
S
S#define UART_MODEMSTS_CTSACTLV_Pos       (8)                                               /*!< UART_T::MODEMSTS: CTSACTLV Position       */
S#define UART_MODEMSTS_CTSACTLV_Msk       (0x1ul << UART_MODEMSTS_CTSACTLV_Pos)             /*!< UART_T::MODEMSTS: CTSACTLV Mask           */
S
S#define UART_FIFOSTS_RXOVIF_Pos          (0)                                               /*!< UART_T::FIFOSTS: RXOVIF Position          */
S#define UART_FIFOSTS_RXOVIF_Msk          (0x1ul << UART_FIFOSTS_RXOVIF_Pos)                /*!< UART_T::FIFOSTS: RXOVIF Mask              */
S
S#define UART_FIFOSTS_ABRDIF_Pos          (1)                                               /*!< UART_T::FIFOSTS: ABRDIF Position          */
S#define UART_FIFOSTS_ABRDIF_Msk          (0x1ul << UART_FIFOSTS_ABRDIF_Pos)                /*!< UART_T::FIFOSTS: ABRDIF Mask              */
S
S#define UART_FIFOSTS_ABRDTOIF_Pos        (2)                                               /*!< UART_T::FIFOSTS: ABRDTOIF Position        */
S#define UART_FIFOSTS_ABRDTOIF_Msk        (0x1ul << UART_FIFOSTS_ABRDTOIF_Pos)              /*!< UART_T::FIFOSTS: ABRDTOIF Mask            */
S
S#define UART_FIFOSTS_ADDRDETF_Pos        (3)                                               /*!< UART_T::FIFOSTS: ADDRDETF Position        */
S#define UART_FIFOSTS_ADDRDETF_Msk        (0x1ul << UART_FIFOSTS_ADDRDETF_Pos)              /*!< UART_T::FIFOSTS: ADDRDETF Mask            */
S
S#define UART_FIFOSTS_PEF_Pos             (4)                                               /*!< UART_T::FIFOSTS: PEF Position             */
S#define UART_FIFOSTS_PEF_Msk             (0x1ul << UART_FIFOSTS_PEF_Pos)                   /*!< UART_T::FIFOSTS: PEF Mask                 */
S
S#define UART_FIFOSTS_FEF_Pos             (5)                                               /*!< UART_T::FIFOSTS: FEF Position             */
S#define UART_FIFOSTS_FEF_Msk             (0x1ul << UART_FIFOSTS_FEF_Pos)                   /*!< UART_T::FIFOSTS: FEF Mask                 */
S
S#define UART_FIFOSTS_BIF_Pos             (6)                                               /*!< UART_T::FIFOSTS: BIF Position             */
S#define UART_FIFOSTS_BIF_Msk             (0x1ul << UART_FIFOSTS_BIF_Pos)                   /*!< UART_T::FIFOSTS: BIF Mask                 */
S
S#define UART_FIFOSTS_RXPTR_Pos           (8)                                               /*!< UART_T::FIFOSTS: RXPTR Position           */
S#define UART_FIFOSTS_RXPTR_Msk           (0x3ful << UART_FIFOSTS_RXPTR_Pos)                /*!< UART_T::FIFOSTS: RXPTR Mask               */
S
S#define UART_FIFOSTS_RXEMPTY_Pos         (14)                                              /*!< UART_T::FIFOSTS: RXEMPTY Position         */
S#define UART_FIFOSTS_RXEMPTY_Msk         (0x1ul << UART_FIFOSTS_RXEMPTY_Pos)               /*!< UART_T::FIFOSTS: RXEMPTY Mask             */
S
S#define UART_FIFOSTS_RXFULL_Pos          (15)                                              /*!< UART_T::FIFOSTS: RXFULL Position          */
S#define UART_FIFOSTS_RXFULL_Msk          (0x1ul << UART_FIFOSTS_RXFULL_Pos)                /*!< UART_T::FIFOSTS: RXFULL Mask              */
S
S#define UART_FIFOSTS_TXPTR_Pos           (16)                                              /*!< UART_T::FIFOSTS: TXPTR Position           */
S#define UART_FIFOSTS_TXPTR_Msk           (0x3ful << UART_FIFOSTS_TXPTR_Pos)                /*!< UART_T::FIFOSTS: TXPTR Mask               */
S
S#define UART_FIFOSTS_TXEMPTY_Pos         (22)                                              /*!< UART_T::FIFOSTS: TXEMPTY Position         */
S#define UART_FIFOSTS_TXEMPTY_Msk         (0x1ul << UART_FIFOSTS_TXEMPTY_Pos)               /*!< UART_T::FIFOSTS: TXEMPTY Mask             */
S
S#define UART_FIFOSTS_TXFULL_Pos          (23)                                              /*!< UART_T::FIFOSTS: TXFULL Position          */
S#define UART_FIFOSTS_TXFULL_Msk          (0x1ul << UART_FIFOSTS_TXFULL_Pos)                /*!< UART_T::FIFOSTS: TXFULL Mask              */
S
S#define UART_FIFOSTS_TXOVIF_Pos          (24)                                              /*!< UART_T::FIFOSTS: TXOVIF Position          */
S#define UART_FIFOSTS_TXOVIF_Msk          (0x1ul << UART_FIFOSTS_TXOVIF_Pos)                /*!< UART_T::FIFOSTS: TXOVIF Mask              */
S
S#define UART_FIFOSTS_TXEMPTYF_Pos        (28)                                              /*!< UART_T::FIFOSTS: TXEMPTYF Position        */
S#define UART_FIFOSTS_TXEMPTYF_Msk        (0x1ul << UART_FIFOSTS_TXEMPTYF_Pos)              /*!< UART_T::FIFOSTS: TXEMPTYF Mask            */
S
S#define UART_INTSTS_RDAIF_Pos            (0)                                               /*!< UART_T::INTSTS: RDAIF Position            */
S#define UART_INTSTS_RDAIF_Msk            (0x1ul << UART_INTSTS_RDAIF_Pos)                  /*!< UART_T::INTSTS: RDAIF Mask                */
S
S#define UART_INTSTS_THREIF_Pos           (1)                                               /*!< UART_T::INTSTS: THREIF Position           */
S#define UART_INTSTS_THREIF_Msk           (0x1ul << UART_INTSTS_THREIF_Pos)                 /*!< UART_T::INTSTS: THREIF Mask               */
S
S#define UART_INTSTS_RLSIF_Pos            (2)                                               /*!< UART_T::INTSTS: RLSIF Position            */
S#define UART_INTSTS_RLSIF_Msk            (0x1ul << UART_INTSTS_RLSIF_Pos)                  /*!< UART_T::INTSTS: RLSIF Mask                */
S
S#define UART_INTSTS_MODEMIF_Pos          (3)                                               /*!< UART_T::INTSTS: MODEMIF Position          */
S#define UART_INTSTS_MODEMIF_Msk          (0x1ul << UART_INTSTS_MODEMIF_Pos)                /*!< UART_T::INTSTS: MODEMIF Mask              */
S
S#define UART_INTSTS_RXTOIF_Pos           (4)                                               /*!< UART_T::INTSTS: RXTOIF Position           */
S#define UART_INTSTS_RXTOIF_Msk           (0x1ul << UART_INTSTS_RXTOIF_Pos)                 /*!< UART_T::INTSTS: RXTOIF Mask               */
S
S#define UART_INTSTS_BUFERRIF_Pos         (5)                                               /*!< UART_T::INTSTS: BUFERRIF Position         */
S#define UART_INTSTS_BUFERRIF_Msk         (0x1ul << UART_INTSTS_BUFERRIF_Pos)               /*!< UART_T::INTSTS: BUFERRIF Mask             */
S
S#define UART_INTSTS_WKIF_Pos             (6)                                               /*!< UART_T::INTSTS: WKIF Position             */
S#define UART_INTSTS_WKIF_Msk             (0x1ul << UART_INTSTS_WKIF_Pos)                   /*!< UART_T::INTSTS: WKIF Mask                 */
S
S#define UART_INTSTS_LINIF_Pos            (7)                                               /*!< UART_T::INTSTS: LINIF Position            */
S#define UART_INTSTS_LINIF_Msk            (0x1ul << UART_INTSTS_LINIF_Pos)                  /*!< UART_T::INTSTS: LINIF Mask                */
S
S#define UART_INTSTS_RDAINT_Pos           (8)                                               /*!< UART_T::INTSTS: RDAINT Position           */
S#define UART_INTSTS_RDAINT_Msk           (0x1ul << UART_INTSTS_RDAINT_Pos)                 /*!< UART_T::INTSTS: RDAINT Mask               */
S
S#define UART_INTSTS_THREINT_Pos          (9)                                               /*!< UART_T::INTSTS: THREINT Position          */
S#define UART_INTSTS_THREINT_Msk          (0x1ul << UART_INTSTS_THREINT_Pos)                /*!< UART_T::INTSTS: THREINT Mask              */
S
S#define UART_INTSTS_RLSINT_Pos           (10)                                              /*!< UART_T::INTSTS: RLSINT Position           */
S#define UART_INTSTS_RLSINT_Msk           (0x1ul << UART_INTSTS_RLSINT_Pos)                 /*!< UART_T::INTSTS: RLSINT Mask               */
S
S#define UART_INTSTS_MODEMINT_Pos         (11)                                              /*!< UART_T::INTSTS: MODEMINT Position         */
S#define UART_INTSTS_MODEMINT_Msk         (0x1ul << UART_INTSTS_MODEMINT_Pos)               /*!< UART_T::INTSTS: MODEMINT Mask             */
S
S#define UART_INTSTS_RXTOINT_Pos          (12)                                              /*!< UART_T::INTSTS: RXTOINT Position          */
S#define UART_INTSTS_RXTOINT_Msk          (0x1ul << UART_INTSTS_RXTOINT_Pos)                /*!< UART_T::INTSTS: RXTOINT Mask              */
S
S#define UART_INTSTS_BUFERRINT_Pos        (13)                                              /*!< UART_T::INTSTS: BUFERRINT Position        */
S#define UART_INTSTS_BUFERRINT_Msk        (0x1ul << UART_INTSTS_BUFERRINT_Pos)              /*!< UART_T::INTSTS: BUFERRINT Mask            */
S
S#define UART_INTSTS_LININT_Pos           (15)                                              /*!< UART_T::INTSTS: LININT Position           */
S#define UART_INTSTS_LININT_Msk           (0x1ul << UART_INTSTS_LININT_Pos)                 /*!< UART_T::INTSTS: LININT Mask               */
S
S#define UART_INTSTS_CTSWKIF_Pos          (16)                                              /*!< UART_T::INTSTS: CTSWKIF Position          */
S#define UART_INTSTS_CTSWKIF_Msk          (0x1ul << UART_INTSTS_CTSWKIF_Pos)                /*!< UART_T::INTSTS: CTSWKIF Mask              */
S
S#define UART_INTSTS_DATWKIF_Pos          (17)                                              /*!< UART_T::INTSTS: DATWKIF Position          */
S#define UART_INTSTS_DATWKIF_Msk          (0x1ul << UART_INTSTS_DATWKIF_Pos)                /*!< UART_T::INTSTS: DATWKIF Mask              */
S
S#define UART_INTSTS_HWRLSIF_Pos          (18)                                              /*!< UART_T::INTSTS: HWRLSIF Position          */
S#define UART_INTSTS_HWRLSIF_Msk          (0x1ul << UART_INTSTS_HWRLSIF_Pos)                /*!< UART_T::INTSTS: HWRLSIF Mask              */
S
S#define UART_INTSTS_HWMODIF_Pos          (19)                                              /*!< UART_T::INTSTS: HWMODIF Position          */
S#define UART_INTSTS_HWMODIF_Msk          (0x1ul << UART_INTSTS_HWMODIF_Pos)                /*!< UART_T::INTSTS: HWMODIF Mask              */
S
S#define UART_INTSTS_HWTOIF_Pos           (20)                                              /*!< UART_T::INTSTS: HWTOIF Position           */
S#define UART_INTSTS_HWTOIF_Msk           (0x1ul << UART_INTSTS_HWTOIF_Pos)                 /*!< UART_T::INTSTS: HWTOIF Mask               */
S
S#define UART_INTSTS_HWBUFEIF_Pos         (21)                                              /*!< UART_T::INTSTS: HWBUFEIF Position         */
S#define UART_INTSTS_HWBUFEIF_Msk         (0x1ul << UART_INTSTS_HWBUFEIF_Pos)               /*!< UART_T::INTSTS: HWBUFEIF Mask             */
S
S#define UART_INTSTS_HWRLSINT_Pos         (26)                                              /*!< UART_T::INTSTS: HWRLSINT Position         */
S#define UART_INTSTS_HWRLSINT_Msk         (0x1ul << UART_INTSTS_HWRLSINT_Pos)               /*!< UART_T::INTSTS: HWRLSINT Mask             */
S
S#define UART_INTSTS_HWMODINT_Pos         (27)                                              /*!< UART_T::INTSTS: HWMODINT Position         */
S#define UART_INTSTS_HWMODINT_Msk         (0x1ul << UART_INTSTS_HWMODINT_Pos)               /*!< UART_T::INTSTS: HWMODINT Mask             */
S
S#define UART_INTSTS_HWTOINT_Pos          (28)                                              /*!< UART_T::INTSTS: HWTOINT Position          */
S#define UART_INTSTS_HWTOINT_Msk          (0x1ul << UART_INTSTS_HWTOINT_Pos)                /*!< UART_T::INTSTS: HWTOINT Mask              */
S
S#define UART_INTSTS_HWBUFEINT_Pos        (29)                                              /*!< UART_T::INTSTS: HWBUFEINT Position        */
S#define UART_INTSTS_HWBUFEINT_Msk        (0x1ul << UART_INTSTS_HWBUFEINT_Pos)              /*!< UART_T::INTSTS: HWBUFEINT Mask            */
S
S#define UART_TOUT_TOIC_Pos               (0)                                               /*!< UART_T::TOUT: TOIC Position               */
S#define UART_TOUT_TOIC_Msk               (0xfful << UART_TOUT_TOIC_Pos)                    /*!< UART_T::TOUT: TOIC Mask                   */
S
S#define UART_TOUT_DLY_Pos                (8)                                               /*!< UART_T::TOUT: DLY Position                */
S#define UART_TOUT_DLY_Msk                (0xfful << UART_TOUT_DLY_Pos)                     /*!< UART_T::TOUT: DLY Mask                    */
S
S#define UART_BAUD_BRD_Pos                (0)                                               /*!< UART_T::BAUD: BRD Position                */
S#define UART_BAUD_BRD_Msk                (0xfffful << UART_BAUD_BRD_Pos)                   /*!< UART_T::BAUD: BRD Mask                    */
S
S#define UART_BAUD_EDIVM1_Pos             (24)                                              /*!< UART_T::BAUD: EDIVM1 Position             */
S#define UART_BAUD_EDIVM1_Msk             (0xful << UART_BAUD_EDIVM1_Pos)                   /*!< UART_T::BAUD: EDIVM1 Mask                 */
S
S#define UART_BAUD_BAUDM0_Pos             (28)                                              /*!< UART_T::BAUD: BAUDM0 Position             */
S#define UART_BAUD_BAUDM0_Msk             (0x1ul << UART_BAUD_BAUDM0_Pos)                   /*!< UART_T::BAUD: BAUDM0 Mask                 */
S
S#define UART_BAUD_BAUDM1_Pos             (29)                                              /*!< UART_T::BAUD: BAUDM1 Position             */
S#define UART_BAUD_BAUDM1_Msk             (0x1ul << UART_BAUD_BAUDM1_Pos)                   /*!< UART_T::BAUD: BAUDM1 Mask                 */
S
S#define UART_IRDA_TXEN_Pos               (1)                                               /*!< UART_T::IRDA: TXEN Position               */
S#define UART_IRDA_TXEN_Msk               (0x1ul << UART_IRDA_TXEN_Pos)                     /*!< UART_T::IRDA: TXEN Mask                   */
S
S#define UART_IRDA_TXINV_Pos              (5)                                               /*!< UART_T::IRDA: TXINV Position              */
S#define UART_IRDA_TXINV_Msk              (0x1ul << UART_IRDA_TXINV_Pos)                    /*!< UART_T::IRDA: TXINV Mask                  */
S
S#define UART_IRDA_RXINV_Pos              (6)                                               /*!< UART_T::IRDA: RXINV Position              */
S#define UART_IRDA_RXINV_Msk              (0x1ul << UART_IRDA_RXINV_Pos)                    /*!< UART_T::IRDA: RXINV Mask                  */
S
S#define UART_ALTCTL_BRKFL_Pos            (0)                                               /*!< UART_T::ALTCTL: BRKFL Position            */
S#define UART_ALTCTL_BRKFL_Msk            (0xful << UART_ALTCTL_BRKFL_Pos)                  /*!< UART_T::ALTCTL: BRKFL Mask                */
S
S#define UART_ALTCTL_LINRXEN_Pos          (6)                                               /*!< UART_T::ALTCTL: LINRXEN Position          */
S#define UART_ALTCTL_LINRXEN_Msk          (0x1ul << UART_ALTCTL_LINRXEN_Pos)                /*!< UART_T::ALTCTL: LINRXEN Mask              */
S
S#define UART_ALTCTL_LINTXEN_Pos          (7)                                               /*!< UART_T::ALTCTL: LINTXEN Position          */
S#define UART_ALTCTL_LINTXEN_Msk          (0x1ul << UART_ALTCTL_LINTXEN_Pos)                /*!< UART_T::ALTCTL: LINTXEN Mask              */
S
S#define UART_ALTCTL_RS485NMM_Pos         (8)                                               /*!< UART_T::ALTCTL: RS485NMM Position         */
S#define UART_ALTCTL_RS485NMM_Msk         (0x1ul << UART_ALTCTL_RS485NMM_Pos)               /*!< UART_T::ALTCTL: RS485NMM Mask             */
S
S#define UART_ALTCTL_RS485AAD_Pos         (9)                                               /*!< UART_T::ALTCTL: RS485AAD Position         */
S#define UART_ALTCTL_RS485AAD_Msk         (0x1ul << UART_ALTCTL_RS485AAD_Pos)               /*!< UART_T::ALTCTL: RS485AAD Mask             */
S
S#define UART_ALTCTL_RS485AUD_Pos         (10)                                              /*!< UART_T::ALTCTL: RS485AUD Position         */
S#define UART_ALTCTL_RS485AUD_Msk         (0x1ul << UART_ALTCTL_RS485AUD_Pos)               /*!< UART_T::ALTCTL: RS485AUD Mask             */
S
S#define UART_ALTCTL_ADDRDEN_Pos          (15)                                              /*!< UART_T::ALTCTL: ADDRDEN Position          */
S#define UART_ALTCTL_ADDRDEN_Msk          (0x1ul << UART_ALTCTL_ADDRDEN_Pos)                /*!< UART_T::ALTCTL: ADDRDEN Mask              */
S
S#define UART_ALTCTL_ABRIF_Pos            (17)                                              /*!< UART_T::ALTCTL: ABRIF Position            */
S#define UART_ALTCTL_ABRIF_Msk            (0x1ul << UART_ALTCTL_ABRIF_Pos)                  /*!< UART_T::ALTCTL: ABRIF Mask                */
S
S#define UART_ALTCTL_ABRDEN_Pos           (18)                                              /*!< UART_T::ALTCTL: ABRDEN Position           */
S#define UART_ALTCTL_ABRDEN_Msk           (0x1ul << UART_ALTCTL_ABRDEN_Pos)                 /*!< UART_T::ALTCTL: ABRDEN Mask               */
S
S#define UART_ALTCTL_ABRDBITS_Pos         (19)                                              /*!< UART_T::ALTCTL: ABRDBITS Position         */
S#define UART_ALTCTL_ABRDBITS_Msk         (0x3ul << UART_ALTCTL_ABRDBITS_Pos)               /*!< UART_T::ALTCTL: ABRDBITS Mask             */
S
S#define UART_ALTCTL_ADDRMV_Pos           (24)                                              /*!< UART_T::ALTCTL: ADDRMV Position           */
S#define UART_ALTCTL_ADDRMV_Msk           (0xfful << UART_ALTCTL_ADDRMV_Pos)                /*!< UART_T::ALTCTL: ADDRMV Mask               */
S
S#define UART_FUNCSEL_FUNCSEL_Pos         (0)                                               /*!< UART_T::FUNCSEL: FUNCSEL Position         */
S#define UART_FUNCSEL_FUNCSEL_Msk         (0x3ul << UART_FUNCSEL_FUNCSEL_Pos)               /*!< UART_T::FUNCSEL: FUNCSEL Mask             */
S
S#define UART_LINCTL_SLVEN_Pos            (0)                                               /*!< UART_T::LINCTL: SLVEN Position            */
S#define UART_LINCTL_SLVEN_Msk            (0x1ul << UART_LINCTL_SLVEN_Pos)                  /*!< UART_T::LINCTL: SLVEN Mask                */
S
S#define UART_LINCTL_SLVHDEN_Pos          (1)                                               /*!< UART_T::LINCTL: SLVHDEN Position          */
S#define UART_LINCTL_SLVHDEN_Msk          (0x1ul << UART_LINCTL_SLVHDEN_Pos)                /*!< UART_T::LINCTL: SLVHDEN Mask              */
S
S#define UART_LINCTL_SLVAREN_Pos          (2)                                               /*!< UART_T::LINCTL: SLVAREN Position          */
S#define UART_LINCTL_SLVAREN_Msk          (0x1ul << UART_LINCTL_SLVAREN_Pos)                /*!< UART_T::LINCTL: SLVAREN Mask              */
S
S#define UART_LINCTL_SLVDUEN_Pos          (3)                                               /*!< UART_T::LINCTL: SLVDUEN Position          */
S#define UART_LINCTL_SLVDUEN_Msk          (0x1ul << UART_LINCTL_SLVDUEN_Pos)                /*!< UART_T::LINCTL: SLVDUEN Mask              */
S
S#define UART_LINCTL_MUTE_Pos             (4)                                               /*!< UART_T::LINCTL: MUTE Position             */
S#define UART_LINCTL_MUTE_Msk             (0x1ul << UART_LINCTL_MUTE_Pos)                   /*!< UART_T::LINCTL: MUTE Mask                 */
S
S#define UART_LINCTL_SENDH_Pos            (8)                                               /*!< UART_T::LINCTL: SENDH Position            */
S#define UART_LINCTL_SENDH_Msk            (0x1ul << UART_LINCTL_SENDH_Pos)                  /*!< UART_T::LINCTL: SENDH Mask                */
S
S#define UART_LINCTL_IDPEN_Pos            (9)                                               /*!< UART_T::LINCTL: IDPEN Position            */
S#define UART_LINCTL_IDPEN_Msk            (0x1ul << UART_LINCTL_IDPEN_Pos)                  /*!< UART_T::LINCTL: IDPEN Mask                */
S
S#define UART_LINCTL_BRKDETEN_Pos         (10)                                              /*!< UART_T::LINCTL: BRKDETEN Position         */
S#define UART_LINCTL_BRKDETEN_Msk         (0x1ul << UART_LINCTL_BRKDETEN_Pos)               /*!< UART_T::LINCTL: BRKDETEN Mask             */
S
S#define UART_LINCTL_RXOFF_Pos            (11)                                              /*!< UART_T::LINCTL: RXOFF Position            */
S#define UART_LINCTL_RXOFF_Msk            (0x1ul << UART_LINCTL_RXOFF_Pos)                  /*!< UART_T::LINCTL: RXOFF Mask                */
S
S#define UART_LINCTL_BITERREN_Pos         (12)                                              /*!< UART_T::LINCTL: BITERREN Position         */
S#define UART_LINCTL_BITERREN_Msk         (0x1ul << UART_LINCTL_BITERREN_Pos)               /*!< UART_T::LINCTL: BITERREN Mask             */
S
S#define UART_LINCTL_BRKFL_Pos            (16)                                              /*!< UART_T::LINCTL: BRKFL Position            */
S#define UART_LINCTL_BRKFL_Msk            (0xful << UART_LINCTL_BRKFL_Pos)                  /*!< UART_T::LINCTL: BRKFL Mask                */
S
S#define UART_LINCTL_BSL_Pos              (20)                                              /*!< UART_T::LINCTL: BSL Position              */
S#define UART_LINCTL_BSL_Msk              (0x3ul << UART_LINCTL_BSL_Pos)                    /*!< UART_T::LINCTL: BSL Mask                  */
S
S#define UART_LINCTL_HSEL_Pos             (22)                                              /*!< UART_T::LINCTL: HSEL Position             */
S#define UART_LINCTL_HSEL_Msk             (0x3ul << UART_LINCTL_HSEL_Pos)                   /*!< UART_T::LINCTL: HSEL Mask                 */
S
S#define UART_LINCTL_PID_Pos              (24)                                              /*!< UART_T::LINCTL: PID Position              */
S#define UART_LINCTL_PID_Msk              (0xfful << UART_LINCTL_PID_Pos)                   /*!< UART_T::LINCTL: PID Mask                  */
S
S#define UART_LINSTS_SLVHDETF_Pos         (0)                                               /*!< UART_T::LINSTS: SLVHDETF Position         */
S#define UART_LINSTS_SLVHDETF_Msk         (0x1ul << UART_LINSTS_SLVHDETF_Pos)               /*!< UART_T::LINSTS: SLVHDETF Mask             */
S
S#define UART_LINSTS_SLVHEF_Pos           (1)                                               /*!< UART_T::LINSTS: SLVHEF Position           */
S#define UART_LINSTS_SLVHEF_Msk           (0x1ul << UART_LINSTS_SLVHEF_Pos)                 /*!< UART_T::LINSTS: SLVHEF Mask               */
S
S#define UART_LINSTS_SLVIDPEF_Pos         (2)                                               /*!< UART_T::LINSTS: SLVIDPEF Position         */
S#define UART_LINSTS_SLVIDPEF_Msk         (0x1ul << UART_LINSTS_SLVIDPEF_Pos)               /*!< UART_T::LINSTS: SLVIDPEF Mask             */
S
S#define UART_LINSTS_SLVSYNCF_Pos         (3)                                               /*!< UART_T::LINSTS: SLVSYNCF Position         */
S#define UART_LINSTS_SLVSYNCF_Msk         (0x1ul << UART_LINSTS_SLVSYNCF_Pos)               /*!< UART_T::LINSTS: SLVSYNCF Mask             */
S
S#define UART_LINSTS_BRKDETF_Pos          (8)                                               /*!< UART_T::LINSTS: BRKDETF Position          */
S#define UART_LINSTS_BRKDETF_Msk          (0x1ul << UART_LINSTS_BRKDETF_Pos)                /*!< UART_T::LINSTS: BRKDETF Mask              */
S
S#define UART_LINSTS_BITEF_Pos            (9)                                               /*!< UART_T::LINSTS: BITEF Position            */
S#define UART_LINSTS_BITEF_Msk            (0x1ul << UART_LINSTS_BITEF_Pos)                  /*!< UART_T::LINSTS: BITEF Mask                */
S
S
S/**@}*/ /* UART_CONST */
S/**@}*/ /* end of UART register group */
S
S
S/*---------------------- Universal Serial Bus Controller -------------------------*/
S/**
S    @addtogroup USB Universal Serial Bus Controller(USB)
S    Memory Mapped Structure for USB Controller
S@{ */
S
S/**
S  * @brief USBD endpoints register
S  */
S
Stypedef struct
S{
S
S
S/**
S * @var USBD_EP_T::BUFSEG
S * Offset: 0x500/0x510/0x520/0x530/0x540/0x550/0x560/0x570  Endpoint 0~7 Buffer Segmentation Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[8:3]   |BUFSEG    |Endpoint Buffer Segmentation
S * |        |          |It is used to indicate the offset address for each endpoint with the USB SRAM starting address The effective starting address of the endpoint is
S * |        |          |USB_SRAM address + { BUFSEG[8:3], 3'b000}
S * |        |          |Where the USB_SRAM address = USBD_BA+0x100h.
S * |        |          |Refer to the section 5.4.4.7 for the endpoint SRAM structure and its description.
S * @var USBD_EP_T::MXPLD
S * Offset: 0x504/0x514/0x524/0x534/0x544/0x554/0x564/0x574  Endpoint 0~7 Maximal Payload Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[8:0]   |MXPLD     |Maximal Payload
S * |        |          |Define the data length which is transmitted to host (IN token) or the actual data length which is received from the host (OUT token).
S * |        |          |It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.
S * |        |          |(1) When the register is written by CPU,
S * |        |          |For IN token, the value of MXPLD is used to define the data length to be transmitted and indicate the data buffer is ready.
S * |        |          |For OUT token, it means that the controller is ready to receive data from the host and the value of MXPLD is the maximal data length comes from host.
S * |        |          |(2) When the register is read by CPU,
S * |        |          |For IN token, the value of MXPLD is indicated by the data length be transmitted to host
S * |        |          |For OUT token, the value of MXPLD is indicated the actual data length receiving from host.
S * |        |          |Note: Once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.
S * @var USBD_EP_T::CFG
S * Offset: 0x508/0x518/0x528/0x538/0x548/0x558/0x568/0x578  Endpoint 0~7 Configuration Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |EPNUM     |Endpoint Number
S * |        |          |These bits are used to define the endpoint number of the current endpoint.
S * |[4]     |ISOCH     |Isochronous Endpoint
S * |        |          |This bit is used to set the endpoint as Isochronous endpoint, no handshake.
S * |        |          |0 = No Isochronous endpoint.
S * |        |          |1 = Isochronous endpoint.
S * |[6:5]   |STATE     |Endpoint STATE
S * |        |          |00 = Endpoint is Disabled.
S * |        |          |01 = Out endpoint.
S * |        |          |10 = IN endpoint.
S * |        |          |11 = Undefined.
S * |[7]     |DSQSYNC   |Data Sequence Synchronization
S * |        |          |0 = DATA0 PID.
S * |        |          |1 = DATA1 PID.
S * |        |          |Note: It is used to specify the DATA0 or DATA1 PID in the following IN token transaction.
S * |        |          |Hardware will toggle automatically in IN token base on the bit.
S * |[9]     |CSTALL    |Clear STALL Response
S * |        |          |0 = Disable the device to clear the STALL handshake in setup stage.
S * |        |          |1 = Clear the device to response STALL handshake in setup stage.
S * @var USBD_EP_T::CFGP
S * Offset: 0x50C/0x51C/0x52C/0x53C/0x54C/0x55C/0x56C/0x57C  Endpoint 0~7 Set Stall and Clear In/Out Ready Control Register
S    * ---------------------------------------------------------------------------------------------------
S    * |Bits    |Field     |Descriptions
S    * | :----: | :----:   | :---- |
S    * |[0]     |CLRRDY    |Clear Ready
S    * |        |          |When the USB_MXPLD register is set by user, it means that the endpoint is ready to transmit or receive data.
S    * |        |          |If the user wants to turn off this transaction before the transaction start, users can set this bit to 1 to turn it off and it will be cleared to 0 automatically.
S    * |        |          |For IN token, write 1 to clear the IN token had ready to transmit the data to USB.
S    * |        |          |For OUT token, write 1 to clear the OUT token had ready to receive the data from USB.
S    * |        |          |This bit is write 1 only and is always 0 when it is read back.
S    * |[1]     |SSTALL    |Set STALL
S    * |        |          |0 = Disable the device to response STALL.
S    * |        |          |1 = Set the device to respond STALL automatically.
S    */
S
S    __IO uint32_t BUFSEG;        /* Offset: 0x500/0x510/0x520/0x530/0x540/0x550/0x560/0x570  Endpoint 0~7 Buffer Segmentation Register */
S    __IO uint32_t MXPLD;         /* Offset: 0x504/0x514/0x524/0x534/0x544/0x554/0x564/0x574  Endpoint 0~7 Maximal Payload Register */
S    __IO uint32_t CFG;           /* Offset: 0x508/0x518/0x528/0x538/0x548/0x558/0x568/0x578  Endpoint 0~7 Configuration Register */
S    __IO uint32_t CFGP;          /* Offset: 0x50C/0x51C/0x52C/0x53C/0x54C/0x55C/0x56C/0x57C  Endpoint 0~7 Set Stall and Clear In/Out Ready Control Register */
S
S} USBD_EP_T;
S
S
S
S
S
Stypedef struct
S{
S
S
S/**
S * @var USBD_T::INTEN
S * Offset: 0x00  USB Interrupt Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |BUSIEN    |Bus Event Interrupt Enable
S * |        |          |0 = BUS event interrupt Disabled.
S * |        |          |1 = BUS event interrupt Enabled.
S * |[1]     |USBIEN    |USB Event Interrupt Enable
S * |        |          |0 = USB event interrupt Disabled.
S * |        |          |1 = USB event interrupt Enabled.
S * |[2]     |VBDETIEN  |VBUS Detection Interrupt Enable
S * |        |          |0 = Floating detection Interrupt Disabled.
S * |        |          |1 = Floating detection Interrupt Enabled.
S * |[3]     |NEVWKIEN  |USB No-Event-Wake-Up Interrupt Enable
S * |        |          |0 = No-Event-Wake-up Interrupt Disabled.
S * |        |          |1 = No-Event-Wake-up Interrupt Enabled.
S * |[8]     |WKEN      |Wake-Up Function Enable
S * |        |          |0 = USB wake-up function Disabled.
S * |        |          |1 = USB wake-up function Enabled.
S * |[15]    |INNAKEN   |Active NAK Function And Its Status In IN Token
S * |        |          |0 = When device responds NAK after receiving IN token, IN NAK status will not be
S * |        |          |    updated to USBD_EPSTS register, so that the USB interrupt event will not be asserted.
S * |        |          |1 = IN NAK status will be updated to USBD_EPSTS register and the USB interrupt event
S * |        |          |    will be asserted, when the device responds NAK after receiving IN token.
S * @var USBD_T::INTSTS
S * Offset: 0x04  USB Interrupt Event Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |BUSIF     |BUS Interrupt Status
S * |        |          |The BUS event means that there is one of the suspense or the resume function in the bus.
S * |        |          |0 = No BUS event occurred.
S * |        |          |1 = Bus event occurred; check USB_ATTR[3:0] to know which kind of bus event was occurred, cleared by write 1 to USB_INTSTS[0].
S * |[1]     |USBIF     |USB Event Interrupt Status
S * |        |          |The USB event includes the SETUP Token, IN Token, OUT ACK, ISO IN, or ISO OUT events in the bus.
S * |        |          |0 = No USB event occurred.
S * |        |          |1 = USB event occurred, check EPSTS0~7 to know which kind of USB event occurred.
S * |        |          |Cleared by write 1 to USB_INTSTS[1] or EPEVT0~7 and SETUP (USB_INTSTS[31]).
S * |[2]     |VBDETIF   |VBUS Detection Interrupt Status
S * |        |          |0 = There is not attached/detached event in the USB.
S * |        |          |1 = There is attached/detached event in the USB bus and it is cleared by write 1 to USB_INTSTS[2].
S * |[3]     |NEVWKIF   |USB No-Event-Wake-Up Interrupt Status
S * |        |          |0 = No Wake-up event occurred.
S * |        |          |1 = Wake-up event occurred, cleared by write 1 to USB_INTSTS[3].
S * |[16]    |EPEVT0    |Endpoint 0's USB Event Status
S * |        |          |0 = No event occurred on endpoint 0.
S * |        |          |1 = USB event occurred on Endpoint 0, check USB_EPSTS[10:8] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[16] or USB_INTSTS[1].
S * |[17]    |EPEVT1    |Endpoint 1's USB Event Status
S * |        |          |0 = No event occurred on endpoint 1.
S * |        |          |1 = USB event occurred on Endpoint 1, check USB_EPSTS[13:11] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[17] or USB_INTSTS[1].
S * |[18]    |EPEVT2    |Endpoint 2's USB Event Status
S * |        |          |0 = No event occurred on endpoint 2.
S * |        |          |1 = USB event occurred on Endpoint 2, check USB_EPSTS[16:14] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[18] or USB_INTSTS[1].
S * |[19]    |EPEVT3    |Endpoint 3's USB Event Status
S * |        |          |0 = No event occurred on endpoint 3.
S * |        |          |1 = USB event occurred on Endpoint 3, check USB_EPSTS[19:17] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[19] or USB_INTSTS[1].
S * |[20]    |EPEVT4    |Endpoint 4's USB Event Status
S * |        |          |0 = No event occurred on endpoint 4.
S * |        |          |1 = USB event occurred on Endpoint 4, check USB_EPSTS[22:20] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[20] or USB_INTSTS[1].
S * |[21]    |EPEVT5    |Endpoint 5's USB Event Status
S * |        |          |0 = No event occurred on endpoint 5.
S * |        |          |1 = USB event occurred on Endpoint 5, check USB_EPSTS[25:23] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[21] or USB_INTSTS[1].
S * |[22]    |EPEVT6    |Endpoint 6's USB Event Status
S * |        |          |0 = No event occurred on endpoint 6.
S * |        |          |1 = USB event occurred on Endpoint 6, check USB_EPSTS[28:26] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[22] or USB_INTSTS[1].
S * |[23]    |EPEVT7    |Endpoint 7's USB Event Status
S * |        |          |0 = No event occurred on endpoint 7.
S * |        |          |1 = USB event occurred on Endpoint 7, check USB_EPSTS[31:29] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[23] or USB_INTSTS[1].
S * |[31]    |SETUP     |Setup Event Status
S * |        |          |0 = No Setup event.
S * |        |          |1 = SETUP event occurred, cleared by write 1 to USB_INTSTS[31].
S * @var USBD_T::FADDR
S * Offset: 0x08  USB Device Function Address Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[6:0]   |FADDR     |USB Device Function Address
S * @var USBD_T::EPSTS
S * Offset: 0x0C  USB Endpoint Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7]     |OV        |Overrun
S * |        |          |It indicates that the received data is over the maximum payload number or not.
S * |        |          |0 = No overrun.
S * |        |          |1 = Out Data is more than the Max Payload in MXPLD register or the Setup Data is more than 8 Bytes.
S * |[10:8]  |EPSTS0    |Endpoint 0 Bus Status
S * |        |          |These bits are used to indicate the current status of this endpoint
S * |        |          |000 = In ACK.
S * |        |          |001 = In NAK.
S * |        |          |010 = Out Packet Data0 ACK.
S * |        |          |110 = Out Packet Data1 ACK.
S * |        |          |011 = Setup ACK.
S * |        |          |111 = Isochronous transfer end.
S * |[13:11] |EPSTS1    |Endpoint 1 Bus Status
S * |        |          |These bits are used to indicate the current status of this endpoint
S * |        |          |000 = In ACK.
S * |        |          |001 = In NAK.
S * |        |          |010 = Out Packet Data0 ACK.
S * |        |          |110 = Out Packet Data1 ACK.
S * |        |          |011 = Setup ACK.
S * |        |          |111 = Isochronous transfer end.
S * |[16:14] |EPSTS2    |Endpoint 2 Bus Status
S * |        |          |These bits are used to indicate the current status of this endpoint
S * |        |          |000 = In ACK.
S * |        |          |001 = In NAK.
S * |        |          |010 = Out Packet Data0 ACK.
S * |        |          |110 = Out Packet Data1 ACK.
S * |        |          |011 = Setup ACK.
S * |        |          |111 = Isochronous transfer end.
S * |[19:17] |EPSTS3    |Endpoint 3 Bus Status
S * |        |          |These bits are used to indicate the current status of this endpoint
S * |        |          |000 = In ACK.
S * |        |          |001 = In NAK.
S * |        |          |010 = Out Packet Data0 ACK.
S * |        |          |110 = Out Packet Data1 ACK.
S * |        |          |011 = Setup ACK.
S * |        |          |111 = Isochronous transfer end.
S * |[22:20] |EPSTS4    |Endpoint 4 Bus Status
S * |        |          |These bits are used to indicate the current status of this endpoint
S * |        |          |000 = In ACK.
S * |        |          |001 = In NAK.
S * |        |          |010 = Out Packet Data0 ACK.
S * |        |          |110 = Out Packet Data1 ACK.
S * |        |          |011 = Setup ACK.
S * |        |          |111 = Isochronous transfer end.
S * |[25:23] |EPSTS5    |Endpoint 5 Bus Status
S * |        |          |These bits are used to indicate the current status of this endpoint
S * |        |          |000 = In ACK.
S * |        |          |001 = In NAK.
S * |        |          |010 = Out Packet Data0 ACK.
S * |        |          |110 = Out Packet Data1 ACK.
S * |        |          |011 = Setup ACK.
S * |        |          |111 = Isochronous transfer end.
S * |[28:26] |EPSTS6    |Endpoint 6 Bus Status
S * |        |          |These bits are used to indicate the current status of this endpoint
S * |        |          |000 = In ACK.
S * |        |          |001 = In NAK.
S * |        |          |010 = Out Packet Data0 ACK.
S * |        |          |110 = Out Packet Data1 ACK.
S * |        |          |011 = Setup ACK.
S * |        |          |111 = Isochronous transfer end.
S * |[31:29] |EPSTS7    |Endpoint 7 Bus Status
S * |        |          |These bits are used to indicate the current status of this endpoint
S * |        |          |000 = In ACK.
S * |        |          |001 = In NAK.
S * |        |          |010 = Out Packet Data0 ACK.
S * |        |          |110 = Out Packet Data1 ACK.
S * |        |          |011 = Setup ACK.
S * |        |          |111 = Isochronous transfer end.
S * @var USBD_T::ATTR
S * Offset: 0x10  USB Bus Status and Attribution Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |USBRST    |USB Reset Status
S * |        |          |0 = Bus no reset.
S * |        |          |1 = Bus reset when SE0 (single-ended 0) is presented more than 2.5us.
S * |        |          |Note: This bit is read only.
S * |[1]     |SUSPEND   |Suspend Status
S * |        |          |0 = Bus no suspend.
S * |        |          |1 = Bus idle more than 3ms, either cable is plugged off or host is sleeping.
S * |        |          |Note: This bit is read only.
S * |[2]     |RESUME    |Resume Status
S * |        |          |0 = No bus resume.
S * |        |          |1 = Resume from suspend.
S * |        |          |Note: This bit is read only.
S * |[3]     |TOUT      |Time-Out Status
S * |        |          |0 = No time-out.
S * |        |          |1 = No Bus response more than 18 bits time.
S * |        |          |Note: This bit is read only.
S * |[4]     |PHYEN     |PHY Transceiver Function Enable
S * |        |          |0 = PHY transceiver function Disabled.
S * |        |          |1 = PHY transceiver function Enabled.
S * |[5]     |RWAKEUP   |Remote Wake-Up
S * |        |          |0 = Release the USB bus from K state.
S * |        |          |1 = Force USB bus to K (USB_D+ low, USB_D- high) state, used for remote wake-up.
S * |[7]     |USBEN     |USB Controller Enable
S * |        |          |0 = USB Controller Disabled.
S * |        |          |1 = USB Controller Enabled.
S * |[8]     |DPPUEN    |Pull-Up Resistor On USB_D+ Enable
S * |        |          |0 = Pull-up resistor in USB_D+ pin Disabled.
S * |        |          |1 = Pull-up resistor in USB_D+ pin Enabled.
S * |[9]     |PWRDN     |Power Down PHY Transceiver, Low Active (M45xD/M45xC Only)
S * |        |          |0 = Power down related circuits of PHY transceiver.
S * |        |          |1 = Turn on related circuits of  PHY transceiver.
S * |[10]    |BYTEM     |CPU Access USB SRAM Size Mode Selection
S * |        |          |0 = Word mode: The size of the transfer from CPU to USB SRAM can be Word only.
S * |        |          |1 = Byte mode: The size of the transfer from CPU to USB SRAM can be Byte only.
S * @var USBD_T::VBUSDET
S * Offset: 0x14  USB Device VBUS Detection Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |FLDET     |Device VBUS Detected
S * |        |          |0 = Controller is not attached into the USB host.
S * |        |          |1 =Controller is attached into the BUS.
S * @var USBD_T::STBUFSEG
S * Offset: 0x18  Setup Token Buffer Segmentation Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[8:3]   |STBUFSEG  |Setup Token Buffer Segmentation
S * |        |          |It is used to indicate the offset address for the SETUP token with the USB Device SRAM starting address The effective starting address is
S * |        |          |USB_SRAM address + {STBUFSEG[8:3], 3'b000}
S * |        |          |Where the USB_SRAM address = USBD_BA+0x100h.
S * |        |          |Note: It is used for SETUP token only.
S * @var USBD_T::SE0
S * Offset: 0x90  USB Drive SE0 Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |DRVSE0    |Drive Single Ended Zero In USB Bus
S * |        |          |The Single Ended Zero (SE0) is when both lines (USB_D+ and USB_D-) are being pulled low.
S * |        |          |0 = None.
S * |        |          |1 = Force USB PHY transceiver to drive SE0.
S * @var USBD_T::EP
S * Offset: 0x500 ~ 0x57C  USB End Point 0 ~ 7 Configuration Register
S * ---------------------------------------------------------------------------------------------------
S */
S
S    __IO uint32_t INTEN;         /* Offset: 0x00  USB Interrupt Enable Register                                      */
S    __IO uint32_t INTSTS;        /* Offset: 0x04  USB Interrupt Event Status Register                                */
S    __IO uint32_t FADDR;         /* Offset: 0x08  USB Device Function Address Register                               */
S    __I  uint32_t EPSTS;         /* Offset: 0x0C  USB Endpoint Status Register                                       */
S    __IO uint32_t ATTR;          /* Offset: 0x10  USB Bus Status and Attribution Register                            */
S    __I  uint32_t VBUSDET;       /* Offset: 0x14  USB Device VBUS Detection Register                                 */
S    __IO uint32_t STBUFSEG;      /* Offset: 0x18  Setup Token Buffer Segmentation Register                           */
S    __I  uint32_t RESERVE0[29]; 
S    __IO uint32_t SE0;           /* Offset: 0x90  USB Drive SE0 Control Register                                     */
S    __I  uint32_t RESERVE1[283];
S    USBD_EP_T     EP[8];         /* Offset: 0x500 ~ 0x57C  USB End Point 0 ~ 7 Configuration Register                */
S
S} USBD_T;
S
S
S
S/**
S    @addtogroup USB_CONST USB Bit Field Definition
S    Constant Definitions for USB Controller
S@{ */
S
S#define USBD_INTEN_BUSIEN_Pos            (0)                                               /*!< USBD_T::INTEN: BUSIEN Position            */
S#define USBD_INTEN_BUSIEN_Msk            (0x1ul << USBD_INTEN_BUSIEN_Pos)                  /*!< USBD_T::INTEN: BUSIEN Mask                */
S
S#define USBD_INTEN_USBIEN_Pos            (1)                                               /*!< USBD_T::INTEN: USBIEN Position            */
S#define USBD_INTEN_USBIEN_Msk            (0x1ul << USBD_INTEN_USBIEN_Pos)                  /*!< USBD_T::INTEN: USBIEN Mask                */
S
S#define USBD_INTEN_VBDETIEN_Pos          (2)                                               /*!< USBD_T::INTEN: VBDETIEN Position          */
S#define USBD_INTEN_VBDETIEN_Msk          (0x1ul << USBD_INTEN_VBDETIEN_Pos)                /*!< USBD_T::INTEN: VBDETIEN Mask              */
S
S#define USBD_INTEN_NEVWKIEN_Pos          (3)                                               /*!< USBD_T::INTEN: NEVWKIEN Position          */
S#define USBD_INTEN_NEVWKIEN_Msk          (0x1ul << USBD_INTEN_NEVWKIEN_Pos)                /*!< USBD_T::INTEN: NEVWKIEN Mask              */
S
S#define USBD_INTEN_WKEN_Pos              (8)                                               /*!< USBD_T::INTEN: WKEN Position              */
S#define USBD_INTEN_WKEN_Msk              (0x1ul << USBD_INTEN_WKEN_Pos)                    /*!< USBD_T::INTEN: WKEN Mask                  */
S
S#define USBD_INTEN_INNAKEN_Pos           (15)                                              /*!< USBD_T::INTEN: INNAKEN Position           */
S#define USBD_INTEN_INNAKEN_Msk           (0x1ul << USBD_INTEN_INNAKEN_Pos)                 /*!< USBD_T::INTEN: INNAKEN Mask               */
S
S#define USBD_INTSTS_BUSIF_Pos            (0)                                               /*!< USBD_T::INTSTS: BUSIF Position            */
S#define USBD_INTSTS_BUSIF_Msk            (0x1ul << USBD_INTSTS_BUSIF_Pos)                  /*!< USBD_T::INTSTS: BUSIF Mask                */
S
S#define USBD_INTSTS_USBIF_Pos            (1)                                               /*!< USBD_T::INTSTS: USBIF Position            */
S#define USBD_INTSTS_USBIF_Msk            (0x1ul << USBD_INTSTS_USBIF_Pos)                  /*!< USBD_T::INTSTS: USBIF Mask                */
S
S#define USBD_INTSTS_VBDETIF_Pos          (2)                                               /*!< USBD_T::INTSTS: VBDETIF Position          */
S#define USBD_INTSTS_VBDETIF_Msk          (0x1ul << USBD_INTSTS_VBDETIF_Pos)                /*!< USBD_T::INTSTS: VBDETIF Mask              */
S
S#define USBD_INTSTS_NEVWKIF_Pos          (3)                                               /*!< USBD_T::INTSTS: NEVWKIF Position          */
S#define USBD_INTSTS_NEVWKIF_Msk          (0x1ul << USBD_INTSTS_NEVWKIF_Pos)                /*!< USBD_T::INTSTS: NEVWKIF Mask              */
S
S#define USBD_INTSTS_EPEVT0_Pos           (16)                                              /*!< USBD_T::INTSTS: EPEVT0 Position           */
S#define USBD_INTSTS_EPEVT0_Msk           (0x1ul << USBD_INTSTS_EPEVT0_Pos)                 /*!< USBD_T::INTSTS: EPEVT0 Mask               */
S
S#define USBD_INTSTS_EPEVT1_Pos           (17)                                              /*!< USBD_T::INTSTS: EPEVT1 Position           */
S#define USBD_INTSTS_EPEVT1_Msk           (0x1ul << USBD_INTSTS_EPEVT1_Pos)                 /*!< USBD_T::INTSTS: EPEVT1 Mask               */
S
S#define USBD_INTSTS_EPEVT2_Pos           (18)                                              /*!< USBD_T::INTSTS: EPEVT2 Position           */
S#define USBD_INTSTS_EPEVT2_Msk           (0x1ul << USBD_INTSTS_EPEVT2_Pos)                 /*!< USBD_T::INTSTS: EPEVT2 Mask               */
S
S#define USBD_INTSTS_EPEVT3_Pos           (19)                                              /*!< USBD_T::INTSTS: EPEVT3 Position           */
S#define USBD_INTSTS_EPEVT3_Msk           (0x1ul << USBD_INTSTS_EPEVT3_Pos)                 /*!< USBD_T::INTSTS: EPEVT3 Mask               */
S
S#define USBD_INTSTS_EPEVT4_Pos           (20)                                              /*!< USBD_T::INTSTS: EPEVT4 Position           */
S#define USBD_INTSTS_EPEVT4_Msk           (0x1ul << USBD_INTSTS_EPEVT4_Pos)                 /*!< USBD_T::INTSTS: EPEVT4 Mask               */
S
S#define USBD_INTSTS_EPEVT5_Pos           (21)                                              /*!< USBD_T::INTSTS: EPEVT5 Position           */
S#define USBD_INTSTS_EPEVT5_Msk           (0x1ul << USBD_INTSTS_EPEVT5_Pos)                 /*!< USBD_T::INTSTS: EPEVT5 Mask               */
S
S#define USBD_INTSTS_EPEVT6_Pos           (22)                                              /*!< USBD_T::INTSTS: EPEVT6 Position           */
S#define USBD_INTSTS_EPEVT6_Msk           (0x1ul << USBD_INTSTS_EPEVT6_Pos)                 /*!< USBD_T::INTSTS: EPEVT6 Mask               */
S
S#define USBD_INTSTS_EPEVT7_Pos           (23)                                              /*!< USBD_T::INTSTS: EPEVT7 Position           */
S#define USBD_INTSTS_EPEVT7_Msk           (0x1ul << USBD_INTSTS_EPEVT7_Pos)                 /*!< USBD_T::INTSTS: EPEVT7 Mask               */
S
S#define USBD_INTSTS_SETUP_Pos            (31)                                              /*!< USBD_T::INTSTS: SETUP Position            */
S#define USBD_INTSTS_SETUP_Msk            (0x1ul << USBD_INTSTS_SETUP_Pos)                  /*!< USBD_T::INTSTS: SETUP Mask                */
S
S#define USBD_FADDR_FADDR_Pos             (0)                                               /*!< USBD_T::FADDR: FADDR Position             */
S#define USBD_FADDR_FADDR_Msk             (0x7ful << USBD_FADDR_FADDR_Pos)                  /*!< USBD_T::FADDR: FADDR Mask                 */
S
S#define USBD_EPSTS_OV_Pos                (7)                                               /*!< USBD_T::EPSTS: OV Position                */
S#define USBD_EPSTS_OV_Msk                (0x1ul << USBD_EPSTS_OV_Pos)                      /*!< USBD_T::EPSTS: OV Mask                    */
S
S#define USBD_EPSTS_EPSTS0_Pos            (8)                                               /*!< USBD_T::EPSTS: EPSTS0 Position            */
S#define USBD_EPSTS_EPSTS0_Msk            (0x7ul << USBD_EPSTS_EPSTS0_Pos)                  /*!< USBD_T::EPSTS: EPSTS0 Mask                */
S
S#define USBD_EPSTS_EPSTS1_Pos            (11)                                              /*!< USBD_T::EPSTS: EPSTS1 Position            */
S#define USBD_EPSTS_EPSTS1_Msk            (0x7ul << USBD_EPSTS_EPSTS1_Pos)                  /*!< USBD_T::EPSTS: EPSTS1 Mask                */
S
S#define USBD_EPSTS_EPSTS2_Pos            (14)                                              /*!< USBD_T::EPSTS: EPSTS2 Position            */
S#define USBD_EPSTS_EPSTS2_Msk            (0x7ul << USBD_EPSTS_EPSTS2_Pos)                  /*!< USBD_T::EPSTS: EPSTS2 Mask                */
S
S#define USBD_EPSTS_EPSTS3_Pos            (17)                                              /*!< USBD_T::EPSTS: EPSTS3 Position            */
S#define USBD_EPSTS_EPSTS3_Msk            (0x7ul << USBD_EPSTS_EPSTS3_Pos)                  /*!< USBD_T::EPSTS: EPSTS3 Mask                */
S
S#define USBD_EPSTS_EPSTS4_Pos            (20)                                              /*!< USBD_T::EPSTS: EPSTS4 Position            */
S#define USBD_EPSTS_EPSTS4_Msk            (0x7ul << USBD_EPSTS_EPSTS4_Pos)                  /*!< USBD_T::EPSTS: EPSTS4 Mask                */
S
S#define USBD_EPSTS_EPSTS5_Pos            (23)                                              /*!< USBD_T::EPSTS: EPSTS5 Position            */
S#define USBD_EPSTS_EPSTS5_Msk            (0x7ul << USBD_EPSTS_EPSTS5_Pos)                  /*!< USBD_T::EPSTS: EPSTS5 Mask                */
S
S#define USBD_EPSTS_EPSTS6_Pos            (26)                                              /*!< USBD_T::EPSTS: EPSTS6 Position            */
S#define USBD_EPSTS_EPSTS6_Msk            (0x7ul << USBD_EPSTS_EPSTS6_Pos)                  /*!< USBD_T::EPSTS: EPSTS6 Mask                */
S
S#define USBD_EPSTS_EPSTS7_Pos            (29)                                              /*!< USBD_T::EPSTS: EPSTS7 Position            */
S#define USBD_EPSTS_EPSTS7_Msk            (0x7ul << USBD_EPSTS_EPSTS7_Pos)                  /*!< USBD_T::EPSTS: EPSTS7 Mask                */
S
S#define USBD_ATTR_USBRST_Pos             (0)                                               /*!< USBD_T::ATTR: USBRST Position             */
S#define USBD_ATTR_USBRST_Msk             (0x1ul << USBD_ATTR_USBRST_Pos)                   /*!< USBD_T::ATTR: USBRST Mask                 */
S
S#define USBD_ATTR_SUSPEND_Pos            (1)                                               /*!< USBD_T::ATTR: SUSPEND Position            */
S#define USBD_ATTR_SUSPEND_Msk            (0x1ul << USBD_ATTR_SUSPEND_Pos)                  /*!< USBD_T::ATTR: SUSPEND Mask                */
S
S#define USBD_ATTR_RESUME_Pos             (2)                                               /*!< USBD_T::ATTR: RESUME Position             */
S#define USBD_ATTR_RESUME_Msk             (0x1ul << USBD_ATTR_RESUME_Pos)                   /*!< USBD_T::ATTR: RESUME Mask                 */
S
S#define USBD_ATTR_TOUT_Pos               (3)                                               /*!< USBD_T::ATTR: TOUT Position               */
S#define USBD_ATTR_TOUT_Msk               (0x1ul << USBD_ATTR_TOUT_Pos)                     /*!< USBD_T::ATTR: TOUT Mask                   */
S
S#define USBD_ATTR_PHYEN_Pos              (4)                                               /*!< USBD_T::ATTR: PHYEN Position              */
S#define USBD_ATTR_PHYEN_Msk              (0x1ul << USBD_ATTR_PHYEN_Pos)                    /*!< USBD_T::ATTR: PHYEN Mask                  */
S
S#define USBD_ATTR_RWAKEUP_Pos            (5)                                               /*!< USBD_T::ATTR: RWAKEUP Position            */
S#define USBD_ATTR_RWAKEUP_Msk            (0x1ul << USBD_ATTR_RWAKEUP_Pos)                  /*!< USBD_T::ATTR: RWAKEUP Mask                */
S
S#define USBD_ATTR_USBEN_Pos              (7)                                               /*!< USBD_T::ATTR: USBEN Position              */
S#define USBD_ATTR_USBEN_Msk              (0x1ul << USBD_ATTR_USBEN_Pos)                    /*!< USBD_T::ATTR: USBEN Mask                  */
S
S#define USBD_ATTR_DPPUEN_Pos             (8)                                               /*!< USBD_T::ATTR: DPPUEN Position             */
S#define USBD_ATTR_DPPUEN_Msk             (0x1ul << USBD_ATTR_DPPUEN_Pos)                   /*!< USBD_T::ATTR: DPPUEN Mask                 */
S
S#define USBD_ATTR_PWRDN_Pos              (9)                                               /*!< USBD_T::ATTR: PWRDN Position              */
S#define USBD_ATTR_PWRDN_Msk              (0x1ul << USBD_ATTR_PWRDN_Pos)                    /*!< USBD_T::ATTR: PWRDN Mask                  */
S
S#define USBD_ATTR_BYTEM_Pos              (10)                                              /*!< USBD_T::ATTR: BYTEM Position              */
S#define USBD_ATTR_BYTEM_Msk              (0x1ul << USBD_ATTR_BYTEM_Pos)                    /*!< USBD_T::ATTR: BYTEM Mask                  */
S
S#define USBD_VBUSDET_VBUSDET_Pos         (0)                                               /*!< USBD_T::VBUSDET: VBUSDET Position         */
S#define USBD_VBUSDET_VBUSDET_Msk         (0x1ul << USBD_VBUSDET_VBUSDET_Pos)               /*!< USBD_T::VBUSDET: VBUSDET Mask             */
S
S#define USBD_STBUFSEG_STBUFSEG_Pos       (3)                                               /*!< USBD_T::STBUFSEG: STBUFSEG Position       */
S#define USBD_STBUFSEG_STBUFSEG_Msk       (0x3ful << USBD_STBUFSEG_STBUFSEG_Pos)            /*!< USBD_T::STBUFSEG: STBUFSEG Mask           */
S
S#define USBD_SE0_SE0_Pos                 (0)                                               /*!< USBD_T::SE0: SE0 Position                 */
S#define USBD_SE0_SE0_Msk                 (0x1ul << USBD_SE0_SE0_Pos)                       /*!< USBD_T::SE0: SE0 Mask                     */
S
S#define USBD_BUFSEG_BUFSEG_Pos           (3)                                               /*!< USBD_EP_T::BUFSEG: BUFSEG Position          */
S#define USBD_BUFSEG_BUFSEG_Msk           (0x3ful << USBD_BUFSEG_BUFSEG_Pos)                /*!< USBD_EP_T::BUFSEG: BUFSEG Mask              */
S
S#define USBD_MXPLD_MXPLD_Pos             (0)                                               /*!< USBD_EP_T::MXPLD: MXPLD Position            */
S#define USBD_MXPLD_MXPLD_Msk             (0x1fful << USBD_MXPLD_MXPLD_Pos)                 /*!< USBD_EP_T::MXPLD: MXPLD Mask                */
S
S#define USBD_CFG_EPNUM_Pos               (0)                                               /*!< USBD_EP_T::CFG: EPNUM Position              */
S#define USBD_CFG_EPNUM_Msk               (0xful << USBD_CFG_EPNUM_Pos)                     /*!< USBD_EP_T::CFG: EPNUM Mask                  */
S
S#define USBD_CFG_ISOCH_Pos               (4)                                               /*!< USBD_EP_T::CFG: ISOCH Position              */
S#define USBD_CFG_ISOCH_Msk               (0x1ul << USBD_CFG_ISOCH_Pos)                     /*!< USBD_EP_T::CFG: ISOCH Mask                  */
S
S#define USBD_CFG_STATE_Pos               (5)                                               /*!< USBD_EP_T::CFG: STATE Position              */
S#define USBD_CFG_STATE_Msk               (0x3ul << USBD_CFG_STATE_Pos)                     /*!< USBD_EP_T::CFG: STATE Mask                  */
S
S#define USBD_CFG_DSQSYNC_Pos             (7)                                               /*!< USBD_EP_T::CFG: DSQSYNC Position            */
S#define USBD_CFG_DSQSYNC_Msk             (0x1ul << USBD_CFG_DSQSYNC_Pos)                   /*!< USBD_EP_T::CFG: DSQSYNC Mask                */
S
S#define USBD_CFG_CSTALL_Pos              (9)                                               /*!< USBD_EP_T::CFG: CSTALL Position             */
S#define USBD_CFG_CSTALL_Msk              (0x1ul << USBD_CFG_CSTALL_Pos)                    /*!< USBD_EP_T::CFG: CSTALL Mask                 */
S
S#define USBD_CFGP_CLRRDY_Pos             (0)                                               /*!< USBD_EP_T::CFGP: CLRRDY Position            */
S#define USBD_CFGP_CLRRDY_Msk             (0x1ul << USBD_CFGP_CLRRDY_Pos)                   /*!< USBD_EP_T::CFGP: CLRRDY Mask                */
S
S#define USBD_CFGP_SSTALL_Pos             (1)                                               /*!< USBD_EP_T::CFGP: SSTALL Position            */
S#define USBD_CFGP_SSTALL_Msk             (0x1ul << USBD_CFGP_SSTALL_Pos)                   /*!< USBD_EP_T::CFGP: SSTALL Mask                */
S
S/**@}*/ /* USB_CONST */
S/**@}*/ /* end of USB register group */
S
S
S/*---------------------- USB Host Controller -------------------------*/
S/**
S    @addtogroup USBH USB Host Controller(USBH)
S    Memory Mapped Structure for USBH Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S
S
S/**
S * @var USBH_T::HcRevision
S * Offset: 0x00  Host Controller Revision Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |REV       |Revision Number
S * |        |          |Indicates the Open HCI Specification revision number implemented by the Hardware.
S * |        |          |Host Controller supports 1.1 specification.
S * |        |          |(X.Y = XYh).
S * @var USBH_T::HcControl
S * Offset: 0x04  Host Controller Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |CBSR      |Control Bulk Service Ratio
S * |        |          |This specifies the service ratio between Control and Bulk EDs.
S * |        |          |Before processing any of the non-periodic lists, HC must compare the ratio specified with its internal count on how many nonempty Control EDs have been processed, in determining whether to continue serving another Control ED or switching to Bulk EDs.
S * |        |          |The internal count will be retained when crossing the frame boundary.
S * |        |          |In case of reset, HCD is responsible for restoring this.
S * |        |          |Value.
S * |        |          |00 = Number of Control EDs over Bulk EDs served is 1:1.
S * |        |          |01 = Number of Control EDs over Bulk EDs served is 2:1.
S * |        |          |10 = Number of Control EDs over Bulk EDs served is 3:1.
S * |        |          |11 = Number of Control EDs over Bulk EDs served is 4:1.
S * |[2]     |PLE       |Periodic List Enable Bit
S * |        |          |When set, this bit enables processing of the Periodic (interrupt and Isochronous) list.
S * |        |          |The Host Controller checks this bit prior to attempting any periodic transfers in a frame.
S * |        |          |0 = Disable the processing of the Periodic (Interrupt and Isochronous) list after next SOF (Start-Of-Frame).
S * |        |          |1 = Enable the processing of the Periodic (Interrupt and Isochronous) list in the next frame.
S * |        |          |Note: To enable the processing of the Isochronous list, user has to set both PLE and IE (HcControl[3]) high.
S * |[3]     |IE        |Isochronous List Enable Bit
S * |        |          |Both ISOEn and PLE (HcControl[2]) high enables Host Controller to process the Isochronous list.
S * |        |          |Either ISOEn or PLE (HcControl[2]) is low disables Host Controller to process the Isochronous list.
S * |        |          |0 = Disable the processing of the Isochronous list after next SOF (Start-Of-Frame).
S * |        |          |1 = Enable the processing of the Isochronous list in the next frame if the PLE (HcControl[2]) is high, too.
S * |[4]     |CLE       |Control List Enable Bit
S * |        |          |0 = Disable processing of the Control list after next SOF (Start-Of-Frame).
S * |        |          |1 = Enable processing of the Control list in the next frame.
S * |[5]     |BLE       |Bulk List Enable Bit
S * |        |          |0 = Disable processing of the Bulk list after next SOF (Start-Of-Frame).
S * |        |          |1 = Enable processing of the Bulk list in the next frame.
S * |[7:6]   |HCFS      |Host Controller Functional State
S * |        |          |This field sets the Host Controller state.
S * |        |          |The Controller may force a state change from USBSUSPEND to USBRESUME after detecting resume signaling from a downstream port.
S * |        |          |States are:
S * |        |          |00 = USBSUSPEND.
S * |        |          |01 = USBRESUME.
S * |        |          |10 = USBOPERATIONAL.
S * |        |          |11 = USBRESET.
S * @var USBH_T::HcCommandStatus
S * Offset: 0x08  Host Controller CMD Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |HCR       |Host Controller Reset
S * |        |          |This bit is set to initiate the software reset of Host Controller.
S * |        |          |This bit is cleared by the Host Controller, upon completed of the reset operation.
S * |        |          |This bit, when set, didn't reset the Root Hub and no subsequent reset signaling be asserted to its downstream ports.
S * |        |          |0 = Host Controller is not in software reset state.
S * |        |          |1 = Host Controller is in software reset state.
S * |[1]     |CLF       |Control List Filled
S * |        |          |Set high to indicate there is an active TD on the Control List.
S * |        |          |It may be set by either software or the Host Controller and cleared by the Host Controller each time it begins processing the head of the Control List.
S * |        |          |0 = No active TD found or Host Controller begins to process the head of the Control list.
S * |        |          |1 = An active TD added or found on the Control list.
S * |[2]     |BLF       |Bulk List Filled
S * |        |          |Set high to indicate there is an active TD on the Bulk list.
S * |        |          |This bit may be set by either software or the Host Controller and cleared by the Host Controller each time it begins processing the head of the Bulk list.
S * |        |          |0 = No active TD found or Host Controller begins to process the head of the Bulk list.
S * |        |          |1 = An active TD added or found on the Bulk list.
S * |[17:16] |SOC       |Schedule Overrun Count
S * |        |          |These bits are incremented on each scheduling overrun error.
S * |        |          |It is initialized to 00b and wraps around at 11b.
S * |        |          |This will be incremented when a scheduling overrun is detected even if SO (HcIntSts[0]) has already been set.
S * @var USBH_T::HcInterruptStatus
S * Offset: 0x0C  Host Controller Interrupt Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |SO        |Scheduling Overrun
S * |        |          |Set when the List Processor determines a Schedule Overrun has occurred.
S * |        |          |0 = Schedule Overrun didn't occur.
S * |        |          |1 = Schedule Overrun has occurred.
S * |[1]     |WDH       |Write Back Done Head
S * |        |          |Set after the Host Controller has written HcDoneHead to HccaDoneHead.
S * |        |          |Further updates of the HccaDoneHead will not occur until this bit has been cleared.
S * |        |          |0 =.Host Controller didn't update HccaDoneHead.
S * |        |          |1 =.Host Controller has written HcDoneHead to HccaDoneHead.
S * |[2]     |SF        |Start Of Frame
S * |        |          |Set when the Frame Management functional block signals a 'Start of Frame' event.
S * |        |          |Host Control generates a SOF token at the same time.
S * |        |          |0 =.Not the start of a frame.
S * |        |          |1 =.Indicate the start of a frame and Host Controller generates a SOF token.
S * |[3]     |RD        |Resume Detected
S * |        |          |Set when Host Controller detects resume signaling on a downstream port.
S * |        |          |0 = No resume signaling detected on a downstream port.
S * |        |          |1 = Resume signaling detected on a downstream port.
S * |[5]     |FNO       |Frame Number Overflow
S * |        |          |This bit is set when bit 15 of Frame Number changes from 1 to 0 or from 0 to 1.
S * |        |          |0 = The bit 15 of Frame Number didn't change.
S * |        |          |1 = The bit 15 of Frame Number changes from 1 to 0 or from 0 to 1.
S * |[6]     |RHSC      |Root Hub Status Change
S * |        |          |This bit is set when the content of HcRhSts or the content of HcRhPrt1 register has changed.
S * |        |          |0 = The content of HcRhSts and the content of HcRhPrt1 register didn't change.
S * |        |          |1 = The content of HcRhSts or the content of HcRhPrt1 register has changed.
S * @var USBH_T::HcInterruptEnable
S * Offset: 0x10  Host Controller Interrupt Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |SO        |Scheduling Overrun Enable Bit
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Enable interrupt generation due to SO (HcIntSts[0]).
S * |        |          |Read Operation:
S * |        |          |0 = Interrupt generation due to SO (HcIntSts[0]) disabled.
S * |        |          |1 = Interrupt generation due to SO (HcIntSts[0]) enabled.
S * |[1]     |WDH       |Write Back Done Head Enable Bit
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Enable interrupt generation due to WDH (HcIntSts[1]).
S * |        |          |Read Operation:
S * |        |          |0 = Interrupt generation due to WDH (HcIntSts[1]) disabled.
S * |        |          |1 = Interrupt generation due to WDH (HcIntSts[1]) enabled.
S * |[2]     |SF        |Start Of Frame Enable Bit
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Enable interrupt generation due to SF (HcIntSts[2]).
S * |        |          |Read Operation:
S * |        |          |0 = Interrupt generation due to SF (HcIntSts[2]) disabled.
S * |        |          |1 = Interrupt generation due to SF (HcIntSts[2]) enabled.
S * |[3]     |RD        |Resume Detected Enable Bit
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Enable interrupt generation due to RD (HcIntSts[3]).
S * |        |          |Read Operation:
S * |        |          |0 = Interrupt generation due to RD (HcIntSts[3]) disabled.
S * |        |          |1 = Interrupt generation due to RD (HcIntSts[3]) enabled.
S * |[5]     |FNO       |Frame Number Overflow Enable Bit
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Enable interrupt generation due to FNO (HcIntSts[5]).
S * |        |          |Read Operation:
S * |        |          |0 = Interrupt generation due to FNO (HcIntSts[5]) disabled.
S * |        |          |1 = Interrupt generation due to FNO (HcIntSts[5]) enabled.
S * |[6]     |RHSC      |Root Hub Status Change Enable Bit
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Enable interrupt generation due to RHSC (HcIntSts[6]).
S * |        |          |Read Operation:
S * |        |          |0 = Interrupt generation due to RHSC (HcIntSts[6]) disabled.
S * |        |          |1 = Interrupt generation due to RHSC (HcIntSts[6]) enabled.
S * |[31]    |MIE       |Master Interrupt Enable Bit
S * |        |          |This bit is a global interrupt enable.
S * |        |          |A write of '1' allows interrupts to be enabled via the specific enable bits listed above.
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Enable interrupt generation due to RHSC (HcIntSts[6]), FNO (HcIntSts[5]), RD (HcIntSts[3]), SF (HcIntSts[2]), WDH (HcIntSts[1]) or SO (HcIntSts[0]) if the corresponding bit in HcIntEn is high.
S * |        |          |Read Operation:
S * |        |          |0 = Interrupt generation due to RHSC (HcIntSts[6]), FNO (HcIntSts[5]), RD (HcIntSts[3]), SF (HcIntSts[2]), WDH (HcIntSts[1]) or SO (HcIntSts[0]) disabled even if the corresponding bit in HcIntEn is high.
S * |        |          |1 = Interrupt generation due to RHSC (HcIntSts[6]), FNO (HcIntSts[5]), RD (HcIntSts[3]), SF (HcIntSts[2]), WDH (HcIntSts[1]) or SO (HcIntSts[0]) enabled if the corresponding bit in HcIntEn is high.
S * @var USBH_T::HcInterruptDisable
S * Offset: 0x14  Host Controller Interrupt Disable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |SO        |Scheduling Overrun Disable Bit
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Disable interrupt generation due to SO (HcIntSts[0]).
S * |        |          |Read Operation:
S * |        |          |0 = Interrupt generation due to SO (HcIntSts[0]) disabled.
S * |        |          |1 = Interrupt generation due to SO (HcIntSts[0]) enabled.
S * |[1]     |WDH       |Write Back Done Head Disable Bit
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Disable interrupt generation due to WDH (HcIntSts[1]).
S * |        |          |Read Operation:
S * |        |          |0 = Interrupt generation due to WDH (HcIntSts[1]) disabled.
S * |        |          |1 = Interrupt generation due to WDH (HcIntSts[1]) enabled.
S * |[2]     |SF        |Start Of Frame Disable Bit
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Disable interrupt generation due to SF (HcIntSts[2]).
S * |        |          |Read Operation:
S * |        |          |0 = Interrupt generation due to SF (HcIntSts[2]) disabled.
S * |        |          |1 = Interrupt generation due to SF (HcIntSts[2]) enabled.
S * |[3]     |RD        |Resume Detected Disable Bit
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Disable interrupt generation due to RD (HcIntSts[3]).
S * |        |          |Read Operation:
S * |        |          |0 = Interrupt generation due to RD (HcIntSts[3]) disabled.
S * |        |          |1 = Interrupt generation due to RD (HcIntSts[3]) enabled.
S * |[5]     |FNO       |Frame Number Overflow Disable Bit
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Disable interrupt generation due to FNO (HcIntSts[5]).
S * |        |          |Read Operation:
S * |        |          |0 = Interrupt generation due to FNO (HcIntSts[5]) disabled.
S * |        |          |1 = Interrupt generation due to FNO (HcIntSts[5]) enabled.
S * |[6]     |RHSC      |Root Hub Status Change Disable Bit
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Disable interrupt generation due to RHSC (HcIntSts[6]).
S * |        |          |Read Operation:
S * |        |          |0 = Interrupt generation due to RHSC (HcIntSts[6]) disabled.
S * |        |          |1 = Interrupt generation due to RHSC (HcIntSts[6]) enabled.
S * |[31]    |MIE       |Master Interrupt Disable Bit
S * |        |          |Global interrupt disable. Writing '1' to disable all interrupts.
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Disable interrupt generation due to RHSC (HcIntSts[6]), FNO (HcIntSts[5]), RD (HcIntSts[3]), SF (HcIntSts[2]), WDH (HcIntSts[1]) or SO (HcIntSts[0]) if the corresponding bit in HcIntEn is high.
S * |        |          |Read Operation:
S * |        |          |0 = Interrupt generation due to RHSC (HcIntSts[6]), FNO (HcIntSts[5]), RD (HcIntSts[3]), SF (HcIntSts[2]), WDH (HcIntSts[1]) or SO (HcIntSts[0]) disabled even if the corresponding bit in HcIntEn is high.
S * |        |          |1 = Interrupt generation due to RHSC (HcIntSts[6]), FNO (HcIntSts[5]), RD (HcIntSts[3]), SF (HcIntSts[2]), WDH (HcIntSts[1]) or SO (HcIntSts[0]) enabled if the corresponding bit in HcIntEn is high.
S * @var USBH_T::HcHCCA
S * Offset: 0x18  Host Controller Communication Area Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:8]  |HCCA      |Host Controller Communication Area
S * |        |          |Pointer to indicate base address of the Host Controller Communication Area (HCCA).
S * @var USBH_T::HcPeriodCurrentED
S * Offset: 0x1C  Host Controller Period Current ED Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:4]  |PCED      |Periodic Current ED
S * |        |          |Pointer to indicate physical address of the current Isochronous or Interrupt Endpoint Descriptor.
S * @var USBH_T::HcControlHeadED
S * Offset: 0x20  Host Controller Control Head ED Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:4]  |CHED      |Control Head ED
S * |        |          |Pointer to indicate physical address of the first Endpoint Descriptor of the Control list.
S * @var USBH_T::HcControlCurrentED
S * Offset: 0x24  Host Controller Control Current ED Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:4]  |CCED      |Control Current Head ED
S * |        |          |Pointer to indicate the physical address of the current Endpoint Descriptor of the Control list.
S * @var USBH_T::HcBulkHeadED
S * Offset: 0x28  Host Controller Bulk Head ED Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:4]  |BHED      |Bulk Head ED
S * |        |          |Pointer to indicate the physical address of the first Endpoint Descriptor of the Bulk list.
S * @var USBH_T::HcBulkCurrentED
S * Offset: 0x2C  Host Controller Bulk Current ED Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:4]  |BCED      |Bulk Current Head ED
S * |        |          |Pointer to indicate the physical address of the current endpoint of the Bulk list.
S * @var USBH_T::HcDoneHead
S * Offset: 0x30  Host Controller Done Head Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:4]  |DH        |Done Head
S * |        |          |Pointer to indicate the physical address of the last completed Transfer Descriptor that was added to the Done queue.
S * @var USBH_T::HcFmInterval
S * Offset: 0x34  Host Controller Frame Interval Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[13:0]  |FI        |Frame Interval
S * |        |          |This field specifies the length of a frame as (bit times - 1).
S * |        |          |For 12,000 bit times in a frame, a value of 11,999 is stored here.
S * |[30:16] |FSMPS     |FS Largest Data Packet
S * |        |          |This field specifies a value that is loaded into the Largest Data Packet Counter at the beginning of each frame.
S * |[31]    |FIT       |Frame Interval Toggle
S * |        |          |This bit is toggled by Host Controller Driver when it loads a new value into FI (HcFmIntv[13:0]).
S * |        |          |0 = Host Controller Driver didn't load new value into FI (HcFmIntv[13:0]).
S * |        |          |1 = Host Controller Driver loads a new value into FI (HcFmIntv[13:0]).
S * @var USBH_T::HcFmRemaining
S * Offset: 0x38  Host Controller Frame Remaining Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[13:0]  |FR        |Frame Remaining
S * |        |          |When the Host Controller is in the USBOPERATIONAL state, this 14-bit field decrements each 12 MHz clock period.
S * |        |          |When the count reaches 0, (end of frame) the counter reloads with Frame Interval.
S * |        |          |In addition, the counter loads when the Host Controller transitions into USBOPERATIONAL.
S * |[31]    |FRT       |Frame Remaining Toggle
S * |        |          |This bit is loaded from the FIT (HcFmIntv[31]) whenever FR (HcFmRem[13:0]) reaches 0.
S * @var USBH_T::HcFmNumber
S * Offset: 0x3C  Host Controller Frame Number Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |FN        |Frame Number
S * |        |          |This 16-bit incrementing counter field is incremented coincident with the re-load of FR (HcFmRem[13:0]).
S * |        |          |The count rolls over from 'FFFFh' to '0h.'.
S * @var USBH_T::HcPeriodicStart
S * Offset: 0x40  Host Controller Periodic Start Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[13:0]  |PS        |Periodic Start
S * |        |          |This field contains a value used by the List Processor to determine where in a frame the Periodic List processing must begin.
S * @var USBH_T::HcLSThreshold
S * Offset: 0x44  Host Controller Low-speed Threshold Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[11:0]  |LST       |Low-Speed Threshold
S * |        |          |This field contains a value which is compared to the FR (HcFmRem[13:0]) field prior to initiating a Low-speed transaction.
S * |        |          |The transaction is started only if FR (HcFmRem[13:0]) >= this field.
S * |        |          |The value is calculated by Host Controller Driver with the consideration of transmission and setup overhead.
S * @var USBH_T::HcRhDescriptorA
S * Offset: 0x48  Host Controller Root Hub Descriptor A Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |NDP       |Number Downstream Ports
S * |        |          |USB host control supports two downstream ports and only one port is available in this series of chip.
S * |[8]     |PSM       |Power Switching Mode
S * |        |          |This bit is used to specify how the power switching of the Root Hub ports is controlled.
S * |        |          |0 = Global Switching.
S * |        |          |1 = Individual Switching.
S * |[11]    |OCPM      |Over Current Protection Mode
S * |        |          |This bit describes how the over current status for the Root Hub ports reported.
S * |        |          |This bit is only valid when NOCP (HcRhDeA[12]) is cleared.
S * |        |          |0 = Global Over current.
S * |        |          |1 = Individual Over current.
S * |[12]    |NOCP      |No Over Current Protection
S * |        |          |This bit describes how the over current status for the Root Hub ports reported.
S * |        |          |0 = Over current status is reported.
S * |        |          |1 = Over current status is not reported.
S * @var USBH_T::HcRhDescriptorB
S * Offset: 0x4C  Host Controller Root Hub Descriptor B Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:16] |PPCM      |Port Power Control Mask
S * |        |          |Global power switching.
S * |        |          |This field is only valid if PowerSwitchingMode is set (individual port switching).
S * |        |          |When set, the port only responds to individual port power switching commands (Set/ClearPortPower).
S * |        |          |When cleared, the port only responds to global power switching commands (Set/ClearGlobalPower).
S * |        |          |0 = Port power controlled by global power switching.
S * |        |          |1 = Port power controlled by port power switching.
S * |        |          |Note: PPCM[15:2] and PPCM[0] are reserved.
S * @var USBH_T::HcRhStatus
S * Offset: 0x50  Host Controller Root Hub Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |LPS       |Clear Global Power
S * |        |          |In global power mode (PSM (HcRhDeA[8]) = 0), this bit is written to one to clear all ports' power.
S * |        |          |This bit always read as zero.
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Clear global power.
S * |[1]     |OCI       |Over Current Indicator
S * |        |          |This bit reflects the state of the over current status pin.
S * |        |          |This field is only valid if NOCP (HcRhDesA[12]) and OCPM (HcRhDesA[11]) are cleared.
S * |        |          |0 = No over current condition.
S * |        |          |1 = Over current condition.
S * |[15]    |DRWE      |Device Remote Wakeup Enable Bit
S * |        |          |This bit controls if port's Connect Status Change as a remote wake-up event.
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Enable Connect Status Change as a remote wake-up event.
S * |        |          |Read Operation:
S * |        |          |0 = Connect Status Change as a remote wake-up event disabled.
S * |        |          |1 = Connect Status Change as a remote wake-up event enabled.
S * |[16]    |LPSC      |Set Global Power
S * |        |          |In global power mode (PSM (HcRhDeA[8]) = 0), this bit is written to one to enable power to all ports.
S * |        |          |This bit always read as zero.
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Set global power.
S * |[17]    |OCIC      |Over Current Indicator Change
S * |        |          |This bit is set by hardware when a change has occurred in OCI (HcRhSts[1]).
S * |        |          |Write 1 to clear this bit to zero.
S * |        |          |0 = OCI (HcRhSts[1]) didn't change.
S * |        |          |1 = OCI (HcRhSts[1]) change.
S * |[31]    |CRWE      |Clear Remote Wake-up Enable Bit
S * |        |          |This bit is use to clear DRWE (HcRhSts[15]).
S * |        |          |This bit always read as zero.
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Clear DRWE (HcRhSts[15]).
S * @var USBH_T::HcRhPortStatus
S * Offset: 0x54  Host Controller Root Hub Port Status [1]
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |CCS       |CurrentConnectStatus (Read) Or ClearPortEnable Bit (Write)
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Clear port enable.
S * |        |          |Read Operation:
S * |        |          |0 = No device connected.
S * |        |          |1 = Device connected.
S * |[1]     |PES       |Port Enable Status
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Set port enable.
S * |        |          |Read Operation:
S * |        |          |0 = Port Disabled.
S * |        |          |1 = Port Enabled.
S * |[2]     |PSS       |Port Suspend Status
S * |        |          |This bit indicates the port is suspended
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Set port suspend.
S * |        |          |Read Operation:
S * |        |          |0 = Port is not suspended.
S * |        |          |1 = Port is selectively suspended.
S * |[3]     |POCI      |Port Over Current Indicator (Read) Or Clear Port Suspend (Write)
S * |        |          |This bit reflects the state of the over current status pin dedicated to this port.
S * |        |          |This field is only valid if NOCP (HcRhDeA[12]) is cleared and OCPM (HcRhDeA[11]) is set.
S * |        |          |This bit is also used to initiate the selective result sequence for the port.
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Clear port suspend.
S * |        |          |Read Operation:
S * |        |          |0 = No over current condition.
S * |        |          |1 = Over current condition.
S * |[4]     |PRS       |Port Reset Status
S * |        |          |This bit reflects the reset state of the port.
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Set port reset.
S * |        |          |Read Operation
S * |        |          |0 = Port reset signal is not active.
S * |        |          |1 = Port reset signal is active.
S * |[8]     |PPS       |Port Power Status
S * |        |          |This bit reflects the power state of the port regardless of the power switching mode.
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Port Power Enabled.
S * |        |          |Read Operation:
S * |        |          |0 = Port power is Disabled.
S * |        |          |1 = Port power is Enabled.
S * |[9]     |LSDA      |Low Speed Device Attached (Read) Or Clear Port Power (Write)
S * |        |          |This bit defines the speed (and bud idle) of the attached device.
S * |        |          |It is only valid when CCS (HcRhPrt1[0]) is set.
S * |        |          |This bit is also used to clear port power.
S * |        |          |Write Operation:
S * |        |          |0 = No effect.
S * |        |          |1 = Clear PPS (HcRhPrt1[8]).
S * |        |          |Read Operation:
S * |        |          |0 = Full Speed device.
S * |        |          |1 = Low-speed device.
S * |[16]    |CSC       |Connect Status Change
S * |        |          |This bit indicates connect or disconnect event has been detected (CCS
S * |        |          |(HcRhPrt1[0]) changed).
S * |        |          |Write 1 to clear this bit to zero.
S * |        |          |0 = No connect/disconnect event (CCS (HcRhPrt1[0]) didn't change).
S * |        |          |1 = Hardware detection of connect/disconnect event (CCS
S * |        |          |(HcRhPrt1[0]) changed).
S * |[17]    |PESC      |Port Enable Status Change
S * |        |          |This bit indicates that the port has been disabled (PES (HcRhPrt1[1]) cleared) due to a hardware event.
S * |        |          |Write 1 to clear this bit to zero.
S * |        |          |0 = PES (HcRhPrt1[1]) didn't change.
S * |        |          |1 = PES (HcRhPrt1[1]) changed.
S * |[18]    |PSSC      |Port Suspend Status Change
S * |        |          |This bit indicates the completion of the selective resume sequence for the port.
S * |        |          |Write 1 to clear this bit to zero.
S * |        |          |0 = Port resume is not completed.
S * |        |          |1 = Port resume completed.
S * |[19]    |OCIC      |Port Over Current Indicator Change
S * |        |          |This bit is set when POCI (HcRhPrt1[3]) changes.
S * |        |          |Write 1 to clear this bit to zero.
S * |        |          |0 = POCI (HcRhPrt1[3]) didn't change.
S * |        |          |1 = POCI (HcRhPrt1[3]) changes.
S * |[20]    |PRSC      |Port Reset Status Change
S * |        |          |This bit indicates that the port reset signal has completed.
S * |        |          |Write 1 to clear this bit to zero.
S * |        |          |0 = Port reset is not complete.
S * |        |          |1 = Port reset is complete.
S * @var USBH_T::HcPhyControl
S * Offset: 0x200  USB Host Controller PHY Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[27]    |STBYEN    |USB Transceiver Standby Enable Bit
S * |        |          |This bit controls if USB transceiver could enter the standby mode to reduce power consumption.
S * |        |          |0 = The USB transceiver would never enter the standby mode.
S * |        |          |1 = The USB transceiver will enter standby mode while port is in power off state (port power is inactive).
S * @var USBH_T::HcMiscControl
S * Offset: 0x204  USB Host Controller Miscellaneous Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1]     |ABORT     |AHB Bus ERROR Response
S * |        |          |This bit indicates there is an ERROR response received in AHB bus.
S * |        |          |0 = No ERROR response received.
S * |        |          |1 = ERROR response received.
S * |[3]     |OCAL      |Over Current Active Low
S * |        |          |This bit controls the polarity of over current flag from external power IC.
S * |        |          |0 = Over current flag is high active.
S * |        |          |1 = Over current flag is low active.
S * |[16]    |DPRT1     |Disable Port 1
S * |        |          |This bit controls if the connection between USB host controller and transceiver of port 1 is disabled.
S * |        |          |If the connection is disabled, the USB host controller will not recognize any event of USB bus.
S * |        |          |Set this bit high, the transceiver of port 1 will also be forced into the standby mode no matter what USB host controller operation is.
S * |        |          |0 = The connection between USB host controller and transceiver of port 1 is enabled.
S * |        |          |1 = The connection between USB host controller and transceiver of port 1 is disabled and the transceiver of port 1 will also be forced into the standby mode.
S    */
S
S    __I  uint32_t HcRevision;    /* Offset: 0x00  Host Controller Revision Register                                  */
S    __IO uint32_t HcControl;     /* Offset: 0x04  Host Controller Control Register                                   */
S    __IO uint32_t HcCommandStatus; /* Offset: 0x08  Host Controller CMD Status Register                                */
S    __IO uint32_t HcInterruptStatus; /* Offset: 0x0C  Host Controller Interrupt Status Register                          */
S    __IO uint32_t HcInterruptEnable; /* Offset: 0x10  Host Controller Interrupt Enable Register                          */
S    __IO uint32_t HcInterruptDisable; /* Offset: 0x14  Host Controller Interrupt Disable Register                         */
S    __IO uint32_t HcHCCA;        /* Offset: 0x18  Host Controller Communication Area Register                        */
S    __IO uint32_t HcPeriodCurrentED; /* Offset: 0x1C  Host Controller Period Current ED Register                         */
S    __IO uint32_t HcControlHeadED; /* Offset: 0x20  Host Controller Control Head ED Register                           */
S    __IO uint32_t HcControlCurrentED; /* Offset: 0x24  Host Controller Control Current ED Register                        */
S    __IO uint32_t HcBulkHeadED;  /* Offset: 0x28  Host Controller Bulk Head ED Register                              */
S    __IO uint32_t HcBulkCurrentED; /* Offset: 0x2C  Host Controller Bulk Current ED Register                           */
S    __IO uint32_t HcDoneHead;    /* Offset: 0x30  Host Controller Done Head Register                                 */
S    __IO uint32_t HcFmInterval;  /* Offset: 0x34  Host Controller Frame Interval Register                            */
S    __I  uint32_t HcFmRemaining; /* Offset: 0x38  Host Controller Frame Remaining Register                           */
S    __I  uint32_t HcFmNumber;    /* Offset: 0x3C  Host Controller Frame Number Register                              */
S    __IO uint32_t HcPeriodicStart; /* Offset: 0x40  Host Controller Periodic Start Register                            */
S    __IO uint32_t HcLSThreshold; /* Offset: 0x44  Host Controller Low-speed Threshold Register                       */
S    __IO uint32_t HcRhDescriptorA; /* Offset: 0x48  Host Controller Root Hub Descriptor A Register                     */
S    __IO uint32_t HcRhDescriptorB; /* Offset: 0x4C  Host Controller Root Hub Descriptor B Register                     */
S    __IO uint32_t HcRhStatus;    /* Offset: 0x50  Host Controller Root Hub Status Register                           */
S    __IO uint32_t HcRhPortStatus[2]; /* Offset: 0x54  Host Controller Root Hub Port Status [1]                           */
S    __I  uint32_t RESERVE0[105];
S    __IO uint32_t HcPhyControl;  /* Offset: 0x200  USB Host Controller PHY Control Register                          */
S    __IO uint32_t HcMiscControl; /* Offset: 0x204  USB Host Controller Miscellaneous Control Register                */
S
S} USBH_T;
S
S
S
S
S/**
S    @addtogroup USBH_CONST USBH Bit Field Definition
S    Constant Definitions for USBH Controller
S@{ */
S
S#define USBH_HcRevision_REV_Pos          (0)                                               /*!< USBH_T::HcRevision: REV Position          */
S#define USBH_HcRevision_REV_Msk          (0xfful << USBH_HcRevision_REV_Pos)               /*!< USBH_T::HcRevision: REV Mask              */
S
S#define USBH_HcControl_CBSR_Pos          (0)                                               /*!< USBH_T::HcControl: CBSR Position          */
S#define USBH_HcControl_CBSR_Msk          (0x3ul << USBH_HcControl_CBSR_Pos)                /*!< USBH_T::HcControl: CBSR Mask              */
S
S#define USBH_HcControl_PLE_Pos           (2)                                               /*!< USBH_T::HcControl: CBSR Position          */
S#define USBH_HcControl_PLE_Msk           (0x1ul << USBH_HcControl_PLE_Pos)                 /*!< USBH_T::HcControl: CBSR Mask              */
S
S#define USBH_HcControl_IE_Pos            (3)                                               /*!< USBH_T::HcControl: IE Position            */
S#define USBH_HcControl_IE_Msk            (0x1ul << USBH_HcControl_IE_Pos)                  /*!< USBH_T::HcControl: IE Mask                */
S
S#define USBH_HcControl_CLE_Pos           (4)                                               /*!< USBH_T::HcControl: CLE Position           */
S#define USBH_HcControl_CLE_Msk           (0x1ul << USBH_HcControl_CLE_Pos)                 /*!< USBH_T::HcControl: CLE Mask               */
S
S#define USBH_HcControl_BLE_Pos           (5)                                               /*!< USBH_T::HcControl: BLE Position           */
S#define USBH_HcControl_BLE_Msk           (0x1ul << USBH_HcControl_BLE_Pos)                 /*!< USBH_T::HcControl: BLE Mask               */
S
S#define USBH_HcControl_HCFS_Pos          (6)                                               /*!< USBH_T::HcControl: HCFS Position          */
S#define USBH_HcControl_HCFS_Msk          (0x3ul << USBH_HcControl_HCFS_Pos)                /*!< USBH_T::HcControl: HCFS Mask              */
S
S#define USBH_HcCommandStatus_HCR_Pos     (0)                                               /*!< USBH_T::HcCommandStatus: HCR Position     */
S#define USBH_HcCommandStatus_HCR_Msk     (0x1ul << USBH_HcCommandStatus_HCR_Pos)           /*!< USBH_T::HcCommandStatus: HCR Mask         */
S
S#define USBH_HcCommandStatus_CLF_Pos     (1)                                               /*!< USBH_T::HcCommandStatus: CLF Position     */
S#define USBH_HcCommandStatus_CLF_Msk     (0x1ul << USBH_HcCommandStatus_CLF_Pos)           /*!< USBH_T::HcCommandStatus: CLF Mask         */
S
S#define USBH_HcCommandStatus_BLF_Pos     (2)                                               /*!< USBH_T::HcCommandStatus: BLF Position     */
S#define USBH_HcCommandStatus_BLF_Msk     (0x1ul << USBH_HcCommandStatus_BLF_Pos)           /*!< USBH_T::HcCommandStatus: BLF Mask         */
S
S#define USBH_HcCommandStatus_SOC_Pos     (16)                                              /*!< USBH_T::HcCommandStatus: SOC Position     */
S#define USBH_HcCommandStatus_SOC_Msk     (0x3ul << USBH_HcCommandStatus_SOC_Pos)           /*!< USBH_T::HcCommandStatus: SOC Mask         */
S
S#define USBH_HcInterruptStatus_SO_Pos    (0)                                               /*!< USBH_T::HcInterruptStatus: SO Position    */
S#define USBH_HcInterruptStatus_SO_Msk    (0x1ul << USBH_HcInterruptStatus_SO_Pos)          /*!< USBH_T::HcInterruptStatus: SO Mask        */
S
S#define USBH_HcInterruptStatus_WDH_Pos   (1)                                               /*!< USBH_T::HcInterruptStatus: WDH Position   */
S#define USBH_HcInterruptStatus_WDH_Msk   (0x1ul << USBH_HcInterruptStatus_WDH_Pos)         /*!< USBH_T::HcInterruptStatus: WDH Mask       */
S
S#define USBH_HcInterruptStatus_SF_Pos    (2)                                               /*!< USBH_T::HcInterruptStatus: SF Position    */
S#define USBH_HcInterruptStatus_SF_Msk    (0x1ul << USBH_HcInterruptStatus_SF_Pos)          /*!< USBH_T::HcInterruptStatus: SF Mask        */
S
S#define USBH_HcInterruptStatus_RD_Pos    (3)                                               /*!< USBH_T::HcInterruptStatus: RD Position    */
S#define USBH_HcInterruptStatus_RD_Msk    (0x1ul << USBH_HcInterruptStatus_RD_Pos)          /*!< USBH_T::HcInterruptStatus: RD Mask        */
S
S#define USBH_HcInterruptStatus_FNO_Pos   (5)                                               /*!< USBH_T::HcInterruptStatus: FNO Position   */
S#define USBH_HcInterruptStatus_FNO_Msk   (0x1ul << USBH_HcInterruptStatus_FNO_Pos)         /*!< USBH_T::HcInterruptStatus: FNO Mask       */
S
S#define USBH_HcInterruptStatus_RHSC_Pos  (6)                                               /*!< USBH_T::HcInterruptStatus: RHSC Position  */
S#define USBH_HcInterruptStatus_RHSC_Msk  (0x1ul << USBH_HcInterruptStatus_RHSC_Pos)        /*!< USBH_T::HcInterruptStatus: RHSC Mask      */
S
S#define USBH_HcInterruptEnable_SO_Pos    (0)                                               /*!< USBH_T::HcInterruptEnable: SO Position    */
S#define USBH_HcInterruptEnable_SO_Msk    (0x1ul << USBH_HcInterruptEnable_SO_Pos)          /*!< USBH_T::HcInterruptEnable: SO Mask        */
S
S#define USBH_HcInterruptEnable_WDH_Pos   (1)                                               /*!< USBH_T::HcInterruptEnable: WDH Position   */
S#define USBH_HcInterruptEnable_WDH_Msk   (0x1ul << USBH_HcInterruptEnable_WDH_Pos)         /*!< USBH_T::HcInterruptEnable: WDH Mask       */
S
S#define USBH_HcInterruptEnable_SF_Pos    (2)                                               /*!< USBH_T::HcInterruptEnable: SF Position    */
S#define USBH_HcInterruptEnable_SF_Msk    (0x1ul << USBH_HcInterruptEnable_SF_Pos)          /*!< USBH_T::HcInterruptEnable: SF Mask        */
S
S#define USBH_HcInterruptEnable_RD_Pos    (3)                                               /*!< USBH_T::HcInterruptEnable: RD Position    */
S#define USBH_HcInterruptEnable_RD_Msk    (0x1ul << USBH_HcInterruptEnable_RD_Pos)          /*!< USBH_T::HcInterruptEnable: RD Mask        */
S
S#define USBH_HcInterruptEnable_FNO_Pos   (5)                                               /*!< USBH_T::HcInterruptEnable: FNO Position   */
S#define USBH_HcInterruptEnable_FNO_Msk   (0x1ul << USBH_HcInterruptEnable_FNO_Pos)         /*!< USBH_T::HcInterruptEnable: FNO Mask       */
S
S#define USBH_HcInterruptEnable_RHSC_Pos  (6)                                               /*!< USBH_T::HcInterruptEnable: RHSC Position  */
S#define USBH_HcInterruptEnable_RHSC_Msk  (0x1ul << USBH_HcInterruptEnable_RHSC_Pos)        /*!< USBH_T::HcInterruptEnable: RHSC Mask      */
S
S#define USBH_HcInterruptEnable_MIE_Pos   (31)                                              /*!< USBH_T::HcInterruptEnable: MIE Position   */
S#define USBH_HcInterruptEnable_MIE_Msk   (0x1ul << USBH_HcInterruptEnable_MIE_Pos)         /*!< USBH_T::HcInterruptEnable: MIE Mask       */
S
S#define USBH_HcInterruptDisable_SO_Pos   (0)                                               /*!< USBH_T::HcInterruptDisable: SO Position   */
S#define USBH_HcInterruptDisable_SO_Msk   (0x1ul << USBH_HcInterruptDisable_SO_Pos)         /*!< USBH_T::HcInterruptDisable: SO Mask       */
S
S#define USBH_HcInterruptDisable_WDH_Pos  (1)                                               /*!< USBH_T::HcInterruptDisable: WDH Position  */
S#define USBH_HcInterruptDisable_WDH_Msk  (0x1ul << USBH_HcInterruptDisable_WDH_Pos)        /*!< USBH_T::HcInterruptDisable: WDH Mask      */
S
S#define USBH_HcInterruptDisable_SF_Pos   (2)                                               /*!< USBH_T::HcInterruptDisable: SF Position   */
S#define USBH_HcInterruptDisable_SF_Msk   (0x1ul << USBH_HcInterruptDisable_SF_Pos)         /*!< USBH_T::HcInterruptDisable: SF Mask       */
S
S#define USBH_HcInterruptDisable_RD_Pos   (3)                                               /*!< USBH_T::HcInterruptDisable: RD Position   */
S#define USBH_HcInterruptDisable_RD_Msk   (0x1ul << USBH_HcInterruptDisable_RD_Pos)         /*!< USBH_T::HcInterruptDisable: RD Mask       */
S
S#define USBH_HcInterruptDisable_FNO_Pos  (5)                                               /*!< USBH_T::HcInterruptDisable: FNO Position  */
S#define USBH_HcInterruptDisable_FNO_Msk  (0x1ul << USBH_HcInterruptDisable_FNO_Pos)        /*!< USBH_T::HcInterruptDisable: FNO Mask      */
S
S#define USBH_HcInterruptDisable_RHSC_Pos (6)                                               /*!< USBH_T::HcInterruptDisable: RHSC Position */
S#define USBH_HcInterruptDisable_RHSC_Msk (0x1ul << USBH_HcInterruptDisable_RHSC_Pos)       /*!< USBH_T::HcInterruptDisable: RHSC Mask     */
S
S#define USBH_HcInterruptDisable_MIE_Pos  (31)                                              /*!< USBH_T::HcInterruptDisable: MIE Position  */
S#define USBH_HcInterruptDisable_MIE_Msk  (0x1ul << USBH_HcInterruptDisable_MIE_Pos)        /*!< USBH_T::HcInterruptDisable: MIE Mask      */
S
S#define USBH_HcHCCA_HCCA_Pos             (8)                                               /*!< USBH_T::HcHCCA: HCCA Position             */
S#define USBH_HcHCCA_HCCA_Msk             (0xfffffful << USBH_HcHCCA_HCCA_Pos)              /*!< USBH_T::HcHCCA: HCCA Mask                 */
S
S#define USBH_HcPeriodCurrentED_PCED_Pos  (4)                                               /*!< USBH_T::HcPeriodCurrentED: PCED Position  */
S#define USBH_HcPeriodCurrentED_PCED_Msk  (0xffffffful << USBH_HcPeriodCurrentED_PCED_Pos)  /*!< USBH_T::HcPeriodCurrentED: PCED Mask      */
S
S#define USBH_HcControlHeadED_CHED_Pos    (4)                                               /*!< USBH_T::HcControlHeadED: CHED Position    */
S#define USBH_HcControlHeadED_CHED_Msk    (0xffffffful << USBH_HcControlHeadED_CHED_Pos)    /*!< USBH_T::HcControlHeadED: CHED Mask        */
S
S#define USBH_HcControlCurrentED_CCED_Pos (4)                                               /*!< USBH_T::HcControlCurrentED: CCED Position */
S#define USBH_HcControlCurrentED_CCED_Msk (0xffffffful << USBH_HcControlCurrentED_CCED_Pos) /*!< USBH_T::HcControlCurrentED: CCED Mask     */
S
S#define USBH_HcBulkHeadED_BHED_Pos       (4)                                               /*!< USBH_T::HcBulkHeadED: BHED Position       */
S#define USBH_HcBulkHeadED_BHED_Msk       (0xffffffful << USBH_HcBulkHeadED_BHED_Pos)       /*!< USBH_T::HcBulkHeadED: BHED Mask           */
S
S#define USBH_HcBulkCurrentED_BCED_Pos    (4)                                               /*!< USBH_T::HcBulkCurrentED: BCED Position    */
S#define USBH_HcBulkCurrentED_BCED_Msk    (0xffffffful << USBH_HcBulkCurrentED_BCED_Pos)    /*!< USBH_T::HcBulkCurrentED: BCED Mask        */
S
S#define USBH_HcDoneHead_DH_Pos           (4)                                               /*!< USBH_T::HcDoneHead: DH Position           */
S#define USBH_HcDoneHead_DH_Msk           (0xffffffful << USBH_HcDoneHead_DH_Pos)           /*!< USBH_T::HcDoneHead: DH Mask               */
S
S#define USBH_HcFmInterval_FI_Pos         (0)                                               /*!< USBH_T::HcFmInterval: FI Position         */
S#define USBH_HcFmInterval_FI_Msk         (0x3ffful << USBH_HcFmInterval_FI_Pos)            /*!< USBH_T::HcFmInterval: FI Mask             */
S
S#define USBH_HcFmInterval_FSMPS_Pos      (16)                                              /*!< USBH_T::HcFmInterval: FSMPS Position      */
S#define USBH_HcFmInterval_FSMPS_Msk      (0x7ffful << USBH_HcFmInterval_FSMPS_Pos)         /*!< USBH_T::HcFmInterval: FSMPS Mask          */
S
S#define USBH_HcFmInterval_FIT_Pos        (31)                                              /*!< USBH_T::HcFmInterval: FIT Position        */
S#define USBH_HcFmInterval_FIT_Msk        (0x1ul << USBH_HcFmInterval_FIT_Pos)              /*!< USBH_T::HcFmInterval: FIT Mask            */
S
S#define USBH_HcFmRemaining_FR_Pos        (0)                                               /*!< USBH_T::HcFmRemaining: FR Position        */
S#define USBH_HcFmRemaining_FR_Msk        (0x3ffful << USBH_HcFmRemaining_FR_Pos)           /*!< USBH_T::HcFmRemaining: FR Mask            */
S
S#define USBH_HcFmRemaining_FRT_Pos       (31)                                              /*!< USBH_T::HcFmRemaining: FRT Position       */
S#define USBH_HcFmRemaining_FRT_Msk       (0x1ul << USBH_HcFmRemaining_FRT_Pos)             /*!< USBH_T::HcFmRemaining: FRT Mask           */
S
S#define USBH_HcFmNumber_FN_Pos           (0)                                               /*!< USBH_T::HcFmNumber: FN Position           */
S#define USBH_HcFmNumber_FN_Msk           (0xfffful << USBH_HcFmNumber_FN_Pos)              /*!< USBH_T::HcFmNumber: FN Mask               */
S
S#define USBH_HcPeriodicStart_PS_Pos      (0)                                               /*!< USBH_T::HcPeriodicStart: PS Position      */
S#define USBH_HcPeriodicStart_PS_Msk      (0x3ffful << USBH_HcPeriodicStart_PS_Pos)         /*!< USBH_T::HcPeriodicStart: PS Mask          */
S
S#define USBH_HcLSThreshold_LST_Pos       (0)                                               /*!< USBH_T::HcLSThreshold: LST Position       */
S#define USBH_HcLSThreshold_LST_Msk       (0xffful << USBH_HcLSThreshold_LST_Pos)           /*!< USBH_T::HcLSThreshold: LST Mask           */
S
S#define USBH_HcRhDescriptorA_NDP_Pos     (0)                                               /*!< USBH_T::HcRhDescriptorA: NDP Position     */
S#define USBH_HcRhDescriptorA_NDP_Msk     (0xfful << USBH_HcRhDescriptorA_NDP_Pos)          /*!< USBH_T::HcRhDescriptorA: NDP Mask         */
S
S#define USBH_HcRhDescriptorA_PSM_Pos     (8)                                               /*!< USBH_T::HcRhDescriptorA: PSM Position     */
S#define USBH_HcRhDescriptorA_PSM_Msk     (0x1ul << USBH_HcRhDescriptorA_PSM_Pos)           /*!< USBH_T::HcRhDescriptorA: PSM Mask         */
S
S#define USBH_HcRhDescriptorA_OCPM_Pos    (11)                                              /*!< USBH_T::HcRhDescriptorA: OCPM Position    */
S#define USBH_HcRhDescriptorA_OCPM_Msk    (0x1ul << USBH_HcRhDescriptorA_OCPM_Pos)          /*!< USBH_T::HcRhDescriptorA: OCPM Mask        */
S
S#define USBH_HcRhDescriptorA_NOCP_Pos    (12)                                              /*!< USBH_T::HcRhDescriptorA: NOCP Position    */
S#define USBH_HcRhDescriptorA_NOCP_Msk    (0x1ul << USBH_HcRhDescriptorA_NOCP_Pos)          /*!< USBH_T::HcRhDescriptorA: NOCP Mask        */
S
S#define USBH_HcRhDescriptorB_PPCM_Pos    (16)                                              /*!< USBH_T::HcRhDescriptorB: PPCM Position    */
S#define USBH_HcRhDescriptorB_PPCM_Msk    (0xfffful << USBH_HcRhDescriptorB_PPCM_Pos)       /*!< USBH_T::HcRhDescriptorB: PPCM Mask        */
S
S#define USBH_HcRhStatus_LPS_Pos          (0)                                               /*!< USBH_T::HcRhStatus: LPS Position          */
S#define USBH_HcRhStatus_LPS_Msk          (0x1ul << USBH_HcRhStatus_LPS_Pos)                /*!< USBH_T::HcRhStatus: LPS Mask              */
S
S#define USBH_HcRhStatus_OCI_Pos          (1)                                               /*!< USBH_T::HcRhStatus: OCI Position          */
S#define USBH_HcRhStatus_OCI_Msk          (0x1ul << USBH_HcRhStatus_OCI_Pos)                /*!< USBH_T::HcRhStatus: OCI Mask              */
S
S#define USBH_HcRhStatus_DRWE_Pos         (15)                                              /*!< USBH_T::HcRhStatus: DRWE Position         */
S#define USBH_HcRhStatus_DRWE_Msk         (0x1ul << USBH_HcRhStatus_DRWE_Pos)               /*!< USBH_T::HcRhStatus: DRWE Mask             */
S
S#define USBH_HcRhStatus_LPSC_Pos         (16)                                              /*!< USBH_T::HcRhStatus: LPSC Position         */
S#define USBH_HcRhStatus_LPSC_Msk         (0x1ul << USBH_HcRhStatus_LPSC_Pos)               /*!< USBH_T::HcRhStatus: LPSC Mask             */
S
S#define USBH_HcRhStatus_OCIC_Pos         (17)                                              /*!< USBH_T::HcRhStatus: OCIC Position         */
S#define USBH_HcRhStatus_OCIC_Msk         (0x1ul << USBH_HcRhStatus_OCIC_Pos)               /*!< USBH_T::HcRhStatus: OCIC Mask             */
S
S#define USBH_HcRhStatus_CRWE_Pos         (31)                                              /*!< USBH_T::HcRhStatus: CRWE Position         */
S#define USBH_HcRhStatus_CRWE_Msk         (0x1ul << USBH_HcRhStatus_CRWE_Pos)               /*!< USBH_T::HcRhStatus: CRWE Mask             */
S
S#define USBH_HcRhPortStatus_CCS_Pos      (0)                                               /*!< USBH_T::HcRhPortStatus: CCS Position      */
S#define USBH_HcRhPortStatus_CCS_Msk      (0x1ul << USBH_HcRhPortStatus_CCS_Pos)             /*!< USBH_T::HcRhPortStatus: CCS Mask         */
S
S#define USBH_HcRhPortStatus_PES_Pos      (1)                                               /*!< USBH_T::HcRhPortStatus: PES Position      */
S#define USBH_HcRhPortStatus_PES_Msk      (0x1ul << USBH_HcRhPortStatus_PES_Pos)            /*!< USBH_T::HcRhPortStatus: PES Mask          */
S
S#define USBH_HcRhPortStatus_PSS_Pos      (2)                                               /*!< USBH_T::HcRhPortStatus: PSS Position      */
S#define USBH_HcRhPortStatus_PSS_Msk      (0x1ul << USBH_HcRhPortStatus_PSS_Pos)            /*!< USBH_T::HcRhPortStatus: PSS Mask          */
S
S#define USBH_HcRhPortStatus_POCI_Pos     (3)                                               /*!< USBH_T::HcRhPortStatus: POCI Position     */
S#define USBH_HcRhPortStatus_POCI_Msk     (0x1ul << USBH_HcRhPortStatus_POCI_Pos)           /*!< USBH_T::HcRhPortStatus: POCI Mask         */
S
S#define USBH_HcRhPortStatus_PRS_Pos      (4)                                               /*!< USBH_T::HcRhPortStatus: PRS Position      */
S#define USBH_HcRhPortStatus_PRS_Msk      (0x1ul << USBH_HcRhPortStatus_PRS_Pos)            /*!< USBH_T::HcRhPortStatus: PRS Mask          */
S
S#define USBH_HcRhPortStatus_PPS_Pos      (8)                                               /*!< USBH_T::HcRhPortStatus: PPS Position      */
S#define USBH_HcRhPortStatus_PPS_Msk      (0x1ul << USBH_HcRhPortStatus_PPS_Pos)            /*!< USBH_T::HcRhPortStatus: PPS Mask          */
S
S#define USBH_HcRhPortStatus_LSDA_Pos     (9)                                               /*!< USBH_T::HcRhPortStatus: LSDA Position     */
S#define USBH_HcRhPortStatus_LSDA_Msk     (0x1ul << USBH_HcRhPortStatus_LSDA_Pos)           /*!< USBH_T::HcRhPortStatus: LSDA Mask         */
S
S#define USBH_HcRhPortStatus_CSC_Pos      (16)                                              /*!< USBH_T::HcRhPortStatus: CSC Position      */
S#define USBH_HcRhPortStatus_CSC_Msk      (0x1ul << USBH_HcRhPortStatus_CSC_Pos)            /*!< USBH_T::HcRhPortStatus: CSC Mask          */
S
S#define USBH_HcRhPortStatus_PESC_Pos     (17)                                              /*!< USBH_T::HcRhPortStatus: PESC Position     */
S#define USBH_HcRhPortStatus_PESC_Msk     (0x1ul << USBH_HcRhPortStatus_PESC_Pos)           /*!< USBH_T::HcRhPortStatus: PESC Mask         */
S
S#define USBH_HcRhPortStatus_PSSC_Pos     (18)                                              /*!< USBH_T::HcRhPortStatus: PSSC Position     */
S#define USBH_HcRhPortStatus_PSSC_Msk     (0x1ul << USBH_HcRhPortStatus_PSSC_Pos)           /*!< USBH_T::HcRhPortStatus: PSSC Mask         */
S
S#define USBH_HcRhPortStatus_OCIC_Pos     (19)                                              /*!< USBH_T::HcRhPortStatus: OCIC Position     */
S#define USBH_HcRhPortStatus_OCIC_Msk     (0x1ul << USBH_HcRhPortStatus_OCIC_Pos)           /*!< USBH_T::HcRhPortStatus: OCIC Mask         */
S
S#define USBH_HcRhPortStatus_PRSC_Pos     (20)                                              /*!< USBH_T::HcRhPortStatus: PRSC Position     */
S#define USBH_HcRhPortStatus_PRSC_Msk     (0x1ul << USBH_HcRhPortStatus_PRSC_Pos)           /*!< USBH_T::HcRhPortStatus: PRSC Mask         */
S
S#define USBH_HcPhyControl_STBYEN_Pos     (27)                                              /*!< USBH_T::HcPhyControl: STBYEN Position     */
S#define USBH_HcPhyControl_STBYEN_Msk     (0x1ul << USBH_HcPhyControl_STBYEN_Pos)           /*!< USBH_T::HcPhyControl: STBYEN Mask         */
S
S#define USBH_HcMiscControl_ABORT_Pos     (1)                                               /*!< USBH_T::HcMiscControl: ABORT Position     */
S#define USBH_HcMiscControl_ABORT_Msk     (0x1ul << USBH_HcMiscControl_ABORT_Pos)           /*!< USBH_T::HcMiscControl: ABORT Mask         */
S
S#define USBH_HcMiscControl_OCAL_Pos      (3)                                               /*!< USBH_T::HcMiscControl: OCAL Position      */
S#define USBH_HcMiscControl_OCAL_Msk      (0x1ul << USBH_HcMiscControl_OCAL_Pos)            /*!< USBH_T::HcMiscControl: OCAL Mask          */
S
S#define USBH_HcMiscControl_DPRT1_Pos     (16)                                              /*!< USBH_T::HcMiscControl: DPRT1 Position     */
S#define USBH_HcMiscControl_DPRT1_Msk     (0x1ul << USBH_HcMiscControl_DPRT1_Pos)           /*!< USBH_T::HcMiscControl: DPRT1 Mask         */
S
S/**@}*/ /* USBH_CONST */
S/**@}*/ /* end of USBH register group */
S
S
S/*---------------------- Watch Dog Timer Controller -------------------------*/
S/**
S    @addtogroup WDT Watch Dog Timer Controller(WDT)
S    Memory Mapped Structure for WDT Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S
S
S/**
S * @var WDT_T::CTL
S * Offset: 0x00  WDT Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |RSTCNT    |Reset WDT Up Counter (Write Protect)
S * |        |          |0 = No effect.
S * |        |          |1 = Reset the internal 18-bit WDT up counter value.
S * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |        |          |Note2: This bit will be automatically cleared by hardware.
S * |[1]     |RSTEN     |WDT Time-Out Reset Enable Control (Write Protect)
S * |        |          |Setting this bit will enable the WDT time-out reset function If the WDT up counter value has not been cleared after the specific WDT reset delay period expires.
S * |        |          |0 = WDT time-out reset function Disabled.
S * |        |          |1 = WDT time-out reset function Enabled.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[2]     |RSTF      |WDT Time-Out Reset Flag
S * |        |          |This bit indicates the system has been reset by WDT time-out reset or not.
S * |        |          |0 = WDT time-out reset did not occur.
S * |        |          |1 = WDT time-out reset occurred.
S * |        |          |Note: This bit is cleared by writing 1 to it.
S * |[3]     |IF        |WDT Time-Out Interrupt Flag
S * |        |          |This bit will set to 1 while WDT up counter value reaches the selected WDT time-out interval
S * |        |          |0 = WDT time-out interrupt did not occur.
S * |        |          |1 = WDT time-out interrupt occurred.
S * |        |          |Note: This bit is cleared by writing 1 to it.
S * |[4]     |WKEN      |WDT Time-Out Wake-Up Function Control (Write Protect)
S * |        |          |If this bit is set to 1, while WDT time-out interrupt flag IF (WDT_CTL[3]) is generated to 1 and interrupt enable bit INTEN (WDT_CTL[6]) is enabled, the WDT time-out interrupt signal will generate a wake-up trigger event to chip.
S * |        |          |0 = Wake-up trigger event Disabled if WDT time-out interrupt signal generated.
S * |        |          |1 = Wake-up trigger event Enabled if WDT time-out interrupt signal generated.
S * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |        |          |Note2: Chip can be woken-up by WDT time-out interrupt signal generated only if WDT clock source is selected to 10 kHz oscillator.
S * |[5]     |WKF       |WDT Time-Out Wake-Up Flag
S * |        |          |This bit indicates the interrupt wake-up flag status of WDT
S * |        |          |0 = WDT does not cause chip wake-up.
S * |        |          |1 = Chip wake-up from Idle or Power-down mode if WDT time-out interrupt signal generated.
S * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |        |          |Note2: This bit is cleared by writing 1 to it.
S * |[6]     |INTEN     |WDT Time-Out Interrupt Enable Control (Write Protect)
S * |        |          |If this bit is enabled, the WDT time-out interrupt signal is generated and inform to CPU.
S * |        |          |0 = WDT time-out interrupt Disabled.
S * |        |          |1 = WDT time-out interrupt Enabled.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[7]     |WDTEN     |WDT Enable Control (Write Protect)
S * |        |          |0 = WDT Disabled (This action will reset the internal up counter value).
S * |        |          |1 = WDT Enabled.
S * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |        |          |Note2: If CWDTEN[2:0] (combined by Config0[31] and Config0[4:3]) bits is not configure to 111, this bit is forced as 1 and user cannot change this bit to 0.
S * |[10:8]  |TOUTSEL   |WDT Time-Out Interval Selection (Write Protect)
S * |        |          |These three bits select the time-out interval period for the WDT.
S * |        |          |000 = (2^4)*TWDT.
S * |        |          |001 = (2^6)*TWDT.
S * |        |          |010 = (2^8)*TWDT.
S * |        |          |011 = (2^10)*TWDT.
S * |        |          |100 = (2^12)*TWDT.
S * |        |          |101 = (2^14)*TWDT.
S * |        |          |110 = (2^16)*TWDT.
S * |        |          |111 = (2^18)*TWDT.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable Control (Write Protect)
S * |        |          |0 = ICE debug mode acknowledgement affects WDT counting.
S * |        |          |WDT up counter will be held while CPU is held by ICE.
S * |        |          |1 = ICE debug mode acknowledgement Disabled.
S * |        |          |WDT up counter will keep going no matter CPU is held by ICE or not.
S * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
S * @var WDT_T::ALTCTL
S * Offset: 0x04  WDT Alternative Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |RSTDSEL   |WDT Reset Delay Selection (Write Protect)
S * |        |          |When WDT time-out happened, user has a time named WDT Reset Delay Period to clear WDT counter by setting RSTCNT (WDT_CTL[0]) to prevent WDT time-out reset happened.
S * |        |          |User can select a suitable setting of RSTDSEL for different WDT Reset Delay Period.
S * |        |          |00 = WDT Reset Delay Period is 1026 * WDT_CLK.
S * |        |          |01 = WDT Reset Delay Period is 130 * WDT_CLK.
S * |        |          |10 = WDT Reset Delay Period is 18 * WDT_CLK.
S * |        |          |11 = WDT Reset Delay Period is 3 * WDT_CLK.
S * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
S * |        |          |Note2: This register will be reset to 0 if WDT time-out reset happened.
S */
S
S    __IO uint32_t CTL;           /* Offset: 0x00  WDT Control Register                                               */
S    __IO uint32_t ALTCTL;        /* Offset: 0x04  WDT Alternative Control Register                                   */
S
S} WDT_T;
S
S
S
S/**
S    @addtogroup WDT_CONST WDT Bit Field Definition
S    Constant Definitions for WDT Controller
S@{ */
S
S#define WDT_CTL_RSTCNT_Pos               (0)                                               /*!< WDT_T::CTL: RSTCNT Position               */
S#define WDT_CTL_RSTCNT_Msk               (0x1ul << WDT_CTL_RSTCNT_Pos)                     /*!< WDT_T::CTL: RSTCNT Mask                   */
S
S#define WDT_CTL_RSTEN_Pos                (1)                                               /*!< WDT_T::CTL: RSTEN Position                */
S#define WDT_CTL_RSTEN_Msk                (0x1ul << WDT_CTL_RSTEN_Pos)                      /*!< WDT_T::CTL: RSTEN Mask                    */
S
S#define WDT_CTL_RSTF_Pos                 (2)                                               /*!< WDT_T::CTL: RSTF Position                 */
S#define WDT_CTL_RSTF_Msk                 (0x1ul << WDT_CTL_RSTF_Pos)                       /*!< WDT_T::CTL: RSTF Mask                     */
S
S#define WDT_CTL_IF_Pos                   (3)                                               /*!< WDT_T::CTL: IF Position                   */
S#define WDT_CTL_IF_Msk                   (0x1ul << WDT_CTL_IF_Pos)                         /*!< WDT_T::CTL: IF Mask                       */
S
S#define WDT_CTL_WKEN_Pos                 (4)                                               /*!< WDT_T::CTL: WKEN Position                 */
S#define WDT_CTL_WKEN_Msk                 (0x1ul << WDT_CTL_WKEN_Pos)                       /*!< WDT_T::CTL: WKEN Mask                     */
S
S#define WDT_CTL_WKF_Pos                  (5)                                               /*!< WDT_T::CTL: WKF Position                  */
S#define WDT_CTL_WKF_Msk                  (0x1ul << WDT_CTL_WKF_Pos)                        /*!< WDT_T::CTL: WKF Mask                      */
S
S#define WDT_CTL_INTEN_Pos                (6)                                               /*!< WDT_T::CTL: INTEN Position                */
S#define WDT_CTL_INTEN_Msk                (0x1ul << WDT_CTL_INTEN_Pos)                      /*!< WDT_T::CTL: INTEN Mask                    */
S
S#define WDT_CTL_WDTEN_Pos                (7)                                               /*!< WDT_T::CTL: WDTEN Position                */
S#define WDT_CTL_WDTEN_Msk                (0x1ul << WDT_CTL_WDTEN_Pos)                      /*!< WDT_T::CTL: WDTEN Mask                    */
S
S#define WDT_CTL_TOUTSEL_Pos              (8)                                               /*!< WDT_T::CTL: TOUTSEL Position              */
S#define WDT_CTL_TOUTSEL_Msk              (0x7ul << WDT_CTL_TOUTSEL_Pos)                    /*!< WDT_T::CTL: TOUTSEL Mask                  */
S
S#define WDT_CTL_ICEDEBUG_Pos             (31)                                              /*!< WDT_T::CTL: ICEDEBUG Position             */
S#define WDT_CTL_ICEDEBUG_Msk             (0x1ul << WDT_CTL_ICEDEBUG_Pos)                   /*!< WDT_T::CTL: ICEDEBUG Mask                 */
S
S#define WDT_ALTCTL_RSTDSEL_Pos           (0)                                               /*!< WDT_T::ALTCTL: RSTDSEL Position           */
S#define WDT_ALTCTL_RSTDSEL_Msk           (0x3ul << WDT_ALTCTL_RSTDSEL_Pos)                 /*!< WDT_T::ALTCTL: RSTDSEL Mask               */
S
S/**@}*/ /* WDT_CONST */
S/**@}*/ /* end of WDT register group */
S
S
S/*---------------------- Window Watchdog Timer -------------------------*/
S/**
S    @addtogroup WWDT Window Watchdog Timer(WWDT)
S    Memory Mapped Structure for WWDT Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S
S
S/**
S * @var WWDT_T::RLDCNT
S * Offset: 0x00  WWDT Reload Counter Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |WWDT_RLDCNT|WWDT Reload Counter Register
S * |        |          |Writing 0x00005AA5 to this register will reload the WWDT counter value to 0x3F.
S * |        |          |Note: User can only write WWDT_RLDCNT register to reload WWDT counter value when current WWDT counter value between 0 and CMPDAT (WWDT_CTL[21:16]).
S * |        |          |If user writes WWDT_RLDCNT when current WWDT counter value is larger than CMPDAT , WWDT reset signal will generate immediately.
S * @var WWDT_T::CTL
S * Offset: 0x04  WWDT Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |WWDTEN    |WWDT Enable Control Bit
S * |        |          |Set this bit to enable WWDT counter counting.
S * |        |          |0 = WWDT counter is stopped.
S * |        |          |1 = WWDT counter is starting counting.
S * |[1]     |INTEN     |WWDT Interrupt Enable Control Bit
S * |        |          |If this bit is enabled, the WWDT counter compare match interrupt signal is generated and inform to CPU.
S * |        |          |0 = WWDT counter compare match interrupt Disabled.
S * |        |          |1 = WWDT counter compare match interrupt Enabled.
S * |[11:8]  |PSCSEL    |WWDT Counter Prescale Period Selection
S * |        |          |0000 = Pre-scale is 1; Max time-out period is 1 * 64 * TWWDT.
S * |        |          |0001 = Pre-scale is 2; Max time-out period is 2 * 64 * TWWDT.
S * |        |          |0010 = Pre-scale is 4; Max time-out period is 4 * 64 * TWWDT.
S * |        |          |0011 = Pre-scale is 8; Max time-out period is 8 * 64 * TWWDT.
S * |        |          |0100 = Pre-scale is 16; Max time-out period is 16 * 64 * TWWDT.
S * |        |          |0101 = Pre-scale is 32; Max time-out period is 32 * 64 * TWWDT.
S * |        |          |0110 = Pre-scale is 64; Max time-out period is 64 * 64 * TWWDT.
S * |        |          |0111 = Pre-scale is 128; Max time-out period is 128 * 64 * TWWDT.
S * |        |          |1000 = Pre-scale is 192; Max time-out period is 192 * 64 * TWWDT.
S * |        |          |1001 = Pre-scale is 256; Max time-out period is 256 * 64 * TWWDT.
S * |        |          |1010 = Pre-scale is 384; Max time-out period is 384 * 64 * TWWDT.
S * |        |          |1011 = Pre-scale is 512; Max time-out period is 512 * 64 * TWWDT.
S * |        |          |1100 = Pre-scale is 768; Max time-out period is 768 * 64 * TWWDT.
S * |        |          |1101 = Pre-scale is 1024; Max time-out period is 1024 * 64 * TWWDT.
S * |        |          |1110 = Pre-scale is 1536; Max time-out period is 1536 * 64 * TWWDT.
S * |        |          |1111 = Pre-scale is 2048; Max time-out period is 2048 * 64 * TWWDT.
S * |[21:16] |CMPDAT    |WWDT Window Compare Register
S * |        |          |Set this register to adjust the valid reload window.
S * |        |          |Note: User can only write WWDT_RLDCNT register to reload WWDT counter value when current WWDT counter value between 0 and CMPDAT.
S * |        |          |If user writes WWDT_RLDCNT register when current WWDT counter value larger than CMPDAT, WWDT reset signal will generate immediately.
S * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable Control
S * |        |          |0 = ICE debug mode acknowledgement effects WWDT counting.
S * |        |          |WWDT down counter will be held while CPU is held by ICE.
S * |        |          |1 = ICE debug mode acknowledgement Disabled.
S * |        |          |WWDT down counter will keep going no matter CPU is held by ICE or not.
S * @var WWDT_T::STATUS
S * Offset: 0x08  WWDT Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |WWDTIF    |WWDT Compare Match Interrupt Flag
S * |        |          |This bit indicates the interrupt flag status of WWDT while WWDT counter value matches CMPDAT (WWDT_CTL[21:16]).
S * |        |          |0 = No effect.
S * |        |          |1 = WWDT counter value matches CMPDAT.
S * |        |          |Note: This bit is cleared by writing 1 to it.
S * |[1]     |WWDTRF    |WWDT Timer-Out Reset Flag
S * |        |          |This bit indicates the system has been reset by WWDT time-out reset or not.
S * |        |          |0 = WWDT time-out reset did not occur.
S * |        |          |1 = WWDT time-out reset occurred.
S * |        |          |Note: This bit is cleared by writing 1 to it.
S * @var WWDT_T::CNT
S * Offset: 0x0C  WWDT Counter Value Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |CNTDAT    |WWDT Counter Value
S * |        |          |CNTDAT will be updated continuously to monitor 6-bit WWDT down counter value.
S */
S
S    __O  uint32_t RLDCNT;        /* Offset: 0x00  WWDT Reload Counter Register                                       */
S    __IO uint32_t CTL;           /* Offset: 0x04  WWDT Control Register                                              */
S    __IO uint32_t STATUS;        /* Offset: 0x08  WWDT Status Register                                               */
S    __I  uint32_t CNT;           /* Offset: 0x0C  WWDT Counter Value Register                                        */
S
S} WWDT_T;
S
S
S
S/**
S    @addtogroup WWDT_CONST WWDT Bit Field Definition
S    Constant Definitions for WWDT Controller
S@{ */
S
S#define WWDT_RLDCNT_WWDT_RLDCNT_Pos      (0)                                               /*!< WWDT_T::RLDCNT: WWDT_RLDCNT Position      */
S#define WWDT_RLDCNT_WWDT_RLDCNT_Msk      (0xfffffffful << WWDT_RLDCNT_WWDT_RLDCNT_Pos)     /*!< WWDT_T::RLDCNT: WWDT_RLDCNT Mask          */
S
S#define WWDT_CTL_WWDTEN_Pos              (0)                                               /*!< WWDT_T::CTL: WWDTEN Position              */
S#define WWDT_CTL_WWDTEN_Msk              (0x1ul << WWDT_CTL_WWDTEN_Pos)                    /*!< WWDT_T::CTL: WWDTEN Mask                  */
S
S#define WWDT_CTL_INTEN_Pos               (1)                                               /*!< WWDT_T::CTL: INTEN Position               */
S#define WWDT_CTL_INTEN_Msk               (0x1ul << WWDT_CTL_INTEN_Pos)                     /*!< WWDT_T::CTL: INTEN Mask                   */
S
S#define WWDT_CTL_PSCSEL_Pos              (8)                                               /*!< WWDT_T::CTL: PSCSEL Position              */
S#define WWDT_CTL_PSCSEL_Msk              (0xful << WWDT_CTL_PSCSEL_Pos)                    /*!< WWDT_T::CTL: PSCSEL Mask                  */
S
S#define WWDT_CTL_CMPDAT_Pos              (16)                                              /*!< WWDT_T::CTL: CMPDAT Position              */
S#define WWDT_CTL_CMPDAT_Msk              (0x3ful << WWDT_CTL_CMPDAT_Pos)                   /*!< WWDT_T::CTL: CMPDAT Mask                  */
S
S#define WWDT_CTL_ICEDEBUG_Pos            (31)                                              /*!< WWDT_T::CTL: ICEDEBUG Position            */
S#define WWDT_CTL_ICEDEBUG_Msk            (0x1ul << WWDT_CTL_ICEDEBUG_Pos)                  /*!< WWDT_T::CTL: ICEDEBUG Mask                */
S
S#define WWDT_STATUS_WWDTIF_Pos           (0)                                               /*!< WWDT_T::STATUS: WWDTIF Position           */
S#define WWDT_STATUS_WWDTIF_Msk           (0x1ul << WWDT_STATUS_WWDTIF_Pos)                 /*!< WWDT_T::STATUS: WWDTIF Mask               */
S
S#define WWDT_STATUS_WWDTRF_Pos           (1)                                               /*!< WWDT_T::STATUS: WWDTRF Position           */
S#define WWDT_STATUS_WWDTRF_Msk           (0x1ul << WWDT_STATUS_WWDTRF_Pos)                 /*!< WWDT_T::STATUS: WWDTRF Mask               */
S
S#define WWDT_CNT_CNTDAT_Pos              (0)                                               /*!< WWDT_T::CNT: CNTDAT Position              */
S#define WWDT_CNT_CNTDAT_Msk              (0x3ful << WWDT_CNT_CNTDAT_Pos)                   /*!< WWDT_T::CNT: CNTDAT Mask                  */
S
S/**@}*/ /* WWDT_CONST */
S/**@}*/ /* end of WWDT register group */
S
S
S/**@}*/ /* end of REGISTER group */
S
S
S/******************************************************************************/
S/*                         Peripheral memory map                              */
S/******************************************************************************/
S/** @addtogroup MemoryMap Memory Mapping
S  @{
S*/
S
S/* Peripheral and SRAM base address */
S#define SRAM_BASE            (0x20000000UL)                              /*!< (SRAM      ) Base Address */
S#define PERIPH_BASE          (0x40000000UL)                              /*!< (Peripheral) Base Address */
S
S
S/* Peripheral memory map */
S#define AHBPERIPH_BASE       PERIPH_BASE
S#define APBPERIPH_BASE       (PERIPH_BASE + 0x00040000)
S
S/*!< AHB peripherals */
S#define GCR_BASE             (AHBPERIPH_BASE + 0x00000)               
S#define CLK_BASE             (AHBPERIPH_BASE + 0x00200)
S#define INT_BASE             (AHBPERIPH_BASE + 0x00300)
S#define GPIO_BASE            (AHBPERIPH_BASE + 0x04000)
S#define GPIOA_BASE           (AHBPERIPH_BASE + 0x04000)
S#define GPIOB_BASE           (AHBPERIPH_BASE + 0x04040)
S#define GPIOC_BASE           (AHBPERIPH_BASE + 0x04080)
S#define GPIOD_BASE           (AHBPERIPH_BASE + 0x040C0)
S#define GPIOE_BASE           (AHBPERIPH_BASE + 0x04100)
S#define GPIOF_BASE           (AHBPERIPH_BASE + 0x04140)
S#define GPIO_DBCTL_BASE      (AHBPERIPH_BASE + 0x04440)
S#define GPIO_PIN_DATA_BASE   (AHBPERIPH_BASE + 0x04800)
S#define PDMA_BASE            (AHBPERIPH_BASE + 0x08000)
S#define USBH_BASE            (AHBPERIPH_BASE + 0x09000)
S#define FMC_BASE             (AHBPERIPH_BASE + 0x0C000)
S#define EBI_BASE             (AHBPERIPH_BASE + 0x10000)
S#define CRC_BASE             (AHBPERIPH_BASE + 0x31000)
S
S/*!< APB0 peripherals */
S#define WDT_BASE             (APBPERIPH_BASE + 0x00000)
S#define WWDT_BASE            (APBPERIPH_BASE + 0x00100)
S#define TMR01_BASE           (APBPERIPH_BASE + 0x10000)
S#define PWM0_BASE            (APBPERIPH_BASE + 0x18000)
S#define SPI0_BASE            (APBPERIPH_BASE + 0x20000)
S#define SPI2_BASE            (APBPERIPH_BASE + 0x22000)
S#define UART0_BASE           (APBPERIPH_BASE + 0x30000)
S#define UART2_BASE           (APBPERIPH_BASE + 0x32000)
S#define I2C0_BASE            (APBPERIPH_BASE + 0x40000)
S#define SC0_BASE             (APBPERIPH_BASE + 0x50000)
S#define CAN0_BASE            (APBPERIPH_BASE + 0x60000)
S#define USBD_BASE            (APBPERIPH_BASE + 0x80000)
S#define TK_BASE              (APBPERIPH_BASE + 0xA2000)
S
S/*!< APB1 peripherals */
S#define RTC_BASE             (APBPERIPH_BASE + 0x01000)
S#define EADC0_BASE           (APBPERIPH_BASE + 0x03000)
S#define ACMP01_BASE          (APBPERIPH_BASE + 0x05000)
S#define DAC_BASE             (APBPERIPH_BASE + 0x07000)
S#define OTG_BASE             (APBPERIPH_BASE + 0x0D000)
S#define TMR23_BASE           (APBPERIPH_BASE + 0x11000)
S#define PWM1_BASE            (APBPERIPH_BASE + 0x19000)
S#define SPI1_BASE            (APBPERIPH_BASE + 0x21000)
S#define UART1_BASE           (APBPERIPH_BASE + 0x31000)
S#define UART3_BASE           (APBPERIPH_BASE + 0x33000)
S#define I2C1_BASE            (APBPERIPH_BASE + 0x41000)
S/*@}*/ /* end of group MemoryMap */
S
S
S/******************************************************************************/
S/*                         Peripheral declaration                             */
S/******************************************************************************/
S/** @addtogroup PeripheralDecl Peripheral Declaration
S  @{
S*/
S
S
S#define SYS                  ((SYS_T *)   GCR_BASE)
S#define SYSINT               ((SYS_INT_T *) INT_BASE)                   
S#define CLK                  ((CLK_T *)   CLK_BASE)
S#define PA                   ((GPIO_T *)  GPIOA_BASE)
S#define PB                   ((GPIO_T *)  GPIOB_BASE)
S#define PC                   ((GPIO_T *)  GPIOC_BASE)
S#define PD                   ((GPIO_T *)  GPIOD_BASE)
S#define PE                   ((GPIO_T *)  GPIOE_BASE)
S#define PF                   ((GPIO_T *)  GPIOF_BASE)
S#define GPIO                 ((GPIO_DBCTL_T *) GPIO_DBCTL_BASE)
S#define PDMA                 ((PDMA_T *)  PDMA_BASE)
S#define USBH                 ((USBH_T *)  USBH_BASE)
S#define FMC                  ((FMC_T *)   FMC_BASE)
S#define EBI                  ((EBI_T *)   EBI_BASE)
S#define CRC                  ((CRC_T *)   CRC_BASE)
S
S#define WDT                  ((WDT_T *)   WDT_BASE)
S#define WWDT                 ((WWDT_T *)  WWDT_BASE)
S#define RTC                  ((RTC_T *)   RTC_BASE)
S#define EADC                  ((EADC_T *)   EADC0_BASE)
S#define ACMP01               ((ACMP_T *)  ACMP01_BASE)
S
S#define USBD                 ((USBD_T *)  USBD_BASE)
S#define OTG                  ((OTG_T *)   OTG_BASE)
S#define TIMER0               ((TIMER_T *) TMR01_BASE)
S#define TIMER1               ((TIMER_T *) (TMR01_BASE + 0x20))
S#define TIMER2               ((TIMER_T *) TMR23_BASE)
S#define TIMER3               ((TIMER_T *) (TMR23_BASE+ 0x20))
S#define PWM0                 ((PWM_T *)   PWM0_BASE)
S#define PWM1                 ((PWM_T *)   PWM1_BASE)
S#define DAC                  ((DAC_T *)   DAC_BASE)
S#define SPI0                 ((SPI_T *)   SPI0_BASE)
S#define SPI1                 ((SPI_T *)   SPI1_BASE)
S#define SPI2                 ((SPI_T *)   SPI2_BASE)
S#define UART0                ((UART_T *)  UART0_BASE)
S#define UART1                ((UART_T *)  UART1_BASE)
S#define UART2                ((UART_T *)  UART2_BASE)
S#define UART3                ((UART_T *)  UART3_BASE)
S#define I2C0                 ((I2C_T *)   I2C0_BASE)
S#define I2C1                 ((I2C_T *)   I2C1_BASE)
S#define SC0                  ((SC_T *)    SC0_BASE)
S#define CAN0                 ((CAN_T *)   CAN0_BASE)
S#define TK                   ((TK_T *)   TK_BASE)
S
S/* One Bit Mask Definitions */
S#define BIT0    0x00000001
S#define BIT1    0x00000002
S#define BIT2    0x00000004
S#define BIT3    0x00000008
S#define BIT4    0x00000010
S#define BIT5    0x00000020
S#define BIT6    0x00000040
S#define BIT7    0x00000080
S#define BIT8    0x00000100
S#define BIT9    0x00000200
S#define BIT10   0x00000400
S#define BIT11   0x00000800
S#define BIT12   0x00001000
S#define BIT13   0x00002000
S#define BIT14   0x00004000
S#define BIT15   0x00008000
S#define BIT16   0x00010000
S#define BIT17   0x00020000
S#define BIT18   0x00040000
S#define BIT19   0x00080000
S#define BIT20   0x00100000
S#define BIT21   0x00200000
S#define BIT22   0x00400000
S#define BIT23   0x00800000
S#define BIT24   0x01000000
S#define BIT25   0x02000000
S#define BIT26   0x04000000
S#define BIT27   0x08000000
S#define BIT28   0x10000000
S#define BIT29   0x20000000
S#define BIT30   0x40000000
S#define BIT31   0x80000000
S
S/* Byte Mask Definitions */
S#define BYTE0_Msk               (0x000000FF)
S#define BYTE1_Msk               (0x0000FF00)
S#define BYTE2_Msk               (0x00FF0000)
S#define BYTE3_Msk               (0xFF000000)
S
S#define _GET_BYTE0(u32Param)    (((u32Param) & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
S#define _GET_BYTE1(u32Param)    (((u32Param) & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
S#define _GET_BYTE2(u32Param)    (((u32Param) & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
S#define _GET_BYTE3(u32Param)    (((u32Param) & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
S
S#ifndef TRUE
S# define TRUE 1
S#endif
S#ifndef FALSE
S# define FALSE 0
S#endif
S
S#ifndef NULL
S#define NULL        0
S#endif
S
S#include "sys.h"
S#include "clk.h"
S#include "gpio.h"
S#include "i2c.h"
S#include "crc.h"
S#include "ebi.h"
S#include "rtc.h"
S#include "timer.h"
S#include "wdt.h"
S#include "wwdt.h"
S#include "spi.h"
S#include "sc.h"
S#include "scuart.h"
S#include "acmp.h"
S#include "eadc.h"
S#include "dac.h"
S#include "can.h"
S#include "usbd.h"
S#include "fmc.h"
S#include "uart.h"
S#include "pwm.h"
S#include "pdma.h"
S#include "tk.h"
S#include "otg.h"
S
Stypedef volatile unsigned char  vu8;
Stypedef volatile unsigned long  vu32;
Stypedef volatile unsigned short vu16;
S#define M8(adr)  (*((vu8  *) (adr)))
S#define M16(adr) (*((vu16 *) (adr)))
S#define M32(adr) (*((vu32 *) (adr)))
S
S#define outpw(port,value)   (*((volatile unsigned int *)(port))=(value))
S#define inpw(port)          (*((volatile unsigned int *)(port)))
S#define outpb(port,value)   (*((volatile unsigned char *)(port))=(value))
S#define inpb(port)          (*((volatile unsigned char *)(port)))
S#define outps(port,value)   (*((volatile unsigned short *)(port))=(value))
S#define inps(port)          (*((volatile unsigned short *)(port)))
S
S#define outp32(port,value)  (*((volatile unsigned int *)(port))=(value))
S#define inp32(port)         (*((volatile unsigned int *)(port)))
S#define outp8(port,value)   (*((volatile unsigned char *)(port))=(value))
S#define inp8(port)          (*((volatile unsigned char *)(port)))
S#define outp16(port,value)  (*((volatile unsigned short *)(port))=(value))
S#define inp16(port)         (*((volatile unsigned short *)(port)))
S
S/*@}*/ /* end of group PeripheralDecl */
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif  /* __M451SERIES_H__ */
N
N/*** (C) COPYRIGHT 2014~2015 Nuvoton Technology Corp. ***/
N
N
N
L 16 "..\..\..\..\Library\StdDriver\inc\i2c.h" 2
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup I2C_Driver I2C Driver
N  @{
N*/
N
N/** @addtogroup I2C_EXPORTED_CONSTANTS I2C Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  I2C_CTL constant definitions.                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define I2C_CTL_STA_SI            0x28UL /*!< I2C_CTL setting for I2C control bits. It would set STA and SI bits          */
N#define I2C_CTL_STA_SI_AA         0x2CUL /*!< I2C_CTL setting for I2C control bits. It would set STA, SI and AA bits      */
N#define I2C_CTL_STO_SI            0x18UL /*!< I2C_CTL setting for I2C control bits. It would set STO and SI bits          */
N#define I2C_CTL_STO_SI_AA         0x1CUL /*!< I2C_CTL setting for I2C control bits. It would set STO, SI and AA bits      */
N#define I2C_CTL_SI                0x08UL /*!< I2C_CTL setting for I2C control bits. It would set SI bit                   */
N#define I2C_CTL_SI_AA             0x0CUL /*!< I2C_CTL setting for I2C control bits. It would set SI and AA bits           */
N#define I2C_CTL_STA               0x20UL /*!< I2C_CTL setting for I2C control bits. It would set STA bit                  */
N#define I2C_CTL_STO               0x10UL /*!< I2C_CTL setting for I2C control bits. It would set STO bit                  */
N#define I2C_CTL_AA                0x04UL /*!< I2C_CTL setting for I2C control bits. It would set AA bit                   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  I2C GCMode constant definitions.                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define I2C_GCMODE_ENABLE           1    /*!< Enable  I2C GC Mode                                                         */
N#define I2C_GCMODE_DISABLE          0    /*!< Disable I2C GC Mode                                                         */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  I2C SMBUS constant definitions.                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N#define I2C_SMBH_ENABLE             1    /*!< Enable  SMBus Host Mode enable                                              */
N#define I2C_SMBD_ENABLE             0    /*!< Enable  SMBus Device Mode enable                                            */
N#define I2C_PECTX_ENABLE            1    /*!< Enable  SMBus Packet Error Check Transmit function                          */
N#define I2C_PECTX_DISABLE           0    /*!< Disable SMBus Packet Error Check Transmit function                          */
N
N/*@}*/ /* end of group I2C_EXPORTED_CONSTANTS */
N
N/** @addtogroup I2C_EXPORTED_FUNCTIONS I2C Exported Functions
N  @{
N*/
N/**
N *    @brief        The macro is used to set I2C bus condition at One Time
N *
N *    @param[in]    i2c        Specify I2C port
N *    @param[in]    u8Ctrl     A byte writes to I2C control register
N *
N *    @return       None
N *
N *    @details      Set I2C_CTL register to control I2C bus conditions of START, STOP, SI, ACK.
N */
N#define I2C_SET_CONTROL_REG(i2c, u8Ctrl) ((i2c)->CTL = ((i2c)->CTL & ~0x3c) | (u8Ctrl))
N
N/**
N *    @brief        The macro is used to set START condition of I2C Bus
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       None
N *
N *    @details      Set the I2C bus START condition in I2C_CTL register.
N */
N#define I2C_START(i2c)  ((i2c)->CTL = ((i2c)->CTL & ~I2C_CTL_SI_Msk) | I2C_CTL_STA_Msk)
N
N/**
N *    @brief        The macro is used to wait I2C bus status get ready
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       None
N *
N *    @details      When a new status is presented of I2C bus, the SI flag will be set in I2C_CTL register.
N */
N#define I2C_WAIT_READY(i2c)     while(!((i2c)->CTL & I2C_CTL_SI_Msk))
N
N/**
N *    @brief        The macro is used to Read I2C Bus Data Register
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       A byte of I2C data register
N *
N *    @details      I2C controller read data from bus and save it in I2CDAT register.
N */
N#define I2C_GET_DATA(i2c)   ((i2c)->DAT)
N
N/**
N *    @brief        Write a Data to I2C Data Register
N *
N *    @param[in]    i2c         Specify I2C port
N *    @param[in]    u8Data      A byte that writes to data register
N *
N *    @return       None
N *
N *    @details      When write a data to I2C_DAT register, the I2C controller will shift it to I2C bus.
N */
N#define I2C_SET_DATA(i2c, u8Data) ((i2c)->DAT = (u8Data))
N
N/**
N *    @brief        Get I2C Bus status code
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       I2C status code
N *
N *    @details      To get this status code to monitor I2C bus event.
N */
N#define I2C_GET_STATUS(i2c) ((i2c)->STATUS)
N
N/**
N *    @brief        Get Time-out flag from I2C Bus
N *
N *    @param[in]    i2c     Specify I2C port
N *
N *    @retval       0       I2C Bus time-out is not happened
N *    @retval       1       I2C Bus time-out is happened
N *
N *    @details      When I2C bus occurs time-out event, the time-out flag will be set.
N */
N#define I2C_GET_TIMEOUT_FLAG(i2c)   ( ((i2c)->TOCTL & I2C_TOCTL_TOIF_Msk) == I2C_TOCTL_TOIF_Msk ? 1:0 )
N
N/**
N *    @brief        To get wake-up flag from I2C Bus
N *
N *    @param[in]    i2c     Specify I2C port
N *
N *    @retval       0       Chip is not woken-up from power-down mode
N *    @retval       1       Chip is woken-up from power-down mode
N *
N *    @details      I2C bus occurs wake-up event, wake-up flag will be set.
N */
N#define I2C_GET_WAKEUP_FLAG(i2c) ( ((i2c)->WKSTS & I2C_WKSTS_WKIF_Msk) == I2C_WKSTS_WKIF_Msk ? 1:0  )
N
N/**
N *    @brief        To clear wake-up flag
N *
N *    @param[in]    i2c     Specify I2C port
N *
N *    @return       None
N *
N *    @details      If wake-up flag is set, use this macro to clear it.
N */
N#define I2C_CLEAR_WAKEUP_FLAG(i2c)  ((i2c)->WKSTS = I2C_WKSTS_WKIF_Msk)
N
N/**
N * @brief      To get SMBus Status
N *
N * @param[in]  i2c          Specify I2C port
N *
N * @return     SMBus status
N *
N * @details    To get the Bus Management status of I2C_BUSSTS register
N *
N */
N#define I2C_SMBUS_GET_STATUS(i2c) ((i2c)->BUSSTS)
N
N/**
N * @brief      Get SMBus CRC value
N *
N * @param[in]  i2c          Specify I2C port
N *
N * @return     Packet error check byte value
N *
N * @details    The CRC check value after a transmission or a reception by count by using CRC8
N *
N */
N#define I2C_SMBUS_GET_PEC_VALUE(i2c) ((i2c)->PKTCRC)
N
N/**
N * @brief      Set SMBus Bytes number of Transmission or reception
N *
N * @param[in]  i2c              Specify I2C port
N * @param[in]  u32PktSize       Transmit / Receive bytes
N *
N * @return     None
N *
N * @details    The transmission or receive byte number in one transaction when PECEN is set. The maximum is 255 bytes.
N *
N */
N#define I2C_SMBUS_SET_PACKET_BYTE_COUNT(i2c, u32PktSize) ((i2c)->PKTSIZE = (u32PktSize))
N
N/**
N * @brief      Enable SMBus Alert function
N *
N * @param[in]  i2c              Specify I2C port
N *
N * @return     None
N *
N * @details    Device Mode(BMHEN=0): If ALERTEN(I2C_BUSCTL[4]) is set, the Alert pin will pull lo, and reply ACK when get ARP from host
N *             Host   Mode(BMHEN=1): If ALERTEN(I2C_BUSCTL[4]) is set, the Alert pin is supported to receive alert state(Lo trigger)
N *
N */
N#define I2C_SMBUS_ENABLE_ALERT(i2c) ((i2c)->BUSCTL |= I2C_BUSCTL_ALERTEN_Msk)
N
N/**
N * @brief      Disable SMBus Alert pin function
N *
N * @param[in]  i2c              Specify I2C port
N *
N * @return     None
N *
N * @details    Device Mode(BMHEN=0): If ALERTEN(I2C_BUSCTL[4]) is clear, the Alert pin will pull hi, and reply NACK when get ARP from host
N *             Host   Mode(BMHEN=1): If ALERTEN(I2C_BUSCTL[4]) is clear, the Alert pin is not supported to receive alert state(Lo trigger)
N *
N */
N#define I2C_SMBUS_DISABLE_ALERT(i2c) ((i2c)->BUSCTL &= ~I2C_BUSCTL_ALERTEN_Msk)
N
N/**
N * @brief      Set SMBus SUSCON pin is output mode
N *
N * @param[in]  i2c              Specify I2C port
N *
N * @return     None
N *
N * @details    This function to set SUSCON(I2C_BUSCTL[6]) pin is output mode.
N *
N *
N */
N#define I2C_SMBUS_SET_SUSCON_OUT(i2c)   ((i2c)->BUSCTL |= I2C_BUSCTL_SCTLOEN_Msk)
N
N/**
N * @brief      Set SMBus SUSCON pin is input mode
N *
N * @param[in]  i2c              Specify I2C port
N *
N * @return     None
N *
N * @details    This function to set SUSCON(I2C_BUSCTL[6]) pin is input mode.
N *
N *
N */
N#define I2C_SMBUS_SET_SUSCON_IN(i2c)   ((i2c)->BUSCTL &= ~I2C_BUSCTL_SCTLOEN_Msk)
N
N/**
N * @brief      Set SMBus SUSCON pin output high state
N *
N * @param[in]  i2c              Specify I2C port
N *
N * @return     None
N *
N * @details    This function to set SUSCON(I2C_BUSCTL[6]) pin is output hi state.
N *
N */
N#define I2C_SMBUS_SET_SUSCON_HIGH(i2c)   ((i2c)->BUSCTL |= I2C_BUSCTL_SCTLOSTS_Msk)
N
N
N/**
N * @brief      Set SMBus SUSCON pin output low state
N *
N * @param[in]  i2c              Specify I2C port
N *
N * @return     None
N *
N * @details    This function to set SUSCON(I2C_BUSCTL[6]) pin is output lo state.
N *
N */
N#define I2C_SMBUS_SET_SUSCON_LOW(i2c)   ((i2c)->BUSCTL &= ~I2C_BUSCTL_SCTLOSTS_Msk)
N
N/**
N * @brief      Enable SMBus Acknowledge control by manual
N *
N * @param[in]  i2c              Specify I2C port
N *
N * @return     None
N *
N * @details    The 9th bit can response the ACK or NACK according the received data by user. When the byte is received, SCLK line stretching to low between the 8th and 9th SCLK pulse.
N *
N */
N#define I2C_SMBUS_ACK_MANUAL(i2c)   ((i2c)->BUSCTL |= I2C_BUSCTL_ACKMEN_Msk)
N
N/**
N * @brief      Disable SMBus Acknowledge control by manual
N *
N * @param[in]  i2c              Specify I2C port
N *
N * @return     None
N *
N * @details    Disable acknowledge response control by user.
N *
N */
N#define I2C_SMBUS_ACK_AUTO(i2c)   ((i2c)->BUSCTL &= ~I2C_BUSCTL_ACKMEN_Msk)
N
N/**
N * @brief      Enable SMBus Acknowledge manual interrupt
N *
N * @param[in]  i2c              Specify I2C port
N *
N * @return     None
N *
N * @details    This function is used to enable SMBUS acknowledge manual interrupt on the 9th clock cycle when SMBUS=1 and ACKMEN=1
N *
N */
N#define I2C_SMBUS_9THBIT_INT_ENABLE(i2c)   ((i2c)->BUSCTL |= I2C_BUSCTL_ACKM9SI_Msk)
N
N/**
N * @brief      Disable SMBus Acknowledge manual interrupt
N *
N * @param[in]  i2c              Specify I2C port
N *
N * @return     None
N *
N * @details    This function is used to disable SMBUS acknowledge manual interrupt on the 9th clock cycle when SMBUS=1 and ACKMEN=1
N *
N */
N#define I2C_SMBUS_9THBIT_INT_DISABLE(i2c)   ((i2c)->BUSCTL &= ~I2C_BUSCTL_ACKM9SI_Msk)
N
N/**
N * @brief      Enable SMBus PEC clear at REPEAT START
N *
N * @param[in]  i2c              Specify I2C port
N *
N * @return     None
N *
N * @details    This function is used to enable the condition of REAEAT START can clear the PEC calculation.
N *
N */
N#define I2C_SMBUS_RST_PEC_AT_START_ENABLE(i2c)   ((i2c)->BUSCTL |= I2C_BUSCTL_PECCLR_Msk)
N
N/**
N * @brief      Disable SMBus PEC clear at Repeat START
N *
N * @param[in]  i2c              Specify I2C port
N *
N * @return     None
N *
N * @details    This function is used to disable the condition of Repeat START can clear the PEC calculation.
N *
N */
N#define I2C_SMBUS_RST_PEC_AT_START_DISABLE(i2c)   ((i2c)->BUSCTL &= ~I2C_BUSCTL_PECCLR_Msk)
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* inline functions                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N *    @brief        The macro is used to set STOP condition of I2C Bus
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       None
N *
N *    @details      Set the I2C bus STOP condition in I2C_CTL register.
N */
Nstatic __INLINE void I2C_STOP(I2C_T *i2c)
Xstatic __inline void I2C_STOP(I2C_T *i2c)
N{
N
N    (i2c)->CTL |= (I2C_CTL_SI_Msk | I2C_CTL_STO_Msk);
X    (i2c)->CTL |= ((0x1ul << (3)) | (0x1ul << (4)));
N    while(i2c->CTL & I2C_CTL_STO_Msk);
X    while(i2c->CTL & (0x1ul << (4)));
N}
N
Nvoid I2C_ClearTimeoutFlag(I2C_T *i2c);
Nvoid I2C_Close(I2C_T *i2c);
Nvoid I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack);
Nvoid I2C_DisableInt(I2C_T *i2c);
Nvoid I2C_EnableInt(I2C_T *i2c);
Nuint32_t I2C_GetBusClockFreq(I2C_T *i2c);
Nuint32_t I2C_GetIntFlag(I2C_T *i2c);
Nuint32_t I2C_GetStatus(I2C_T *i2c);
Nuint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock);
Nuint8_t I2C_GetData(I2C_T *i2c);
Nvoid I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode);
Nvoid I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask);
Nuint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock);
Nvoid I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout);
Nvoid I2C_DisableTimeout(I2C_T *i2c);
Nvoid I2C_EnableWakeup(I2C_T *i2c);
Nvoid I2C_DisableWakeup(I2C_T *i2c);
Nvoid I2C_SetData(I2C_T *i2c, uint8_t u8Data);
N
Nuint32_t I2C_SMBusGetStatus(I2C_T *i2c);
Nvoid I2C_SMBusClearInterruptFlag(I2C_T *i2c, uint8_t u8ClrSMBusIntFlag);
Nvoid I2C_SMBusSetPacketByteCount(I2C_T *i2c, uint32_t u32PktSize);
Nvoid I2C_SMBusOpen(I2C_T *i2c, uint8_t u8HostDevice);
Nvoid I2C_SMBusClose(I2C_T *i2c);
Nvoid I2C_SMBusPECTxEnable(I2C_T *i2c, uint8_t u8PECTxEn);
Nuint8_t I2C_SMBusGetPECValue(I2C_T *i2c);
Nvoid I2C_SMBusIdleTimeout(I2C_T *i2c, uint32_t us, uint32_t u32Hclk);
Nvoid I2C_SMBusTimeout(I2C_T *i2c, uint32_t ms, uint32_t u32Pclk);
Nvoid I2C_SMBusClockLoTimeout(I2C_T *i2c, uint32_t ms, uint32_t u32Pclk);
N/*@}*/ /* end of group I2C_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group I2C_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N#endif //__I2C_H__
L 17097 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N#include "crc.h"
L 1 "..\..\..\..\Library\StdDriver\inc\crc.h" 1
N/**************************************************************************//**
N * @file     crc.h
N * @version  V3.00
N * $Revision: 6 $
N * $Date: 15/08/11 10:26a $
N * @brief    M451 series CRC driver header file
N *
N * @note
N * Copyright (C) 2013~2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __CRC_H__
N#define __CRC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup CRC_Driver CRC Driver
N  @{
N*/
N
N/** @addtogroup CRC_EXPORTED_CONSTANTS CRC Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CRC Polynomial Mode Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CRC_CCITT           0x00000000UL            /*!<CRC Polynomial Mode - CCITT */
N#define CRC_8               0x40000000UL            /*!<CRC Polynomial Mode - CRC8 */
N#define CRC_16              0x80000000UL            /*!<CRC Polynomial Mode - CRC16 */
N#define CRC_32              0xC0000000UL            /*!<CRC Polynomial Mode - CRC32 */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Checksum, Write data Constant Definitions                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CRC_CHECKSUM_COM    0x08000000UL            /*!<CRC Checksum Complement */
N#define CRC_CHECKSUM_RVS    0x02000000UL            /*!<CRC Checksum Reverse */
N#define CRC_WDATA_COM       0x04000000UL            /*!<CRC Write Data Complement */
N#define CRC_WDATA_RVS       0x01000000UL            /*!<CRC Write Data Reverse */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CPU Write Data Length Constant Definitions                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CRC_CPU_WDATA_8     0x00000000UL            /*!<CRC CPU Write Data length is 8-bit */
N#define CRC_CPU_WDATA_16    0x10000000UL            /*!<CRC CPU Write Data length is 16-bit */
N#define CRC_CPU_WDATA_32    0x20000000UL            /*!<CRC CPU Write Data length is 32-bit */
N
N/*@}*/ /* end of group CRC_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup CRC_EXPORTED_FUNCTIONS CRC Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Set CRC Seed Value
N  *
N  * @param[in]  u32Seed     Seed value
N  *
N  * @return     None
N  *
N  * @details    This macro is used to set CRC seed value.
N  *
N  * @note       User must to perform CRC_RST(CRC_CTL[1] CRC Engine Reset) to reload the new seed value
N  *             to CRC controller.
N  */
N#define CRC_SET_SEED(u32Seed)   { CRC->SEED = (u32Seed); CRC->CTL |= CRC_CTL_CRCRST_Msk; }
N
N/**
N * @brief       Get CRC Seed Value
N *
N  * @param      None
N *
N * @return      CRC seed value
N *
N * @details     This macro gets the current CRC seed value.
N */
N#define CRC_GET_SEED()          (CRC->SEED)
N
N/**
N * @brief       CRC Write Data
N *
N * @param[in]   u32Data     Write data
N *
N * @return      None
N *
N  * @details    User can write data directly to CRC Write Data Register(CRC_DAT) by this macro to perform CRC operation.
N */
N#define CRC_WRITE_DATA(u32Data)   (CRC->DAT = (u32Data))
N
Nvoid CRC_Open(uint32_t u32Mode, uint32_t u32Attribute, uint32_t u32Seed, uint32_t u32DataLen);
Nuint32_t CRC_GetChecksum(void);
N
N/*@}*/ /* end of group CRC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group CRC_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__CRC_H__
N
N/*** (C) COPYRIGHT 2013~2015 Nuvoton Technology Corp. ***/
L 17098 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N#include "ebi.h"
L 1 "..\..\..\..\Library\StdDriver\inc\ebi.h" 1
N/**************************************************************************//**
N * @file     ebi.h
N * @version  V3.00
N * $Revision: 8 $
N * $Date: 15/08/11 10:26a $
N * @brief    M451 series EBI driver header file
N *
N * @note
N * Copyright (C) 2013~2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __EBI_H__
N#define __EBI_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup EBI_Driver EBI Driver
N  @{
N*/
N
N/** @addtogroup EBI_EXPORTED_CONSTANTS EBI Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Miscellaneous Constant Definitions                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EBI_BANK0_BASE_ADDR     0x60000000UL /*!< EBI bank0 base address */
N#define EBI_BANK1_BASE_ADDR     0x60100000UL /*!< EBI bank1 base address */
N#define EBI_MAX_SIZE            0x00100000UL /*!< Maximum EBI size for each bank is 1 MB */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Constants for EBI bank number                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EBI_BANK0               0   /*!< EBI bank 0 */
N#define EBI_BANK1               1   /*!< EBI bank 1 */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Constants for EBI data bus width                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EBI_BUSWIDTH_8BIT       8   /*!< EBI bus width is 8-bit */
N#define EBI_BUSWIDTH_16BIT      16  /*!< EBI bus width is 16-bit */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Constants for EBI CS Active Level                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EBI_CS_ACTIVE_LOW       0   /*!< EBI CS active level is low */
N#define EBI_CS_ACTIVE_HIGH      1   /*!< EBI CS active level is high */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Constants for EBI MCLK divider and Timing                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EBI_MCLKDIV_1           0x0UL /*!< EBI output clock(MCLK) is HCLK/1 */
N#define EBI_MCLKDIV_2           0x1UL /*!< EBI output clock(MCLK) is HCLK/2 */
N#define EBI_MCLKDIV_4           0x2UL /*!< EBI output clock(MCLK) is HCLK/4 */
N#define EBI_MCLKDIV_8           0x3UL /*!< EBI output clock(MCLK) is HCLK/8 */
N#define EBI_MCLKDIV_16          0x4UL /*!< EBI output clock(MCLK) is HCLK/16 */
N#define EBI_MCLKDIV_32          0x5UL /*!< EBI output clock(MCLK) is HCLK/32 */
N
N#define EBI_TIMING_FASTEST      0x0UL /*!< EBI timing is the fastest */
N#define EBI_TIMING_VERYFAST     0x1UL /*!< EBI timing is very fast */
N#define EBI_TIMING_FAST         0x2UL /*!< EBI timing is fast */
N#define EBI_TIMING_NORMAL       0x3UL /*!< EBI timing is normal  */
N#define EBI_TIMING_SLOW         0x4UL /*!< EBI timing is slow */
N#define EBI_TIMING_VERYSLOW     0x5UL /*!< EBI timing is very slow */
N#define EBI_TIMING_SLOWEST      0x6UL /*!< EBI timing is the slowest */
N
N/*@}*/ /* end of group EBI_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup EBI_EXPORTED_FUNCTIONS EBI Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Read 8-bit data on EBI bank0
N  *
N  * @param[in]  u32Addr     The data address on EBI bank0.
N  *
N  * @return     8-bit Data
N  *
N  * @details    This macro is used to read 8-bit data from specify address on EBI bank0.
N  */
N#define EBI0_READ_DATA8(u32Addr)            (*((volatile unsigned char *)(EBI_BANK0_BASE_ADDR+(u32Addr))))
N
N/**
N  * @brief      Write 8-bit data to EBI bank0
N  *
N  * @param[in]  u32Addr     The data address on EBI bank0.
N  * @param[in]  u32Data     Specify data to be written.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to write 8-bit data to specify address on EBI bank0.
N  */
N#define EBI0_WRITE_DATA8(u32Addr, u32Data)  (*((volatile unsigned char *)(EBI_BANK0_BASE_ADDR+(u32Addr))) = (u32Data))
N
N/**
N  * @brief      Read 16-bit data on EBI bank0
N  *
N  * @param[in]  u32Addr     The data address on EBI bank0.
N  *
N  * @return     16-bit Data
N  *
N  * @details    This macro is used to read 16-bit data from specify address on EBI bank0.
N  */
N#define EBI0_READ_DATA16(u32Addr)           (*((volatile unsigned short *)(EBI_BANK0_BASE_ADDR+(u32Addr))))
N
N/**
N  * @brief      Write 16-bit data to EBI bank0
N  *
N  * @param[in]  u32Addr     The data address on EBI bank0.
N  * @param[in]  u32Data     Specify data to be written.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to write 16-bit data to specify address on EBI bank0.
N  */
N#define EBI0_WRITE_DATA16(u32Addr, u32Data) (*((volatile unsigned short *)(EBI_BANK0_BASE_ADDR+(u32Addr))) = (u32Data))
N
N/**
N  * @brief      Read 32-bit data on EBI bank0
N  *
N  * @param[in]  u32Addr     The data address on EBI bank0.
N  *
N  * @return     32-bit Data
N  *
N  * @details    This macro is used to read 32-bit data from specify address on EBI bank0.
N  */
N#define EBI0_READ_DATA32(u32Addr)           (*((volatile unsigned int *)(EBI_BANK0_BASE_ADDR+(u32Addr))))
N
N/**
N  * @brief      Write 32-bit data to EBI bank0
N  *
N  * @param[in]  u32Addr     The data address on EBI bank0.
N  * @param[in]  u32Data     Specify data to be written.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to write 32-bit data to specify address on EBI bank0.
N  */
N#define EBI0_WRITE_DATA32(u32Addr, u32Data) (*((volatile unsigned int *)(EBI_BANK0_BASE_ADDR+(u32Addr))) = (u32Data))
N
N/**
N  * @brief      Read 8-bit data on EBI bank1
N  *
N  * @param[in]  u32Addr     The data address on EBI bank1.
N  *
N  * @return     8-bit Data
N  *
N  * @details    This macro is used to read 8-bit data from specify address on EBI bank1.
N  */
N#define EBI1_READ_DATA8(u32Addr)            (*((volatile unsigned char *)(EBI_BANK1_BASE_ADDR+(u32Addr))))
N
N/**
N  * @brief      Write 8-bit data to EBI bank1
N  *
N  * @param[in]  u32Addr     The data address on EBI bank1.
N  * @param[in]  u32Data     Specify data to be written.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to write 8-bit data to specify address on EBI bank1.
N  */
N#define EBI1_WRITE_DATA8(u32Addr, u32Data)  (*((volatile unsigned char *)(EBI_BANK1_BASE_ADDR+(u32Addr))) = (u32Data))
N
N/**
N  * @brief      Read 16-bit data on EBI bank1
N  *
N  * @param[in]  u32Addr     The data address on EBI bank1.
N  *
N  * @return     16-bit Data
N  *
N  * @details    This macro is used to read 16-bit data from specify address on EBI bank1.
N  */
N#define EBI1_READ_DATA16(u32Addr)           (*((volatile unsigned short *)(EBI_BANK1_BASE_ADDR+(u32Addr))))
N
N/**
N  * @brief      Write 16-bit data to EBI bank1
N  *
N  * @param[in]  u32Addr     The data address on EBI bank1.
N  * @param[in]  u32Data     Specify data to be written.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to write 16-bit data to specify address on EBI bank1.
N  */
N#define EBI1_WRITE_DATA16(u32Addr, u32Data) (*((volatile unsigned short *)(EBI_BANK1_BASE_ADDR+(u32Addr))) = (u32Data))
N
N/**
N  * @brief      Read 32-bit data on EBI bank1
N  *
N  * @param[in]  u32Addr     The data address on EBI bank1.
N  *
N  * @return     32-bit Data
N  *
N  * @details    This macro is used to read 32-bit data from specify address on EBI bank1.
N  */
N#define EBI1_READ_DATA32(u32Addr)           (*((volatile unsigned int *)(EBI_BANK1_BASE_ADDR+(u32Addr))))
N
N/**
N  * @brief      Write 32-bit data to EBI bank1
N  *
N  * @param[in]  u32Addr     The data address on EBI bank1.
N  * @param[in]  u32Data     Specify data to be written.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to write 32-bit data to specify address on EBI bank1.
N  */
N#define EBI1_WRITE_DATA32(u32Addr, u32Data) (*((volatile unsigned int *)(EBI_BANK1_BASE_ADDR+(u32Addr))) = (u32Data))
N
Nvoid EBI_Open(uint32_t u32Bank, uint32_t u32DataWidth, uint32_t u32TimingClass, uint32_t u32BusMode, uint32_t u32CSActiveLevel);
Nvoid EBI_Close(uint32_t u32Bank);
Nvoid EBI_SetBusTiming(uint32_t u32Bank, uint32_t u32TimingConfig, uint32_t u32MclkDiv);
N
N/*@}*/ /* end of group EBI_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group EBI_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__EBI_H__
N
N/*** (C) COPYRIGHT 2013~2015 Nuvoton Technology Corp. ***/
L 17099 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N#include "rtc.h"
L 1 "..\..\..\..\Library\StdDriver\inc\rtc.h" 1
N/**************************************************************************//**
N * @file     rtc.h
N * @version  V3.00
N * $Revision: 10 $
N * $Date: 15/08/11 10:26a $
N * @brief    M451 series RTC driver header file
N *
N * @note
N * Copyright (C) 2013~2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __RTC_H__
N#define __RTC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup RTC_Driver RTC Driver
N  @{
N*/
N
N/** @addtogroup RTC_EXPORTED_CONSTANTS RTC Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  RTC Initial Keyword Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define RTC_INIT_KEY            0xA5EB1357UL    /*!< RTC Initiation Key to make RTC leaving reset state */
N#define RTC_WRITE_KEY           0x0000A965UL    /*!< RTC Register Access Enable Key to enable RTC read/write accessible and kept 1024 RTC clock */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  RTC Time Attribute Constant Definitions                                                                */
N/*---------------------------------------------------------------------------------------------------------*/
N#define RTC_CLOCK_12            0               /*!< RTC as 12-hour time scale with AM and PM indication */
N#define RTC_CLOCK_24            1               /*!< RTC as 24-hour time scale */
N#define RTC_AM                  1               /*!< RTC as AM indication */
N#define RTC_PM                  2               /*!< RTC as PM indication */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  RTC Tick Period Constant Definitions                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define RTC_TICK_1_SEC          0x0UL           /*!< RTC time tick period is 1 second */
N#define RTC_TICK_1_2_SEC        0x1UL           /*!< RTC time tick period is 1/2 second */
N#define RTC_TICK_1_4_SEC        0x2UL           /*!< RTC time tick period is 1/4 second */
N#define RTC_TICK_1_8_SEC        0x3UL           /*!< RTC time tick period is 1/8 second */
N#define RTC_TICK_1_16_SEC       0x4UL           /*!< RTC time tick period is 1/16 second */
N#define RTC_TICK_1_32_SEC       0x5UL           /*!< RTC time tick period is 1/32 second */
N#define RTC_TICK_1_64_SEC       0x6UL           /*!< RTC time tick period is 1/64 second */
N#define RTC_TICK_1_128_SEC      0x7UL           /*!< RTC time tick period is 1/128 second */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  RTC Day of Week Constant Definitions                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define RTC_SUNDAY              0x0UL           /*!< Day of the Week is Sunday */
N#define RTC_MONDAY              0x1UL           /*!< Day of the Week is Monday */
N#define RTC_TUESDAY             0x2UL           /*!< Day of the Week is Tuesday */
N#define RTC_WEDNESDAY           0x3UL           /*!< Day of the Week is Wednesday */
N#define RTC_THURSDAY            0x4UL           /*!< Day of the Week is Thursday */
N#define RTC_FRIDAY              0x5UL           /*!< Day of the Week is Friday */
N#define RTC_SATURDAY            0x6UL           /*!< Day of the Week is Saturday */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  RTC Snooper Detection Mode Constant Definitions                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N#define RTC_SNOOPER_LOW_LEVEL       0x0UL       /*!< Snooper pin detected is low-level trigger */
N#define RTC_SNOOPER_HIGH_LEVEL      0x2UL       /*!< Snooper pin detected is high-level trigger */
N#define RTC_SNOOPER_FALLING_EDGE    0x8UL       /*!< Snooper pin detected is falling-edge trigger */
N#define RTC_SNOOPER_RISING_EDGE     0xAUL       /*!< Snooper pin detected is rising-edge trigger */
N#define RTC_SNOOPER_DETECT_Msk      0xAUL       /*!< Snooper pin detected mask bits */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  RTC Miscellaneous Constant Definitions                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#define RTC_WAIT_COUNT          0xFFFFFFFF      /*!< Initial Time-out Value */
N#define RTC_YEAR2000            2000            /*!< RTC Reference for compute year data */
N#define RTC_FCR_REFERENCE       32761           /*!< RTC Reference for frequency compensation */
N
N/*@}*/ /* end of group RTC_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup RTC_EXPORTED_STRUCTS RTC Exported Structs
N  @{
N*/
N/**
N  * @details    RTC define Time Data Struct
N  */
Ntypedef struct
N{
N    uint32_t u32Year;           /*!< Year value */
N    uint32_t u32Month;          /*!< Month value */
N    uint32_t u32Day;            /*!< Day value */
N    uint32_t u32DayOfWeek;      /*!< Day of week value */
N    uint32_t u32Hour;           /*!< Hour value */
N    uint32_t u32Minute;         /*!< Minute value */
N    uint32_t u32Second;         /*!< Second value */
N    uint32_t u32TimeScale;      /*!< 12-Hour, 24-Hour */
N    uint32_t u32AmPm;           /*!< Only Time Scale select 12-hr used */
N} S_RTC_TIME_DATA_T;
N
N/*@}*/ /* end of group RTC_EXPORTED_STRUCTS */
N
N
N/** @addtogroup RTC_EXPORTED_FUNCTIONS RTC Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Indicate is Leap Year or not
N  *
N  * @param      None
N  *
N  * @retval     0   This year is not a leap year
N  * @retval     1   This year is a leap year
N  *
N  * @details    According to current date, return this year is leap year or not.
N  */
N#define RTC_IS_LEAP_YEAR()              (RTC->LEAPYEAR & RTC_LEAPYEAR_LEAPYEAR_Msk ? 1:0)
N
N/**
N  * @brief      Clear RTC Alarm Interrupt Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to clear RTC alarm interrupt flag.
N  */
N#define RTC_CLEAR_ALARM_INT_FLAG()      (RTC->INTSTS = (RTC->INTSTS & ~(RTC_INTSTS_TICKIF_Msk | RTC_INTSTS_SNPDIF_Msk)) | RTC_INTSTS_ALMIF_Msk)
N
N/**
N  * @brief      Clear RTC Tick Interrupt Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to clear RTC tick interrupt flag.
N  */
N#define RTC_CLEAR_TICK_INT_FLAG()       (RTC->INTSTS = (RTC->INTSTS & ~(RTC_INTSTS_ALMIF_Msk | RTC_INTSTS_SNPDIF_Msk)) | RTC_INTSTS_TICKIF_Msk)
N
N/**
N  * @brief      Clear RTC Snooper Interrupt Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to clear RTC snooper pin interrupt flag.
N  */
N#define RTC_CLEAR_SNOOPER_INT_FLAG()    (RTC->INTSTS = (RTC->INTSTS & ~(RTC_INTSTS_ALMIF_Msk | RTC_INTSTS_TICKIF_Msk)) | RTC_INTSTS_SNPDIF_Msk)
N
N/**
N  * @brief      Get RTC Alarm Interrupt Flag
N  *
N  * @param      None
N  *
N  * @retval     0   RTC alarm interrupt did not occur
N  * @retval     1   RTC alarm interrupt occurred
N  *
N  * @details    This macro indicates RTC alarm interrupt occurred or not.
N  */
N#define RTC_GET_ALARM_INT_FLAG()        ((RTC->INTSTS & RTC_INTSTS_ALMIF_Msk)? 1:0)
N
N/**
N  * @brief      Get RTC Time Tick Interrupt Flag
N  *
N  * @param      None
N  *
N  * @retval     0   RTC time tick interrupt did not occur
N  * @retval     1   RTC time tick interrupt occurred
N  *
N  * @details    This macro indicates RTC time tick interrupt occurred or not.
N  */
N#define RTC_GET_TICK_INT_FLAG()         ((RTC->INTSTS & RTC_INTSTS_TICKIF_Msk)? 1:0)
N
N/**
N  * @brief      Get RTC Snooper Interrupt Flag
N  *
N  * @param      None
N  *
N  * @retval     0   RTC snooper pin interrupt did not occur
N  * @retval     1   RTC snooper pin interrupt occurred
N  *
N  * @details    This macro indicates RTC snooper pin interrupt occurred or not.
N  */
N#define RTC_GET_SNPPOER_INT_FLAG()      ((RTC->INTSTS & RTC_INTSTS_SNPDIF_Msk)? 1:0)
N
N/**
N  * @brief      Read Spare Register
N  *
N  * @param[in]  u32RegNum   The spare register number, 0~19.
N  *
N  * @return     Spare register content
N  *
N  * @details    Read the specify spare register content.
N  * @note       The returned value is valid only when SPRRDY(SPRCTL[7] SPR Register Ready) bit is set. \n
N  *             And its controlled by RTC Access Enable Register.
N  */
N#define RTC_READ_SPARE_REGISTER(u32RegNum)                  (RTC->SPR[(u32RegNum)])
N
N/**
N  * @brief      Write Spare Register
N  *
N  * @param[in]  u32RegNum    The spare register number, 0~19.
N  * @param[in]  u32RegValue  The spare register value.
N  *
N  * @return     None
N  *
N  * @details    Write specify data to spare register.
N  * @note       This macro is effect only when SPRRDY(SPRCTL[7] SPR Register Ready) bit is set. \n
N  *             And its controlled by RTC Access Enable Register(RTC_RWEN).
N  */
N#define RTC_WRITE_SPARE_REGISTER(u32RegNum, u32RegValue)    (RTC->SPR[(u32RegNum)] = (u32RegValue))
N
N/**
N  * @brief      Wait RTC Access Enable
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the maximum RTC read/write accessible time.
N  */
Nstatic __INLINE void RTC_WaitAccessEnable(void)
Xstatic __inline void RTC_WaitAccessEnable(void)
N{
N    /* To wait RWENF bit is cleared and enable RWENF bit (Access Enable bit) again */
N    while((RTC->RWEN & RTC_RWEN_RWENF_Msk) == RTC_RWEN_RWENF_Msk);
X    while((((RTC_T *) (((0x40000000UL) + 0x00040000) + 0x01000))->RWEN & (0x1ul << (16))) == (0x1ul << (16)));
N    RTC->RWEN = RTC_WRITE_KEY;
X    ((RTC_T *) (((0x40000000UL) + 0x00040000) + 0x01000))->RWEN = 0x0000A965UL;
N
N    /* To wait RWENF bit is set and user can access the protected-register of RTC from now on */
N    while((RTC->RWEN & RTC_RWEN_RWENF_Msk) == 0x0);
X    while((((RTC_T *) (((0x40000000UL) + 0x00040000) + 0x01000))->RWEN & (0x1ul << (16))) == 0x0);
N}
N
Nvoid RTC_Open(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_Close(void);
Nvoid RTC_32KCalibration(int32_t i32FrequencyX100);
Nvoid RTC_GetDateAndTime(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_GetAlarmDateAndTime(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_SetDateAndTime(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_SetAlarmDateAndTime(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_SetDate(uint32_t u32Year, uint32_t u32Month, uint32_t u32Day, uint32_t u32DayOfWeek);
Nvoid RTC_SetTime(uint32_t u32Hour, uint32_t u32Minute, uint32_t u32Second, uint32_t u32TimeMode, uint32_t u32AmPm);
Nvoid RTC_SetAlarmDate(uint32_t u32Year, uint32_t u32Month, uint32_t u32Day);
Nvoid RTC_SetAlarmTime(uint32_t u32Hour, uint32_t u32Minute, uint32_t u32Second, uint32_t u32TimeMode, uint32_t u32AmPm);
Nuint32_t RTC_GetDayOfWeek(void);
Nvoid RTC_SetTickPeriod(uint32_t u32TickSelection);
Nvoid RTC_EnableInt(uint32_t u32IntFlagMask);
Nvoid RTC_DisableInt(uint32_t u32IntFlagMask);
Nvoid RTC_EnableSpareAccess(void);
Nvoid RTC_DisableSpareRegister(void);
Nvoid RTC_EnableSnooperDetection(uint32_t u32PinCondition);
Nvoid RTC_DisableSnooperDetection(void);
N
N/*@}*/ /* end of group RTC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group RTC_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__RTC_H__
N
N/*** (C) COPYRIGHT 2013~2015 Nuvoton Technology Corp. ***/
L 17100 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N#include "timer.h"
L 1 "..\..\..\..\Library\StdDriver\inc\timer.h" 1
N/**************************************************************************//**
N * @file     timer.h
N * @version  V3.00
N * $Revision: 10 $
N * $Date: 15/08/11 10:26a $
N * @brief    M451 series Timer driver header file
N *
N * @note
N * Copyright (C) 2013~2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __TIMER_H__
N#define __TIMER_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup TIMER_Driver TIMER Driver
N  @{
N*/
N
N/** @addtogroup TIMER_EXPORTED_CONSTANTS TIMER Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  TIMER Operation Mode, External Counter and Capture Mode Constant Definitions                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define TIMER_ONESHOT_MODE                      (0UL << TIMER_CTL_OPMODE_Pos)      /*!< Timer working in one-shot mode */
N#define TIMER_PERIODIC_MODE                     (1UL << TIMER_CTL_OPMODE_Pos)      /*!< Timer working in periodic mode */
N#define TIMER_TOGGLE_MODE                       (2UL << TIMER_CTL_OPMODE_Pos)      /*!< Timer working in toggle-output mode */
N#define TIMER_CONTINUOUS_MODE                   (3UL << TIMER_CTL_OPMODE_Pos)      /*!< Timer working in continuous counting mode */
N#define TIMER_TOUT_PIN_FROM_TX                  (0UL << TIMER_CTL_TGLPINSEL_Pos)   /*!< Timer toggle-output pin is from Tx pin */
N#define TIMER_TOUT_PIN_FROM_TX_EXT              (1UL << TIMER_CTL_TGLPINSEL_Pos)   /*!< Timer toggle-output pin is from Tx_EXT pin */
N#define TIMER_CAPTURE_FREE_COUNTING_MODE        (0UL << TIMER_EXTCTL_CAPFUNCS_Pos) /*!< Timer capture event to get timer counter value */
N#define TIMER_CAPTURE_COUNTER_RESET_MODE        (1UL << TIMER_EXTCTL_CAPFUNCS_Pos) /*!< Timer capture event to reset timer counter */
N#define TIMER_CAPTURE_FALLING_EDGE              (0UL << TIMER_EXTCTL_CAPEDGE_Pos)  /*!< Falling edge detection to trigger timer capture */
N#define TIMER_CAPTURE_RISING_EDGE               (1UL << TIMER_EXTCTL_CAPEDGE_Pos)  /*!< Rising edge detection to trigger timer capture */
N#define TIMER_CAPTURE_FALLING_AND_RISING_EDGE   (2UL << TIMER_EXTCTL_CAPEDGE_Pos)  /*!< Both falling and rising edge detection to trigger timer capture */
N#define TIMER_COUNTER_FALLING_EDGE              (0UL << TIMER_EXTCTL_CNTPHASE_Pos) /*!< Counter increase on falling edge detection */
N#define TIMER_COUNTER_RISING_EDGE               (1UL << TIMER_EXTCTL_CNTPHASE_Pos) /*!< Counter increase on rising edge detection */
N
N/*@}*/ /* end of group TIMER_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup TIMER_EXPORTED_FUNCTIONS TIMER Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Set Timer Compared Value
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  * @param[in]  u32Value    Timer compare value. Valid values are between 2 to 0xFFFFFF.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to set timer compared value to adjust timer time-out interval.
N  * @note       1. Never write 0x0 or 0x1 in this field, or the core will run into unknown state. \n
N  *             2. If update timer compared value in continuous counting mode, timer counter value will keep counting continuously. \n
N  *                But if timer is operating at other modes, the timer up counter will restart counting and start from 0.
N  */
N#define TIMER_SET_CMP_VALUE(timer, u32Value)        ((timer)->CMP = (u32Value))
N
N/**
N  * @brief      Set Timer Prescale Value
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  * @param[in]  u32Value    Timer prescale value. Valid values are between 0 to 0xFF.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to set timer prescale value and timer source clock will be divided by (prescale + 1) \n
N  *             before it is fed into timer.
N  */
N#define TIMER_SET_PRESCALE_VALUE(timer, u32Value)   ((timer)->CTL = ((timer)->CTL & ~TIMER_CTL_PSC_Msk) | (u32Value))
N
N/**
N  * @brief      Check specify Timer Status
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Timer 24-bit up counter is inactive
N  * @retval     1   Timer 24-bit up counter is active
N  *
N  * @details    This macro is used to check if specify Timer counter is inactive or active.
N  */
N#define TIMER_IS_ACTIVE(timer)                      (((timer)->CTL & TIMER_CTL_ACTSTS_Msk)? 1 : 0)
N
N/**
N  * @brief      Select Toggle-output Pin
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  * @param[in]  u32ToutSel  Toggle-output pin selection, valid values are:
N  *                         - \ref TIMER_TOUT_PIN_FROM_TX
N  *                         - \ref TIMER_TOUT_PIN_FROM_TX_EXT
N  *
N  * @return     None
N  *
N  * @details    This macro is used to select timer toggle-output pin is output on Tx or Tx_EXT pin.
N  */
N#define TIMER_SELECT_TOUT_PIN(timer, u32ToutSel)    ((timer)->CTL = ((timer)->CTL & ~TIMER_CTL_TGLPINSEL_Msk) | (u32ToutSel))
N
N/**
N  * @brief      Start Timer Counting
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to start Timer counting.
N  */
Nstatic __INLINE void TIMER_Start(TIMER_T *timer)
Xstatic __inline void TIMER_Start(TIMER_T *timer)
N{
N    timer->CTL |= TIMER_CTL_CNTEN_Msk;
X    timer->CTL |= (0x1ul << (30));
N}
N
N/**
N  * @brief      Stop Timer Counting
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to stop/suspend Timer counting.
N  */
Nstatic __INLINE void TIMER_Stop(TIMER_T *timer)
Xstatic __inline void TIMER_Stop(TIMER_T *timer)
N{
N    timer->CTL &= ~TIMER_CTL_CNTEN_Msk;
X    timer->CTL &= ~(0x1ul << (30));
N}
N
N/**
N  * @brief      Enable Timer Interrupt Wake-up Function
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the timer interrupt wake-up function and interrupt source could be time-out interrupt, \n
N  *             counter event interrupt or capture trigger interrupt.
N  * @note       To wake the system from Power-down mode, timer clock source must be ether LXT or LIRC.
N  */
Nstatic __INLINE void TIMER_EnableWakeup(TIMER_T *timer)
Xstatic __inline void TIMER_EnableWakeup(TIMER_T *timer)
N{
N    timer->CTL |= TIMER_CTL_WKEN_Msk;
X    timer->CTL |= (0x1ul << (23));
N}
N
N/**
N  * @brief      Disable Timer Wake-up Function
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the timer interrupt wake-up function.
N  */
Nstatic __INLINE void TIMER_DisableWakeup(TIMER_T *timer)
Xstatic __inline void TIMER_DisableWakeup(TIMER_T *timer)
N{
N    timer->CTL &= ~TIMER_CTL_WKEN_Msk;
X    timer->CTL &= ~(0x1ul << (23));
N}
N
N/**
N  * @brief      Enable Capture Pin De-bounce
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the detect de-bounce function of capture pin.
N  */
Nstatic __INLINE void TIMER_EnableCaptureDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_EnableCaptureDebounce(TIMER_T *timer)
N{
N    timer->EXTCTL |= TIMER_EXTCTL_CAPDBEN_Msk;
X    timer->EXTCTL |= (0x1ul << (6));
N}
N
N/**
N  * @brief      Disable Capture Pin De-bounce
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the detect de-bounce function of capture pin.
N  */
Nstatic __INLINE void TIMER_DisableCaptureDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_DisableCaptureDebounce(TIMER_T *timer)
N{
N    timer->EXTCTL &= ~TIMER_EXTCTL_CAPDBEN_Msk;
X    timer->EXTCTL &= ~(0x1ul << (6));
N}
N
N/**
N  * @brief      Enable Counter Pin De-bounce
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the detect de-bounce function of counter pin.
N  */
Nstatic __INLINE void TIMER_EnableEventCounterDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_EnableEventCounterDebounce(TIMER_T *timer)
N{
N    timer->EXTCTL |= TIMER_EXTCTL_CNTDBEN_Msk;
X    timer->EXTCTL |= (0x1ul << (7));
N}
N
N/**
N  * @brief      Disable Counter Pin De-bounce
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the detect de-bounce function of counter pin.
N  */
Nstatic __INLINE void TIMER_DisableEventCounterDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_DisableEventCounterDebounce(TIMER_T *timer)
N{
N    timer->EXTCTL &= ~TIMER_EXTCTL_CNTDBEN_Msk;
X    timer->EXTCTL &= ~(0x1ul << (7));
N}
N
N/**
N  * @brief      Enable Timer Time-out Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the timer time-out interrupt function.
N  */
Nstatic __INLINE void TIMER_EnableInt(TIMER_T *timer)
Xstatic __inline void TIMER_EnableInt(TIMER_T *timer)
N{
N    timer->CTL |= TIMER_CTL_INTEN_Msk;
X    timer->CTL |= (0x1ul << (29));
N}
N
N/**
N  * @brief      Disable Timer Time-out Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the timer time-out interrupt function.
N  */
Nstatic __INLINE void TIMER_DisableInt(TIMER_T *timer)
Xstatic __inline void TIMER_DisableInt(TIMER_T *timer)
N{
N    timer->CTL &= ~TIMER_CTL_INTEN_Msk;
X    timer->CTL &= ~(0x1ul << (29));
N}
N
N/**
N  * @brief      Enable Capture Trigger Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the timer capture trigger interrupt function.
N  */
Nstatic __INLINE void TIMER_EnableCaptureInt(TIMER_T *timer)
Xstatic __inline void TIMER_EnableCaptureInt(TIMER_T *timer)
N{
N    timer->EXTCTL |= TIMER_EXTCTL_CAPIEN_Msk;
X    timer->EXTCTL |= (0x1ul << (5));
N}
N
N/**
N  * @brief      Disable Capture Trigger Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the timer capture trigger interrupt function.
N  */
Nstatic __INLINE void TIMER_DisableCaptureInt(TIMER_T *timer)
Xstatic __inline void TIMER_DisableCaptureInt(TIMER_T *timer)
N{
N    timer->EXTCTL &= ~TIMER_EXTCTL_CAPIEN_Msk;
X    timer->EXTCTL &= ~(0x1ul << (5));
N}
N
N/**
N  * @brief      Get Timer Time-out Interrupt Flag
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Timer time-out interrupt did not occur
N  * @retval     1   Timer time-out interrupt occurred
N  *
N  * @details    This function indicates timer time-out interrupt occurred or not.
N  */
Nstatic __INLINE uint32_t TIMER_GetIntFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetIntFlag(TIMER_T *timer)
N{
N    return ((timer->INTSTS & TIMER_INTSTS_TIF_Msk) ? 1 : 0);
X    return ((timer->INTSTS & (0x1ul << (0))) ? 1 : 0);
N}
N
N/**
N  * @brief      Clear Timer Time-out Interrupt Flag
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function clears timer time-out interrupt flag to 0.
N  */
Nstatic __INLINE void TIMER_ClearIntFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearIntFlag(TIMER_T *timer)
N{
N    timer->INTSTS = (timer->INTSTS & ~TIMER_INTSTS_TWKF_Msk) | TIMER_INTSTS_TIF_Msk;
X    timer->INTSTS = (timer->INTSTS & ~(0x1ul << (1))) | (0x1ul << (0));
N}
N
N/**
N  * @brief      Get Timer Capture Interrupt Flag
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Timer capture interrupt did not occur
N  * @retval     1   Timer capture interrupt occurred
N  *
N  * @details    This function indicates timer capture trigger interrupt occurred or not.
N  */
Nstatic __INLINE uint32_t TIMER_GetCaptureIntFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCaptureIntFlag(TIMER_T *timer)
N{
N    return timer->EINTSTS;
N}
N
N/**
N  * @brief      Clear Timer Capture Interrupt Flag
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function clears timer capture trigger interrupt flag to 0.
N  */
Nstatic __INLINE void TIMER_ClearCaptureIntFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearCaptureIntFlag(TIMER_T *timer)
N{
N    timer->EINTSTS = TIMER_EINTSTS_CAPIF_Msk;
X    timer->EINTSTS = (0x1ul << (0));
N}
N
N/**
N  * @brief      Get Timer Wake-up Flag
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Timer does not cause CPU wake-up
N  * @retval     1   Timer interrupt event cause CPU wake-up
N  *
N  * @details    This function indicates timer interrupt event has waked up system or not.
N  */
Nstatic __INLINE uint32_t TIMER_GetWakeupFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetWakeupFlag(TIMER_T *timer)
N{
N    return (timer->INTSTS & TIMER_INTSTS_TWKF_Msk ? 1 : 0);
X    return (timer->INTSTS & (0x1ul << (1)) ? 1 : 0);
N}
N
N/**
N  * @brief      Clear Timer Wake-up Flag
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function clears the timer wake-up system flag to 0.
N  */
Nstatic __INLINE void TIMER_ClearWakeupFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearWakeupFlag(TIMER_T *timer)
N{
N    timer->INTSTS = (timer->INTSTS & ~TIMER_INTSTS_TIF_Msk) | TIMER_INTSTS_TWKF_Msk;
X    timer->INTSTS = (timer->INTSTS & ~(0x1ul << (0))) | (0x1ul << (1));
N}
N
N/**
N  * @brief      Get Capture value
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     24-bit Capture Value
N  *
N  * @details    This function reports the current 24-bit timer capture value.
N  */
Nstatic __INLINE uint32_t TIMER_GetCaptureData(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCaptureData(TIMER_T *timer)
N{
N    return timer->CAP;
N}
N
N/**
N  * @brief      Get Counter value
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     24-bit Counter Value
N  *
N  * @details    This function reports the current 24-bit timer counter value.
N  */
Nstatic __INLINE uint32_t TIMER_GetCounter(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCounter(TIMER_T *timer)
N{
N    return timer->CNT;
N}
N
Nuint32_t TIMER_Open(TIMER_T *timer, uint32_t u32Mode, uint32_t u32Freq);
Nvoid TIMER_Close(TIMER_T *timer);
Nvoid TIMER_Delay(TIMER_T *timer, uint32_t u32Usec);
Nvoid TIMER_EnableCapture(TIMER_T *timer, uint32_t u32CapMode, uint32_t u32Edge);
Nvoid TIMER_DisableCapture(TIMER_T *timer);
Nvoid TIMER_EnableEventCounter(TIMER_T *timer, uint32_t u32Edge);
Nvoid TIMER_DisableEventCounter(TIMER_T *timer);
Nuint32_t TIMER_GetModuleClock(TIMER_T *timer);
N
N/*@}*/ /* end of group TIMER_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group TIMER_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__TIMER_H__
N
N/*** (C) COPYRIGHT 2013~2015 Nuvoton Technology Corp. ***/
L 17101 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N#include "wdt.h"
L 1 "..\..\..\..\Library\StdDriver\inc\wdt.h" 1
N/**************************************************************************//**
N * @file     wdt.h
N * @version  V3.00
N * $Revision: 7 $
N * $Date: 15/08/11 10:26a $
N * @brief    M451 series WDT driver header file
N *
N * @note
N * Copyright (C) 2013~2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __WDT_H__
N#define __WDT_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup WDT_Driver WDT Driver
N  @{
N*/
N
N/** @addtogroup WDT_EXPORTED_CONSTANTS WDT Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  WDT Time-out Interval Period Constant Definitions                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define WDT_TIMEOUT_2POW4           (0UL << WDT_CTL_TOUTSEL_Pos) /*!< Setting WDT time-out interval to 2^4 * WDT clocks */
N#define WDT_TIMEOUT_2POW6           (1UL << WDT_CTL_TOUTSEL_Pos) /*!< Setting WDT time-out interval to 2^6 * WDT clocks */
N#define WDT_TIMEOUT_2POW8           (2UL << WDT_CTL_TOUTSEL_Pos) /*!< Setting WDT time-out interval to 2^8 * WDT clocks */
N#define WDT_TIMEOUT_2POW10          (3UL << WDT_CTL_TOUTSEL_Pos) /*!< Setting WDT time-out interval to 2^10 * WDT clocks */
N#define WDT_TIMEOUT_2POW12          (4UL << WDT_CTL_TOUTSEL_Pos) /*!< Setting WDT time-out interval to 2^12 * WDT clocks */
N#define WDT_TIMEOUT_2POW14          (5UL << WDT_CTL_TOUTSEL_Pos) /*!< Setting WDT time-out interval to 2^14 * WDT clocks */
N#define WDT_TIMEOUT_2POW16          (6UL << WDT_CTL_TOUTSEL_Pos) /*!< Setting WDT time-out interval to 2^16 * WDT clocks */
N#define WDT_TIMEOUT_2POW18          (7UL << WDT_CTL_TOUTSEL_Pos) /*!< Setting WDT time-out interval to 2^18 * WDT clocks */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  WDT  Reset Delay Period Constant Definitions                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define WDT_RESET_DELAY_1026CLK     (0UL << WDT_ALTCTL_RSTDSEL_Pos) /*!< Setting WDT reset delay period to 1026 * WDT clocks */
N#define WDT_RESET_DELAY_130CLK      (1UL << WDT_ALTCTL_RSTDSEL_Pos) /*!< Setting WDT reset delay period to 130 * WDT clocks */
N#define WDT_RESET_DELAY_18CLK       (2UL << WDT_ALTCTL_RSTDSEL_Pos) /*!< Setting WDT reset delay period to 18 * WDT clocks */
N#define WDT_RESET_DELAY_3CLK        (3UL << WDT_ALTCTL_RSTDSEL_Pos) /*!< Setting WDT reset delay period to 3 * WDT clocks */
N
N/*@}*/ /* end of group WDT_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup WDT_EXPORTED_FUNCTIONS WDT Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Clear WDT Reset System Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro clears WDT time-out reset system flag.
N  */
N#define WDT_CLEAR_RESET_FLAG()          (WDT->CTL = (WDT->CTL & ~(WDT_CTL_IF_Msk | WDT_CTL_WKF_Msk)) | WDT_CTL_RSTF_Msk)
N
N/**
N  * @brief      Clear WDT Time-out Interrupt Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro clears WDT time-out interrupt flag.
N  */
N#define WDT_CLEAR_TIMEOUT_INT_FLAG()    (WDT->CTL = (WDT->CTL & ~(WDT_CTL_RSTF_Msk | WDT_CTL_WKF_Msk)) | WDT_CTL_IF_Msk)
N
N/**
N  * @brief      Clear WDT Wake-up Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro clears WDT time-out wake-up system flag.
N  */
N#define WDT_CLEAR_TIMEOUT_WAKEUP_FLAG() (WDT->CTL = (WDT->CTL & ~(WDT_CTL_RSTF_Msk | WDT_CTL_IF_Msk)) | WDT_CTL_WKF_Msk)
N
N/**
N  * @brief      Get WDT Time-out Reset Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WDT time-out reset system did not occur
N  * @retval     1   WDT time-out reset system occurred
N  *
N  * @details    This macro indicates system has been reset by WDT time-out reset or not.
N  */
N#define WDT_GET_RESET_FLAG()            ((WDT->CTL & WDT_CTL_RSTF_Msk)? 1 : 0)
N
N/**
N  * @brief      Get WDT Time-out Interrupt Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WDT time-out interrupt did not occur
N  * @retval     1   WDT time-out interrupt occurred
N  *
N  * @details    This macro indicates WDT time-out interrupt occurred or not.
N  */
N#define WDT_GET_TIMEOUT_INT_FLAG()      ((WDT->CTL & WDT_CTL_IF_Msk)? 1 : 0)
N
N/**
N  * @brief      Get WDT Time-out Wake-up Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WDT time-out interrupt does not cause CPU wake-up
N  * @retval     1   WDT time-out interrupt event cause CPU wake-up
N  *
N  * @details    This macro indicates WDT time-out interrupt event has waked up system or not.
N  */
N#define WDT_GET_TIMEOUT_WAKEUP_FLAG()   ((WDT->CTL & WDT_CTL_WKF_Msk)? 1 : 0)
N
N/**
N  * @brief      Reset WDT Counter
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to reset the internal 18-bit WDT up counter value.
N  * @note       If WDT is activated and time-out reset system function is enabled also, user should \n
N  *             reset the 18-bit WDT up counter value to avoid generate WDT time-out reset signal to \n
N  *             reset system before the WDT time-out reset delay period expires.
N  */
N#define WDT_RESET_COUNTER()             (WDT->CTL = (WDT->CTL & ~(WDT_CTL_IF_Msk | WDT_CTL_WKF_Msk | WDT_CTL_RSTF_Msk)) | WDT_CTL_RSTCNT_Msk)
N
N/**
N  * @brief      Stop WDT Counting
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This function will stop WDT counting and disable WDT module.
N  */
Nstatic __INLINE void WDT_Close(void)
Xstatic __inline void WDT_Close(void)
N{
N    WDT->CTL = 0;
X    ((WDT_T *) (((0x40000000UL) + 0x00040000) + 0x00000))->CTL = 0;
N    return;
N}
N
N/**
N  * @brief      Enable WDT Time-out Interrupt
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This function will enable the WDT time-out interrupt function.
N  */
Nstatic __INLINE void WDT_EnableInt(void)
Xstatic __inline void WDT_EnableInt(void)
N{
N    WDT->CTL |= WDT_CTL_INTEN_Msk;
X    ((WDT_T *) (((0x40000000UL) + 0x00040000) + 0x00000))->CTL |= (0x1ul << (6));
N    return;
N}
N
N/**
N  * @brief      Disable WDT Time-out Interrupt
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This function will disable the WDT time-out interrupt function.
N  */
Nstatic __INLINE void WDT_DisableInt(void)
Xstatic __inline void WDT_DisableInt(void)
N{
N    // Do not touch another write 1 clear bits
N    WDT->CTL &= ~(WDT_CTL_INTEN_Msk | WDT_CTL_RSTF_Msk | WDT_CTL_IF_Msk | WDT_CTL_WKF_Msk);
X    ((WDT_T *) (((0x40000000UL) + 0x00040000) + 0x00000))->CTL &= ~((0x1ul << (6)) | (0x1ul << (2)) | (0x1ul << (3)) | (0x1ul << (5)));
N    return;
N}
N
Nvoid WDT_Open(uint32_t u32TimeoutInterval, uint32_t u32ResetDelay, uint32_t u32EnableReset, uint32_t u32EnableWakeup);
N
N/*@}*/ /* end of group WDT_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group WDT_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__WDT_H__
N
N/*** (C) COPYRIGHT 2013~2015 Nuvoton Technology Corp. ***/
L 17102 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N#include "wwdt.h"
L 1 "..\..\..\..\Library\StdDriver\inc\wwdt.h" 1
N/**************************************************************************//**
N * @file     wwdt.h
N * @version  V3.00
N * $Revision: 7 $
N * $Date: 15/08/11 10:26a $
N * @brief    M451 series WWDT driver header file
N *
N * @note
N * Copyright (C) 2013~2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __WWDT_H__
N#define __WWDT_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup WWDT_Driver WWDT Driver
N  @{
N*/
N
N/** @addtogroup WWDT_EXPORTED_CONSTANTS WWDT Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  WWDT Prescale Period Constant Definitions                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define WWDT_PRESCALER_1        (0 << WWDT_CTL_PSCSEL_Pos)  /*!< Select max time-out period to 1 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_2        (1 << WWDT_CTL_PSCSEL_Pos)  /*!< Select max time-out period to 2 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_4        (2 << WWDT_CTL_PSCSEL_Pos)  /*!< Select max time-out period to 4 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_8        (3 << WWDT_CTL_PSCSEL_Pos)  /*!< Select max time-out period to 8 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_16       (4 << WWDT_CTL_PSCSEL_Pos)  /*!< Select max time-out period to 16 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_32       (5 << WWDT_CTL_PSCSEL_Pos)  /*!< Select max time-out period to 32 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_64       (6 << WWDT_CTL_PSCSEL_Pos)  /*!< Select max time-out period to 64 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_128      (7 << WWDT_CTL_PSCSEL_Pos)  /*!< Select max time-out period to 128 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_192      (8 << WWDT_CTL_PSCSEL_Pos)  /*!< Select max time-out period to 192 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_256      (9 << WWDT_CTL_PSCSEL_Pos)  /*!< Select max time-out period to 256 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_384      (10 << WWDT_CTL_PSCSEL_Pos) /*!< Select max time-out period to 384 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_512      (11 << WWDT_CTL_PSCSEL_Pos) /*!< Select max time-out period to 512 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_768      (12 << WWDT_CTL_PSCSEL_Pos) /*!< Select max time-out period to 768 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_1024     (13 << WWDT_CTL_PSCSEL_Pos) /*!< Select max time-out period to 1024 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_1536     (14 << WWDT_CTL_PSCSEL_Pos) /*!< Select max time-out period to 1536 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_2048     (15 << WWDT_CTL_PSCSEL_Pos) /*!< Select max time-out period to 2048 * (64*WWDT_CLK) */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  WWDT Reload Counter Keyword Constant Definitions                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define WWDT_RELOAD_WORD        (0x00005AA5)                /*!< Fill this value to WWDT_RLDCNT register to reload WWDT counter */
N
N/*@}*/ /* end of group WWDT_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup WWDT_EXPORTED_FUNCTIONS WWDT Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Clear WWDT Reset System Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to clear WWDT time-out reset system flag.
N  */
N#define WWDT_CLEAR_RESET_FLAG()     (WWDT->STATUS = (WWDT->STATUS & ~WWDT_STATUS_WWDTIF_Msk) | WWDT_STATUS_WWDTRF_Msk)
N
N/**
N  * @brief      Clear WWDT Compared Match Interrupt Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to clear WWDT compared match interrupt flag.
N  */
N#define WWDT_CLEAR_INT_FLAG()       (WWDT->STATUS = (WWDT->STATUS & ~WWDT_STATUS_WWDTRF_Msk) | WWDT_STATUS_WWDTIF_Msk)
N
N/**
N  * @brief      Get WWDT Reset System Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WWDT time-out reset system did not occur
N  * @retval     1   WWDT time-out reset system occurred
N  *
N  * @details    This macro is used to indicate system has been reset by WWDT time-out reset or not.
N  */
N#define WWDT_GET_RESET_FLAG()       ((WWDT->STATUS & WWDT_STATUS_WWDTRF_Msk)? 1 : 0)
N
N/**
N  * @brief      Get WWDT Compared Match Interrupt Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WWDT compare match interrupt did not occur
N  * @retval     1   WWDT compare match interrupt occurred
N  *
N  * @details    This macro is used to indicate WWDT counter value matches CMPDAT value or not.
N  */
N#define WWDT_GET_INT_FLAG()         ((WWDT->STATUS & WWDT_STATUS_WWDTIF_Msk)? 1 : 0)
N
N/**
N  * @brief      Get WWDT Counter
N  *
N  * @param      None
N  *
N  * @return     WWDT Counter Value
N  *
N  * @details    This macro reflects the current WWDT counter value.
N  */
N#define WWDT_GET_COUNTER()          (WWDT->CNT)
N
N/**
N  * @brief      Reload WWDT Counter
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to reload the WWDT counter value to 0x3F.
N  * @note       User can only write WWDT_RLDCNT register to reload WWDT counter value when current WWDT counter value \n
N  *             between 0 and CMPDAT value. If user writes WWDT_RLDCNT when current WWDT counter value is larger than CMPDAT, \n
N  *             WWDT reset signal will generate immediately to reset system.
N  */
N#define WWDT_RELOAD_COUNTER()       (WWDT->RLDCNT = WWDT_RELOAD_WORD)
N
Nvoid WWDT_Open(uint32_t u32PreScale, uint32_t u32CmpValue, uint32_t u32EnableInt);
N
N/*@}*/ /* end of group WWDT_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group WWDT_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__WWDT_H__
N
N/*** (C) COPYRIGHT 2013~2015 Nuvoton Technology Corp. ***/
L 17103 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N#include "spi.h"
L 1 "..\..\..\..\Library\StdDriver\inc\spi.h" 1
N/******************************************************************************
N * @file     spi.h
N * @version  V0.10
N * $Revision: 17 $
N * $Date: 15/08/11 10:26a $
N * @brief    M451 series SPI driver header file
N *
N * @note
N * Copyright (C) 2014~2015 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef __SPI_H__
N#define __SPI_H__
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Include related headers                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#include "M451Series.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup SPI_Driver SPI Driver
N  @{
N*/
N
N/** @addtogroup SPI_EXPORTED_CONSTANTS SPI Exported Constants
N  @{
N*/
N
N#define SPI_MODE_0        (SPI_CTL_TXNEG_Msk)                             /*!< CLKPOL=0; RXNEG=0; TXNEG=1 */
N#define SPI_MODE_1        (SPI_CTL_RXNEG_Msk)                             /*!< CLKPOL=0; RXNEG=1; TXNEG=0 */
N#define SPI_MODE_2        (SPI_CTL_CLKPOL_Msk | SPI_CTL_RXNEG_Msk)        /*!< CLKPOL=1; RXNEG=1; TXNEG=0 */
N#define SPI_MODE_3        (SPI_CTL_CLKPOL_Msk | SPI_CTL_TXNEG_Msk)        /*!< CLKPOL=1; RXNEG=0; TXNEG=1 */
N
N#define SPI_SLAVE         (SPI_CTL_SLAVE_Msk)                             /*!< Set as slave */
N#define SPI_MASTER        (0x0)                                           /*!< Set as master */
N
N#define SPI_SS                (SPI_SSCTL_SS_Msk)                          /*!< Set SS */
N#define SPI_SS_ACTIVE_HIGH    (SPI_SSCTL_SSACTPOL_Msk)                    /*!< SS active high */
N#define SPI_SS_ACTIVE_LOW     (0x0)                                       /*!< SS active low */
N
N/* SPI Interrupt Mask */
N#define SPI_UNIT_INT_MASK                (0x001)                          /*!< Unit transfer interrupt mask */
N#define SPI_SSACT_INT_MASK               (0x002)                          /*!< Slave selection signal active interrupt mask */
N#define SPI_SSINACT_INT_MASK             (0x004)                          /*!< Slave selection signal inactive interrupt mask */
N#define SPI_SLVUR_INT_MASK               (0x008)                          /*!< Slave under run interrupt mask */
N#define SPI_SLVBE_INT_MASK               (0x010)                          /*!< Slave bit count error interrupt mask */
N#define SPI_SLVTO_INT_MASK               (0x020)                          /*!< Slave time-out interrupt mask */
N#define SPI_TXUF_INT_MASK                (0x040)                          /*!< Slave TX underflow interrupt mask */
N#define SPI_FIFO_TXTH_INT_MASK           (0x080)                          /*!< FIFO TX threshold interrupt mask */
N#define SPI_FIFO_RXTH_INT_MASK           (0x100)                          /*!< FIFO RX threshold interrupt mask */
N#define SPI_FIFO_RXOV_INT_MASK           (0x200)                          /*!< FIFO RX overrun interrupt mask */
N#define SPI_FIFO_RXTO_INT_MASK           (0x400)                          /*!< FIFO RX time-out interrupt mask */
N
N/* SPI Status Mask */
N#define SPI_BUSY_MASK                    (0x01)                           /*!< Busy status mask */
N#define SPI_RX_EMPTY_MASK                (0x02)                           /*!< RX empty status mask */
N#define SPI_RX_FULL_MASK                 (0x04)                           /*!< RX full status mask */
N#define SPI_TX_EMPTY_MASK                (0x08)                           /*!< TX empty status mask */
N#define SPI_TX_FULL_MASK                 (0x10)                           /*!< TX full status mask */
N#define SPI_TXRX_RESET_MASK              (0x20)                           /*!< TX or RX reset status mask */
N#define SPI_SPIEN_STS_MASK               (0x40)                           /*!< SPIEN status mask */
N#define SPI_SSLINE_STS_MASK              (0x80)                           /*!< SPIn_SS line status mask */
N
N
N/* I2S Data Width */
N#define I2S_DATABIT_8           (0 << SPI_I2SCTL_WDWIDTH_Pos)      /*!< I2S data width is 8-bit */
N#define I2S_DATABIT_16          (1 << SPI_I2SCTL_WDWIDTH_Pos)      /*!< I2S data width is 16-bit */
N#define I2S_DATABIT_24          (2 << SPI_I2SCTL_WDWIDTH_Pos)      /*!< I2S data width is 24-bit */
N#define I2S_DATABIT_32          (3 << SPI_I2SCTL_WDWIDTH_Pos)      /*!< I2S data width is 32-bit */
N
N/* I2S Audio Format */
N#define I2S_MONO                SPI_I2SCTL_MONO_Msk                /*!< Monaural channel */
N#define I2S_STEREO              0                                  /*!< Stereo channel */
N
N/* I2S Data Format */
N#define I2S_FORMAT_I2S          (0<<SPI_I2SCTL_FORMAT_Pos)         /*!< I2S data format */
N#define I2S_FORMAT_MSB          (1<<SPI_I2SCTL_FORMAT_Pos)         /*!< MSB justified data format */
N#define I2S_FORMAT_PCMA         (2<<SPI_I2SCTL_FORMAT_Pos)         /*!< PCM mode A data format */
N#define I2S_FORMAT_PCMB         (3<<SPI_I2SCTL_FORMAT_Pos)         /*!< PCM mode B data format */
N
N/* I2S Operation mode */
N#define I2S_MODE_SLAVE          SPI_I2SCTL_SLAVE_Msk               /*!< As slave mode */
N#define I2S_MODE_MASTER         0                                  /*!< As master mode */
N
N/* I2S TX FIFO Threshold */
N#define I2S_FIFO_TX_LEVEL_WORD_0    0                              /*!< TX threshold is 0 word */
N#define I2S_FIFO_TX_LEVEL_WORD_1    (1 << SPI_FIFOCTL_TXTH_Pos)    /*!< TX threshold is 1 word */
N#define I2S_FIFO_TX_LEVEL_WORD_2    (2 << SPI_FIFOCTL_TXTH_Pos)    /*!< TX threshold is 2 words */
N#define I2S_FIFO_TX_LEVEL_WORD_3    (3 << SPI_FIFOCTL_TXTH_Pos)    /*!< TX threshold is 3 words */
N/* I2S RX FIFO Threshold */
N#define I2S_FIFO_RX_LEVEL_WORD_1    0                              /*!< RX threshold is 1 word */
N#define I2S_FIFO_RX_LEVEL_WORD_2    (1 << SPI_FIFOCTL_RXTH_Pos)    /*!< RX threshold is 2 words */
N#define I2S_FIFO_RX_LEVEL_WORD_3    (2 << SPI_FIFOCTL_RXTH_Pos)    /*!< RX threshold is 3 words */
N#define I2S_FIFO_RX_LEVEL_WORD_4    (3 << SPI_FIFOCTL_RXTH_Pos)    /*!< RX threshold is 4 words */
N
N/* I2S Record Channel */
N#define I2S_MONO_RIGHT          0                                  /*!< Record mono right channel */
N#define I2S_MONO_LEFT           SPI_I2SCTL_RXLCH_Msk               /*!< Record mono left channel */
N
N/* I2S Channel */
N#define I2S_RIGHT               0                                  /*!< Select right channel */
N#define I2S_LEFT                1                                  /*!< Select left channel */
N
N/* I2S Interrupt Mask */
N#define I2S_FIFO_TXTH_INT_MASK           (0x01)                          /*!< TX FIFO threshold interrupt mask */
N#define I2S_FIFO_RXTH_INT_MASK           (0x02)                          /*!< RX FIFO threshold interrupt mask */
N#define I2S_FIFO_RXOV_INT_MASK           (0x04)                          /*!< RX FIFO overrun interrupt mask */
N#define I2S_FIFO_RXTO_INT_MASK           (0x08)                          /*!< RX FIFO time-out interrupt mask */
N#define I2S_TXUF_INT_MASK                (0x10)                          /*!< TX FIFO underflow interrupt mask */
N#define I2S_RIGHT_ZC_INT_MASK            (0x20)                          /*!< Right channel zero cross interrupt mask */
N#define I2S_LEFT_ZC_INT_MASK             (0x40)                          /*!< Left channel zero cross interrupt mask */
N
N/*@}*/ /* end of group SPI_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup SPI_EXPORTED_FUNCTIONS SPI Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Clear the unit transfer interrupt flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Write 1 to UNITIF bit of SPI_STATUS register to clear the unit transfer interrupt flag.
N  */
N#define SPI_CLR_UNIT_TRANS_INT_FLAG(spi)   ((spi)->STATUS = SPI_STATUS_UNITIF_Msk)
N
N/**
N  * @brief      Disable 2-bit Transfer mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear TWOBIT bit of SPI_CTL register to disable 2-bit Transfer mode.
N  */
N#define SPI_DISABLE_2BIT_MODE(spi)   ((spi)->CTL &= ~SPI_CTL_TWOBIT_Msk)
N
N/**
N  * @brief      Disable Slave 3-wire mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear SLV3WIRE bit of SPI_SSCTL register to disable Slave 3-wire mode.
N  */
N#define SPI_DISABLE_3WIRE_MODE(spi)   ((spi)->SSCTL &= ~SPI_SSCTL_SLV3WIRE_Msk)
N
N/**
N  * @brief      Disable Dual I/O mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear DUALIOEN bit of SPI_CTL register to disable Dual I/O mode.
N  */
N#define SPI_DISABLE_DUAL_MODE(spi)   ((spi)->CTL &= ~SPI_CTL_DUALIOEN_Msk)
N
N/**
N  * @brief      Disable Quad I/O mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear QUADIOEN bit of SPI_CTL register to disable Quad I/O mode.
N  */
N#define SPI_DISABLE_QUAD_MODE(spi)   ((spi)->CTL &= ~SPI_CTL_QUADIOEN_Msk)
N
N/**
N  * @brief      Enable 2-bit Transfer mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set TWOBIT bit of SPI_CTL register to enable 2-bit Transfer mode.
N  */
N#define SPI_ENABLE_2BIT_MODE(spi)   ((spi)->CTL |= SPI_CTL_TWOBIT_Msk)
N
N/**
N  * @brief      Enable Slave 3-wire mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set SLV3WIRE bit of SPI_SSCTL register to enable Slave 3-wire mode.
N  */
N#define SPI_ENABLE_3WIRE_MODE(spi)   ((spi)->SSCTL |= SPI_SSCTL_SLV3WIRE_Msk)
N
N/**
N  * @brief      Enable Dual input mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear QDIODIR bit and set DUALIOEN bit of SPI_CTL register to enable Dual input mode.
N  */
N#define SPI_ENABLE_DUAL_INPUT_MODE(spi)   ((spi)->CTL = ((spi)->CTL & (~SPI_CTL_QDIODIR_Msk)) | SPI_CTL_DUALIOEN_Msk)
N
N/**
N  * @brief      Enable Dual output mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set QDIODIR bit and DUALIOEN bit of SPI_CTL register to enable Dual output mode.
N  */
N#define SPI_ENABLE_DUAL_OUTPUT_MODE(spi)   ((spi)->CTL |= (SPI_CTL_QDIODIR_Msk | SPI_CTL_DUALIOEN_Msk))
N
N/**
N  * @brief      Enable Quad input mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear QDIODIR bit and set QUADIOEN bit of SPI_CTL register to enable Quad input mode.
N  */
N#define SPI_ENABLE_QUAD_INPUT_MODE(spi)   ((spi)->CTL = ((spi)->CTL & (~SPI_CTL_QDIODIR_Msk)) | SPI_CTL_QUADIOEN_Msk)
N
N/**
N  * @brief      Enable Quad output mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set QDIODIR bit and QUADIOEN bit of SPI_CTL register to enable Quad output mode.
N  */
N#define SPI_ENABLE_QUAD_OUTPUT_MODE(spi)   ((spi)->CTL |= (SPI_CTL_QDIODIR_Msk | SPI_CTL_QUADIOEN_Msk))
N
N/**
N  * @brief      Trigger RX PDMA function.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set RXPDMAEN bit of SPI_PDMACTL register to enable RX PDMA transfer function.
N  */
N#define SPI_TRIGGER_RX_PDMA(spi)   ((spi)->PDMACTL |= SPI_PDMACTL_RXPDMAEN_Msk)
N
N/**
N  * @brief      Trigger TX PDMA function.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set TXPDMAEN bit of SPI_PDMACTL register to enable TX PDMA transfer function.
N  */
N#define SPI_TRIGGER_TX_PDMA(spi)   ((spi)->PDMACTL |= SPI_PDMACTL_TXPDMAEN_Msk)
N
N/**
N  * @brief      Disable RX PDMA transfer.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear RXPDMAEN bit of SPI_PDMACTL register to disable RX PDMA transfer function.
N  */
N#define SPI_DISABLE_RX_PDMA(spi) ( (spi)->PDMACTL &= ~SPI_PDMACTL_RXPDMAEN_Msk )
N
N/**
N  * @brief      Disable TX PDMA transfer.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear TXPDMAEN bit of SPI_PDMACTL register to disable TX PDMA transfer function.
N  */
N#define SPI_DISABLE_TX_PDMA(spi) ( (spi)->PDMACTL &= ~SPI_PDMACTL_TXPDMAEN_Msk )
N
N/**
N  * @brief      Get the count of available data in RX FIFO.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     The count of available data in RX FIFO.
N  * @details    Read RXCNT (SPI_STATUS[27:24]) to get the count of available data in RX FIFO.
N  */
N#define SPI_GET_RX_FIFO_COUNT(spi)   (((spi)->STATUS & SPI_STATUS_RXCNT_Msk) >> SPI_STATUS_RXCNT_Pos)
N
N/**
N  * @brief      Get the RX FIFO empty flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @retval     0 RX FIFO is not empty.
N  * @retval     1 RX FIFO is empty.
N  * @details    Read RXEMPTY bit of SPI_STATUS register to get the RX FIFO empty flag.
N  */
N#define SPI_GET_RX_FIFO_EMPTY_FLAG(spi)   (((spi)->STATUS & SPI_STATUS_RXEMPTY_Msk)>>SPI_STATUS_RXEMPTY_Pos)
N
N/**
N  * @brief      Get the TX FIFO empty flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @retval     0 TX FIFO is not empty.
N  * @retval     1 TX FIFO is empty.
N  * @details    Read TXEMPTY bit of SPI_STATUS register to get the TX FIFO empty flag.
N  */
N#define SPI_GET_TX_FIFO_EMPTY_FLAG(spi)   (((spi)->STATUS & SPI_STATUS_TXEMPTY_Msk)>>SPI_STATUS_TXEMPTY_Pos)
N
N/**
N  * @brief      Get the TX FIFO full flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @retval     0 TX FIFO is not full.
N  * @retval     1 TX FIFO is full.
N  * @details    Read TXFULL bit of SPI_STATUS register to get the TX FIFO full flag.
N  */
N#define SPI_GET_TX_FIFO_FULL_FLAG(spi)   (((spi)->STATUS & SPI_STATUS_TXFULL_Msk)>>SPI_STATUS_TXFULL_Pos)
N
N/**
N  * @brief      Get the datum read from RX register.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     Data in RX register.
N  * @details    Read SPI_RX register to get the received datum.
N  */
N#define SPI_READ_RX(spi)   ((spi)->RX)
N
N/**
N  * @brief      Write datum to TX register.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @param[in]  u32TxData The datum which user attempt to transfer through SPI bus.
N  * @return     None.
N  * @details    Write u32TxData to SPI_TX register.
N  */
N#define SPI_WRITE_TX(spi, u32TxData)   ((spi)->TX = (u32TxData))
N
N/**
N  * @brief      Set SPIn_SS pin to high state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Disable automatic slave selection function and set SPIn_SS pin to high state.
N  */
N#define SPI_SET_SS_HIGH(spi)   ((spi)->SSCTL = ((spi)->SSCTL & (~SPI_SSCTL_AUTOSS_Msk)) | (SPI_SSCTL_SSACTPOL_Msk | SPI_SSCTL_SS_Msk))
N
N/**
N  * @brief      Set SPIn_SS pin to low state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Disable automatic slave selection function and set SPIn_SS pin to low state.
N  */
N#define SPI_SET_SS_LOW(spi)   ((spi)->SSCTL = ((spi)->SSCTL & (~(SPI_SSCTL_AUTOSS_Msk | SPI_SSCTL_SSACTPOL_Msk))) | SPI_SSCTL_SS_Msk)
N
N/**
N  * @brief      Enable Byte Reorder function.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Enable Byte Reorder function. The suspend interval depends on the setting of SUSPITV (SPI_CTL[7:4]).
N  */
N#define SPI_ENABLE_BYTE_REORDER(spi)   ((spi)->CTL |=  SPI_CTL_REORDER_Msk)
N
N/**
N  * @brief      Disable Byte Reorder function.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear REORDER bit field of SPI_CTL register to disable Byte Reorder function.
N  */
N#define SPI_DISABLE_BYTE_REORDER(spi)   ((spi)->CTL &= ~SPI_CTL_REORDER_Msk)
N
N/**
N  * @brief      Set the length of suspend interval.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @param[in]  u32SuspCycle Decides the length of suspend interval. It could be 0 ~ 15.
N  * @return     None.
N  * @details    Set the length of suspend interval according to u32SuspCycle.
N  *             The length of suspend interval is ((u32SuspCycle + 0.5) * the length of one SPI bus clock cycle).
N  */
N#define SPI_SET_SUSPEND_CYCLE(spi, u32SuspCycle)   ((spi)->CTL = ((spi)->CTL & ~SPI_CTL_SUSPITV_Msk) | ((u32SuspCycle) << SPI_CTL_SUSPITV_Pos))
N
N/**
N  * @brief      Set the SPI transfer sequence with LSB first.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set LSB bit of SPI_CTL register to set the SPI transfer sequence with LSB first.
N  */
N#define SPI_SET_LSB_FIRST(spi)   ((spi)->CTL |= SPI_CTL_LSB_Msk)
N
N/**
N  * @brief      Set the SPI transfer sequence with MSB first.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear LSB bit of SPI_CTL register to set the SPI transfer sequence with MSB first.
N  */
N#define SPI_SET_MSB_FIRST(spi)   ((spi)->CTL &= ~SPI_CTL_LSB_Msk)
N
N/**
N  * @brief      Set the data width of a SPI transaction.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @param[in]  u32Width The bit width of one transaction.
N  * @return     None.
N  * @details    The data width can be 8 ~ 32 bits.
N  */
N#define SPI_SET_DATA_WIDTH(spi, u32Width)   ((spi)->CTL = ((spi)->CTL & ~SPI_CTL_DWIDTH_Msk) | (((u32Width)&0x1F) << SPI_CTL_DWIDTH_Pos))
N
N/**
N  * @brief      Get the SPI busy state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @retval     0 SPI controller is not busy.
N  * @retval     1 SPI controller is busy.
N  * @details    This macro will return the busy state of SPI controller.
N  */
N#define SPI_IS_BUSY(spi)   ( ((spi)->STATUS & SPI_STATUS_BUSY_Msk)>>SPI_STATUS_BUSY_Pos )
N
N/**
N  * @brief      Enable SPI controller.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set SPIEN (SPI_CTL[0]) to enable SPI controller.
N  */
N#define SPI_ENABLE(spi)   ((spi)->CTL |= SPI_CTL_SPIEN_Msk)
N
N/**
N  * @brief      Disable SPI controller.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear SPIEN (SPI_CTL[0]) to disable SPI controller.
N  */
N#define SPI_DISABLE(spi)   ((spi)->CTL &= ~SPI_CTL_SPIEN_Msk)
N
N
N/**
N  * @brief  Enable zero cross detection function.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @param[in] u32ChMask The mask for left or right channel. Valid values are:
N  *                    - \ref I2S_RIGHT
N  *                    - \ref I2S_LEFT
N  * @return None
N  * @details This function will set RZCEN or LZCEN bit of SPI_I2SCTL register to enable zero cross detection function.
N  */
Nstatic __INLINE void I2S_ENABLE_TX_ZCD(SPI_T *i2s, uint32_t u32ChMask)
Xstatic __inline void I2S_ENABLE_TX_ZCD(SPI_T *i2s, uint32_t u32ChMask)
N{
N    if(u32ChMask == I2S_RIGHT)
X    if(u32ChMask == 0)
N        i2s->I2SCTL |= SPI_I2SCTL_RZCEN_Msk;
X        i2s->I2SCTL |= (0x1ul << (16));
N    else
N        i2s->I2SCTL |= SPI_I2SCTL_LZCEN_Msk;
X        i2s->I2SCTL |= (0x1ul << (17));
N}
N
N/**
N  * @brief  Disable zero cross detection function.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @param[in] u32ChMask The mask for left or right channel. Valid values are:
N  *                    - \ref I2S_RIGHT
N  *                    - \ref I2S_LEFT
N  * @return None
N  * @details This function will clear RZCEN or LZCEN bit of SPI_I2SCTL register to disable zero cross detection function.
N  */
Nstatic __INLINE void I2S_DISABLE_TX_ZCD(SPI_T *i2s, uint32_t u32ChMask)
Xstatic __inline void I2S_DISABLE_TX_ZCD(SPI_T *i2s, uint32_t u32ChMask)
N{
N    if(u32ChMask == I2S_RIGHT)
X    if(u32ChMask == 0)
N        i2s->I2SCTL &= ~SPI_I2SCTL_RZCEN_Msk;
X        i2s->I2SCTL &= ~(0x1ul << (16));
N    else
N        i2s->I2SCTL &= ~SPI_I2SCTL_LZCEN_Msk;
X        i2s->I2SCTL &= ~(0x1ul << (17));
N}
N
N/**
N  * @brief  Enable I2S TX DMA function.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return None
N  * @details This macro will set TXPDMAEN bit of SPI_PDMACTL register to transmit data with PDMA.
N  */
N#define I2S_ENABLE_TXDMA(i2s)  ( (i2s)->PDMACTL |= SPI_PDMACTL_TXPDMAEN_Msk )
N
N/**
N  * @brief  Disable I2S TX DMA function.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return None
N  * @details This macro will clear TXPDMAEN bit of SPI_PDMACTL register to disable TX DMA function.
N  */
N#define I2S_DISABLE_TXDMA(i2s) ( (i2s)->PDMACTL &= ~SPI_PDMACTL_TXPDMAEN_Msk )
N
N/**
N  * @brief  Enable I2S RX DMA function.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return None
N  * @details This macro will set RXPDMAEN bit of SPI_PDMACTL register to receive data with PDMA.
N  */
N#define I2S_ENABLE_RXDMA(i2s) ( (i2s)->PDMACTL |= SPI_PDMACTL_RXPDMAEN_Msk )
N
N/**
N  * @brief  Disable I2S RX DMA function.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return None
N  * @details This macro will clear RXPDMAEN bit of SPI_PDMACTL register to disable RX DMA function.
N  */
N#define I2S_DISABLE_RXDMA(i2s) ( (i2s)->PDMACTL &= ~SPI_PDMACTL_RXPDMAEN_Msk )
N
N/**
N  * @brief  Enable I2S TX function.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return None
N  * @details This macro will set TXEN bit of SPI_I2SCTL register to enable I2S TX function.
N  */
N#define I2S_ENABLE_TX(i2s) ( (i2s)->I2SCTL |= SPI_I2SCTL_TXEN_Msk )
N
N/**
N  * @brief  Disable I2S TX function.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return None
N  * @details This macro will clear TXEN bit of SPI_I2SCTL register to disable I2S TX function.
N  */
N#define I2S_DISABLE_TX(i2s) ( (i2s)->I2SCTL &= ~SPI_I2SCTL_TXEN_Msk )
N
N/**
N  * @brief  Enable I2S RX function.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return None
N  * @details This macro will set RXEN bit of SPI_I2SCTL register to enable I2S RX function.
N  */
N#define I2S_ENABLE_RX(i2s) ( (i2s)->I2SCTL |= SPI_I2SCTL_RXEN_Msk )
N
N/**
N  * @brief  Disable I2S RX function.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return None
N  * @details This macro will clear RXEN bit of SPI_I2SCTL register to disable I2S RX function.
N  */
N#define I2S_DISABLE_RX(i2s) ( (i2s)->I2SCTL &= ~SPI_I2SCTL_RXEN_Msk )
N
N/**
N  * @brief  Enable TX Mute function.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return None
N  * @details This macro will set MUTE bit of SPI_I2SCTL register to enable I2S TX mute function.
N  */
N#define I2S_ENABLE_TX_MUTE(i2s)  ( (i2s)->I2SCTL |= SPI_I2SCTL_MUTE_Msk )
N
N/**
N  * @brief  Disable TX Mute function.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return None
N  * @details This macro will clear MUTE bit of SPI_I2SCTL register to disable I2S TX mute function.
N  */
N#define I2S_DISABLE_TX_MUTE(i2s) ( (i2s)->I2SCTL &= ~SPI_I2SCTL_MUTE_Msk )
N
N/**
N  * @brief  Clear TX FIFO.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return None
N  * @details This macro will clear TX FIFO. The internal TX FIFO pointer will be reset to FIFO start point.
N  */
N#define I2S_CLR_TX_FIFO(i2s) ( (i2s)->FIFOCTL |= SPI_FIFOCTL_TXFBCLR_Msk )
N
N/**
N  * @brief  Clear RX FIFO.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return None
N  * @details This macro will clear RX FIFO. The internal RX FIFO pointer will be reset to FIFO start point.
N  */
N#define I2S_CLR_RX_FIFO(i2s) ( (i2s)->FIFOCTL |= SPI_FIFOCTL_RXFBCLR_Msk )
N
N/**
N  * @brief  This function sets the recording source channel when mono mode is used.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @param[in] u32Ch left or right channel. Valid values are:
N  *                - \ref I2S_MONO_LEFT
N  *                - \ref I2S_MONO_RIGHT
N  * @return None
N  * @details This function selects the recording source channel of monaural mode.
N  */
Nstatic __INLINE void I2S_SET_MONO_RX_CHANNEL(SPI_T *i2s, uint32_t u32Ch)
Xstatic __inline void I2S_SET_MONO_RX_CHANNEL(SPI_T *i2s, uint32_t u32Ch)
N{
N    u32Ch == I2S_MONO_LEFT ?
X    u32Ch == (0x1ul << (23)) ?
N    (i2s->I2SCTL |= SPI_I2SCTL_RXLCH_Msk) :
X    (i2s->I2SCTL |= (0x1ul << (23))) :
N    (i2s->I2SCTL &= ~SPI_I2SCTL_RXLCH_Msk);
X    (i2s->I2SCTL &= ~(0x1ul << (23)));
N}
N
N/**
N  * @brief  Write data to I2S TX FIFO.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @param[in] u32Data The value written to TX FIFO.
N  * @return None
N  * @details This macro will write a value to TX FIFO.
N  */
N#define I2S_WRITE_TX_FIFO(i2s, u32Data)  ( (i2s)->TX = (u32Data) )
N
N/**
N  * @brief  Read RX FIFO.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return The value read from RX FIFO.
N  * @details This function will return a value read from RX FIFO.
N  */
N#define I2S_READ_RX_FIFO(i2s) ( (i2s)->RX )
N
N/**
N  * @brief  Get the interrupt flag.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @param[in] u32Mask The mask value for all interrupt flags.
N  * @return The interrupt flags specified by the u32mask parameter.
N  * @details This macro will return the combination interrupt flags of SPI_I2SSTS register. The flags are specified by the u32mask parameter.
N  */
N#define I2S_GET_INT_FLAG(i2s, u32Mask) ( (i2s)->I2SSTS & (u32Mask) )
N
N/**
N  * @brief  Clear the interrupt flag.
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @param[in] u32Mask The mask value for all interrupt flags.
N  * @return None
N  * @details This macro will clear the interrupt flags specified by the u32mask parameter.
N  * @note Except TX and RX FIFO threshold interrupt flags, the other interrupt flags can be cleared by writing 1 to itself.
N  */
N#define I2S_CLR_INT_FLAG(i2s, u32Mask) ( (i2s)->I2SSTS = (u32Mask) )
N
N/**
N  * @brief  Get transmit FIFO level
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return TX FIFO level
N  * @details This macro will return the number of available words in TX FIFO.
N  */
N#define I2S_GET_TX_FIFO_LEVEL(i2s) ( ((i2s)->I2SSTS & SPI_I2SSTS_TXCNT_Msk) >> SPI_I2SSTS_TXCNT_Pos  )
N
N/**
N  * @brief  Get receive FIFO level
N  * @param[in] i2s The pointer of the specified I2S module.
N  * @return RX FIFO level
N  * @details This macro will return the number of available words in RX FIFO.
N  */
N#define I2S_GET_RX_FIFO_LEVEL(i2s) ( ((i2s)->I2SSTS & SPI_I2SSTS_RXCNT_Msk) >> SPI_I2SSTS_RXCNT_Pos )
N
N
N
N/* Function prototype declaration */
Nuint32_t SPI_Open(SPI_T *spi, uint32_t u32MasterSlave, uint32_t u32SPIMode, uint32_t u32DataWidth, uint32_t u32BusClock);
Nvoid SPI_Close(SPI_T *spi);
Nvoid SPI_ClearRxFIFO(SPI_T *spi);
Nvoid SPI_ClearTxFIFO(SPI_T *spi);
Nvoid SPI_DisableAutoSS(SPI_T *spi);
Nvoid SPI_EnableAutoSS(SPI_T *spi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel);
Nuint32_t SPI_SetBusClock(SPI_T *spi, uint32_t u32BusClock);
Nvoid SPI_SetFIFO(SPI_T *spi, uint32_t u32TxThreshold, uint32_t u32RxThreshold);
Nuint32_t SPI_GetBusClock(SPI_T *spi);
Nvoid SPI_EnableInt(SPI_T *spi, uint32_t u32Mask);
Nvoid SPI_DisableInt(SPI_T *spi, uint32_t u32Mask);
Nuint32_t SPI_GetIntFlag(SPI_T *spi, uint32_t u32Mask);
Nvoid SPI_ClearIntFlag(SPI_T *spi, uint32_t u32Mask);
Nuint32_t SPI_GetStatus(SPI_T *spi, uint32_t u32Mask);
N
Nuint32_t I2S_Open(SPI_T *i2s, uint32_t u32MasterSlave, uint32_t u32SampleRate, uint32_t u32WordWidth, uint32_t u32Channels, uint32_t u32DataFormat);
Nvoid I2S_Close(SPI_T *i2s);
Nvoid I2S_EnableInt(SPI_T *i2s, uint32_t u32Mask);
Nvoid I2S_DisableInt(SPI_T *i2s, uint32_t u32Mask);
Nuint32_t I2S_EnableMCLK(SPI_T *i2s, uint32_t u32BusClock);
Nvoid I2S_DisableMCLK(SPI_T *i2s);
Nvoid I2S_SetFIFO(SPI_T *i2s, uint32_t u32TxThreshold, uint32_t u32RxThreshold);
N
N
N/*@}*/ /* end of group SPI_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group SPI_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SPI_H__
N
N/*** (C) COPYRIGHT 2014~2015 Nuvoton Technology Corp. ***/
L 17104 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N#include "sc.h"
L 1 "..\..\..\..\Library\StdDriver\inc\sc.h" 1
N/**************************************************************************//**
N * @file     sc.h
N * @version  V3.00
N * $Revision: 13 $
N * $Date: 15/08/11 10:26a $
N * @brief    M451 series Smartcard (SC) driver header file
N *
N * @note
N * Copyright (C) 2013~2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __SC_H__
N#define __SC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup SC_Driver SC Driver
N  @{
N*/
N
N/** @addtogroup SC_EXPORTED_CONSTANTS SC Exported Constants
N  @{
N*/
N#define SC_INTERFACE_NUM        1                /*!< Smartcard interface numbers */ /* M451 series has only one SC interface */
N#define SC_PIN_STATE_HIGH       1                /*!< Smartcard pin status high   */
N#define SC_PIN_STATE_LOW        0                /*!< Smartcard pin status low    */
N#define SC_PIN_STATE_IGNORE     0xFFFFFFFF       /*!< Ignore pin status           */
N#define SC_CLK_ON               1                /*!< Smartcard clock on          */
N#define SC_CLK_OFF              0                /*!< Smartcard clock off         */
N
N#define SC_TMR_MODE_0                   (0ul << SC_TMRCTL0_OPMODE_Pos)     /*!<Timer Operation Mode 0, down count                                                      */
N#define SC_TMR_MODE_1                   (1ul << SC_TMRCTL0_OPMODE_Pos)     /*!<Timer Operation Mode 1, down count, start after detect start bit                        */
N#define SC_TMR_MODE_2                   (2ul << SC_TMRCTL0_OPMODE_Pos)     /*!<Timer Operation Mode 2, down count, start after receive start bit                       */
N#define SC_TMR_MODE_3                   (3ul << SC_TMRCTL0_OPMODE_Pos)     /*!<Timer Operation Mode 3, down count, use for activation, only timer 0 support this mode  */
N#define SC_TMR_MODE_4                   (4ul << SC_TMRCTL0_OPMODE_Pos)     /*!<Timer Operation Mode 4, down count with reload after timeout                            */
N#define SC_TMR_MODE_5                   (5ul << SC_TMRCTL0_OPMODE_Pos)     /*!<Timer Operation Mode 5, down count, start after detect start bit, reload after timeout  */
N#define SC_TMR_MODE_6                   (6ul << SC_TMRCTL0_OPMODE_Pos)     /*!<Timer Operation Mode 6, down count, start after receive start bit, reload after timeout */
N#define SC_TMR_MODE_7                   (7ul << SC_TMRCTL0_OPMODE_Pos)     /*!<Timer Operation Mode 7, down count, start and reload after detect start bit             */
N#define SC_TMR_MODE_8                   (8ul << SC_TMRCTL0_OPMODE_Pos)     /*!<Timer Operation Mode 8, up count                                                        */
N#define SC_TMR_MODE_F                   (0xF << SC_TMRCTL0_OPMODE_Pos)     /*!<Timer Operation Mode 15, down count, reload after detect start bit                      */
N
N
N/*@}*/ /* end of group SC_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup SC_EXPORTED_FUNCTIONS SC Exported Functions
N  @{
N*/
N
N/**
N  * @brief Enable smartcard interrupt.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u32Mask Interrupt mask to be enabled. A combination of
N  *             - \ref SC_INTEN_ACERRIEN_Msk
N  *             - \ref SC_INTEN_RXTOIF_Msk
N  *             - \ref SC_INTEN_INITIEN_Msk
N  *             - \ref SC_INTEN_CDIEN_Msk
N  *             - \ref SC_INTEN_BGTIEN_Msk
N  *             - \ref SC_INTEN_TMR2IEN_Msk
N  *             - \ref SC_INTEN_TMR1IEN_Msk
N  *             - \ref SC_INTEN_TMR0IEN_Msk
N  *             - \ref SC_INTEN_TERRIEN_Msk
N  *             - \ref SC_INTEN_TBEIEN_Msk
N  *             - \ref SC_INTEN_RDAIEN_Msk
N  * @return None
N  * @details The macro is used to enable Auto-convention error interrupt, Receiver buffer time-out interrupt, Initial end interrupt,
N  *          Card detect interrupt, Block guard time interrupt, Timer2 interrupt, Timer1 interrupt, Timer0 interrupt,
N  *          Transfer error interrupt, Transmit buffer empty interrupt or Receive data reach trigger level interrupt.
N  * \hideinitializer
N  */
N#define SC_ENABLE_INT(sc, u32Mask) ((sc)->INTEN |= (u32Mask))
N
N/**
N  * @brief Disable smartcard interrupt.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u32Mask Interrupt mask to be disabled. A combination of
N  *             - \ref SC_INTEN_ACERRIEN_Msk
N  *             - \ref SC_INTEN_RXTOIF_Msk
N  *             - \ref SC_INTEN_INITIEN_Msk
N  *             - \ref SC_INTEN_CDIEN_Msk
N  *             - \ref SC_INTEN_BGTIEN_Msk
N  *             - \ref SC_INTEN_TMR2IEN_Msk
N  *             - \ref SC_INTEN_TMR1IEN_Msk
N  *             - \ref SC_INTEN_TMR0IEN_Msk
N  *             - \ref SC_INTEN_TERRIEN_Msk
N  *             - \ref SC_INTEN_TBEIEN_Msk
N  *             - \ref SC_INTEN_RDAIEN_Msk
N  * @return None
N  * @details The macro is used to disable Auto-convention error interrupt, Receiver buffer time-out interrupt, Initial end interrupt,
N  *          Card detect interrupt, Block guard time interrupt, Timer2 interrupt, Timer1 interrupt, Timer0 interrupt,
N  *          Transfer error interrupt, Transmit buffer empty interrupt or Receive data reach trigger level interrupt.
N  * \hideinitializer
N  */
N#define SC_DISABLE_INT(sc, u32Mask) ((sc)->INTEN &= ~(u32Mask))
N
N/**
N  * @brief This macro set VCC pin state of smartcard interface.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u32State Pin state of VCC pin, valid parameters are:
N  *                 \ref SC_PIN_STATE_HIGH    :Smartcard pin status high.
N  *                 \ref SC_PIN_STATE_LOW     :Smartcard pin status low.
N  * @return None
N  * @details User can set PWREN (SC_PINCTL[0]) and PWRINV (SC_PINCTL[11])to decide SC_PWR pin is in high or low level.
N  * \hideinitializer
N  */
N#define SC_SET_VCC_PIN(sc, u32State) \
N    do {\
N            while((sc)->PINCTL & SC_PINCTL_SYNC_Msk);\
N            if(u32State)\
N                (sc)->PINCTL |= SC_PINCTL_PWREN_Msk;\
N            else\
N                (sc)->PINCTL &= ~SC_PINCTL_PWREN_Msk;\
N    }while(0)
X#define SC_SET_VCC_PIN(sc, u32State)     do {            while((sc)->PINCTL & SC_PINCTL_SYNC_Msk);            if(u32State)                (sc)->PINCTL |= SC_PINCTL_PWREN_Msk;            else                (sc)->PINCTL &= ~SC_PINCTL_PWREN_Msk;    }while(0)
N
N
N/**
N  * @brief Set CLK output status.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u32OnOff Clock on or off for selected smartcard module, valid values are:
N  *                 \ref SC_CLK_ON    :Smartcard clock on.
N  *                 \ref SC_CLK_OFF   :Smartcard clock off.
N  * @return None
N  * @details User can set CLKKEEP (SC_PINCTL[6]) to decide SC_CLK pin always keeps free running or not.
N  * \hideinitializer
N  */
N#define SC_SET_CLK_PIN(sc, u32OnOff)\
N    do {\
N            while((sc)->PINCTL & SC_PINCTL_SYNC_Msk);\
N            if(u32OnOff)\
N                (sc)->PINCTL |= SC_PINCTL_CLKKEEP_Msk;\
N            else\
N                (sc)->PINCTL &= ~(SC_PINCTL_CLKKEEP_Msk);\
N    }while(0)
X#define SC_SET_CLK_PIN(sc, u32OnOff)    do {            while((sc)->PINCTL & SC_PINCTL_SYNC_Msk);            if(u32OnOff)                (sc)->PINCTL |= SC_PINCTL_CLKKEEP_Msk;            else                (sc)->PINCTL &= ~(SC_PINCTL_CLKKEEP_Msk);    }while(0)
N
N/**
N  * @brief Set I/O pin state.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u32State Pin state of I/O pin, valid parameters are:
N  *                 \ref SC_PIN_STATE_HIGH    :Smartcard pin status high.
N  *                 \ref SC_PIN_STATE_LOW     :Smartcard pin status low.
N  * @return None
N  * @details User can set SCDOUT(SC_PINCTL[9]) to decide SCDOUT pin to high or low.
N  * \hideinitializer
N  */
N#define SC_SET_IO_PIN(sc, u32State)\
N    do {\
N            while((sc)->PINCTL & SC_PINCTL_SYNC_Msk);\
N            if(u32State)\
N                (sc)->PINCTL |= SC_PINCTL_SCDOUT_Msk;\
N            else\
N                (sc)->PINCTL &= ~SC_PINCTL_SCDOUT_Msk;\
N    }while(0)
X#define SC_SET_IO_PIN(sc, u32State)    do {            while((sc)->PINCTL & SC_PINCTL_SYNC_Msk);            if(u32State)                (sc)->PINCTL |= SC_PINCTL_SCDOUT_Msk;            else                (sc)->PINCTL &= ~SC_PINCTL_SCDOUT_Msk;    }while(0)
N
N/**
N  * @brief Set RST pin state.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u32State Pin state of RST pin, valid parameters are:
N  *                 \ref SC_PIN_STATE_HIGH    :Smartcard pin status high.
N  *                 \ref SC_PIN_STATE_LOW     :Smartcard pin status low.
N  * @return None
N  * @details User can set SCRST(SC_PINCTL[1]) to decide SCRST pin to high or low.
N  * \hideinitializer
N  */
N#define SC_SET_RST_PIN(sc, u32State)\
N    do {\
N            while((sc)->PINCTL & SC_PINCTL_SYNC_Msk);\
N            if(u32State)\
N                (sc)->PINCTL |= SC_PINCTL_SCRST_Msk;\
N            else\
N                (sc)->PINCTL &= ~SC_PINCTL_SCRST_Msk;\
N    }while(0)
X#define SC_SET_RST_PIN(sc, u32State)    do {            while((sc)->PINCTL & SC_PINCTL_SYNC_Msk);            if(u32State)                (sc)->PINCTL |= SC_PINCTL_SCRST_Msk;            else                (sc)->PINCTL &= ~SC_PINCTL_SCRST_Msk;    }while(0)
N
N/**
N  * @brief Read one byte from smartcard module receive FIFO.
N  * @param[in] sc The pointer of smartcard module.
N  * @return One byte read from receive FIFO.
N  * @details By reading DAT register, the SC will return an 8-bit received data.
N  * \hideinitializer
N  */
N#define SC_READ(sc) ((char)((sc)->DAT))
N
N/**
N  * @brief Write one byte to smartcard module transmit FIFO.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u8Data Data to write to transmit FIFO.
N  * @return None
N  * @details By writing data to DAT register, the SC will send out an 8-bit data.
N  * \hideinitializer
N  */
N#define SC_WRITE(sc, u8Data) ((sc)->DAT = (u8Data))
N
N/**
N  * @brief This macro set smartcard stop bit length.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u32Len Stop bit length, ether 1 or 2.
N  * @return None
N  * @details Stop bit length must be 1 for T = 1 protocol and 2 for T = 0 protocol.
N  * \hideinitializer
N  */
N#define SC_SET_STOP_BIT_LEN(sc, u32Len) ((sc)->CTL = ((sc)->CTL & ~SC_CTL_NSB_Msk) | ((u32Len) == 1 ? SC_CTL_NSB_Msk : 0))
N
N/**
N  * @brief Enable/Disable Tx error retry, and set Tx error retry count.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u32Count The number of times of Tx error retry count, between 0~8. 0 means disable Tx error retry.
N  * @return None
N  * @details This macro enable/disable transmitter retry function when parity error has occurred, and set error retry count.
N  */
N__STATIC_INLINE void SC_SetTxRetry(SC_T *sc, uint32_t u32Count)
Xstatic __inline void SC_SetTxRetry(SC_T *sc, uint32_t u32Count)
N{
N    while((sc)->CTL & SC_CTL_SYNC_Msk);
X    while((sc)->CTL & (0x1ul << (30)));
N    if(u32Count == 0) {       // disable Tx error retry
N        (sc)->CTL &= ~(SC_CTL_TXRTY_Msk | SC_CTL_TXRTYEN_Msk);
X        (sc)->CTL &= ~((0x7ul << (20)) | (0x1ul << (23)));
N    } else {
N        (sc)->CTL = ((sc)->CTL & ~SC_CTL_TXRTY_Msk) | ((u32Count - 1) << SC_CTL_TXRTY_Pos) | SC_CTL_TXRTYEN_Msk;
X        (sc)->CTL = ((sc)->CTL & ~(0x7ul << (20))) | ((u32Count - 1) << (20)) | (0x1ul << (23));
N    }
N}
N
N/**
N  * @brief Enable/Disable Rx error retry, and set Rx error retry count.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u32Count The number of times of Rx error retry count, between 0~8. 0 means disable Rx error retry.
N  * @return None
N  * @details This macro enable/disable receiver retry function when parity error has occurred, and set error retry count.
N  */
N__STATIC_INLINE void  SC_SetRxRetry(SC_T *sc, uint32_t u32Count)
Xstatic __inline void  SC_SetRxRetry(SC_T *sc, uint32_t u32Count)
N{
N    while((sc)->CTL & SC_CTL_SYNC_Msk);
X    while((sc)->CTL & (0x1ul << (30)));
N    if(u32Count == 0) {       // disable Rx error retry
N        (sc)->CTL &= ~(SC_CTL_RXRTY_Msk | SC_CTL_RXRTYEN_Msk);
X        (sc)->CTL &= ~((0x7ul << (16)) | (0x1ul << (19)));
N    } else {
N        (sc)->CTL = ((sc)->CTL & ~SC_CTL_RXRTY_Msk) | ((u32Count - 1) << SC_CTL_RXRTY_Pos) | SC_CTL_RXRTYEN_Msk;
X        (sc)->CTL = ((sc)->CTL & ~(0x7ul << (16))) | ((u32Count - 1) << (16)) | (0x1ul << (19));
N    }
N}
N
N
Nuint32_t SC_IsCardInserted(SC_T *sc);
Nvoid SC_ClearFIFO(SC_T *sc);
Nvoid SC_Close(SC_T *sc);
Nvoid SC_Open(SC_T *sc, uint32_t u32CardDet, uint32_t u32PWR);
Nvoid SC_ResetReader(SC_T *sc);
Nvoid SC_SetBlockGuardTime(SC_T *sc, uint32_t u32BGT);
Nvoid SC_SetCharGuardTime(SC_T *sc, uint32_t u32CGT);
Nvoid SC_StopAllTimer(SC_T *sc);
Nvoid SC_StartTimer(SC_T *sc, uint32_t u32TimerNum, uint32_t u32Mode, uint32_t u32ETUCount);
Nvoid SC_StopTimer(SC_T *sc, uint32_t u32TimerNum);
N
N
N/*@}*/ /* end of group SC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group SC_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SC_H__
N
N/*** (C) COPYRIGHT 2013~2015 Nuvoton Technology Corp. ***/
N
L 17105 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N#include "scuart.h"
L 1 "..\..\..\..\Library\StdDriver\inc\scuart.h" 1
N/**************************************************************************//**
N * @file     sc.h
N * @version  V3.00
N * $Revision: 7 $
N * $Date: 15/08/11 10:26a $
N * @brief    M451 series Smartcard UART mode (SCUART) driver header file
N *
N * @note
N * Copyright (C) 2013~2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __SCUART_H__
N#define __SCUART_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup SCUART_Driver SCUART Driver
N  @{
N*/
N
N/** @addtogroup SCUART_EXPORTED_CONSTANTS SCUART Exported Constants
N  @{
N*/
N#define SCUART_CHAR_LEN_5     (0x3ul << SC_UARTCTL_WLS_Pos)  /*!< Set SCUART word length to 5 bits */
N#define SCUART_CHAR_LEN_6     (0x2ul << SC_UARTCTL_WLS_Pos)  /*!< Set SCUART word length to 6 bits */
N#define SCUART_CHAR_LEN_7     (0x1ul << SC_UARTCTL_WLS_Pos)  /*!< Set SCUART word length to 7 bits */
N#define SCUART_CHAR_LEN_8     (0)                            /*!< Set SCUART word length to 8 bits */
N
N#define SCUART_PARITY_NONE    (SC_UARTCTL_PBOFF_Msk)         /*!< Set SCUART transfer with no parity   */
N#define SCUART_PARITY_ODD     (SC_UARTCTL_OPE_Msk)           /*!< Set SCUART transfer with odd parity  */
N#define SCUART_PARITY_EVEN    (0)                            /*!< Set SCUART transfer with even parity */
N
N#define SCUART_STOP_BIT_1     (SC_CTL_NSB_Msk)                 /*!< Set SCUART transfer with one stop bit  */
N#define SCUART_STOP_BIT_2     (0)                               /*!< Set SCUART transfer with two stop bits */
N
N
N/*@}*/ /* end of group SCUART_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup SCUART_EXPORTED_FUNCTIONS SCUART Exported Functions
N  @{
N*/
N
N/* TX Macros */
N/**
N  * @brief Write Data to Tx data register.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u8Data Data byte to transmit.
N  * @return None
N  * @details By writing data to DAT register, the SC will send out an 8-bit data.
N  * \hideinitializer
N  */
N#define SCUART_WRITE(sc, u8Data) ((sc)-> DAT = (u8Data))
N
N/**
N  * @brief Get TX FIFO empty flag status from register.
N  * @param[in] sc The pointer of smartcard module.
N  * @return Transmit FIFO empty status.
N  * @retval 0 Transmit FIFO is not empty.
N  * @retval SC_STATUS_TXEMPTY_Msk Transmit FIFO is empty.
N  * @details When the last byte of TX buffer has been transferred to Transmitter Shift Register, hardware sets TXEMPTY bit (SC_STATUS[9]) high.
N  *          It will be cleared when writing data into DAT (SC_DAT[7:0]).
N  * \hideinitializer
N  */
N#define SCUART_GET_TX_EMPTY(sc) ((sc)->STATUS & SC_STATUS_TXEMPTY_Msk)
N
N/**
N  * @brief Get TX FIFO full flag status from register.
N  * @param[in] sc The pointer of smartcard module.
N  * @retval 0 Transmit FIFO is not full.
N  * @retval SC_STATUS_TXFULL_Msk Transmit FIFO is full.
N  * @details TXFULL(SC_STATUS[10]) is set when TX pointer is equal to 4, otherwise is cleared by hardware.
N  * \hideinitializer
N  */
N#define SCUART_GET_TX_FULL(sc) ((sc)->STATUS & SC_STATUS_TXFULL_Msk)
N
N/**
N  * @brief Wait specified smartcard port transmission complete.
N  * @param[in] sc The pointer of smartcard module.
N  * @return None
N  * @details TXACT (SC_STATUS[31]) is cleared automatically when TX transfer is finished or the last byte transmission has completed.
N  * @note This macro blocks until transmit complete.
N  * \hideinitializer
N  */
N#define SCUART_WAIT_TX_EMPTY(sc) while((sc)->STATUS & SC_STATUS_TXACT_Msk)
N
N/**
N  * @brief Check specified smartcard port transmit FIFO is full or not.
N  * @param[in] sc The pointer of smartcard module.
N  * @retval 0 Transmit FIFO is not full.
N  * @retval 1 Transmit FIFO is full.
N  * @details TXFULL(SC_STATUS[10]) indicates TX buffer full or not.
N  *          This is set when TX pointer is equal to 4, otherwise is cleared by hardware.
N  * \hideinitializer
N  */
N#define SCUART_IS_TX_FULL(sc) ((sc)->STATUS & SC_STATUS_TXFULL_Msk ? 1 : 0)
N
N/**
N  * @brief Check specified smartcard port transmission is over.
N  * @param[in] sc The pointer of smartcard module.
N  * @retval 0 Transmit is not complete.
N  * @retval 1 Transmit complete.
N  * @details TXACT (SC_STATUS[31]) is set by hardware when TX transfer is in active and the STOP bit of the last byte has been transmitted.
N  * \hideinitializer
N  */
N#define SCUART_IS_TX_EMPTY(sc) ((sc)->STATUS & SC_STATUS_TXACT_Msk ? 0 : 1)
N
N
N/* RX Macros */
N
N/**
N  * @brief Read Rx data register.
N  * @param[in] sc The pointer of smartcard module.
N  * @return The oldest data byte in RX FIFO.
N  * @details By reading DAT register, the SC will return an 8-bit received data.
N  * \hideinitializer
N  */
N#define SCUART_READ(sc) ((sc)->DAT)
N
N/**
N  * @brief Get RX FIFO empty flag status from register.
N  * @param[in] sc The pointer of smartcard module.
N  * @retval 0 Receive FIFO is not empty.
N  * @retval SC_STATUS_RXEMPTY_Msk Receive FIFO is empty.
N  * @details When the last byte of Rx buffer has been read by CPU, hardware sets RXEMPTY(SC_STATUS[1]) high.
N  *          It will be cleared when SC receives any new data.
N  * \hideinitializer
N  */
N#define SCUART_GET_RX_EMPTY(sc) ((sc)->STATUS & SC_STATUS_RXEMPTY_Msk)
N
N
N/**
N  * @brief Get RX FIFO full flag status from register.
N  * @param[in] sc The pointer of smartcard module.
N  * @retval 0 Receive FIFO is not full.
N  * @retval SC_STATUS_TXFULL_Msk Receive FIFO is full.
N  * @details RXFULLF(SC_STATUS[2]) is set when RX pointer is equal to 4, otherwise it is cleared by hardware.
N  * \hideinitializer
N  */
N#define SCUART_GET_RX_FULL(sc) ((sc)->STATUS & SC_STATUS_RXFULL_Msk)
N
N/**
N  * @brief Check if receive data number in FIFO reach FIFO trigger level or not.
N  * @param[in] sc The pointer of smartcard module.
N  * @retval 0 The number of bytes in receive FIFO is less than trigger level.
N  * @retval 1 The number of bytes in receive FIFO equals or larger than trigger level.
N  * @details RDAIF(SC_INTSTS[0]) is used for received data reaching trigger level RXTRGLV (SC_CTL[7:6]) interrupt status flag.
N  * @note If receive trigger level is \b not 1 byte, this macro return 0 does not necessary indicates there is no data in FIFO.
N  * \hideinitializer
N  */
N#define SCUART_IS_RX_READY(sc) ((sc)->INTSTS & SC_INTSTS_RDAIF_Msk ? 1 : 0)
N
N/**
N  * @brief Check specified smartcard port receive FIFO is full or not.
N  * @param[in] sc The pointer of smartcard module.
N  * @retval 0 Receive FIFO is not full.
N  * @retval 1 Receive FIFO is full.
N  * @details RXFULLF(SC_STATUS[2]) is set when RX pointer is equal to 4, otherwise it is cleared by hardware.
N  * \hideinitializer
N  */
N#define SCUART_IS_RX_FULL(sc) ((sc)->STATUS & SC_STATUS_RXFULL_Msk ? 1 : 0)
N
N/* Interrupt Macros */
N
N/**
N  * @brief Enable specified interrupts.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u32Mask Interrupt masks to enable, a combination of following bits.
N  *             - \ref SC_INTEN_RXTOIF_Msk
N  *             - \ref SC_INTEN_TERRIEN_Msk
N  *             - \ref SC_INTEN_TBEIEN_Msk
N  *             - \ref SC_INTEN_RDAIEN_Msk
N  * @return None
N  * @details The macro is used to enable receiver buffer time-out interrupt, transfer error interrupt,
N  *          transmit buffer empty interrupt or receive data reach trigger level interrupt.
N  * \hideinitializer
N  */
N#define SCUART_ENABLE_INT(sc, u32Mask) ((sc)->INTEN |= (u32Mask))
N
N/**
N  * @brief Disable specified interrupts.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u32Mask Interrupt masks to disable, a combination of following bits.
N  *             - \ref SC_INTEN_RXTOIF_Msk
N  *             - \ref SC_INTEN_TERRIEN_Msk
N  *             - \ref SC_INTEN_TBEIEN_Msk
N  *             - \ref SC_INTEN_RDAIEN_Msk
N  * @return None
N  * @details The macro is used to disable receiver buffer time-out interrupt, transfer error interrupt,
N  *          transmit buffer empty interrupt or receive data reach trigger level interrupt.
N  * \hideinitializer
N  */
N#define SCUART_DISABLE_INT(sc, u32Mask) ((sc)->INTEN &= ~(u32Mask))
N
N/**
N  * @brief Get specified interrupt flag/status.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u32Type Interrupt flag/status to check, could be one of following value:
N  *             - \ref SC_INTSTS_RBTOIF_Msk
N  *             - \ref SC_INTSTS_TERRIF_Msk
N  *             - \ref SC_INTSTS_TBEIF_Msk
N  *             - \ref SC_INTSTS_RDAIF_Msk
N  * @return The status of specified interrupt.
N  * @retval 0 Specified interrupt does not happened.
N  * @retval 1 Specified interrupt happened.
N  * @details The macro is used to get receiver buffer time-out interrupt status, transfer error interrupt status,
N  *          transmit buffer empty interrupt status or receive data reach interrupt status.
N  * \hideinitializer
N  */
N#define SCUART_GET_INT_FLAG(sc, u32Type) ((sc)->INTSTS & (u32Type) ? 1 : 0)
N
N/**
N  * @brief Clear specified interrupt flag/status.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u32Type Interrupt flag/status to clear, could be the combination of following values:
N  *             - \ref SC_INTSTS_RBTOIF_Msk
N  *             - \ref SC_INTSTS_TERRIF_Msk
N  *             - \ref SC_INTSTS_TBEIF_Msk
N  * @return None
N  * @details The macro is used to clear receiver buffer time-out interrupt flag, transfer error interrupt flag or
N  *          transmit buffer empty interrupt flag.
N  * \hideinitializer
N  */
N#define SCUART_CLR_INT_FLAG(sc, u32Type) ((sc)->INTSTS = (u32Type))
N
N/**
N  * @brief Get receive error flag/status.
N  * @param[in] sc The pointer of smartcard module.
N  * @return Current receive error status, could one of following errors:
N  * @retval SC_STATUS_PEF_Msk Parity error.
N  * @retval SC_STATUS_FEF_Msk Frame error.
N  * @retval SC_STATUS_BEF_Msk Break error.
N  * @details The macro is used to get receiver parity error status, receiver frame error status or
N  *          receiver break error status.
N  * \hideinitializer
N  */
N#define SCUART_GET_ERR_FLAG(sc) ((sc)->STATUS & (SC_STATUS_PEF_Msk | SC_STATUS_FEF_Msk | SC_STATUS_BEF_Msk))
N
N/**
N  * @brief Clear specified receive error flag/status.
N  * @param[in] sc The pointer of smartcard module.
N  * @param[in] u32Mask Receive error flag/status to clear, combination following values:
N  *             - \ref SC_STATUS_PEF_Msk
N  *             - \ref SC_STATUS_FEF_Msk
N  *             - \ref SC_STATUS_BEF_Msk
N  * @return None
N  * @details The macro is used to clear receiver parity error flag, receiver frame error flag or
N  *          receiver break error flag.
N  * \hideinitializer
N  */
N#define SCUART_CLR_ERR_FLAG(sc, u32Mask) ((sc)->STATUS = (u32Mask))
N
Nvoid SCUART_Close(SC_T* sc);
Nuint32_t SCUART_Open(SC_T* sc, uint32_t u32baudrate);
Nuint32_t SCUART_Read(SC_T* sc, uint8_t *pu8RxBuf, uint32_t u32ReadBytes);
Nuint32_t SCUART_SetLineConfig(SC_T* sc, uint32_t u32Baudrate, uint32_t u32DataWidth, uint32_t u32Parity, uint32_t  u32StopBits);
Nvoid SCUART_SetTimeoutCnt(SC_T* sc, uint32_t u32TOC);
Nvoid SCUART_Write(SC_T* sc, uint8_t *pu8TxBuf, uint32_t u32WriteBytes);
N
N/*@}*/ /* end of group SCUART_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group SCUART_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SCUART_H__
N
N/*** (C) COPYRIGHT 2013~2015 Nuvoton Technology Corp. ***/
L 17106 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N#include "acmp.h"
L 1 "..\..\..\..\Library\StdDriver\inc\acmp.h" 1
N/**************************************************************************//**
N * @file     ACMP.h
N * @version  V0.10
N * $Revision: 10 $
N * $Date: 15/08/11 10:26a $
N * @brief    M451 Series ACMP Driver Header File
N *
N * @note
N * Copyright (C) 2014~2015 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __ACMP_H__
N#define __ACMP_H__
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Include related headers                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#include "M451Series.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup ACMP_Driver ACMP Driver
N  @{
N*/
N
N
N/** @addtogroup ACMP_EXPORTED_CONSTANTS ACMP Exported Constants
N  @{
N*/
N
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ACMP_CTL constant definitions                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ACMP_CTL_FILTSEL_OFF         (0UL << 13) /*!< ACMP_CTL setting for filter function disabled. */
N#define ACMP_CTL_FILTSEL_1PCLK       (1UL << 13) /*!< ACMP_CTL setting for 1 PCLK filter count. */
N#define ACMP_CTL_FILTSEL_2PCLK       (2UL << 13) /*!< ACMP_CTL setting for 2 PCLK filter count. */
N#define ACMP_CTL_FILTSEL_4PCLK       (3UL << 13) /*!< ACMP_CTL setting for 4 PCLK filter count. */
N#define ACMP_CTL_FILTSEL_8PCLK       (4UL << 13) /*!< ACMP_CTL setting for 8 PCLK filter count. */
N#define ACMP_CTL_FILTSEL_16PCLK      (5UL << 13) /*!< ACMP_CTL setting for 16 PCLK filter count. */
N#define ACMP_CTL_FILTSEL_32PCLK      (6UL << 13) /*!< ACMP_CTL setting for 32 PCLK filter count. */
N#define ACMP_CTL_FILTSEL_64PCLK      (7UL << 13) /*!< ACMP_CTL setting for 64 PCLK filter count. */
N#define ACMP_CTL_INTPOL_RF           (0UL << 8)  /*!< ACMP_CTL setting for selecting rising edge and falling edge as interrupt condition. */
N#define ACMP_CTL_INTPOL_R            (1UL << 8)  /*!< ACMP_CTL setting for selecting rising edge as interrupt condition. */
N#define ACMP_CTL_INTPOL_F            (2UL << 8)  /*!< ACMP_CTL setting for selecting falling edge as interrupt condition. */
N#define ACMP_CTL_POSSEL_P0           (0UL << 6)  /*!< ACMP_CTL setting for selecting ACMPx_P0 pin as the source of ACMP V+. */
N#define ACMP_CTL_POSSEL_P1           (1UL << 6)  /*!< ACMP_CTL setting for selecting ACMPx_P1 pin as the source of ACMP V+. */
N#define ACMP_CTL_POSSEL_P2           (2UL << 6)  /*!< ACMP_CTL setting for selecting ACMPx_P2 pin as the source of ACMP V+. */
N#define ACMP_CTL_POSSEL_P3           (3UL << 6)  /*!< ACMP_CTL setting for selecting ACMPx_P3 pin as the source of ACMP V+. */
N#define ACMP_CTL_NEGSEL_PIN          (0UL << 4)  /*!< ACMP_CTL setting for selecting the voltage of ACMP negative input pin as the source of ACMP V-. */
N#define ACMP_CTL_NEGSEL_CRV          (1UL << 4)  /*!< ACMP_CTL setting for selecting internal comparator reference voltage as the source of ACMP V-. */
N#define ACMP_CTL_NEGSEL_VBG          (2UL << 4)  /*!< ACMP_CTL setting for selecting internal Band-gap voltage as the source of ACMP V-. */
N#define ACMP_CTL_NEGSEL_DAC          (3UL << 4)  /*!< ACMP_CTL setting for selecting DAC output voltage as the source of ACMP V-. */
N#define ACMP_CTL_HYSTERESIS_ENABLE   (1UL << 2)  /*!< ACMP_CTL setting for enabling the hysteresis function. */
N#define ACMP_CTL_HYSTERESIS_DISABLE  (0UL << 2)  /*!< ACMP_CTL setting for disabling the hysteresis function. */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ACMP_VREF constant definitions                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ACMP_VREF_CRVSSEL_VDDA       (0UL << 6)  /*!< ACMP_VREF setting for selecting analog supply voltage VDDA as the CRV source voltage */
N#define ACMP_VREF_CRVSSEL_INTVREF    (1UL << 6)  /*!< ACMP_VREF setting for selecting internal reference voltage as the CRV source voltage */
N
N
N/*@}*/ /* end of group ACMP_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup ACMP_EXPORTED_FUNCTIONS ACMP Exported Functions
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Macros and functions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N
N
N/**
N  * @brief This macro is used to enable output inverse function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will set ACMPOINV bit of ACMP_CTL register to enable output inverse function.
N  */
N#define ACMP_ENABLE_OUTPUT_INVERSE(acmp, u32ChNum) ((acmp)->CTL[(u32ChNum)%2] |= ACMP_CTL_ACMPOINV_Msk)
N
N/**
N  * @brief This macro is used to disable output inverse function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will clear ACMPOINV bit of ACMP_CTL register to disable output inverse function.
N  */
N#define ACMP_DISABLE_OUTPUT_INVERSE(acmp, u32ChNum) ((acmp)->CTL[(u32ChNum)%2] &= ~ACMP_CTL_ACMPOINV_Msk)
N
N/**
N  * @brief This macro is used to select ACMP negative input source
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @param[in] u32Src is comparator negative input selection. Including:
N  *                  - \ref ACMP_CTL_NEGSEL_PIN
N  *                  - \ref ACMP_CTL_NEGSEL_CRV
N  *                  - \ref ACMP_CTL_NEGSEL_VBG
N  *                  - \ref ACMP_CTL_NEGSEL_DAC
N  * @return None
N  * @details This macro will set NEGSEL (ACMP_CTL[5:4]) to determine the source of negative input.
N  */
N#define ACMP_SET_NEG_SRC(acmp, u32ChNum, u32Src) ((acmp)->CTL[(u32ChNum)%2] = ((acmp)->CTL[(u32ChNum)%2] & ~ACMP_CTL_NEGSEL_Msk) | (u32Src))
N
N/**
N  * @brief This macro is used to enable hysteresis function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will set HYSEN bit of ACMP_CTL register to enable hysteresis function.
N  */
N#define ACMP_ENABLE_HYSTERESIS(acmp, u32ChNum) ((acmp)->CTL[(u32ChNum)%2] |= ACMP_CTL_HYSEN_Msk)
N
N/**
N  * @brief This macro is used to disable hysteresis function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will clear HYSEN bit of ACMP_CTL register to disable hysteresis function.
N  */
N#define ACMP_DISABLE_HYSTERESIS(acmp, u32ChNum) ((acmp)->CTL[(u32ChNum)%2] &= ~ACMP_CTL_HYSEN_Msk)
N
N/**
N  * @brief This macro is used to enable interrupt
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will set ACMPIE bit of ACMP_CTL register to enable interrupt function.
N  *          If wake-up function is enabled, the wake-up interrupt will be enabled as well.
N  */
N#define ACMP_ENABLE_INT(acmp, u32ChNum) ((acmp)->CTL[(u32ChNum)%2] |= ACMP_CTL_ACMPIE_Msk)
N
N/**
N  * @brief This macro is used to disable interrupt
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will clear ACMPIE bit of ACMP_CTL register to disable interrupt function.
N  */
N#define ACMP_DISABLE_INT(acmp, u32ChNum) ((acmp)->CTL[(u32ChNum)%2] &= ~ACMP_CTL_ACMPIE_Msk)
N
N/**
N  * @brief This macro is used to enable ACMP
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will set ACMPEN bit of ACMP_CTL register to enable analog comparator.
N  */
N#define ACMP_ENABLE(acmp, u32ChNum) ((acmp)->CTL[(u32ChNum)%2] |= ACMP_CTL_ACMPEN_Msk)
N
N/**
N  * @brief This macro is used to disable ACMP
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will clear ACMPEN bit of ACMP_CTL register to disable analog comparator.
N  */
N#define ACMP_DISABLE(acmp, u32ChNum) ((acmp)->CTL[(u32ChNum)%2] &= ~ACMP_CTL_ACMPEN_Msk)
N
N/**
N  * @brief This macro is used to get ACMP output value
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return  ACMP output value
N  * @details This macro will return the ACMP output value.
N  */
N#define ACMP_GET_OUTPUT(acmp, u32ChNum) (((acmp)->STATUS & (ACMP_STATUS_ACMPO0_Msk<<((u32ChNum)%2)))?1:0)
N
N/**
N  * @brief This macro is used to get ACMP interrupt flag
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return   ACMP interrupt occurred (1) or not (0)
N  * @details This macro will return the ACMP interrupt flag.
N  */
N#define ACMP_GET_INT_FLAG(acmp, u32ChNum) (((acmp)->STATUS & (ACMP_STATUS_ACMPIF0_Msk<<((u32ChNum)%2)))?1:0)
N
N/**
N  * @brief This macro is used to clear ACMP interrupt flag
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return   None
N  * @details This macro will write 1 to ACMPIFn bit of ACMP_STATUS register to clear interrupt flag.
N  */
N#define ACMP_CLR_INT_FLAG(acmp, u32ChNum) ((acmp)->STATUS = (ACMP_STATUS_ACMPIF0_Msk<<((u32ChNum)%2)))
N
N/**
N  * @brief This macro is used to clear ACMP wake-up interrupt flag
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return   None
N  * @details This macro will write 1 to WKIFn bit of ACMP_STATUS register to clear interrupt flag.
N  */
N#define ACMP_CLR_WAKEUP_INT_FLAG(acmp, u32ChNum) ((acmp)->STATUS = (ACMP_STATUS_WKIF0_Msk<<((u32ChNum)%2)))
N
N/**
N  * @brief This macro is used to enable ACMP wake-up function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will set WKEN (ACMP_CTL[16]) to enable ACMP wake-up function.
N  */
N#define ACMP_ENABLE_WAKEUP(acmp, u32ChNum) ((acmp)->CTL[(u32ChNum)%2] |= ACMP_CTL_WKEN_Msk)
N
N/**
N  * @brief This macro is used to disable ACMP wake-up function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will clear WKEN (ACMP_CTL[16]) to disable ACMP wake-up function.
N  */
N#define ACMP_DISABLE_WAKEUP(acmp, u32ChNum) ((acmp)->CTL[(u32ChNum)%2] &= ~ACMP_CTL_WKEN_Msk)
N
N/**
N  * @brief This macro is used to select ACMP positive input pin
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @param[in] u32Pin Comparator positive pin selection. Including:
N  *                  - \ref ACMP_CTL_POSSEL_P0
N  *                  - \ref ACMP_CTL_POSSEL_P1
N  *                  - \ref ACMP_CTL_POSSEL_P2
N  *                  - \ref ACMP_CTL_POSSEL_P3
N  * @return None
N  * @details This macro will set POSSEL (ACMP_CTL[7:6]) to determine the comparator positive input pin.
N  */
N#define ACMP_SELECT_P(acmp, u32ChNum, u32Pin) ((acmp)->CTL[(u32ChNum)%2] = ((acmp)->CTL[(u32ChNum)%2] & ~ACMP_CTL_POSSEL_Msk) | (u32Pin))
N
N/**
N  * @brief This macro is used to enable ACMP filter function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will set OUTSEL (ACMP_CTL[12]) to enable output filter function.
N  */
N#define ACMP_ENABLE_FILTER(acmp, u32ChNum) ((acmp)->CTL[(u32ChNum)%2] |= ACMP_CTL_OUTSEL_Msk)
N
N/**
N  * @brief This macro is used to disable ACMP filter function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will clear OUTSEL (ACMP_CTL[12]) to disable output filter function.
N  */
N#define ACMP_DISABLE_FILTER(acmp, u32ChNum) ((acmp)->CTL[(u32ChNum)%2] &= ~ACMP_CTL_OUTSEL_Msk)
N
N/**
N  * @brief This macro is used to set ACMP filter function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @param[in] u32Cnt is comparator filter count setting.
N  *                  - \ref ACMP_CTL_FILTSEL_OFF
N  *                  - \ref ACMP_CTL_FILTSEL_1PCLK
N  *                  - \ref ACMP_CTL_FILTSEL_2PCLK
N  *                  - \ref ACMP_CTL_FILTSEL_4PCLK
N  *                  - \ref ACMP_CTL_FILTSEL_8PCLK
N  *                  - \ref ACMP_CTL_FILTSEL_16PCLK
N  *                  - \ref ACMP_CTL_FILTSEL_32PCLK
N  *                  - \ref ACMP_CTL_FILTSEL_64PCLK
N  * @return None
N  * @details When ACMP output filter function is enabled, the output sampling count is determined by FILTSEL (ACMP_CTL[15:13]).
N  */
N#define ACMP_SET_FILTER(acmp, u32ChNum, u32Cnt) ((acmp)->CTL[(u32ChNum)%2] = ((acmp)->CTL[(u32ChNum)%2] & ~ACMP_CTL_FILTSEL_Msk) | (u32Cnt))
N
N/**
N  * @brief This macro is used to select comparator reference voltage
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32Level  The comparator reference voltage setting.
N  *             The formula is:
N  *                       comparator reference voltage = CRV source voltage x (1/6 + u32Level/24)
N  *             The range of u32Level is 0 ~ 15.
N  * @return   None
N  * @details  When CRV is selected as ACMP negative input source, the CRV level is determined by CRVCTL (ACMP_VREF[3:0]).
N  */
N#define ACMP_CRV_SEL(acmp, u32Level) ((acmp)->VREF = ((acmp)->VREF & ~ACMP_VREF_CRVCTL_Msk) | ((u32Level)<<ACMP_VREF_CRVCTL_Pos))
N
N/**
N  * @brief This macro is used to select the source of CRV
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32Src is the source of CRV. Including:
N  *                  - \ref ACMP_VREF_CRVSSEL_VDDA
N  *                  - \ref ACMP_VREF_CRVSSEL_INTVREF
N  * @return None
N  * @details The source of CRV can be VDDA or internal reference voltage. The internal reference voltage level is determined by SYS_VREFCTL register.
N  */
N#define ACMP_SELECT_CRV_SRC(acmp, u32Src) ((acmp)->VREF = ((acmp)->VREF & ~ACMP_VREF_CRVSSEL_Msk) | (u32Src))
N
N/**
N  * @brief This macro is used to select ACMP interrupt condition
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @param[in] u32Cond Comparator interrupt condition selection. Including:
N  *                  - \ref ACMP_CTL_INTPOL_RF
N  *                  - \ref ACMP_CTL_INTPOL_R
N  *                  - \ref ACMP_CTL_INTPOL_F
N  * @return None
N  * @details The ACMP output interrupt condition can be rising edge, falling edge or any edge.
N  */
N#define ACMP_SELECT_INT_COND(acmp, u32ChNum, u32Cond) ((acmp)->CTL[(u32ChNum)%2] = ((acmp)->CTL[(u32ChNum)%2] & ~ACMP_CTL_INTPOL_Msk) | (u32Cond))
N
N
N
N/* Function prototype declaration */
Nvoid ACMP_Open(ACMP_T *, uint32_t u32ChNum, uint32_t u32NegSrc, uint32_t u32HysteresisEn);
Nvoid ACMP_Close(ACMP_T *, uint32_t u32ChNum);
N
N
N
N/*@}*/ /* end of group ACMP_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ACMP_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif //__ACMP_H__
N
N/*** (C) COPYRIGHT 2014~2015 Nuvoton Technology Corp. ***/
L 17107 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N#include "eadc.h"
L 1 "..\..\..\..\Library\StdDriver\inc\eadc.h" 1
N/******************************************************************************
N * @file     eadc.h
N * @version  V0.10
N * $Revision: 18 $
N * $Date: 15/08/11 10:26a $
N * @brief    M451 series EADC driver header file
N *
N * @note
N * Copyright (C) 2013~2015 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef __EADC_H__
N#define __EADC_H__
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Include related headers                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#include "M451Series.h"
N
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup EADC_Driver EADC Driver
N  @{
N*/
N
N/** @addtogroup EADC_EXPORTED_CONSTANTS EADC Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  EADC_CTL Constant Definitions                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EADC_CTL_DIFFEN_SINGLE_END          (0UL<<EADC_CTL_DIFFEN_Pos)   /*!< Single-end input mode      */
N#define EADC_CTL_DIFFEN_DIFFERENTIAL        (1UL<<EADC_CTL_DIFFEN_Pos)   /*!< Differential input mode    */
N
N#define EADC_CTL_DMOF_STRAIGHT_BINARY       (0UL<<EADC_CTL_DMOF_Pos)     /*!< Select the straight binary format as the output format of the conversion result   */
N#define EADC_CTL_DMOF_TWOS_COMPLEMENT       (1UL<<EADC_CTL_DMOF_Pos)     /*!< Select the 2's complement format as the output format of the conversion result    */
N
N#define EADC_CTL_SMPTSEL1                   (0UL<<EADC_CTL_SMPTSEL_Pos)   /*!< 1 ADC clock sampling time */
N#define EADC_CTL_SMPTSEL2                   (1UL<<EADC_CTL_SMPTSEL_Pos)   /*!< 2 ADC clock sampling time */
N#define EADC_CTL_SMPTSEL3                   (2UL<<EADC_CTL_SMPTSEL_Pos)   /*!< 3 ADC clock sampling time */
N#define EADC_CTL_SMPTSEL4                   (3UL<<EADC_CTL_SMPTSEL_Pos)   /*!< 4 ADC clock sampling time */
N#define EADC_CTL_SMPTSEL5                   (4UL<<EADC_CTL_SMPTSEL_Pos)   /*!< 5 ADC clock sampling time */
N#define EADC_CTL_SMPTSEL6                   (5UL<<EADC_CTL_SMPTSEL_Pos)   /*!< 6 ADC clock sampling time */
N#define EADC_CTL_SMPTSEL7                   (6UL<<EADC_CTL_SMPTSEL_Pos)   /*!< 7 ADC clock sampling time */
N#define EADC_CTL_SMPTSEL8                   (7UL<<EADC_CTL_SMPTSEL_Pos)   /*!< 8 ADC clock sampling time */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* EADC_SCTL Constant Definitions                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EADC_SCTL_CHSEL(x)                  ((x) << EADC_SCTL_CHSEL_Pos)       /*!< A/D sample module channel selection */
N#define EADC_SCTL_TRGDLYDIV(x)              ((x) << EADC_SCTL_TRGDLYDIV_Pos)   /*!< A/D sample module start of conversion trigger delay clock divider selection */
N#define EADC_SCTL_TRGDLYCNT(x)              ((x) << EADC_SCTL_TRGDLYCNT_Pos)   /*!< A/D sample module start of conversion trigger delay time */
N
N#define EADC_SOFTWARE_TRIGGER               (0UL<<EADC_SCTL_TRGSEL_Pos)      /*!< Software trigger */
N#define EADC_FALLING_EDGE_TRIGGER           (EADC_SCTL_EXTFEN_Msk | (1UL<<EADC_SCTL_TRGSEL_Pos))       /*!< STADC pin falling edge trigger */
N#define EADC_RISING_EDGE_TRIGGER            (EADC_SCTL_EXTREN_Msk | (1UL<<EADC_SCTL_TRGSEL_Pos))       /*!< STADC pin rising edge trigger */
N#define EADC_FALLING_RISING_EDGE_TRIGGER    (EADC_SCTL_EXTFEN_Msk | EADC_SCTL_EXTREN_Msk | (1UL<<EADC_SCTL_TRGSEL_Pos)) /*!< STADC pin both falling and rising edge trigger */
N#define EADC_ADINT0_TRIGGER                 (2UL<<EADC_SCTL_TRGSEL_Pos)      /*!< ADC ADINT0 interrupt EOC pulse trigger */
N#define EADC_ADINT1_TRIGGER                 (3UL<<EADC_SCTL_TRGSEL_Pos)      /*!< ADC ADINT1 interrupt EOC pulse trigger */
N#define EADC_TIMER0_TRIGGER                 (4UL<<EADC_SCTL_TRGSEL_Pos)      /*!< Timer0 overflow pulse trigger */
N#define EADC_TIMER1_TRIGGER                 (5UL<<EADC_SCTL_TRGSEL_Pos)      /*!< Timer1 overflow pulse trigger */
N#define EADC_TIMER2_TRIGGER                 (6UL<<EADC_SCTL_TRGSEL_Pos)      /*!< Timer2 overflow pulse trigger */
N#define EADC_TIMER3_TRIGGER                 (7UL<<EADC_SCTL_TRGSEL_Pos)      /*!< Timer3 overflow pulse trigger */
N#define EADC_PWM0TG0_TRIGGER                (8UL<<EADC_SCTL_TRGSEL_Pos)      /*!< PWM0TG0 trigger */
N#define EADC_PWM0TG1_TRIGGER                (9UL<<EADC_SCTL_TRGSEL_Pos)      /*!< PWM0TG1 trigger */
N#define EADC_PWM0TG2_TRIGGER                (0xAUL<<EADC_SCTL_TRGSEL_Pos)    /*!< PWM0TG2 trigger */
N#define EADC_PWM0TG3_TRIGGER                (0xBUL<<EADC_SCTL_TRGSEL_Pos)    /*!< PWM0TG3 trigger */
N#define EADC_PWM0TG4_TRIGGER                (0xCUL<<EADC_SCTL_TRGSEL_Pos)    /*!< PWM0TG4 trigger */
N#define EADC_PWM0TG5_TRIGGER                (0xDUL<<EADC_SCTL_TRGSEL_Pos)    /*!< PWM0TG5 trigger */
N#define EADC_PWM1TG0_TRIGGER                (0xEUL<<EADC_SCTL_TRGSEL_Pos)    /*!< PWM1TG0 trigger */
N#define EADC_PWM1TG1_TRIGGER                (0xFUL<<EADC_SCTL_TRGSEL_Pos)    /*!< PWM1TG1 trigger */
N#define EADC_PWM1TG2_TRIGGER                (0x10UL<<EADC_SCTL_TRGSEL_Pos)   /*!< PWM1TG2 trigger */
N#define EADC_PWM1TG3_TRIGGER                (0x11UL<<EADC_SCTL_TRGSEL_Pos)   /*!< PWM1TG3 trigger */
N#define EADC_PWM1TG4_TRIGGER                (0x12UL<<EADC_SCTL_TRGSEL_Pos)   /*!< PWM1TG4 trigger */
N#define EADC_PWM1TG5_TRIGGER                (0x13UL<<EADC_SCTL_TRGSEL_Pos)   /*!< PWM1TG5 trigger */
N
N#define EADC_SCTL_TRGDLYDIV_DIVIDER_1       (0<<EADC_SCTL_TRGDLYDIV_Pos)           /*!< Trigger delay clock frequency is ADC_CLK/1 */
N#define EADC_SCTL_TRGDLYDIV_DIVIDER_2       (0x1UL<<EADC_SCTL_TRGDLYDIV_Pos)       /*!< Trigger delay clock frequency is ADC_CLK/2 */
N#define EADC_SCTL_TRGDLYDIV_DIVIDER_4       (0x2UL<<EADC_SCTL_TRGDLYDIV_Pos)       /*!< Trigger delay clock frequency is ADC_CLK/4 */
N#define EADC_SCTL_TRGDLYDIV_DIVIDER_16      (0x3UL<<EADC_SCTL_TRGDLYDIV_Pos)       /*!< Trigger delay clock frequency is ADC_CLK/16 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* EADC_CMP Constant Definitions                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EADC_CMP_CMPCOND_LESS_THAN          (0UL<<EADC_CMP_CMPCOND_Pos)   /*!< The compare condition is "less than" */
N#define EADC_CMP_CMPCOND_GREATER_OR_EQUAL   (1UL<<EADC_CMP_CMPCOND_Pos)   /*!< The compare condition is "greater than or equal to" */
N#define EADC_CMP_CMPWEN_ENABLE              (EADC_CMP_CMPWEN_Msk)    /*!< Compare window mode enable */
N#define EADC_CMP_CMPWEN_DISABLE             (~EADC_CMP_CMPWEN_Msk)   /*!< Compare window mode disable */
N#define EADC_CMP_ADCMPIE_ENABLE             (EADC_CMP_ADCMPIE_Msk)   /*!< A/D result compare interrupt enable */
N#define EADC_CMP_ADCMPIE_DISABLE            (~EADC_CMP_ADCMPIE_Msk)  /*!< A/D result compare interrupt disable */
N
N/*@}*/ /* end of group EADC_EXPORTED_CONSTANTS */
N
N/** @addtogroup EADC_EXPORTED_FUNCTIONS EADC Exported Functions
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  EADC Macro Definitions                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/**
N  * @brief A/D Converter Control Circuits Reset.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @return None
N  * @details ADCRST bit (EADC_CT[1]) remains 1 during ADC reset, when ADC reset end, the ADCRST bit is automatically cleared to 0.
N  */
N#define EADC_CONV_RESET(eadc) ((eadc)->CTL |= EADC_CTL_ADRST_Msk)
N
N/**
N  * @brief Enable PDMA transfer.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @return None
N  * @details When A/D conversion is completed, the converted data is loaded into EADC_DATn (n: 0 ~ 18) register,
N  *         user can enable this bit to generate a PDMA data transfer request.
N  * @note When set PDMAEN bit (EADC_CTL[11]), user must set ADINTENn (EADC_CTL[5:2], n=0~3) = 0 to disable interrupt.
N  */
N#define EADC_ENABLE_PDMA(eadc) ((eadc)->CTL |= EADC_CTL_PDMAEN_Msk)
N
N/**
N  * @brief Disable PDMA transfer.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @return None
N  * @details This macro is used to disable PDMA transfer.
N  */
N#define EADC_DISABLE_PDMA(eadc) ((eadc)->CTL &= (~EADC_CTL_PDMAEN_Msk))
N
N/**
N  * @brief Enable double buffer mode.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32ModuleNum Decides the sample module number, valid value are from 0 to 3.
N  * @return None
N  * @details The ADC controller supports a double buffer mode in sample module 0~3.
N  *         If user enable DBMEN (EADC_SCTLn[23], n=0~3), the double buffer mode will enable.
N  */
N#define EADC_ENABLE_DOUBLE_BUFFER(eadc, u32ModuleNum) ((eadc)->SCTL[(u32ModuleNum)] |= EADC_SCTL_DBMEN_Msk)
N
N/**
N  * @brief Disable double buffer mode.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32ModuleNum Decides the sample module number, valid value are from 0 to 3.
N  * @return None
N  * @details Sample has one sample result register.
N  */
N#define EADC_DISABLE_DOUBLE_BUFFER(eadc, u32ModuleNum) ((eadc)->SCTL[(u32ModuleNum)] &= ~EADC_SCTL_DBMEN_Msk)
N
N/**
N  * @brief Set ADIFn at A/D end of conversion.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32ModuleNum Decides the sample module number, valid value are from 0 to 15.
N  * @return None
N  * @details The A/D converter generates ADIFn (EADC_STATUS2[3:0], n=0~3) at the start of conversion.
N  */
N#define EADC_ENABLE_INT_POSITION(eadc, u32ModuleNum) ((eadc)->SCTL[(u32ModuleNum)] |= EADC_SCTL_INTPOS_Msk)
N
N/**
N  * @brief Set ADIFn at A/D start of conversion.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32ModuleNum Decides the sample module number, valid value are from 0 to 15.
N  * @return None
N  * @details The A/D converter generates ADIFn (EADC_STATUS2[3:0], n=0~3) at the end of conversion.
N  */
N#define EADC_DISABLE_INT_POSITION(eadc, u32ModuleNum) ((eadc)->SCTL[(u32ModuleNum)] &= ~EADC_SCTL_INTPOS_Msk)
N
N/**
N  * @brief Enable the interrupt.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32Mask Decides the combination of interrupt status bits. Each bit corresponds to a interrupt status.
N  *                    This parameter decides which interrupts will be enabled. Bit 0 is ADCIEN0, bit 1 is ADCIEN1..., bit 3 is ADCIEN3.
N  * @return None
N  * @details The A/D converter generates a conversion end ADIFn (EADC_STATUS2[n]) upon the end of specific sample module A/D conversion.
N  *         If ADCIENn bit (EADC_CTL[n+2]) is set then conversion end interrupt request ADINTn is generated (n=0~3).
N  */
N#define EADC_ENABLE_INT(eadc, u32Mask) ((eadc)->CTL |= ((u32Mask) << EADC_CTL_ADCIEN0_Pos))
N
N/**
N  * @brief Disable the interrupt.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32Mask Decides the combination of interrupt status bits. Each bit corresponds to a interrupt status.
N  *                    This parameter decides which interrupts will be disabled. Bit 0 is ADCIEN0, bit 1 is ADCIEN1..., bit 3 is ADCIEN3.
N  * @return None
N  * @details Specific sample module A/D ADINT0 interrupt function Disabled.
N  */
N#define EADC_DISABLE_INT(eadc, u32Mask) ((eadc)->CTL &= ~((u32Mask) << EADC_CTL_ADCIEN0_Pos))
N
N/**
N  * @brief Enable the sample module interrupt.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32IntSel Decides which interrupt source will be used, valid value are from 0 to 3.
N  * @param[in] u32ModuleMask the combination of sample module interrupt status bits. Each bit corresponds to a sample module interrupt status.
N  *                          This parameter decides which sample module interrupts will be enabled, valid range are between 1~0x7FFFF.
N  * @return None
N  * @details There are 4 ADC interrupts ADINT0~3, and each of these interrupts has its own interrupt vector address.
N  */
N#define EADC_ENABLE_SAMPLE_MODULE_INT(eadc, u32IntSel, u32ModuleMask) ((eadc)->INTSRC[(u32IntSel)] |= (u32ModuleMask))
N
N/**
N  * @brief Disable the sample module interrupt.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32IntSel Decides which interrupt source will be used, valid value are from 0 to 3.
N  * @param[in] u32ModuleMask the combination of sample module interrupt status bits. Each bit corresponds to a sample module interrupt status.
N  *                          This parameter decides which sample module interrupts will be disabled, valid range are between 1~0x7FFFF.
N  * @return None
N  * @details There are 4 ADC interrupts ADINT0~3, and each of these interrupts has its own interrupt vector address.
N  */
N#define EADC_DISABLE_SAMPLE_MODULE_INT(eadc, u32IntSel, u32ModuleMask) ((eadc)->INTSRC[(u32IntSel)] &= ~(u32ModuleMask))
N
N/**
N  * @brief Set the input mode output format.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32Format Decides the output format. Valid values are:
N  *                       - \ref EADC_CTL_DMOF_STRAIGHT_BINARY      :Select the straight binary format as the output format of the conversion result.
N  *                       - \ref EADC_CTL_DMOF_TWOS_COMPLEMENT      :Select the 2's complement format as the output format of the conversion result.
N  * @return None
N  * @details The macro is used to set A/D input mode output format.
N  */
N#define EADC_SET_DMOF(eadc, u32Format) ((eadc)->CTL = ((eadc)->CTL & ~EADC_CTL_DMOF_Msk) | (u32Format))
N
N/**
N  * @brief Start the A/D conversion.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32ModuleMask The combination of sample module. Each bit corresponds to a sample module.
N  *                         This parameter decides which sample module will be conversion, valid range are between 1~0x7FFFF.
N  *                         Bit 0 is sample module 0, bit 1 is sample module 1..., bit 18 is sample module 18.
N  * @return None
N  * @details After write EADC_SWTRG register to start ADC conversion, the EADC_PENDSTS register will show which SAMPLE will conversion.
N  */
N#define EADC_START_CONV(eadc, u32ModuleMask) ((eadc)->SWTRG = (u32ModuleMask))
N
N/**
N  * @brief Cancel the conversion for sample module.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32ModuleMask The combination of sample module. Each bit corresponds to a sample module.
N  *                         This parameter decides which sample module will stop the conversion, valid range are between 1~0x7FFFF.
N  *                         Bit 0 is sample module 0, bit 1 is sample module 1..., bit 18 is sample module18.
N  * @return None
N  * @details If user want to disable the conversion of the sample module, user can write EADC_PENDSTS register to clear it.
N  */
N#define EADC_STOP_CONV(eadc, u32ModuleMask) ((eadc)->PENDSTS = (u32ModuleMask))
N
N/**
N  * @brief Get the conversion pending flag.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @return Return the conversion pending sample module.
N  * @details This STPFn(EADC_PENDSTS[18:0]) bit remains 1 during pending state, when the respective ADC conversion is end,
N  *         the STPFn (n=0~18) bit is automatically cleared to 0.
N  */
N#define EADC_GET_PENDING_CONV(eadc) ((eadc)->PENDSTS)
N
N/**
N  * @brief Get the conversion data of the user-specified sample module.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32ModuleNum Decides the sample module number, valid value are from 0 to 18.
N  * @return Return the conversion data of the user-specified sample module.
N  * @details This macro is used to read RESULT bit (EADC_DATn[15:0], n=0~18) field to get conversion data.
N  */
N#define EADC_GET_CONV_DATA(eadc, u32ModuleNum) ((eadc)->DAT[(u32ModuleNum)] & EADC_DAT_RESULT_Msk)
N
N/**
N  * @brief Get the data overrun flag of the user-specified sample module.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32ModuleMask The combination of data overrun status bits. Each bit corresponds to a data overrun status, valid range are between 1~0x7FFFF.
N  * @return Return the data overrun flag of the user-specified sample module.
N  * @details This macro is used to read OV bit (EADC_STATUS0[31:16], EADC_STATUS1[18:16]) field to get data overrun status.
N  */
N#define EADC_GET_DATA_OVERRUN_FLAG(eadc, u32ModuleMask) ((((eadc)->STATUS0 >> EADC_STATUS0_OV_Pos) | ((eadc)->STATUS1 & EADC_STATUS1_OV_Msk)) & (u32ModuleMask))
N
N/**
N  * @brief Get the data valid flag of the user-specified sample module.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32ModuleMask The combination of data valid status bits. Each bit corresponds to a data valid status, valid range are between 1~0x7FFFF.
N  * @return Return the data valid flag of the user-specified sample module.
N  * @details This macro is used to read VALID bit (EADC_STATUS0[15:0], EADC_STATUS1[1:0]) field to get data overrun status.
N  */
N#define EADC_GET_DATA_VALID_FLAG(eadc, u32ModuleMask) ((((eadc)->STATUS0 & EADC_STATUS0_VALID_Msk) | (((eadc)->STATUS1 & EADC_STATUS1_VALID_Msk) << 16)) & (u32ModuleMask))
N
N/**
N  * @brief Get the double data of the user-specified sample module.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32ModuleNum Decides the sample module number, valid value are from 0 to 18.
N  * @return Return the double data of the user-specified sample module.
N  * @details This macro is used to read RESULT bit (EADC_DDATn[15:0], n=0~3) field to get conversion data.
N  */
N#define EADC_GET_DOUBLE_DATA(eadc, u32ModuleNum) ((eadc)->DDAT[(u32ModuleNum)] & EADC_DDAT_RESULT_Msk)
N
N/**
N  * @brief Get the user-specified interrupt flags.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32Mask The combination of interrupt status bits. Each bit corresponds to a interrupt status.
N  *                    Bit 0 is ADIF0, bit 1 is ADIF1..., bit 3 is ADIF3.
N  *                    Bit 4 is ADCMPF0, bit 5 is ADCMPF1..., bit 7 is ADCMPF3.
N  * @return Return the user-specified interrupt flags.
N  * @details This macro is used to get the user-specified interrupt flags.
N  */
N#define EADC_GET_INT_FLAG(eadc, u32Mask) ((eadc)->STATUS2 & (u32Mask))
N
N/**
N  * @brief Get the user-specified sample module overrun flags.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32ModuleMask The combination of sample module overrun status bits. Each bit corresponds to a sample module overrun status, valid range are between 1~0x7FFFF.
N  * @return Return the user-specified sample module overrun flags.
N  * @details This macro is used to get the user-specified sample module overrun flags.
N  */
N#define EADC_GET_SAMPLE_MODULE_OV_FLAG(eadc, u32ModuleMask) ((eadc)->OVSTS & (u32ModuleMask))
N
N/**
N  * @brief Clear the selected interrupt status bits.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32Mask The combination of compare interrupt status bits. Each bit corresponds to a compare interrupt status.
N  *                    Bit 0 is ADIF0, bit 1 is ADIF1..., bit 3 is ADIF3.
N  *                    Bit 4 is ADCMPF0, bit 5 is ADCMPF1..., bit 7 is ADCMPF3.
N  * @return None
N  * @details This macro is used to clear clear the selected interrupt status bits.
N  */
N#define EADC_CLR_INT_FLAG(eadc, u32Mask) ((eadc)->STATUS2 = (u32Mask))
N
N/**
N  * @brief Clear the selected sample module overrun status bits.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32ModuleMask The combination of sample module overrun status bits. Each bit corresponds to a sample module overrun status.
N  *                      Bit 0 is SPOVF0, bit 1 is SPOVF1..., bit 18 is SPOVF18.
N  * @return None
N  * @details This macro is used to clear the selected sample module overrun status bits.
N  */
N#define EADC_CLR_SAMPLE_MODULE_OV_FLAG(eadc, u32ModuleMask) ((eadc)->OVSTS = (u32ModuleMask))
N
N/**
N  * @brief Check all sample module A/D result data register overrun flags.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @retval 0 None of sample module data register overrun flag is set to 1.
N  * @retval 1 Any one of sample module data register overrun flag is set to 1.
N  * @details The AOV bit (EADC_STATUS2[27]) will keep 1 when any one of sample module data register overrun flag OVn (EADC_DATn[16]) is set to 1.
N  */
N#define EADC_IS_DATA_OV(eadc) (((eadc)->STATUS2 & EADC_STATUS2_AOV_Msk) >> EADC_STATUS2_AOV_Pos)
N
N/**
N  * @brief Check all sample module A/D result data register valid flags.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @retval 0 None of sample module data register valid flag is set to 1.
N  * @retval 1 Any one of sample module data register valid flag is set to 1.
N  * @details The AVALID bit (EADC_STATUS2[26]) will keep 1 when any one of sample module data register valid flag VALIDn (EADC_DATn[17]) is set to 1.
N  */
N#define EADC_IS_DATA_VALID(eadc) (((eadc)->STATUS2 & EADC_STATUS2_AVALID_Msk) >> EADC_STATUS2_AVALID_Pos)
N
N/**
N  * @brief Check all A/D sample module start of conversion overrun flags.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @retval 0 None of sample module event overrun flag is set to 1.
N  * @retval 1 Any one of sample module event overrun flag is set to 1.
N  * @details The STOVF bit (EADC_STATUS2[25]) will keep 1 when any one of sample module event overrun flag SPOVFn (EADC_OVSTS[n]) is set to 1.
N  */
N#define EADC_IS_SAMPLE_MODULE_OV(eadc) (((eadc)->STATUS2 & EADC_STATUS2_STOVF_Msk) >> EADC_STATUS2_STOVF_Pos)
N
N/**
N  * @brief Check all A/D interrupt flag overrun bits.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @retval 0 None of ADINT interrupt flag is overwritten to 1.
N  * @retval 1 Any one of ADINT interrupt flag is overwritten to 1.
N  * @details The ADOVIF bit (EADC_STATUS2[24]) will keep 1 when any one of ADINT interrupt flag ADOVIFn (EADC_STATUS2[11:8]) is overwritten to 1.
N  */
N#define EADC_IS_INT_FLAG_OV(eadc) (((eadc)->STATUS2 & EADC_STATUS2_ADOVIF_Msk) >> EADC_STATUS2_ADOVIF_Pos)
N
N/**
N  * @brief Get the busy state of EADC.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @retval 0 Idle state.
N  * @retval 1 Busy state.
N  * @details This macro is used to read BUSY bit (EADC_STATUS2[23]) to get busy state.
N  */
N#define EADC_IS_BUSY(eadc) (((eadc)->STATUS2 & EADC_STATUS2_BUSY_Msk) >> EADC_STATUS2_BUSY_Pos)
N
N/**
N  * @brief Configure the comparator 0 and enable it.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32ModuleNum specifies the compare sample module, valid value are from 0 to 18.
N  * @param[in] u32Condition specifies the compare condition. Valid values are:
N  *                        - \ref EADC_CMP_CMPCOND_LESS_THAN            :The compare condition is "less than the compare value"
N  *                        - \ref EADC_CMP_CMPCOND_GREATER_OR_EQUAL     :The compare condition is "greater than or equal to the compare value
N  * @param[in] u16CMPData specifies the compare value, valid range are between 0~0xFFF.
N  * @param[in] u32MatchCount specifies the match count setting, valid range are between 0~0xF.
N  * @return None
N  * @details For example, ADC_ENABLE_CMP0(EADC, 5, ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL, 0x800, 10, EADC_CMP_CMPWEN_DISABLE, EADC_CMP_ADCMPIE_ENABLE);
N  *         Means EADC will assert comparator 0 flag if sample module 5 conversion result is greater or
N  *         equal to 0x800 for 10 times continuously, and a compare interrupt request is generated.
N  */
N#define EADC_ENABLE_CMP0(eadc,\
N                         u32ModuleNum,\
N                         u32Condition,\
N                         u16CMPData,\
N                         u32MatchCount) ((eadc)->CMP[0] |=(((u32ModuleNum) << EADC_CMP_CMPSPL_Pos)|\
N                                                            (u32Condition) |\
N                                                            ((u16CMPData) << EADC_CMP_CMPDAT_Pos)| \
N                                                            (((u32MatchCount) - 1) << EADC_CMP_CMPMCNT_Pos)|\
N                                                            EADC_CMP_ADCMPEN_Msk))
X#define EADC_ENABLE_CMP0(eadc,                         u32ModuleNum,                         u32Condition,                         u16CMPData,                         u32MatchCount) ((eadc)->CMP[0] |=(((u32ModuleNum) << EADC_CMP_CMPSPL_Pos)|                                                            (u32Condition) |                                                            ((u16CMPData) << EADC_CMP_CMPDAT_Pos)|                                                             (((u32MatchCount) - 1) << EADC_CMP_CMPMCNT_Pos)|                                                            EADC_CMP_ADCMPEN_Msk))
N
N/**
N  * @brief Configure the comparator 1 and enable it.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32ModuleNum specifies the compare sample module, valid value are from 0 to 18.
N  * @param[in] u32Condition specifies the compare condition. Valid values are:
N  *                        - \ref EADC_CMP_CMPCOND_LESS_THAN            :The compare condition is "less than the compare value"
N  *                        - \ref EADC_CMP_CMPCOND_GREATER_OR_EQUAL     :The compare condition is "greater than or equal to the compare value
N  * @param[in] u16CMPData specifies the compare value, valid range are between 0~0xFFF.
N  * @param[in] u32MatchCount specifies the match count setting, valid range are between 0~0xF.
N  * @return None
N  * @details For example, ADC_ENABLE_CMP1(EADC, 5, ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL, 0x800, 10, EADC_CMP_ADCMPIE_ENABLE);
N  *         Means EADC will assert comparator 1 flag if sample module 5 conversion result is greater or
N  *         equal to 0x800 for 10 times continuously, and a compare interrupt request is generated.
N  */
N#define EADC_ENABLE_CMP1(eadc,\
N                         u32ModuleNum,\
N                         u32Condition,\
N                         u16CMPData,\
N                         u32MatchCount) ((eadc)->CMP[1] |=(((u32ModuleNum) << EADC_CMP_CMPSPL_Pos)|\
N                                                            (u32Condition) |\
N                                                            ((u16CMPData) << EADC_CMP_CMPDAT_Pos)| \
N                                                            (((u32MatchCount) - 1) << EADC_CMP_CMPMCNT_Pos)|\
N                                                            EADC_CMP_ADCMPEN_Msk))
X#define EADC_ENABLE_CMP1(eadc,                         u32ModuleNum,                         u32Condition,                         u16CMPData,                         u32MatchCount) ((eadc)->CMP[1] |=(((u32ModuleNum) << EADC_CMP_CMPSPL_Pos)|                                                            (u32Condition) |                                                            ((u16CMPData) << EADC_CMP_CMPDAT_Pos)|                                                             (((u32MatchCount) - 1) << EADC_CMP_CMPMCNT_Pos)|                                                            EADC_CMP_ADCMPEN_Msk))
N
N/**
N  * @brief Configure the comparator 2 and enable it.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32ModuleNum specifies the compare sample module, valid value are from 0 to 18.
N  * @param[in] u32Condition specifies the compare condition. Valid values are:
N  *                        - \ref EADC_CMP_CMPCOND_LESS_THAN            :The compare condition is "less than the compare value"
N  *                        - \ref EADC_CMP_CMPCOND_GREATER_OR_EQUAL     :The compare condition is "greater than or equal to the compare value
N  * @param[in] u16CMPData specifies the compare value, valid range are between 0~0xFFF.
N  * @param[in] u32MatchCount specifies the match count setting, valid range are between 0~0xF.
N  * @return None
N  * @details For example, ADC_ENABLE_CMP2(EADC, 5, ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL, 0x800, 10, EADC_CMP_CMPWEN_DISABLE, EADC_CMP_ADCMPIE_ENABLE);
N  *         Means EADC will assert comparator 2 flag if sample module 5 conversion result is greater or
N  *         equal to 0x800 for 10 times continuously, and a compare interrupt request is generated.
N  */
N#define EADC_ENABLE_CMP2(eadc,\
N                         u32ModuleNum,\
N                         u32Condition,\
N                         u16CMPData,\
N                         u32MatchCount) ((eadc)->CMP[2] |=(((u32ModuleNum) << EADC_CMP_CMPSPL_Pos)|\
N                                                            (u32Condition) |\
N                                                            ((u16CMPData) << EADC_CMP_CMPDAT_Pos)| \
N                                                            (((u32MatchCount) - 1) << EADC_CMP_CMPMCNT_Pos)|\
N                                                            EADC_CMP_ADCMPEN_Msk))
X#define EADC_ENABLE_CMP2(eadc,                         u32ModuleNum,                         u32Condition,                         u16CMPData,                         u32MatchCount) ((eadc)->CMP[2] |=(((u32ModuleNum) << EADC_CMP_CMPSPL_Pos)|                                                            (u32Condition) |                                                            ((u16CMPData) << EADC_CMP_CMPDAT_Pos)|                                                             (((u32MatchCount) - 1) << EADC_CMP_CMPMCNT_Pos)|                                                            EADC_CMP_ADCMPEN_Msk))
N
N/**
N  * @brief Configure the comparator 3 and enable it.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32ModuleNum specifies the compare sample module, valid value are from 0 to 18.
N  * @param[in] u32Condition specifies the compare condition. Valid values are:
N  *                        - \ref EADC_CMP_CMPCOND_LESS_THAN            :The compare condition is "less than the compare value"
N  *                        - \ref EADC_CMP_CMPCOND_GREATER_OR_EQUAL     :The compare condition is "greater than or equal to the compare value
N  * @param[in] u16CMPData specifies the compare value, valid range are between 0~0xFFF.
N  * @param[in] u32MatchCount specifies the match count setting, valid range are between 1~0xF.
N  * @return None
N  * @details For example, ADC_ENABLE_CMP3(EADC, 5, ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL, 0x800, 10, EADC_CMP_ADCMPIE_ENABLE);
N  *         Means EADC will assert comparator 3 flag if sample module 5 conversion result is greater or
N  *         equal to 0x800 for 10 times continuously, and a compare interrupt request is generated.
N  */
N#define EADC_ENABLE_CMP3(eadc,\
N                         u32ModuleNum,\
N                         u32Condition,\
N                         u16CMPData,\
N                         u32MatchCount) ((eadc)->CMP[3] |=(((u32ModuleNum) << EADC_CMP_CMPSPL_Pos)|\
N                                                            (u32Condition) |\
N                                                            ((u16CMPData) << EADC_CMP_CMPDAT_Pos)| \
N                                                            (((u32MatchCount) - 1) << EADC_CMP_CMPMCNT_Pos)|\
N                                                            EADC_CMP_ADCMPEN_Msk))
X#define EADC_ENABLE_CMP3(eadc,                         u32ModuleNum,                         u32Condition,                         u16CMPData,                         u32MatchCount) ((eadc)->CMP[3] |=(((u32ModuleNum) << EADC_CMP_CMPSPL_Pos)|                                                            (u32Condition) |                                                            ((u16CMPData) << EADC_CMP_CMPDAT_Pos)|                                                             (((u32MatchCount) - 1) << EADC_CMP_CMPMCNT_Pos)|                                                            EADC_CMP_ADCMPEN_Msk))
N
N/**
N  * @brief Enable the compare window mode.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32CMP Specifies the compare register, valid value are 0 and 2.
N  * @return None
N  * @details ADCMPF0 (EADC_STATUS2[4]) will be set when both EADC_CMP0 and EADC_CMP1 compared condition matched.
N  */
N#define EADC_ENABLE_CMP_WINDOW_MODE(eadc, u32CMP) ((eadc)->CMP[(u32CMP)] |= EADC_CMP_CMPWEN_Msk)
N
N/**
N  * @brief Disable the compare window mode.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32CMP Specifies the compare register, valid value are 0 and 2.
N  * @return None
N  * @details ADCMPF2 (EADC_STATUS2[6]) will be set when both EADC_CMP2 and EADC_CMP3 compared condition matched.
N  */
N#define EADC_DISABLE_CMP_WINDOW_MODE(eadc, u32CMP) ((eadc)->CMP[(u32CMP)] &= ~EADC_CMP_CMPWEN_Msk)
N
N/**
N  * @brief Enable the compare interrupt.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32CMP Specifies the compare register, valid value are from 0 to 3.
N  * @return None
N  * @details If the compare function is enabled and the compare condition matches the setting of CMPCOND (EADC_CMPn[2], n=0~3)
N  *         and CMPMCNT (EADC_CMPn[11:8], n=0~3), ADCMPFn (EADC_STATUS2[7:4], n=0~3) will be asserted, in the meanwhile,
N  *         if ADCMPIE is set to 1, a compare interrupt request is generated.
N  */
N#define EADC_ENABLE_CMP_INT(eadc, u32CMP) ((eadc)->CMP[(u32CMP)] |= EADC_CMP_ADCMPIE_Msk)
N
N/**
N  * @brief Disable the compare interrupt.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @param[in] u32CMP Specifies the compare register, valid value are from 0 to 3.
N  * @return None
N  * @details This macro is used to disable the compare interrupt.
N  */
N#define EADC_DISABLE_CMP_INT(eadc, u32CMP) ((eadc)->CMP[(u32CMP)] &= ~EADC_CMP_ADCMPIE_Msk)
N
N/**
N  * @brief Disable comparator 0.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @return None
N  * @details This macro is used to disable comparator 0.
N  */
N#define EADC_DISABLE_CMP0(eadc) ((eadc)->CMP[0] = 0)
N
N/**
N  * @brief Disable comparator 1.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @return None
N  * @details This macro is used to disable comparator 1.
N  */
N#define EADC_DISABLE_CMP1(eadc) ((eadc)->CMP[1] = 0)
N
N/**
N  * @brief Disable comparator 2.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @return None
N  * @details This macro is used to disable comparator 2.
N  */
N#define EADC_DISABLE_CMP2(eadc) ((eadc)->CMP[2] = 0)
N
N/**
N  * @brief Disable comparator 3.
N  * @param[in] eadc The pointer of the specified EADC module.
N  * @return None
N  * @details This macro is used to disable comparator 3.
N  */
N#define EADC_DISABLE_CMP3(eadc) ((eadc)->CMP[3] = 0)
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define EADC functions prototype                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
Nvoid EADC_Open(EADC_T *eadc, uint32_t u32InputMode);
Nvoid EADC_Close(EADC_T *eadc);
Nvoid EADC_ConfigSampleModule(EADC_T *eadc, uint32_t u32ModuleNum, uint32_t u32TriggerSource, uint32_t u32Channel);
Nvoid EADC_SetTriggerDelayTime(EADC_T *eadc, uint32_t u32ModuleNum, uint32_t u32TriggerDelayTime, uint32_t u32DelayClockDivider);
Nvoid EADC_SetInternalSampleTime(EADC_T *eadc, uint32_t u32SampleTime);
Nvoid EADC_SetExtendSampleTime(EADC_T *eadc, uint32_t u32ModuleNum, uint32_t u32ExtendSampleTime);
N
N/*@}*/ /* end of group EADC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group EADC_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__EADC_H__
N
N/*** (C) COPYRIGHT 2013~2015 Nuvoton Technology Corp. ***/
L 17108 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N#include "dac.h"
L 1 "..\..\..\..\Library\StdDriver\inc\dac.h" 1
N/******************************************************************************
N * @file     dac.h
N * @version  V0.10
N * $Revision: 12 $
N * $Date: 15/08/11 10:26a $
N * @brief    M451 series DAC driver header file
N *
N * @note
N * Copyright (C) 2013~2015 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef __DAC_H__
N#define __DAC_H__
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Include related headers                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#include "M451Series.h"
N
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup DAC_Driver DAC Driver
N  @{
N*/
N
N
N/** @addtogroup DAC_EXPORTED_CONSTANTS DAC Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  DAC_CTL Constant Definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define DAC_CTL_LALIGN_RIGHT_ALIGN   (0UL<<DAC_CTL_LALIGN_Pos)   /*!< Right alignment. */
N#define DAC_CTL_LALIGN_LEFT_ALIGN    (1UL<<DAC_CTL_LALIGN_Pos)   /*!< Left alignment */
N
N#define DAC_WRITE_DAT_TRIGGER      (0UL)    /*!< Write DAC_DAT trigger */
N#define DAC_SOFTWARE_TRIGGER       (0UL|DAC_CTL_TRGEN_Msk)    /*!< Software trigger */
N#define DAC_LOW_LEVEL_TRIGGER      ((0UL<<DAC_CTL_ETRGSEL_Pos)|(1UL<<DAC_CTL_TRGSEL_Pos)|DAC_CTL_TRGEN_Msk)   /*!< STDAC pin low level trigger */
N#define DAC_HIGH_LEVEL_TRIGGER     ((1UL<<DAC_CTL_ETRGSEL_Pos)|(1UL<<DAC_CTL_TRGSEL_Pos)|DAC_CTL_TRGEN_Msk)   /*!< STDAC pin high level trigger */
N#define DAC_FALLING_EDGE_TRIGGER   ((2UL<<DAC_CTL_ETRGSEL_Pos)|(1UL<<DAC_CTL_TRGSEL_Pos)|DAC_CTL_TRGEN_Msk)   /*!< STDAC pin falling edge trigger */
N#define DAC_RISING_EDGE_TRIGGER    ((3UL<<DAC_CTL_ETRGSEL_Pos)|(1UL<<DAC_CTL_TRGSEL_Pos)|DAC_CTL_TRGEN_Msk)   /*!< STDAC pin rising edge trigger */
N#define DAC_TIMER0_TRIGGER         ((2UL<<DAC_CTL_TRGSEL_Pos)|DAC_CTL_TRGEN_Msk)   /*!< Timer 0 trigger */
N#define DAC_TIMER1_TRIGGER         ((3UL<<DAC_CTL_TRGSEL_Pos)|DAC_CTL_TRGEN_Msk)   /*!< Timer 1 trigger */
N#define DAC_TIMER2_TRIGGER         ((4UL<<DAC_CTL_TRGSEL_Pos)|DAC_CTL_TRGEN_Msk)   /*!< Timer 2 trigger */
N#define DAC_TIMER3_TRIGGER         ((5UL<<DAC_CTL_TRGSEL_Pos)|DAC_CTL_TRGEN_Msk)   /*!< Timer 3 trigger */
N#define DAC_PWM0_TRIGGER           ((6UL<<DAC_CTL_TRGSEL_Pos)|DAC_CTL_TRGEN_Msk)   /*!< PWM0 trigger */
N#define DAC_PWM1_TRIGGER           ((7UL<<DAC_CTL_TRGSEL_Pos)|DAC_CTL_TRGEN_Msk)   /*!< PWM1 trigger */
N
N#define DAC_TRIGGER_MODE_DISABLE   (0UL<<DAC_CTL_TRGEN_Pos)   /*!< Trigger mode disable */
N#define DAC_TRIGGER_MODE_ENABLE    (1UL<<DAC_CTL_TRGEN_Pos)   /*!< Trigger mode enable */
N
N
N/*@}*/ /* end of group DAC_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup DAC_EXPORTED_FUNCTIONS DAC Exported Functions
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  DAC Macro Definitions                                                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/**
N  * @brief Start the D/A conversion.
N  * @param[in] dac Base address of DAC module.
N  * @return None
N  * @details User writes SWTRG bit (DAC_SWTRG[0]) to generate one shot pulse and it is cleared to 0 by hardware automatically.
N  */
N#define DAC_START_CONV(dac) ((dac)->SWTRG = DAC_SWTRG_SWTRG_Msk)
N
N/**
N  * @brief Enable DAC data left-aligned.
N  * @param[in] dac Base address of DAC module.
N  * @return None
N  * @details User has to load data into DAC_DAT[15:4] bits. DAC_DAT[31:16] and DAC_DAT[3:0] are ignored in DAC conversion.
N  */
N#define DAC_ENABLE_LEFT_ALIGN(dac) ((dac)->CTL |= DAC_CTL_LALIGN_Msk)
N
N/**
N  * @brief Enable DAC data right-aligned.
N  * @param[in] dac Base address of DAC module.
N  * @return None
N  * @details User has to load data into DAC_DAT[11:0] bits, DAC_DAT[31:12] are ignored in DAC conversion.
N  */
N#define DAC_ENABLE_RIGHT_ALIGN(dac) ((dac)->CTL &= ~DAC_CTL_LALIGN_Msk)
N
N/**
N  * @brief Enable output voltage buffer.
N  * @param[in] dac Base address of DAC module.
N  * @return None
N  * @details The DAC integrates a voltage output buffer that can be used to reduce output impedance and
N  *         drive external loads directly without having to add an external operational amplifier.
N  */
N#define DAC_ENABLE_BYPASS_BUFFER(dac) ((dac)->CTL |= DAC_CTL_BYPASS_Msk)
N
N/**
N  * @brief Disable output voltage buffer.
N  * @param[in] dac Base address of DAC module.
N  * @return None
N  * @details This macro is used to disable output voltage buffer.
N  */
N#define DAC_DISABLE_BYPASS_BUFFER(dac) ((dac)->CTL &= ~DAC_CTL_BYPASS_Msk)
N
N/**
N  * @brief Enable the interrupt.
N  * @param[in] dac Base address of DAC module.
N  * @param[in] u32Ch Not used in M451 Series DAC.
N  * @return None
N  * @details This macro is used to enable DAC interrupt.
N  */
N#define DAC_ENABLE_INT(dac, u32Ch) ((dac)->CTL |= DAC_CTL_DACIEN_Msk)
N
N/**
N  * @brief Disable the interrupt.
N  * @param[in] dac Base address of DAC module.
N  * @param[in] u32Ch Not used in M451 Series DAC.
N  * @return None
N  * @details This macro is used to disable DAC interrupt.
N  */
N#define DAC_DISABLE_INT(dac, u32Ch) ((dac)->CTL &= ~DAC_CTL_DACIEN_Msk)
N
N/**
N  * @brief Enable DMA under-run interrupt.
N  * @param[in] dac Base address of DAC module.
N  * @return None
N  * @details This macro is used to enable DMA under-run interrupt.
N  */
N#define DAC_ENABLE_DMAUDR_INT(dac) ((dac)->CTL |= DAC_CTL_DMAURIEN_Msk)
N
N/**
N  * @brief Disable DMA under-run interrupt.
N  * @param[in] dac Base address of DAC module.
N  * @return None
N  * @details This macro is used to disable DMA under-run interrupt.
N  */
N#define DAC_DISABLE_DMAUDR_INT(dac) ((dac)->CTL &= ~DAC_CTL_DMAURIEN_Msk)
N
N/**
N  * @brief Enable PDMA mode.
N  * @param[in] dac Base address of DAC module.
N  * @return None
N  * @details DAC DMA request is generated when a hardware trigger event occurs while DMAEN (DAC_CTL[2]) is set.
N  */
N#define DAC_ENABLE_PDMA(dac) ((dac)->CTL |= DAC_CTL_DMAEN_Msk)
N
N/**
N  * @brief Disable PDMA mode.
N  * @param[in] dac Base address of DAC module.
N  * @return None
N  * @details This macro is used to disable DMA mode.
N  */
N#define DAC_DISABLE_PDMA(dac) ((dac)->CTL &= ~DAC_CTL_DMAEN_Msk)
N
N/**
N  * @brief Write data for conversion.
N  * @param[in] dac Base address of DAC module.
N  * @param[in] u32Ch Not used in M451 Series DAC.
N  * @param[in] u32Data Decides the data for conversion, valid range are between 0~0xFFF.
N  * @return None
N  * @details 12 bit left alignment: user has to load data into DAC_DAT[15:4] bits.
N  *         12 bit right alignment: user has to load data into DAC_DAT[11:0] bits.
N  */
N#define DAC_WRITE_DATA(dac, u32Ch, u32Data) ((dac)->DAT = (u32Data))
N
N/**
N  * @brief Read DAC 12-bit holding data.
N  * @param[in] dac Base address of DAC module.
N  * @param[in] u32Ch Not used in M451 Series DAC.
N  * @return Return DAC 12-bit holding data.
N  * @details This macro is used to read DAC_DAT register.
N  */
N#define DAC_READ_DATA(dac, u32Ch) ((dac)->DAT)
N
N/**
N  * @brief Get the busy state of DAC.
N  * @param[in] dac Base address of DAC module.
N  * @param[in] u32Ch Not used in M451 Series DAC.
N  * @retval 0 Idle state.
N  * @retval 1 Busy state.
N  * @details This macro is used to read BUSY bit (DAC_STATUS[8]) to get busy state.
N  */
N#define DAC_IS_BUSY(dac, u32Ch) (((dac)->STATUS & DAC_STATUS_BUSY_Msk) >> DAC_STATUS_BUSY_Pos)
N
N/**
N  * @brief Get the interrupt flag.
N  * @param[in] dac Base address of DAC module.
N  * @param[in] u32Ch Not used in M451 Series DAC.
N  * @retval 0 DAC is in conversion state.
N  * @retval 1 DAC conversion finish.
N  * @details This macro is used to read FINISH bit (DAC_STATUS[0]) to get DAC conversion complete finish flag.
N  */
N#define DAC_GET_INT_FLAG(dac, u32Ch) ((dac)->STATUS & DAC_STATUS_FINISH_Msk)
N
N/**
N  * @brief Get the DMA under-run flag.
N  * @param[in] dac Base address of DAC module.
N  * @retval 0 No DMA under-run error condition occurred.
N  * @retval 1 DMA under-run error condition occurred.
N  * @details This macro is used to read DMAUDR bit (DAC_STATUS[1]) to get DMA under-run state.
N  */
N#define DAC_GET_DMAUDR_FLAG(dac) (((dac)->STATUS & DAC_STATUS_DMAUDR_Msk) >> DAC_STATUS_DMAUDR_Pos)
N
N/**
N  * @brief This macro clear the interrupt status bit.
N  * @param[in] dac Base address of DAC module.
N  * @param[in] u32Ch Not used in M451 Series DAC.
N  * @return None
N  * @details User writes FINISH bit (DAC_STATUS[0]) to clear DAC conversion complete finish flag.
N  */
N#define DAC_CLR_INT_FLAG(dac, u32Ch) ((dac)->STATUS = DAC_STATUS_FINISH_Msk)
N
N/**
N  * @brief This macro clear the  DMA under-run flag.
N  * @param[in] dac Base address of DAC module.
N  * @return None
N  * @details User writes DMAUDR bit (DAC_STATUS[1]) to clear DMA under-run flag.
N  */
N#define DAC_CLR_DMAUDR_FLAG(dac) ((dac)->STATUS = DAC_STATUS_DMAUDR_Msk)
N
Nvoid DAC_Open(DAC_T *dac, uint32_t u32Ch, uint32_t u32TrgSrc);
Nvoid DAC_Close(DAC_T *dac, uint32_t u32Ch);
Nfloat DAC_SetDelayTime(DAC_T *dac, uint32_t u16Delay);
N
N/*@}*/ /* end of group DAC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group DAC_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__DAC_H__
N
N/*** (C) COPYRIGHT 2013~2015 Nuvoton Technology Corp. ***/
L 17109 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N#include "can.h"
L 1 "..\..\..\..\Library\StdDriver\inc\can.h" 1
N/**************************************************************************//**
N * @file     can.h
N * @version  V2.00
N * $Revision: 9 $
N * $Date: 15/08/11 10:26a $
N * @brief    M451 Series CAN Driver Header File
N *
N * @note
N * Copyright (C) 2014~2015 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __CAN_H__
N#define __CAN_H__
N
N#include "M451Series.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup CAN_Driver CAN Driver
N  @{
N*/
N
N/** @addtogroup CAN_EXPORTED_CONSTANTS CAN Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/* CAN Test Mode Constant Definitions                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define    CAN_NORMAL_MODE   0
N#define    CAN_BASIC_MODE    1
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Message ID Type Constant Definitions                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define    CAN_STD_ID    0
N#define    CAN_EXT_ID    1
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Message Frame Type Constant Definitions                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#define    CAN_REMOTE_FRAME    0
N#define    CAN_DATA_FRAME    1
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CAN message structure                                                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef struct
N{
N    uint32_t  IdType;
N    uint32_t  FrameType;
N    uint32_t  Id;
N    uint8_t   DLC;
N    uint8_t   Data[8];
N} STR_CANMSG_T;
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CAN mask message structure                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef struct
N{
N    uint8_t   u8Xtd;
N    uint8_t   u8Dir;
N    uint32_t  u32Id;
N    uint8_t   u8IdType;
N} STR_CANMASK_T;
N
N#define MSG(id)  (id)
N
N
N/*@}*/ /* end of group CAN_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup CAN_EXPORTED_FUNCTIONS CAN Exported Functions
N  @{
N*/
N
N/**
N * @brief Get interrupt status.
N *
N * @param[in] can The base address of can module.
N *
N * @return CAN module status register value.
N *
N * @details Status Interrupt is generated by bits BOff (CAN_STATUS[7]), EWarn (CAN_STATUS[6]),
N *          EPass (CAN_STATUS[5]), RxOk (CAN_STATUS[4]), TxOk (CAN_STATUS[3]), and LEC (CAN_STATUS[2:0]).
N */
N#define CAN_GET_INT_STATUS(can) ((can)->STATUS)
N
N/**
N * @brief Get specified interrupt pending status.
N *
N * @param[in] can The base address of can module.
N *
N * @return The source of the interrupt.
N *
N * @details If several interrupts are pending, the CAN Interrupt Register will point to the pending interrupt
N *          with the highest priority, disregarding their chronological order.
N */
N#define CAN_GET_INT_PENDING_STATUS(can) ((can)->IIDR)
N
N/**
N * @brief Disable wake-up function.
N *
N * @param[in] can The base address of can module.
N *
N * @return None
N *
N * @details  The macro is used to disable wake-up function.
N */
N#define CAN_DISABLE_WAKEUP(can) ((can)->WU_EN = 0)
N
N/**
N * @brief Enable wake-up function.
N *
N * @param[in] can The base address of can module.
N *
N * @return None
N *
N * @details User can wake-up system when there is a falling edge in the CAN_Rx pin.
N */
N#define CAN_ENABLE_WAKEUP(can) ((can)->WU_EN = CAN_WUEN_WAKUP_EN_Msk)
N
N/**
N * @brief Get specified Message Object new data into bit value.
N *
N * @param[in] can The base address of can module.
N * @param[in] u32MsgNum Specified Message Object number, valid value are from 0 to 31.
N *
N * @return Specified Message Object new data into bit value.
N *
N * @details The NewDat bit (CAN_IFn_MCON[15]) of a specific Message Object can be set/reset by the software through the IFn Message Interface Registers
N *          or by the Message Handler after reception of a Data Frame or after a successful transmission.
N */
N#define CAN_GET_NEW_DATA_IN_BIT(can, u32MsgNum) ((u32MsgNum) < 16 ? (can)->NDAT1 & (1 << (u32MsgNum)) : (can)->NDAT2 & (1 << ((u32MsgNum)-16)))
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define CAN functions prototype                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
Nuint32_t CAN_SetBaudRate(CAN_T *tCAN, uint32_t u32BaudRate);
Nuint32_t CAN_Open(CAN_T *tCAN, uint32_t u32BaudRate, uint32_t u32Mode);
Nvoid CAN_Close(CAN_T *tCAN);
Nvoid CAN_CLR_INT_PENDING_BIT(CAN_T *tCAN, uint8_t u32MsgNum);
Nvoid CAN_EnableInt(CAN_T *tCAN, uint32_t u32Mask);
Nvoid CAN_DisableInt(CAN_T *tCAN, uint32_t u32Mask);
Nint32_t CAN_Transmit(CAN_T *tCAN, uint32_t u32MsgNum , STR_CANMSG_T* pCanMsg);
Nint32_t CAN_Receive(CAN_T *tCAN, uint32_t u32MsgNum , STR_CANMSG_T* pCanMsg);
Nint32_t CAN_SetMultiRxMsg(CAN_T *tCAN, uint32_t u32MsgNum , uint32_t u32MsgCount, uint32_t u32IDType, uint32_t u32ID);
Nint32_t CAN_SetRxMsg(CAN_T *tCAN, uint32_t u32MsgNum , uint32_t u32IDType, uint32_t u32ID);
Nint32_t CAN_SetRxMsgAndMsk(CAN_T *tCAN, uint32_t u32MsgNum , uint32_t u32IDType, uint32_t u32ID, uint32_t u32IDMask);
Nint32_t CAN_SetTxMsg(CAN_T *tCAN, uint32_t u32MsgNum , STR_CANMSG_T* pCanMsg);
Nint32_t CAN_TriggerTxMsg(CAN_T  *tCAN, uint32_t u32MsgNum);
N
N
N/*@}*/ /* end of group CAN_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group CAN_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__CAN_H__
N
N/*** (C) COPYRIGHT 2014~2015 Nuvoton Technology Corp. ***/
L 17110 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N#include "usbd.h"
L 1 "..\..\..\..\Library\StdDriver\inc\usbd.h" 1
N/******************************************************************************
N * @file     usbd.h
N * @brief    M451 series USB driver header file
N * @version  2.0.0
N * @date     10, January, 2014
N *
N * @note
N * Copyright (C) 2014~2015 Nuvoton Technology Corp. All rights reserved.
N ******************************************************************************/
N#ifndef __USBD_H__
N#define __USBD_H__
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup USBD_Driver USBD Driver
N  @{
N*/
N
N/** @addtogroup USBD_EXPORTED_STRUCTS USBD Exported Structs
N  @{
N*/
Ntypedef struct s_usbd_info
N{
N    const uint8_t *gu8DevDesc;            /*!< Pointer for USB Device Descriptor          */
N    const uint8_t *gu8ConfigDesc;         /*!< Pointer for USB Configuration Descriptor   */
N    const uint8_t **gu8StringDesc;        /*!< Pointer for USB String Descriptor pointers */
N    const uint8_t **gu8HidReportDesc;     /*!< Pointer for USB HID Report Descriptor      */
N    const uint32_t *gu32HidReportSize;    /*!< Pointer for HID Report descriptor Size */
N    const uint32_t *gu32ConfigHidDescIdx; /*!< Pointer for HID Descriptor start index */	
N
N} S_USBD_INFO_T;
N
Nextern const S_USBD_INFO_T gsInfo;
N
N/*@}*/ /* end of group USBD_EXPORTED_STRUCTS */
N
N
N
N
N/** @addtogroup USBD_EXPORTED_CONSTANTS USBD Exported Constants
N  @{
N*/
N#define USBD_BUF_BASE   (USBD_BASE+0x100)
N#define USBD_MAX_EP     8
N
N#define EP0     0       /*!< Endpoint 0 */
N#define EP1     1       /*!< Endpoint 1 */
N#define EP2     2       /*!< Endpoint 2 */
N#define EP3     3       /*!< Endpoint 3 */
N#define EP4     4       /*!< Endpoint 4 */
N#define EP5     5       /*!< Endpoint 5 */
N#define EP6     6       /*!< Endpoint 6 */
N#define EP7     7       /*!< Endpoint 7 */
N
N
N/*!<USB Request Type */
N#define REQ_STANDARD        0x00
N#define REQ_CLASS           0x20
N#define REQ_VENDOR          0x40
N
N/*!<USB Standard Request */
N#define GET_STATUS          0x00
N#define CLEAR_FEATURE       0x01
N#define SET_FEATURE         0x03
N#define SET_ADDRESS         0x05
N#define GET_DESCRIPTOR      0x06
N#define SET_DESCRIPTOR      0x07
N#define GET_CONFIGURATION   0x08
N#define SET_CONFIGURATION   0x09
N#define GET_INTERFACE       0x0A
N#define SET_INTERFACE       0x0B
N#define SYNC_FRAME          0x0C
N
N/*!<USB Descriptor Type */
N#define DESC_DEVICE         0x01
N#define DESC_CONFIG         0x02
N#define DESC_STRING         0x03
N#define DESC_INTERFACE      0x04
N#define DESC_ENDPOINT       0x05
N#define DESC_QUALIFIER      0x06
N#define DESC_OTHERSPEED     0x07
N
N/*!<USB HID Descriptor Type */
N#define DESC_HID            0x21
N#define DESC_HID_RPT        0x22
N
N/*!<USB Descriptor Length */
N#define LEN_DEVICE          18
N#define LEN_CONFIG          9
N#define LEN_INTERFACE       9
N#define LEN_ENDPOINT        7
N#define LEN_HID             9
N#define LEN_CCID            0x36
N
N/*!<USB Endpoint Type */
N#define EP_ISO              0x01
N#define EP_BULK             0x02
N#define EP_INT              0x03
N
N#define EP_INPUT            0x80
N#define EP_OUTPUT           0x00
N
N/*!<USB Feature Selector */
N#define FEATURE_DEVICE_REMOTE_WAKEUP    0x01
N#define FEATURE_ENDPOINT_HALT           0x00
N
N/******************************************************************************/
N/*                USB Specific Macros                                         */
N/******************************************************************************/
N
N#define USBD_WAKEUP_EN          USBD_INTEN_WKEN_Msk         /*!< USB Wake-up Enable */
N#define USBD_DRVSE0             USBD_SE0_SE0_Msk            /*!< Drive SE0 */
N
N#define USBD_DPPU_EN            USBD_ATTR_DPPUEN_Msk        /*!< USB D+ Pull-up Enable */
N#define USBD_PWRDN              USBD_ATTR_PWRDN_Msk         /*!< PHY Turn-On */
N#define USBD_PHY_EN             USBD_ATTR_PHYEN_Msk         /*!< PHY Enable */
N#define USBD_USB_EN             USBD_ATTR_USBEN_Msk         /*!< USB Enable */
N
N#define USBD_INT_BUS            USBD_INTEN_BUSIEN_Msk       /*!< USB Bus Event Interrupt */
N#define USBD_INT_USB            USBD_INTEN_USBIEN_Msk       /*!< USB Event Interrupt */
N#define USBD_INT_FLDET          USBD_INTEN_VBDETIEN_Msk     /*!< USB VBUS Detection Interrupt */
N#define USBD_INT_WAKEUP         (USBD_INTEN_NEVWKIEN_Msk | USBD_INTEN_WKEN_Msk)     /*!< USB No-Event-Wake-Up Interrupt */
N
N#define USBD_INTSTS_WAKEUP      USBD_INTSTS_NEVWKIF_Msk     /*!< USB No-Event-Wake-Up Interrupt Status */
N#define USBD_INTSTS_FLDET       USBD_INTSTS_VBDETIF_Msk     /*!< USB Float Detect Interrupt Status */
N#define USBD_INTSTS_BUS         USBD_INTSTS_BUSIF_Msk       /*!< USB Bus Event Interrupt Status */
N#define USBD_INTSTS_USB         USBD_INTSTS_USBIF_Msk       /*!< USB Event Interrupt Status */
N#define USBD_INTSTS_SETUP       USBD_INTSTS_SETUP_Msk       /*!< USB Setup Event */
N#define USBD_INTSTS_EP0         USBD_INTSTS_EPEVT0_Msk      /*!< USB Endpoint 0 Event */
N#define USBD_INTSTS_EP1         USBD_INTSTS_EPEVT1_Msk      /*!< USB Endpoint 1 Event */
N#define USBD_INTSTS_EP2         USBD_INTSTS_EPEVT2_Msk      /*!< USB Endpoint 2 Event */
N#define USBD_INTSTS_EP3         USBD_INTSTS_EPEVT3_Msk      /*!< USB Endpoint 3 Event */
N#define USBD_INTSTS_EP4         USBD_INTSTS_EPEVT4_Msk      /*!< USB Endpoint 4 Event */
N#define USBD_INTSTS_EP5         USBD_INTSTS_EPEVT5_Msk      /*!< USB Endpoint 5 Event */
N#define USBD_INTSTS_EP6         USBD_INTSTS_EPEVT6_Msk      /*!< USB Endpoint 6 Event */
N#define USBD_INTSTS_EP7         USBD_INTSTS_EPEVT7_Msk      /*!< USB Endpoint 7 Event */
N
N#define USBD_STATE_USBRST       USBD_ATTR_USBRST_Msk        /*!< USB Bus Reset */
N#define USBD_STATE_SUSPEND      USBD_ATTR_SUSPEND_Msk       /*!< USB Bus Suspend */
N#define USBD_STATE_RESUME       USBD_ATTR_RESUME_Msk        /*!< USB Bus Resume */
N#define USBD_STATE_TIMEOUT      USBD_ATTR_TOUT_Msk          /*!< USB Bus Timeout */
N
N#define USBD_CFGP_SSTALL        USBD_CFGP_SSTALL_Msk        /*!< Set Stall */
N#define USBD_CFG_CSTALL         USBD_CFG_CSTALL_Msk         /*!< Clear Stall */
N
N#define USBD_CFG_EPMODE_DISABLE (0ul << USBD_CFG_STATE_Pos)/*!< Endpoint Disable */
N#define USBD_CFG_EPMODE_OUT     (1ul << USBD_CFG_STATE_Pos)/*!< Out Endpoint */
N#define USBD_CFG_EPMODE_IN      (2ul << USBD_CFG_STATE_Pos)/*!< In Endpoint */
N#define USBD_CFG_TYPE_ISO       (1ul << USBD_CFG_ISOCH_Pos) /*!< Isochronous */
N
N
N
N/*@}*/ /* end of group USBD_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup USBD_EXPORTED_FUNCTIONS USBD Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Compare two input numbers and return maximum one.
N  *
N  * @param[in]  a   First number to be compared.
N  * @param[in]  b   Second number to be compared.
N  *
N  * @return     Maximum value between a and b.
N  *
N  * @details    If a > b, then return a. Otherwise, return b.
N  */
N#define Maximum(a,b)        ((a)>(b) ? (a) : (b))
N
N
N/**
N  * @brief      Compare two input numbers and return minimum one
N  *
N  * @param[in]  a   First number to be compared
N  * @param[in]  b   Second number to be compared
N  *
N  * @return     Minimum value between a and b
N  *
N  * @details    If a < b, then return a. Otherwise, return b.
N  */
N#define Minimum(a,b)        ((a)<(b) ? (a) : (b))
N
N
N/**
N  * @brief    Enable USB
N  *
N  * @param    None
N  *
N  * @return   None
N  *
N  * @details  To set USB ATTR control register to enable USB and PHY.
N  *
N  */
N#define USBD_ENABLE_USB()           ((uint32_t)(USBD->ATTR |= (USBD_USB_EN|USBD_PHY_EN)))
N
N/**
N  * @brief    Disable USB
N  *
N  * @param    None
N  *
N  * @return   None
N  *
N  * @details  To set USB ATTR control register to disable USB.
N  *
N  */
N#define USBD_DISABLE_USB()          ((uint32_t)(USBD->ATTR &= ~USBD_USB_EN))
N
N/**
N  * @brief    Enable USB PHY
N  *
N  * @param    None
N  *
N  * @return   None
N  *
N  * @details  To set USB ATTR control register to enable USB PHY.
N  *
N  */
N#define USBD_ENABLE_PHY()           ((uint32_t)(USBD->ATTR |= USBD_PHY_EN))
N
N/**
N  * @brief    Disable USB PHY
N  *
N  * @param    None
N  *
N  * @return   None
N  *
N  * @details  To set USB ATTR control register to disable USB PHY.
N  *
N  */
N#define USBD_DISABLE_PHY()          ((uint32_t)(USBD->ATTR &= ~USBD_PHY_EN))
N
N/**
N  * @brief    Enable SE0. Force USB PHY transceiver to drive SE0.
N  *
N  * @param    None
N  *
N  * @return   None
N  *
N  * @details  Set DRVSE0 bit of USB_DRVSE0 register to enable software-disconnect function. Force USB PHY transceiver to drive SE0 to bus.
N  *
N  */
N#define USBD_SET_SE0()              ((uint32_t)(USBD->SE0 |= USBD_DRVSE0))
N
N/**
N  * @brief    Disable SE0
N  *
N  * @param    None
N  *
N  * @return   None
N  *
N  * @details  Clear DRVSE0 bit of USB_DRVSE0 register to disable software-disconnect function.
N  *
N  */
N#define USBD_CLR_SE0()              ((uint32_t)(USBD->SE0 &= ~USBD_DRVSE0))
N
N/**
N  * @brief       Set USB device address
N  *
N  * @param[in]   addr The USB device address.
N  *
N  * @return      None
N  *
N  * @details     Write USB device address to USB_FADDR register.
N  *
N  */
N#define USBD_SET_ADDR(addr)         (USBD->FADDR = (addr))
N
N/**
N  * @brief    Get USB device address
N  *
N  * @param    None
N  *
N  * @return   USB device address
N  *
N  * @details  Read USB_FADDR register to get USB device address.
N  *
N  */
N#define USBD_GET_ADDR()             ((uint32_t)(USBD->FADDR))
N
N/**
N  * @brief      Enable USB interrupt function
N  *
N  * @param[in]  intr The combination of the specified interrupt enable bits.
N  *             Each bit corresponds to a interrupt enable bit.
N  *             This parameter decides which interrupts will be enabled.
N  *             (USBD_INT_WAKEUP, USBD_INT_FLDET, USBD_INT_USB, USBD_INT_BUS)
N  *
N  * @return     None
N  *
N  * @details    Enable USB related interrupt functions specified by intr parameter.
N  *
N  */
N#define USBD_ENABLE_INT(intr)       (USBD->INTEN |= (intr))
N
N/**
N  * @brief    Get interrupt status
N  *
N  * @param    None
N  *
N  * @return   The value of USB_INTSTS register
N  *
N  * @details  Return all interrupt flags of USB_INTSTS register.
N  *
N  */
N#define USBD_GET_INT_FLAG()         ((uint32_t)(USBD->INTSTS))
N
N/**
N  * @brief      Clear USB interrupt flag
N  *
N  * @param[in]  flag The combination of the specified interrupt flags.
N  *             Each bit corresponds to a interrupt source.
N  *             This parameter decides which interrupt flags will be cleared.
N  *             (USBD_INTSTS_WAKEUP, USBD_INTSTS_FLDET, USBD_INTSTS_BUS, USBD_INTSTS_USB)
N  *
N  * @return     None
N  *
N  * @details    Clear USB related interrupt flags specified by flag parameter.
N  *
N  */
N#define USBD_CLR_INT_FLAG(flag)     (USBD->INTSTS = (flag))
N
N/**
N  * @brief    Get endpoint status
N  *
N  * @param    None
N  *
N  * @return   The value of USB_EPSTS register.
N  *
N  * @details  Return all endpoint status.
N  *
N  */
N#define USBD_GET_EP_FLAG()          ((uint32_t)(USBD->EPSTS))
N
N/**
N  * @brief    Get USB bus state
N  *
N  * @param    None
N  *
N  * @return   The value of USB_ATTR[3:0].
N  *           Bit 0 indicates USB bus reset status.
N  *           Bit 1 indicates USB bus suspend status.
N  *           Bit 2 indicates USB bus resume status.
N  *           Bit 3 indicates USB bus time-out status.
N  *
N  * @details  Return USB_ATTR[3:0] for USB bus events.
N  *
N  */
N#define USBD_GET_BUS_STATE()        ((uint32_t)(USBD->ATTR & 0xf))
N
N/**
N  * @brief    Check cable connection state
N  *
N  * @param    None
N  *
N  * @retval   0 USB cable is not attached.
N  * @retval   1 USB cable is attached.
N  *
N  * @details  Check the connection state by FLDET bit of USB_FLDET register.
N  *
N  */
N#define USBD_IS_ATTACHED()          ((uint32_t)(USBD->VBUSDET & USBD_VBUSDET_VBUSDET_Msk))
N
N/**
N  * @brief      Stop USB transaction of the specified endpoint ID
N  *
N  * @param[in]  ep The USB endpoint ID. M451 Series supports 8 hardware endpoint ID. This parameter could be 0 ~ 7.
N  *
N  * @return     None
N  *
N  * @details    Write 1 to CLRRDY bit of USB_CFGPx register to stop USB transaction of the specified endpoint ID.
N  *
N  */
N#define USBD_STOP_TRANSACTION(ep)   (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFGP + (uint32_t)((ep) << 4))) |= USBD_CFGP_CLRRDY_Msk)
N
N/**
N  * @brief      Set USB DATA1 PID for the specified endpoint ID
N  *
N  * @param[in]  ep The USB endpoint ID. M451 Series supports 8 hardware endpoint ID. This parameter could be 0 ~ 7.
N  *
N  * @return     None
N  *
N  * @details    Set DSQ_SYNC bit of USB_CFGx register to specify the DATA1 PID for the following IN token transaction.
N  *             Base on this setting, hardware will toggle PID between DATA0 and DATA1 automatically for IN token transactions.
N  *
N  */
N#define USBD_SET_DATA1(ep)          (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFG + (uint32_t)((ep) << 4))) |= USBD_CFG_DSQSYNC_Msk)
N
N/**
N  * @brief      Set USB DATA0 PID for the specified endpoint ID
N  *
N  * @param[in]  ep The USB endpoint ID. M451 Series supports 8 hardware endpoint ID. This parameter could be 0 ~ 7.
N  *
N  * @return     None
N  *
N  * @details    Clear DSQ_SYNC bit of USB_CFGx register to specify the DATA0 PID for the following IN token transaction.
N  *             Base on this setting, hardware will toggle PID between DATA0 and DATA1 automatically for IN token transactions.
N  *
N  */
N#define USBD_SET_DATA0(ep)          (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFG + (uint32_t)((ep) << 4))) &= (~USBD_CFG_DSQSYNC_Msk))
N
N/**
N  * @brief      Set USB payload size (IN data)
N  *
N  * @param[in]  ep The USB endpoint ID. M451 Series supports 8 hardware endpoint ID. This parameter could be 0 ~ 7.
N  *
N  * @param[in]  size The transfer length.
N  *
N  * @return     None
N  *
N  * @details    This macro will write the transfer length to USB_MXPLDx register for IN data transaction.
N  *
N  */
N#define USBD_SET_PAYLOAD_LEN(ep, size)  (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].MXPLD + (uint32_t)((ep) << 4))) = (size))
N
N/**
N  * @brief      Get USB payload size (OUT data)
N  *
N  * @param[in]  ep The USB endpoint ID. M451 Series supports 8 endpoint ID. This parameter could be 0 ~ 7.
N  *
N  * @return     The value of USB_MXPLDx register.
N  *
N  * @details    Get the data length of OUT data transaction by reading USB_MXPLDx register.
N  *
N  */
N#define USBD_GET_PAYLOAD_LEN(ep)        ((uint32_t)*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].MXPLD + (uint32_t)((ep) << 4))))
N
N/**
N  * @brief      Configure endpoint
N  *
N  * @param[in]  ep The USB endpoint ID. M451 Series supports 8 hardware endpoint ID. This parameter could be 0 ~ 7.
N  *
N  * @param[in]  config The USB configuration.
N  *
N  * @return     None
N  *
N  * @details    This macro will write config parameter to USB_CFGx register of specified endpoint ID.
N  *
N  */
N#define USBD_CONFIG_EP(ep, config)      (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFG + (uint32_t)((ep) << 4))) = (config))
N
N/**
N  * @brief      Set USB endpoint buffer
N  *
N  * @param[in]  ep The USB endpoint ID. M451 Series supports 8 hardware endpoint ID. This parameter could be 0 ~ 7.
N  *
N  * @param[in]  offset The SRAM offset.
N  *
N  * @return     None
N  *
N  * @details    This macro will set the SRAM offset for the specified endpoint ID.
N  *
N  */
N#define USBD_SET_EP_BUF_ADDR(ep, offset)    (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].BUFSEG + (uint32_t)((ep) << 4))) = (offset))
N
N/**
N  * @brief      Get the offset of the specified USB endpoint buffer
N  *
N  * @param[in]  ep The USB endpoint ID. M451 Series supports 8 hardware endpoint ID. This parameter could be 0 ~ 7.
N  *
N  * @return     The offset of the specified endpoint buffer.
N  *
N  * @details    This macro will return the SRAM offset of the specified endpoint ID.
N  *
N  */
N#define USBD_GET_EP_BUF_ADDR(ep)        ((uint32_t)*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].BUFSEG + (uint32_t)((ep) << 4))))
N
N/**
N  * @brief       Set USB endpoint stall state
N  *
N  * @param[in]   ep  The USB endpoint ID. M451 Series supports 8 hardware endpoint ID. This parameter could be 0 ~ 7.
N  *
N  * @return      None
N  *
N  * @details     Set USB endpoint stall state for the specified endpoint ID. Endpoint will respond STALL token automatically.
N  *
N  */
N#define USBD_SET_EP_STALL(ep)        (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFGP + (uint32_t)((ep) << 4))) |= USBD_CFGP_SSTALL_Msk)
N
N/**
N  * @brief       Clear USB endpoint stall state
N  *
N  * @param[in]   ep  The USB endpoint ID. M451 Series supports 8 hardware endpoint ID. This parameter could be 0 ~ 7.
N  *
N  * @return      None
N  *
N  * @details     Clear USB endpoint stall state for the specified endpoint ID. Endpoint will respond ACK/NAK token.
N  */
N#define USBD_CLR_EP_STALL(ep)        (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFGP + (uint32_t)((ep) << 4))) &= ~USBD_CFGP_SSTALL_Msk)
N
N/**
N  * @brief       Get USB endpoint stall state
N  *
N  * @param[in]   ep  The USB endpoint ID. M451 Series supports 8 hardware endpoint ID. This parameter could be 0 ~ 7.
N  *
N  * @retval      0      USB endpoint is not stalled.
N  * @retval      Others USB endpoint is stalled.
N  *
N  * @details     Get USB endpoint stall state of the specified endpoint ID.
N  *
N  */
N#define USBD_GET_EP_STALL(ep)        (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFGP + (uint32_t)((ep) << 4))) & USBD_CFGP_SSTALL_Msk)
N
N/**
N  * @brief      To support byte access between USB SRAM and system SRAM
N  *
N  * @param[in]  dest Destination pointer.
N  *
N  * @param[in]  src  Source pointer.
N  *
N  * @param[in]  size Byte count.
N  *
N  * @return     None
N  *
N  * @details    This function will copy the number of data specified by size and src parameters to the address specified by dest parameter.
N  *
N  */
Nstatic __INLINE void USBD_MemCopy(uint8_t *dest, uint8_t *src, int32_t size)
Xstatic __inline void USBD_MemCopy(uint8_t *dest, uint8_t *src, int32_t size)
N{
N    while(size--) *dest++ = *src++;
N}
N
N
N/**
N  * @brief       Set USB endpoint stall state
N  *
N  * @param[in]   epnum  USB endpoint number
N  *
N  * @return      None
N  *
N  * @details     Set USB endpoint stall state. Endpoint will respond STALL token automatically.
N  *
N  */
Nstatic __INLINE void USBD_SetStall(uint8_t epnum)
Xstatic __inline void USBD_SetStall(uint8_t epnum)
N{
N    uint32_t u32CfgAddr;
N    uint32_t u32Cfg;
N    int i;
N
N    for(i = 0; i < USBD_MAX_EP; i++)
X    for(i = 0; i < 8; i++)
N    {
N        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFG; /* USBD_CFG0 */
X        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) (((0x40000000UL) + 0x00040000) + 0x80000))->EP[0].CFG;  
N        u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
X        u32Cfg = *((volatile uint32_t *)(u32CfgAddr));
N
N        if((u32Cfg & 0xf) == epnum)
N        {
N            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFGP; /* USBD_CFGP0 */
X            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) (((0x40000000UL) + 0x00040000) + 0x80000))->EP[0].CFGP;  
N            u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
X            u32Cfg = *((volatile uint32_t *)(u32CfgAddr));
N
N            *((__IO uint32_t *)(u32CfgAddr)) = (u32Cfg | USBD_CFGP_SSTALL);
X            *((volatile uint32_t *)(u32CfgAddr)) = (u32Cfg | (0x1ul << (1)));
N            break;
N        }
N    }
N}
N
N/**
N  * @brief       Clear USB endpoint stall state
N  *
N  * @param[in]   epnum  USB endpoint number
N  *
N  * @return      None
N  *
N  * @details     Clear USB endpoint stall state. Endpoint will respond ACK/NAK token.
N  */
Nstatic __INLINE void USBD_ClearStall(uint8_t epnum)
Xstatic __inline void USBD_ClearStall(uint8_t epnum)
N{
N    uint32_t u32CfgAddr;
N    uint32_t u32Cfg;
N    int i;
N
N    for(i = 0; i < USBD_MAX_EP; i++)
X    for(i = 0; i < 8; i++)
N    {
N        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFG; /* USBD_CFG0 */
X        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) (((0x40000000UL) + 0x00040000) + 0x80000))->EP[0].CFG;  
N        u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
X        u32Cfg = *((volatile uint32_t *)(u32CfgAddr));
N
N        if((u32Cfg & 0xf) == epnum)
N        {
N            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFGP; /* USBD_CFGP0 */
X            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) (((0x40000000UL) + 0x00040000) + 0x80000))->EP[0].CFGP;  
N            u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
X            u32Cfg = *((volatile uint32_t *)(u32CfgAddr));
N
N            *((__IO uint32_t *)(u32CfgAddr)) = (u32Cfg & ~USBD_CFGP_SSTALL);
X            *((volatile uint32_t *)(u32CfgAddr)) = (u32Cfg & ~(0x1ul << (1)));
N            break;
N        }
N    }
N}
N
N/**
N  * @brief       Get USB endpoint stall state
N  *
N  * @param[in]   epnum  USB endpoint number
N  *
N  * @retval      0      USB endpoint is not stalled.
N  * @retval      Others USB endpoint is stalled.
N  *
N  * @details     Get USB endpoint stall state.
N  *
N  */
Nstatic __INLINE uint32_t USBD_GetStall(uint8_t epnum)
Xstatic __inline uint32_t USBD_GetStall(uint8_t epnum)
N{
N    uint32_t u32CfgAddr;
N    uint32_t u32Cfg;
N    int i;
N
N    for(i = 0; i < USBD_MAX_EP; i++)
X    for(i = 0; i < 8; i++)
N    {
N        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFG; /* USBD_CFG0 */
X        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) (((0x40000000UL) + 0x00040000) + 0x80000))->EP[0].CFG;  
N        u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
X        u32Cfg = *((volatile uint32_t *)(u32CfgAddr));
N
N        if((u32Cfg & 0xf) == epnum)
N        {
N            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFGP; /* USBD_CFGP0 */
X            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) (((0x40000000UL) + 0x00040000) + 0x80000))->EP[0].CFGP;  
N            break;
N        }
N    }
N
N    return ((*((__IO uint32_t *)(u32CfgAddr))) & USBD_CFGP_SSTALL);
X    return ((*((volatile uint32_t *)(u32CfgAddr))) & (0x1ul << (1)));
N}
N
N
Nextern volatile uint8_t g_usbd_RemoteWakeupEn;
N
N
Ntypedef void (*VENDOR_REQ)(void);           /*!< Functional pointer type definition for Vendor class */
Ntypedef void (*CLASS_REQ)(void);            /*!< Functional pointer type declaration for USB class request callback handler */
Ntypedef void (*SET_INTERFACE_REQ)(void);    /*!< Functional pointer type declaration for USB set interface request callback handler */
Ntypedef void (*SET_CONFIG_CB)(void);       /*!< Functional pointer type declaration for USB set configuration request callback handler */
N
N
N/*--------------------------------------------------------------------*/
Nvoid USBD_Open(const S_USBD_INFO_T *param, CLASS_REQ pfnClassReq, SET_INTERFACE_REQ pfnSetInterface);
Nvoid USBD_Start(void);
Nvoid USBD_GetSetupPacket(uint8_t *buf);
Nvoid USBD_ProcessSetupPacket(void);
Nvoid USBD_StandardRequest(void);
Nvoid USBD_PrepareCtrlIn(uint8_t *pu8Buf, uint32_t u32Size);
Nvoid USBD_CtrlIn(void);
Nvoid USBD_PrepareCtrlOut(uint8_t *pu8Buf, uint32_t u32Size);
Nvoid USBD_CtrlOut(void);
Nvoid USBD_SwReset(void);
Nvoid USBD_SetVendorRequest(VENDOR_REQ pfnVendorReq);
Nvoid USBD_SetConfigCallback(SET_CONFIG_CB pfnSetConfigCallback);
Nvoid USBD_LockEpStall(uint32_t u32EpBitmap);
N
N/*@}*/ /* end of group USBD_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group USBD_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N
N#endif //__USBD_H__
N
N/*** (C) COPYRIGHT 2014~2015 Nuvoton Technology Corp. ***/
L 17111 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N#include "fmc.h"
L 1 "..\..\..\..\Library\StdDriver\inc\fmc.h" 1
N/**************************************************************************//**
N * @file     FMC.h
N * @version  V2.1
N * $Revision: 19 $
N * $Date: 15/08/11 10:26a $
N * @brief    M451 Series Flash Memory Controller Driver Header File
N *
N * @note
N * Copyright (C) 2011~2015 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __FMC_H__
N#define __FMC_H__
N
N#include "M451Series.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup FMC_Driver FMC Driver
N  @{
N*/
N
N/** @addtogroup FMC_EXPORTED_CONSTANTS FMC Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Global constant definitions                                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ISBEN   0
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define Base Address                                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_APROM_BASE          0x00000000UL    /*!< APROM  Base Address         */
N#define FMC_LDROM_BASE          0x00100000UL    /*!< LDROM  Base Address         */
N#define FMC_SPROM_BASE          0x00200000UL    /*!< SPROM  Base Address         */
N#define FMC_CONFIG_BASE         0x00300000UL    /*!< CONFIG Base Address         */
N
N#define FMC_CONFIG0_ADDR        (FMC_CONFIG_BASE)       /*!< CONFIG 0 Address */
N#define FMC_CONFIG1_ADDR        (FMC_CONFIG_BASE + 4)   /*!< CONFIG 1 Address */
N
N
N#define FMC_FLASH_PAGE_SIZE     0x800           /*!< Flash Page Size (2048 Bytes) */
N#define FMC_LDROM_SIZE          0x1000          /*!< LDROM Size (4 kBytes)       */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ISPCTL constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_ISPCTL_BS_LDROM     0x2     /*!< ISPCTL setting to select to boot from LDROM */
N#define FMC_ISPCTL_BS_APROM     0x0     /*!< ISPCTL setting to select to boot from APROM */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ISPCMD constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_ISPCMD_READ         0x00     /*!< ISP Command: Read Flash               */
N#define FMC_ISPCMD_PROGRAM      0x21     /*!< ISP Command: 32-bit Program Flash     */
N#define FMC_ISPCMD_WRITE_8      0x61     /*!< ISP Command: 64-bit program Flash     */
N#define FMC_ISPCMD_PAGE_ERASE   0x22     /*!< ISP Command: Page Erase Flash         */
N#define FMC_ISPCMD_READ_CID     0x0B     /*!< ISP Command: Read Company ID          */
N#define FMC_ISPCMD_READ_UID     0x04     /*!< ISP Command: Read Unique ID           */
N#define FMC_ISPCMD_READ_DID     0x0C     /*!< ISP Command: Read Device ID           */
N#define FMC_ISPCMD_VECMAP       0x2E     /*!< ISP Command: Set vector mapping       */
N#define FMC_ISPCMD_CHECKSUM     0x0D     /*!< ISP Command: Read Checksum            */
N#define FMC_ISPCMD_CAL_CHECKSUM 0x2D     /*!< ISP Command: Run Check Calculation    */
N#define FMC_ISPCMD_MULTI_PROG   0x27     /*!< ISP Command: Flash Multi-Word Program */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  FTCTL constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_FTCTL_OPTIMIZE_DISABLE      0x00       /*!< Frequency Optimize Mode disable */
N#define FMC_FTCTL_OPTIMIZE_12MHZ        0x01       /*!< Frequency Optimize Mode <= 12Mhz */
N#define FMC_FTCTL_OPTIMIZE_36MHZ        0x02       /*!< Frequency Optimize Mode <= 36Mhz */
N#define FMC_FTCTL_OPTIMIZE_60MHZ        0x04       /*!< Frequency Optimize Mode <= 60Mhz */
N#define FMC_FTCTL_OPTIMIZE_72MHZ        0x05       /*!< Frequency Optimize Mode <= 72Mhz */
N
N/*@}*/ /* end of group FMC_EXPORTED_CONSTANTS */
N
N/** @addtogroup FMC_EXPORTED_FUNCTIONS FMC Exported Functions
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  FMC Macro Definitions                                                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Enable ISP Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set ISPEN bit of ISPCTL control register to enable ISP function.
N *
N */
N#define FMC_ENABLE_ISP()          (FMC->ISPCTL |=  FMC_ISPCTL_ISPEN_Msk)  /*!< Enable ISP Function  */
N
N/**
N * @brief      Disable ISP Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will clear ISPEN bit of ISPCTL control register to disable ISP function.
N *
N */
N#define FMC_DISABLE_ISP()         (FMC->ISPCTL &= ~FMC_ISPCTL_ISPEN_Msk)  /*!< Disable ISP Function */
N
N/**
N * @brief      Enable LDROM Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set LDUEN bit of ISPCTL control register to enable LDROM update function.
N *             User needs to set LDUEN bit before they can update LDROM.
N *
N */
N#define FMC_ENABLE_LD_UPDATE()    (FMC->ISPCTL |=  FMC_ISPCTL_LDUEN_Msk)  /*!< Enable LDROM Update Function   */
N
N/**
N * @brief      Disable LDROM Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set ISPEN bit of ISPCTL control register to disable LDROM update function.
N *
N */
N#define FMC_DISABLE_LD_UPDATE()   (FMC->ISPCTL &= ~FMC_ISPCTL_LDUEN_Msk)  /*!< Disable LDROM Update Function  */
N
N/**
N * @brief      Enable User Configuration Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set CFGUEN bit of ISPCTL control register to enable User Configuration update function.
N *             User needs to set CFGUEN bit before they can update User Configuration area.
N *
N */
N#define FMC_ENABLE_CFG_UPDATE()   (FMC->ISPCTL |=  FMC_ISPCTL_CFGUEN_Msk) /*!< Enable CONFIG Update Function  */
N
N/**
N * @brief      Disable User Configuration Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will clear CFGUEN bit of ISPCTL control register to disable User Configuration update function.
N *
N */
N#define FMC_DISABLE_CFG_UPDATE()  (FMC->ISPCTL &= ~FMC_ISPCTL_CFGUEN_Msk) /*!< Disable CONFIG Update Function */
N
N
N/**
N * @brief      Enable APROM Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set APUEN bit of ISPCTL control register to enable APROM update function.
N *             User needs to set APUEN bit before they can update APROM in APROM boot mode.
N *
N */
N#define FMC_ENABLE_AP_UPDATE()    (FMC->ISPCTL |=  FMC_ISPCTL_APUEN_Msk)  /*!< Enable APROM Update Function   */
N
N/**
N * @brief      Disable APROM Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will clear APUEN bit of ISPCTL control register to disable APROM update function.
N *
N */
N#define FMC_DISABLE_AP_UPDATE()   (FMC->ISPCTL &= ~FMC_ISPCTL_APUEN_Msk)  /*!< Disable APROM Update Function  */
N
N/**
N * @brief      Next Booting Selection function
N *
N * @param[in]  x   Booting from APROM(0)/LDROM(1)
N *
N * @return     None
N *
N * @details    This function will set MCU next booting from LDROM/APROM.
N *
N * @note       When use this macro, the Boot Loader booting selection MBS(CONFIG0[5]) must be set.
N *
N */
N#define FMC_SELECT_NEXT_BOOT(x)   (FMC->ISPCTL = (FMC->ISPCTL & ~FMC_ISPCTL_BS_Msk) | ((x) << FMC_ISPCTL_BS_Pos)) /*!< Select Next Booting, x = 0 or 1 */
N
N/**
N * @brief      Get MCU Booting Status
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will get status of chip next booting from LDROM/APROM.
N *
N */
N#define FMC_GET_BOOT_STATUS()     ((FMC->ISPCTL & FMC_ISPCTL_BS_Msk)?1:0) /*!< Get MCU Booting Status */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* inline functions                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Program 32-bit data into specified address of flash
N *
N * @param[in]  u32Addr  Flash address include APROM, LDROM, Data Flash, and CONFIG
N * @param[in]  u32Data  32-bit Data to program
N *
N * @return     None
N *
N * @details    To program word data into Flash include APROM, LDROM, Data Flash, and CONFIG.
N *             The corresponding functions in CONFIG are listed in FMC section of Technical Reference Manual.
N *
N */
Nstatic __INLINE void FMC_Write(uint32_t u32Addr, uint32_t u32Data)
Xstatic __inline void FMC_Write(uint32_t u32Addr, uint32_t u32Data)
N{
N    FMC->ISPCMD = FMC_ISPCMD_PROGRAM;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPCMD = 0x21;
N    FMC->ISPADDR = u32Addr;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPADDR = u32Addr;
N    FMC->ISPDAT = u32Data;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPDAT = u32Data;
N    FMC->ISPTRG = 0x1;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPTRG = 0x1;
N#if ISBEN
X#if 0
S    __ISB();
N#endif
N    while(FMC->ISPTRG);
X    while(((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPTRG);
N}
N
N/**
N * @brief      Program 64-bit data into specified address of flash
N *
N * @param[in]  u32Addr  Flash address include APROM, LDROM, Data Flash, and CONFIG
N * @param[in]  u32Data0 32-bit Data to program
N * @param[in]  u32Data1 32-bit Data to program
N *
N * @return     None
N *
N * @details    To program two words data into Flash include APROM, LDROM, Data Flash, and CONFIG.
N *             The corresponding functions in CONFIG are listed in FMC section of Technical Reference Manual.
N *
N */
Nstatic __INLINE void FMC_Write8(uint32_t u32Addr, uint32_t u32Data0, uint32_t u32Data1)
Xstatic __inline void FMC_Write8(uint32_t u32Addr, uint32_t u32Data0, uint32_t u32Data1)
N{
N    FMC->ISPCMD = FMC_ISPCMD_WRITE_8;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPCMD = 0x61;
N    FMC->ISPADDR = u32Addr;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPADDR = u32Addr;
N    FMC->MPDAT0 = u32Data0;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->MPDAT0 = u32Data0;
N    FMC->MPDAT1 = u32Data1;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->MPDAT1 = u32Data1;
N    FMC->ISPTRG = 0x1;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPTRG = 0x1;
N#if ISBEN
X#if 0
S    __ISB();
N#endif
N    while(FMC->ISPTRG);
X    while(((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPTRG);
N}
N
N
N/**
N * @brief       Read 32-bit Data from specified address of flash
N *
N * @param[in]   u32Addr  Flash address include APROM, LDROM, Data Flash, and CONFIG
N *
N * @return      The data of specified address
N *
N * @details     To read word data from Flash include APROM, LDROM, Data Flash, and CONFIG.
N *
N */
Nstatic __INLINE uint32_t FMC_Read(uint32_t u32Addr)
Xstatic __inline uint32_t FMC_Read(uint32_t u32Addr)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPCMD = 0x00;
N    FMC->ISPADDR = u32Addr;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPADDR = u32Addr;
N    FMC->ISPDAT = 0;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPDAT = 0;
N    FMC->ISPTRG = 0x1;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPTRG = 0x1;
N#if ISBEN
X#if 0
S    __ISB();
N#endif
N    while(FMC->ISPTRG);
X    while(((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPTRG);
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPDAT;
N}
N
N/**
N * @brief      Flash page erase
N *
N * @param[in]  u32Addr  Flash address including APROM, LDROM, Data Flash, and CONFIG
N *
N * @details    To do flash page erase. The target address could be APROM, LDROM, Data Flash, or CONFIG.
N *             The page size is 2048 bytes.
N *
N * @retval      0 Success
N * @retval     -1 Erase failed
N *
N */
Nstatic __INLINE int32_t FMC_Erase(uint32_t u32Addr)
Xstatic __inline int32_t FMC_Erase(uint32_t u32Addr)
N{
N    FMC->ISPCMD = FMC_ISPCMD_PAGE_ERASE;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPCMD = 0x22;
N    FMC->ISPADDR = u32Addr;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPADDR = u32Addr;
N    FMC->ISPTRG = 0x1;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPTRG = 0x1;
N#if ISBEN
X#if 0
S    __ISB();
N#endif
N    while(FMC->ISPTRG);
X    while(((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPTRG);
N
N    /* Check ISPFF flag to know whether erase OK or fail. */
N    if(FMC->ISPCTL & FMC_ISPCTL_ISPFF_Msk)
X    if(((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPCTL & (0x1ul << (6)))
N    {
N        FMC->ISPCTL |= FMC_ISPCTL_ISPFF_Msk;
X        ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPCTL |= (0x1ul << (6));
N        return -1;
N    }
N    return 0;
N}
N
N/**
N * @brief       Read Unique ID
N *
N * @param[in]   u8Index  UID index. 0 = UID[31:0], 1 = UID[63:32], 2 = UID[95:64]
N *
N * @return      The 32-bit unique ID data of specified UID index.
N *
N * @details     To read out 96-bit Unique ID.
N *
N */
Nstatic __INLINE uint32_t FMC_ReadUID(uint8_t u8Index)
Xstatic __inline uint32_t FMC_ReadUID(uint8_t u8Index)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ_UID;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPCMD = 0x04;
N    FMC->ISPADDR = (u8Index << 2);
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPADDR = (u8Index << 2);
N    FMC->ISPDAT = 0;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPDAT = 0;
N    FMC->ISPTRG = 0x1;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPTRG = 0x1;
N#if ISBEN
X#if 0
S    __ISB();
N#endif
N    while(FMC->ISPTRG);
X    while(((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPTRG);
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPDAT;
N}
N
N/**
N  * @brief    Read company ID
N  *
N  * @param    None
N  *
N  * @return   The company ID (32-bit)
N  *
N  * @details  The company ID of Nuvoton is fixed to be 0xDA
N  *
N  */
Nstatic __INLINE uint32_t FMC_ReadCID(void)
Xstatic __inline uint32_t FMC_ReadCID(void)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ_CID;           /* Set ISP Command Code */
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPCMD = 0x0B;            
N    FMC->ISPADDR = 0x0;                          /* Must keep 0x0 when read CID */
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPADDR = 0x0;                           
N    FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;          /* Trigger to start ISP procedure */
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPTRG = (0x1ul << (0));           
N#if ISBEN
X#if 0
S    __ISB();
N#endif                                    /* To make sure ISP/CPU be Synchronized */
N    while(FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk) ;  /* Waiting for ISP Done */
X    while(((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPTRG & (0x1ul << (0))) ;   
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPDAT;
N}
N
N/**
N  * @brief    Read product ID
N  *
N  * @param    None
N  *
N  * @return   The product ID (32-bit)
N  *
N  * @details  This function is used to read product ID.
N  *
N  */
Nstatic __INLINE uint32_t FMC_ReadPID(void)
Xstatic __inline uint32_t FMC_ReadPID(void)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ_DID;          /* Set ISP Command Code */
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPCMD = 0x0C;           
N    FMC->ISPADDR = 0x04;                         /* Must keep 0x4 when read PID */
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPADDR = 0x04;                          
N    FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;         /* Trigger to start ISP procedure */
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPTRG = (0x1ul << (0));          
N#if ISBEN
X#if 0
S    __ISB();
N#endif                                     /* To make sure ISP/CPU be Synchronized */
N    while(FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk);  /* Waiting for ISP Done */
X    while(((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPTRG & (0x1ul << (0)));   
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPDAT;
N}
N
N/**
N  * @brief      To read UCID
N  *
N  * @param[in]  u32Index    Index of the UCID to read. u32Index must be 0, 1, 2, or 3.
N  *
N  * @return     The UCID of specified index
N  *
N  * @details    This function is used to read unique chip ID (UCID).
N  *
N  */
Nstatic __INLINE uint32_t FMC_ReadUCID(uint32_t u32Index)
Xstatic __inline uint32_t FMC_ReadUCID(uint32_t u32Index)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ_UID;          /* Set ISP Command Code */
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPCMD = 0x04;           
N    FMC->ISPADDR = (0x04 * u32Index) + 0x10;     /* The UCID is at offset 0x10 with word alignment. */
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPADDR = (0x04 * u32Index) + 0x10;      
N    FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;         /* Trigger to start ISP procedure */
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPTRG = (0x1ul << (0));          
N#if ISBEN
X#if 0
S    __ISB();
N#endif                                     /* To make sure ISP/CPU be Synchronized */
N    while(FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk);  /* Waiting for ISP Done */
X    while(((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPTRG & (0x1ul << (0)));   
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPDAT;
N}
N
N/**
N * @brief       Set vector mapping address
N *
N * @param[in]   u32PageAddr  The page address to remap to address 0x0. The address must be page alignment.
N *
N * @return      To set VECMAP to remap specified page address to 0x0.
N *
N * @details     This function is used to set VECMAP to map specified page to vector page (0x0).
N *
N * @note
N *              VECMAP only valid when new IAP function is enabled. (CBS = 10'b or 00'b)
N *
N */
Nstatic __INLINE void FMC_SetVectorPageAddr(uint32_t u32PageAddr)
Xstatic __inline void FMC_SetVectorPageAddr(uint32_t u32PageAddr)
N{
N    FMC->ISPCMD = FMC_ISPCMD_VECMAP; /* Set ISP Command Code */
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPCMD = 0x2E;  
N    FMC->ISPADDR = u32PageAddr;       /* The address of specified page which will be map to address 0x0. It must be page alignment. */
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPADDR = u32PageAddr;        
N    FMC->ISPTRG = 0x1;               /* Trigger to start ISP procedure */
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPTRG = 0x1;                
N#if ISBEN
X#if 0
S    __ISB();
N#endif                         /* To make sure ISP/CPU be Synchronized */
N    while(FMC->ISPTRG);              /* Waiting for ISP Done */
X    while(((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPTRG);               
N}
N
N/**
N * @brief       Get current vector mapping address.
N *
N * @param       None
N *
N * @return      The current vector mapping address.
N *
N * @details     To get VECMAP value which is the page address for remapping to vector page (0x0).
N *
N * @note
N *              VECMAP only valid when new IAP function is enabled. (CBS = 10'b or 00'b)
N *
N */
Nstatic __INLINE uint32_t FMC_GetVECMAP(void)
Xstatic __inline uint32_t FMC_GetVECMAP(void)
N{
N    return (FMC->ISPSTS & FMC_ISPSTS_VECMAP_Msk);
X    return (((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPSTS & (0x7ffful << (9)));
N}
N
N/**
N * @brief       Get Flash Checksum
N *
N * @param[in]   u32Addr    Specific flash start address
N * @param[in]   i32Size    Specific a size of Flash area
N *
N * @return      A checksum value of a flash block.
N *
N * @details     To get VECMAP value which is the page address for remapping to vector page (0x0).
N *
N */
Nstatic __INLINE uint32_t FMC_GetCheckSum(uint32_t u32Addr, int32_t i32Size)
Xstatic __inline uint32_t FMC_GetCheckSum(uint32_t u32Addr, int32_t i32Size)
N{
N    FMC->ISPCMD = FMC_ISPCMD_CAL_CHECKSUM;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPCMD = 0x2D;
N    FMC->ISPADDR = u32Addr;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPADDR = u32Addr;
N    FMC->ISPDAT = i32Size;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPDAT = i32Size;
N    FMC->ISPTRG = 0x1;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPTRG = 0x1;
N#if ISBEN
X#if 0
S    __ISB();
N#endif
N    while(FMC->ISPTRG);
X    while(((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPTRG);
N
N    FMC->ISPCMD = FMC_ISPCMD_CHECKSUM;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPCMD = 0x0D;
N    FMC->ISPTRG = 0x1;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPTRG = 0x1;
N    while(FMC->ISPTRG);
X    while(((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPTRG);
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPDAT;
N}
N
N/**
N * @brief      Program Multi-Word data into specified address of flash
N *
N * @param[in]  u32Addr  Flash address include APROM, LDROM, Data Flash, and CONFIG
N * @param[in]  pu32Buf  A data pointer is point to a data buffer start address;
N *
N * @return     None
N *
N * @details    To program multi-words data into Flash include APROM, LDROM, Data Flash, and CONFIG.
N *             The corresponding functions in CONFIG are listed in FMC section of Technical Reference Manual.
N *
N */
Nstatic __INLINE void FMC_Write256(uint32_t u32Addr, uint32_t *pu32Buf)
Xstatic __inline void FMC_Write256(uint32_t u32Addr, uint32_t *pu32Buf)
N{
N    int32_t i, idx;
N    volatile uint32_t *pu32IspData;
N    //int32_t i32Err;
N
N    //i32Err = 0;
N    idx = 0;
N    FMC->ISPCMD = FMC_ISPCMD_MULTI_PROG;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPCMD = 0x27;
N    FMC->ISPADDR = u32Addr;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPADDR = u32Addr;
N
Nretrigger:
N
N    //if(i32Err)
N    //    printf("idx=%d  ISPADDR = 0x%08x\n",idx, FMC->ISPADDR);
N
N    FMC->MPDAT0 = pu32Buf[idx + 0];
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->MPDAT0 = pu32Buf[idx + 0];
N    FMC->MPDAT1 = pu32Buf[idx + 1];
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->MPDAT1 = pu32Buf[idx + 1];
N    FMC->MPDAT2 = pu32Buf[idx + 2];
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->MPDAT2 = pu32Buf[idx + 2];
N    FMC->MPDAT3 = pu32Buf[idx + 3];
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->MPDAT3 = pu32Buf[idx + 3];
N
N
N
N    FMC->ISPTRG = 0x1;
X    ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPTRG = 0x1;
N
N    pu32IspData = &FMC->MPDAT0;
X    pu32IspData = &((FMC_T *) ((0x40000000UL) + 0x0C000))->MPDAT0;
N    idx += 4;
N
N    for(i = idx; i < 256 / 4; i += 4) // Max data length is 256 bytes (256/4 words)
N    {
N
N        __set_PRIMASK(1); // Mask interrupt to avoid status check coherence error
N        do
N        {
N            if((FMC->MPSTS & FMC_MPSTS_MPBUSY_Msk) == 0)
X            if((((FMC_T *) ((0x40000000UL) + 0x0C000))->MPSTS & (0x1ul << (0))) == 0)
N            {
N                __set_PRIMASK(0);
N                //printf("%d %x\n", i, FMC->MPADDR);
N                FMC->ISPADDR = FMC->MPADDR & (~0xful);
X                ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPADDR = ((FMC_T *) ((0x40000000UL) + 0x0C000))->MPADDR & (~0xful);
N                idx = (FMC->ISPADDR - u32Addr) / 4;
X                idx = (((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPADDR - u32Addr) / 4;
N                //i32Err = -1;
N                goto retrigger;
N            }
N        }
N        while(FMC->MPSTS & (3 << FMC_MPSTS_D0_Pos));
X        while(((FMC_T *) ((0x40000000UL) + 0x0C000))->MPSTS & (3 << (4)));
N
N        // Update new data for D0
N        pu32IspData[0] = pu32Buf[i  ];
N        pu32IspData[1] = pu32Buf[i + 1];
N
N        do
N        {
N            if((FMC->MPSTS & FMC_MPSTS_MPBUSY_Msk) == 0)
X            if((((FMC_T *) ((0x40000000UL) + 0x0C000))->MPSTS & (0x1ul << (0))) == 0)
N            {
N                __set_PRIMASK(0);
N                //printf("%d %x\n", i, FMC->MPADDR);
N                FMC->ISPADDR = FMC->MPADDR & (~0xful);
X                ((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPADDR = ((FMC_T *) ((0x40000000UL) + 0x0C000))->MPADDR & (~0xful);
N                idx = (FMC->ISPADDR - u32Addr) / 4;
X                idx = (((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPADDR - u32Addr) / 4;
N                //i32Err = -1;
N                goto retrigger;
N            }
N        }
N        while(FMC->MPSTS & (3 << FMC_MPSTS_D2_Pos));
X        while(((FMC_T *) ((0x40000000UL) + 0x0C000))->MPSTS & (3 << (6)));
N
N        // Update new data for D2
N        pu32IspData[2] = pu32Buf[i + 2];
N        pu32IspData[3] = pu32Buf[i + 3];
N        __set_PRIMASK(0);
N    }
N
N    while(FMC->ISPSTS & FMC_ISPSTS_ISPBUSY_Msk);
X    while(((FMC_T *) ((0x40000000UL) + 0x0C000))->ISPSTS & (0x1ul << (0)));
N}
N
Nvoid FMC_Open(void);
Nvoid FMC_Close(void);
Nvoid FMC_EnableAPUpdate(void);
Nvoid FMC_DisableAPUpdate(void);
Nvoid FMC_EnableConfigUpdate(void);
Nvoid FMC_DisableConfigUpdate(void);
Nvoid FMC_EnableLDUpdate(void);
Nvoid FMC_DisableLDUpdate(void);
Nint32_t FMC_ReadConfig(uint32_t *u32Config, uint32_t u32Count);
Nint32_t FMC_WriteConfig(uint32_t *u32Config, uint32_t u32Count);
Nvoid FMC_SetBootSource(int32_t i32BootSrc);
Nint32_t FMC_GetBootSource(void);
Nuint32_t FMC_ReadDataFlashBaseAddr(void);
Nvoid FMC_EnableFreqOptimizeMode(uint32_t u32Mode);
Nvoid FMC_DisableFreqOptimizeMode(void);
N/*@}*/ /* end of group FMC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group FMC_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif
N
L 17112 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N#include "uart.h"
L 1 "..\..\..\..\Library\StdDriver\inc\uart.h" 1
N/******************************************************************************
N * @file     uart.h
N * @version  V3.00
N * $Revision: 36 $
N * $Date: 15/08/11 10:26a $
N * @brief    M451 series UART driver header file
N *
N * @note
N * Copyright (C) 2013~2015 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef __UART_H__
N#define __UART_H__
N
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup UART_Driver UART Driver
N  @{
N*/
N
N/** @addtogroup UART_EXPORTED_CONSTANTS UART Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART FIFO size constants definitions                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#define UART0_FIFO_SIZE 16 /*!< UART0 supports separated receive/transmit 16/16 bytes entry FIFO */
N#define UART1_FIFO_SIZE 16 /*!< UART1 supports separated receive/transmit 16/16 bytes entry FIFO */
N#define UART2_FIFO_SIZE 16 /*!< UART2 supports separated receive/transmit 16/16 bytes entry FIFO */    
N#define UART3_FIFO_SIZE 16 /*!< UART3 supports separated receive/transmit 16/16 bytes entry FIFO */    
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART_FIFO constants definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#define UART_FIFO_RFITL_1BYTE      (0x0 << UART_FIFO_RFITL_Pos)   /*!< UART_FIFO setting to set RX FIFO Trigger Level to 1 byte */
N#define UART_FIFO_RFITL_4BYTES     (0x1 << UART_FIFO_RFITL_Pos)   /*!< UART_FIFO setting to set RX FIFO Trigger Level to 4 bytes */
N#define UART_FIFO_RFITL_8BYTES     (0x2 << UART_FIFO_RFITL_Pos)   /*!< UART_FIFO setting to set RX FIFO Trigger Level to 8 bytes */
N#define UART_FIFO_RFITL_14BYTES    (0x3 << UART_FIFO_RFITL_Pos)   /*!< UART_FIFO setting to set RX FIFO Trigger Level to 14 bytes */
N
N#define UART_FIFO_RTSTRGLV_1BYTE      (0x0 << UART_FIFO_RTSTRGLV_Pos)  /*!< UART_FIFO setting to set RTS Trigger Level to 1 byte */
N#define UART_FIFO_RTSTRGLV_4BYTES     (0x1 << UART_FIFO_RTSTRGLV_Pos)  /*!< UART_FIFO setting to set RTS Trigger Level to 4 bytes */
N#define UART_FIFO_RTSTRGLV_8BYTES     (0x2 << UART_FIFO_RTSTRGLV_Pos)  /*!< UART_FIFO setting to set RTS Trigger Level to 8 bytes */
N#define UART_FIFO_RTSTRGLV_14BYTES    (0x3 << UART_FIFO_RTSTRGLV_Pos)  /*!< UART_FIFO setting to set RTS Trigger Level to 14 bytes */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART_LINE constants definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_WORD_LEN_5     (0) /*!< UART_LINE setting to set UART word length to 5 bits */
N#define UART_WORD_LEN_6     (1) /*!< UART_LINE setting to set UART word length to 6 bits */
N#define UART_WORD_LEN_7     (2) /*!< UART_LINE setting to set UART word length to 7 bits */
N#define UART_WORD_LEN_8     (3) /*!< UART_LINE setting to set UART word length to 8 bits */
N
N#define UART_PARITY_NONE    (0x0 << UART_LINE_PBE_Pos) /*!< UART_LINE setting to set UART as no parity   */
N#define UART_PARITY_ODD     (0x1 << UART_LINE_PBE_Pos) /*!< UART_LINE setting to set UART as odd parity  */
N#define UART_PARITY_EVEN    (0x3 << UART_LINE_PBE_Pos) /*!< UART_LINE setting to set UART as even parity */
N#define UART_PARITY_MARK    (0x5 << UART_LINE_PBE_Pos) /*!< UART_LINE setting to keep parity bit as '1'  */
N#define UART_PARITY_SPACE   (0x7 << UART_LINE_PBE_Pos) /*!< UART_LINE setting to keep parity bit as '0'  */
N
N#define UART_STOP_BIT_1     (0x0 << UART_LINE_NSB_Pos) /*!< UART_LINE setting for one stop bit  */
N#define UART_STOP_BIT_1_5   (0x1 << UART_LINE_NSB_Pos) /*!< UART_LINE setting for 1.5 stop bit when 5-bit word length  */
N#define UART_STOP_BIT_2     (0x1 << UART_LINE_NSB_Pos) /*!< UART_LINE setting for two stop bit when 6, 7, 8-bit word length */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART RTS ACTIVE LEVEL constants definitions                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_RTS_IS_LOW_LEV_ACTIVE   (0x1 << UART_MODEM_RTSACTLV_Pos) /*!< Set RTS is Low Level Active */
N#define UART_RTS_IS_HIGH_LEV_ACTIVE  (0x0 << UART_MODEM_RTSACTLV_Pos) /*!< Set RTS is High Level Active */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART_IRDA constants definitions                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_IRDA_TXEN      (0x1 << UART_IRDA_TXEN_Pos) /*!< Set IrDA function Tx mode */
N#define UART_IRDA_RXEN      (0x0 << UART_IRDA_TXEN_Pos) /*!< Set IrDA function Rx mode */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART_FUNCSEL constants definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_FUNCSEL_UART  (0x0 << UART_FUNCSEL_FUNCSEL_Pos) /*!< UART_FUNCSEL setting to set UART Function  (Default) */
N#define UART_FUNCSEL_LIN   (0x1 << UART_FUNCSEL_FUNCSEL_Pos) /*!< UART_FUNCSEL setting to set LIN Function             */
N#define UART_FUNCSEL_IrDA  (0x2 << UART_FUNCSEL_FUNCSEL_Pos) /*!< UART_FUNCSEL setting to set IrDA Function            */
N#define UART_FUNCSEL_RS485 (0x3 << UART_FUNCSEL_FUNCSEL_Pos) /*!< UART_FUNCSEL setting to set RS485 Function           */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART_LINCTL constants definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_LINCTL_BRKFL(x)    (((x)-1) << UART_LINCTL_BRKFL_Pos)  /*!< UART_LINCTL setting to set LIN Break Field Length, x = 10 ~ 15, default value is 12 */
N#define UART_LINCTL_BSL(x)      (((x)-1) << UART_LINCTL_BSL_Pos)    /*!< UART_LINCTL setting to set LIN Break/Sync Delimiter Length, x = 1 ~ 4 */
N#define UART_LINCTL_HSEL_BREAK             (0x0UL << UART_LINCTL_HSEL_Pos)    /*!< UART_LINCTL setting to set LIN Header Select to break field */
N#define UART_LINCTL_HSEL_BREAK_SYNC        (0x1UL << UART_LINCTL_HSEL_Pos)    /*!< UART_LINCTL setting to set LIN Header Select to break field and sync field */
N#define UART_LINCTL_HSEL_BREAK_SYNC_ID     (0x2UL << UART_LINCTL_HSEL_Pos)    /*!< UART_LINCTL setting to set LIN Header Select to break field, sync field and ID field*/
N#define UART_LINCTL_PID(x)      ((x) << UART_LINCTL_PID_Pos)       /*!< UART_LINCTL setting to set LIN PID value */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART BAUDRATE MODE constants definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_BAUD_MODE0     (0) /*!< Set UART Baudrate Mode is Mode0 */
N#define UART_BAUD_MODE2     (UART_BAUD_BAUDM1_Msk | UART_BAUD_BAUDM0_Msk) /*!< Set UART Baudrate Mode is Mode2 */
N
N
N/*@}*/ /* end of group UART_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup UART_EXPORTED_FUNCTIONS UART Exported Functions
N  @{
N*/
N
N
N/**
N *    @brief        Calculate UART baudrate mode0 divider
N *
N *    @param[in]    u32SrcFreq      UART clock frequency
N *    @param[in]    u32BaudRate     Baudrate of UART module
N *
N *    @return       UART baudrate mode0 divider
N *
N *    @details      This macro calculate UART baudrate mode0 divider.
N */
N#define UART_BAUD_MODE0_DIVIDER(u32SrcFreq, u32BaudRate)    ((((u32SrcFreq) + ((u32BaudRate)*8)) / (u32BaudRate) >> 4)-2)
N
N
N/**
N *    @brief        Calculate UART baudrate mode2 divider
N *
N *    @param[in]    u32SrcFreq      UART clock frequency
N *    @param[in]    u32BaudRate     Baudrate of UART module
N *
N *    @return       UART baudrate mode2 divider
N *
N *    @details      This macro calculate UART baudrate mode2 divider.
N */
N#define UART_BAUD_MODE2_DIVIDER(u32SrcFreq, u32BaudRate)    ((((u32SrcFreq) + ((u32BaudRate)/2)) / (u32BaudRate))-2)
N
N
N/**
N *    @brief        Write UART data
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *    @param[in]    u8Data  Data byte to transmit.
N *
N *    @return       None
N *
N *    @details      This macro write Data to Tx data register.
N */
N#define UART_WRITE(uart, u8Data)    ((uart)->DAT = (u8Data))
N
N
N/**
N *    @brief        Read UART data
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @return       The oldest data byte in RX FIFO.
N *
N *    @details      This macro read Rx data register.
N */
N#define UART_READ(uart)    ((uart)->DAT)
N
N
N/**
N *    @brief        Get Tx empty
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @retval       0   Tx FIFO is not empty
N *    @retval       >=1 Tx FIFO is empty
N *
N *    @details      This macro get Transmitter FIFO empty register value.
N */
N#define UART_GET_TX_EMPTY(uart)    ((uart)->FIFOSTS & UART_FIFOSTS_TXEMPTY_Msk)
N
N
N/**
N *    @brief        Get Rx empty
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @retval       0   Rx FIFO is not empty
N *    @retval       >=1 Rx FIFO is empty
N *
N *    @details      This macro get Receiver FIFO empty register value.
N */
N#define UART_GET_RX_EMPTY(uart)    ((uart)->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk)
N
N
N/**
N *    @brief        Check specified uart port transmission is over.
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @retval       0 Tx transmission is not over
N *    @retval       1 Tx transmission is over
N *
N *    @details      This macro return Transmitter Empty Flag register bit value.
N *                  It indicates if specified uart port transmission is over nor not.
N */
N#define UART_IS_TX_EMPTY(uart)    (((uart)->FIFOSTS & UART_FIFOSTS_TXEMPTYF_Msk) >> UART_FIFOSTS_TXEMPTYF_Pos)
N
N
N/**
N *    @brief        Wait specified uart port transmission is over
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @return       None
N *
N *    @details      This macro wait specified uart port transmission is over.
N */
N#define UART_WAIT_TX_EMPTY(uart)    while(!((((uart)->FIFOSTS) & UART_FIFOSTS_TXEMPTYF_Msk) >> UART_FIFOSTS_TXEMPTYF_Pos))
N
N
N/**
N *    @brief        Check RX is ready or not
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @retval       0 The number of bytes in the RX FIFO is less than the RFITL
N *    @retval       1 The number of bytes in the RX FIFO equals or larger than RFITL
N *
N *    @details      This macro check receive data available interrupt flag is set or not.
N */
N#define UART_IS_RX_READY(uart)    (((uart)->INTSTS & UART_INTSTS_RDAIF_Msk)>>UART_INTSTS_RDAIF_Pos)
N
N
N/**
N *    @brief        Check TX FIFO is full or not
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @retval       1 TX FIFO is full
N *    @retval       0 TX FIFO is not full
N *
N *    @details      This macro check TX FIFO is full or not.
N */
N#define UART_IS_TX_FULL(uart)    (((uart)->FIFOSTS & UART_FIFOSTS_TXFULL_Msk)>>UART_FIFOSTS_TXFULL_Pos)
N
N
N/**
N *    @brief        Check RX FIFO is full or not
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @retval       1 RX FIFO is full
N *    @retval       0 RX FIFO is not full
N *
N *    @details      This macro check RX FIFO is full or not.
N */
N#define UART_IS_RX_FULL(uart)    (((uart)->FIFOSTS & UART_FIFOSTS_RXFULL_Msk)>>UART_FIFOSTS_RXFULL_Pos)
N
N
N/**
N *    @brief        Get Tx full register value
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @retval       0   Tx FIFO is not full.
N *    @retval       >=1 Tx FIFO is full.
N *
N *    @details      This macro get Tx full register value.
N */
N#define UART_GET_TX_FULL(uart)    ((uart)->FIFOSTS & UART_FIFOSTS_TXFULL_Msk)
N
N
N/**
N *    @brief        Get Rx full register value
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @retval       0   Rx FIFO is not full.
N *    @retval       >=1 Rx FIFO is full.
N *
N *    @details      This macro get Rx full register value.
N */
N#define UART_GET_RX_FULL(uart)    ((uart)->FIFOSTS & UART_FIFOSTS_RXFULL_Msk)
N
N
N/**
N *    @brief        Enable specified UART interrupt
N *
N *    @param[in]    uart        The pointer of the specified UART module
N *    @param[in]    u32eIntSel  Interrupt type select
N *                              - \ref UART_INTEN_ABRIEN_Msk     : Auto baud rate interrupt
N *                              - \ref UART_INTEN_WKCTSIEN_Msk   : CTS wakeup interrupt
N *                              - \ref UART_INTEN_WKDATIEN_Msk   : Data wakeup interrupt
N *                              - \ref UART_INTEN_LINIEN_Msk     : Lin bus interrupt
N *                              - \ref UART_INTEN_BUFERRIEN_Msk  : Buffer Error interrupt
N *                              - \ref UART_INTEN_RXTOIEN_Msk    : Rx time-out interrupt
N *                              - \ref UART_INTEN_MODEMIEN_Msk   : Modem interrupt
N *                              - \ref UART_INTEN_RLSIEN_Msk     : Rx Line status interrupt
N *                              - \ref UART_INTEN_THREIEN_Msk    : Tx empty interrupt
N *                              - \ref UART_INTEN_RDAIEN_Msk     : Rx ready interrupt
N *
N *    @return       None
N *
N *    @details      This macro enable specified UART interrupt.
N */
N#define UART_ENABLE_INT(uart, u32eIntSel)    ((uart)->INTEN |= (u32eIntSel))
N
N
N/**
N *    @brief        Disable specified UART interrupt
N *
N *    @param[in]    uart        The pointer of the specified UART module
N *    @param[in]    u32eIntSel  Interrupt type select
N *                              - \ref UART_INTEN_ABRIEN_Msk     : Auto baud rate interrupt
N *                              - \ref UART_INTEN_WKCTSIEN_Msk   : CTS wakeup interrupt
N *                              - \ref UART_INTEN_WKDATIEN_Msk   : Data wakeup interrupt
N *                              - \ref UART_INTEN_LINIEN_Msk     : Lin bus interrupt
N *                              - \ref UART_INTEN_BUFERRIEN_Msk  : Buffer Error interrupt
N *                              - \ref UART_INTEN_RXTOIEN_Msk    : Rx time-out interrupt
N *                              - \ref UART_INTEN_MODEMIEN_Msk   : Modem status interrupt
N *                              - \ref UART_INTEN_RLSIEN_Msk     : Receive Line status interrupt
N *                              - \ref UART_INTEN_THREIEN_Msk    : Tx empty interrupt
N *                              - \ref UART_INTEN_RDAIEN_Msk     : Rx ready interrupt
N *
N *    @return       None
N *
N *    @details      This macro enable specified UART interrupt.
N */
N#define UART_DISABLE_INT(uart, u32eIntSel)    ((uart)->INTEN &= ~ (u32eIntSel))
N
N
N/**
N *    @brief        Get specified interrupt flag/status
N *
N *    @param[in]    uart            The pointer of the specified UART module
N *    @param[in]    u32eIntTypeFlag Interrupt Type Flag, should be
N *                                  - \ref UART_INTSTS_HWBUFEINT_Msk : In DMA Mode, Buffer Error Interrupt Indicator
N *                                  - \ref UART_INTSTS_HWTOINT_Msk   : In DMA Mode, Time-out Interrupt Indicator
N *                                  - \ref UART_INTSTS_HWMODINT_Msk  : In DMA Mode, MODEM Status Interrupt Indicator
N *                                  - \ref UART_INTSTS_HWRLSINT_Msk  : In DMA Mode, Receive Line Status Interrupt Indicator
N *                                  - \ref UART_INTSTS_HWBUFEIF_Msk  : In DMA Mode, Buffer Error Interrupt Flag
N *                                  - \ref UART_INTSTS_HWTOIF_Msk    : In DMA Mode, Time-out Interrupt Flag
N *                                  - \ref UART_INTSTS_HWMODIF_Msk   : In DMA Mode, MODEM Interrupt Flag
N *                                  - \ref UART_INTSTS_HWRLSIF_Msk   : In DMA Mode, Receive Line Status Flag
N *                                  - \ref UART_INTSTS_LININT_Msk    : LIN Bus Interrupt Indicator
N *                                  - \ref UART_INTSTS_BUFERRINT_Msk : Buffer Error Interrupt Indicator
N *                                  - \ref UART_INTSTS_RXTOINT_Msk   : Time-out Interrupt Indicator
N *                                  - \ref UART_INTSTS_MODEMINT_Msk  : Modem Status Interrupt Indicator
N *                                  - \ref UART_INTSTS_RLSINT_Msk    : Receive Line Status Interrupt Indicator
N *                                  - \ref UART_INTSTS_THREINT_Msk   : Transmit Holding Register Empty Interrupt Indicator
N *                                  - \ref UART_INTSTS_RDAINT_Msk    : Receive Data Available Interrupt Indicator
N *                                  - \ref UART_INTSTS_LINIF_Msk     : LIN Bus Flag
N *                                  - \ref UART_INTSTS_BUFERRIF_Msk  : Buffer Error Interrupt Flag
N *                                  - \ref UART_INTSTS_RXTOIF_Msk    : Rx Time-out Interrupt Flag
N *                                  - \ref UART_INTSTS_MODEMIF_Msk   : Modem Interrupt Flag
N *                                  - \ref UART_INTSTS_RLSIF_Msk     : Receive Line Status Interrupt Flag
N *                                  - \ref UART_INTSTS_THREIF_Msk    : Tx Empty Interrupt Flag
N *                                  - \ref UART_INTSTS_RDAIF_Msk     : Rx Ready Interrupt Flag
N *
N *    @retval       0 The specified interrupt is not happened.
N *                  1 The specified interrupt is happened.
N *
N *    @details      This macro get specified interrupt flag or interrupt indicator status.
N */
N#define UART_GET_INT_FLAG(uart,u32eIntTypeFlag)    (((uart)->INTSTS & (u32eIntTypeFlag))?1:0)
N
N
N/**
N *    @brief        Set RTS pin to low
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @return       None
N *
N *    @details      This macro set RTS pin to low.
N */
N__STATIC_INLINE void UART_CLEAR_RTS(UART_T* uart)
Xstatic __inline void UART_CLEAR_RTS(UART_T* uart)
N{
N    uart->MODEM |= UART_MODEM_RTSACTLV_Msk;
X    uart->MODEM |= (0x1ul << (9));
N    uart->MODEM &= ~UART_MODEM_RTS_Msk;
X    uart->MODEM &= ~(0x1ul << (1));
N}
N
N
N/**
N *    @brief        Set RTS pin to high
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @return       None
N *
N *    @details      This macro set RTS pin to high.
N */
N__STATIC_INLINE void UART_SET_RTS(UART_T* uart)
Xstatic __inline void UART_SET_RTS(UART_T* uart)
N{
N    uart->MODEM |= UART_MODEM_RTSACTLV_Msk | UART_MODEM_RTS_Msk;
X    uart->MODEM |= (0x1ul << (9)) | (0x1ul << (1));
N}
N
N
N/**
N *    @brief        Clear RS-485 Address Byte Detection Flag
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @return       None
N *
N *    @details      This macro clear RS-485 address byte detection flag.
N */
N#define UART_RS485_CLEAR_ADDR_FLAG(uart)    ((uart)->FIFOSTS = UART_FIFOSTS_ADDRDETF_Msk)
N
N
N/**
N *    @brief        Get RS-485 Address Byte Detection Flag
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @retval       0 Receiver detects a data that is not an address bit.
N *    @retval       1 Receiver detects a data that is an address bit.
N *
N *    @details      This macro get RS-485 address byte detection flag.
N */
N#define UART_RS485_GET_ADDR_FLAG(uart)    (((uart)->FIFOSTS  & UART_FIFOSTS_ADDRDETF_Msk) >> UART_FIFOSTS_ADDRDETF_Pos)
N
N
Nvoid UART_ClearIntFlag(UART_T* uart , uint32_t u32InterruptFlag);
Nvoid UART_Close(UART_T* uart);
Nvoid UART_DisableFlowCtrl(UART_T* uart);
Nvoid UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag);
Nvoid UART_EnableFlowCtrl(UART_T* uart);
Nvoid UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag);
Nvoid UART_Open(UART_T* uart, uint32_t u32baudrate);
Nuint32_t UART_Read(UART_T* uart, uint8_t *pu8RxBuf, uint32_t u32ReadBytes);
Nvoid UART_SetLine_Config(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits);
Nvoid UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC);
Nvoid UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction);
Nvoid UART_SelectRS485Mode(UART_T* uart, uint32_t u32Mode, uint32_t u32Addr);
Nvoid UART_SelectLINMode(UART_T* uart, uint32_t u32Mode, uint32_t u32BreakLength);
Nuint32_t UART_Write(UART_T* uart, uint8_t *pu8TxBuf, uint32_t u32WriteBytes);
N
N
N
N
N/*@}*/ /* end of group UART_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group UART_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__UART_H__
N
N/*** (C) COPYRIGHT 2013~2015 Nuvoton Technology Corp. ***/
L 17113 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N#include "pwm.h"
L 1 "..\..\..\..\Library\StdDriver\inc\pwm.h" 1
N/**************************************************************************//**
N * @file     pwm.h
N * @version  V1.00
N * $Revision: 26 $
N * $Date: 15/08/11 10:26a $
N * @brief    M451 series PWM driver header file
N *
N * @note
N * Copyright (C) 2014~2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __PWM_H__
N#define __PWM_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup PWM_Driver PWM Driver
N  @{
N*/
N
N/** @addtogroup PWM_EXPORTED_CONSTANTS PWM Exported Constants
N  @{
N*/
N#define PWM_CHANNEL_NUM                          (6)        /*!< PWM channel number */
N#define PWM_CH_0_MASK                            (0x1UL)    /*!< PWM channel 0 mask \hideinitializer */
N#define PWM_CH_1_MASK                            (0x2UL)    /*!< PWM channel 1 mask \hideinitializer */
N#define PWM_CH_2_MASK                            (0x4UL)    /*!< PWM channel 2 mask \hideinitializer */
N#define PWM_CH_3_MASK                            (0x8UL)    /*!< PWM channel 3 mask \hideinitializer */
N#define PWM_CH_4_MASK                            (0x10UL)   /*!< PWM channel 4 mask \hideinitializer */
N#define PWM_CH_5_MASK                            (0x20UL)   /*!< PWM channel 5 mask \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Counter Type Constant Definitions                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_UP_COUNTER                           (0UL)      /*!< Up counter type */
N#define PWM_DOWN_COUNTER                         (1UL)      /*!< Down counter type */
N#define PWM_UP_DOWN_COUNTER                      (2UL)      /*!< Up-Down counter type */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Aligned Type Constant Definitions                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_EDGE_ALIGNED                         (1UL)      /*!< PWM working in edge aligned type(down count) */
N#define PWM_CENTER_ALIGNED                       (2UL)      /*!< PWM working in center aligned type */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Output Level Constant Definitions                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_OUTPUT_NOTHING                       (0UL)      /*!< PWM output nothing */
N#define PWM_OUTPUT_LOW                           (1UL)      /*!< PWM output low */
N#define PWM_OUTPUT_HIGH                          (2UL)      /*!< PWM output high */
N#define PWM_OUTPUT_TOGGLE                        (3UL)      /*!< PWM output toggle */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Trigger Source Select Constant Definitions                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_TRIGGER_ADC_EVEN_ZERO_POINT                     (0UL)     /*!< PWM trigger ADC while counter of even channel matches zero point */
N#define PWM_TRIGGER_ADC_EVEN_PERIOD_POINT                   (1UL)     /*!< PWM trigger ADC while counter of even channel matches period point */
N#define PWM_TRIGGER_ADC_EVEN_ZERO_OR_PERIOD_POINT           (2UL)     /*!< PWM trigger ADC while counter of even channel matches zero or period point */
N#define PWM_TRIGGER_ADC_EVEN_COMPARE_UP_COUNT_POINT         (3UL)     /*!< PWM trigger ADC while counter of even channel matches up count to comparator point */
N#define PWM_TRIGGER_ADC_EVEN_COMPARE_DOWN_COUNT_POINT       (4UL)     /*!< PWM trigger ADC while counter of even channel matches down count to comparator point */
N#define PWM_TRIGGER_ADC_ODD_ZERO_POINT                      (5UL)     /*!< PWM trigger ADC while counter of odd channel matches zero point */
N#define PWM_TRIGGER_ADC_ODD_PERIOD_POINT                    (6UL)     /*!< PWM trigger ADC while counter of odd channel matches period point */
N#define PWM_TRIGGER_ADC_ODD_ZERO_OR_PERIOD_POINT            (7UL)     /*!< PWM trigger ADC while counter of odd channel matches zero or period point */
N#define PWM_TRIGGER_ADC_ODD_COMPARE_UP_COUNT_POINT          (8UL)     /*!< PWM trigger ADC while counter of odd channel matches up count to comparator point */
N#define PWM_TRIGGER_ADC_ODD_COMPARE_DOWN_COUNT_POINT        (9UL)     /*!< PWM trigger ADC while counter of odd channel matches down count to comparator point */
N#define PWM_TRIGGER_ADC_CH_0_FREE_COMPARE_UP_COUNT_POINT    (10UL)    /*!< PWM trigger ADC while counter of channel 0 matches up count to free comparator point */
N#define PWM_TRIGGER_ADC_CH_0_FREE_COMPARE_DOWN_COUNT_POINT  (11UL)    /*!< PWM trigger ADC while counter of channel 0 matches down count to free comparator point */
N#define PWM_TRIGGER_ADC_CH_2_FREE_COMPARE_UP_COUNT_POINT    (12UL)    /*!< PWM trigger ADC while counter of channel 2 matches up count to free comparator point */
N#define PWM_TRIGGER_ADC_CH_2_FREE_COMPARE_DOWN_COUNT_POINT  (13UL)    /*!< PWM trigger ADC while counter of channel 2 matches down count to free comparator point */
N#define PWM_TRIGGER_ADC_CH_4_FREE_COMPARE_UP_COUNT_POINT    (14UL)    /*!< PWM trigger ADC while counter of channel 4 matches up count to free comparator point */
N#define PWM_TRIGGER_ADC_CH_4_FREE_COMPARE_DOWN_COUNT_POINT  (15UL)    /*!< PWM trigger ADC while counter of channel 4 matches down count to free comparator point */
N
N#define PWM_TRIGGER_DAC_ZERO_POINT                          (0x1UL)           /*!< PWM trigger ADC while counter down count to 0  \hideinitializer */
N#define PWM_TRIGGER_DAC_PERIOD_POINT                        (0x100UL)         /*!< PWM trigger ADC while counter matches (PERIOD + 1) \hideinitializer */
N#define PWM_TRIGGER_DAC_COMPARE_UP_COUNT_POINT              (0x10000UL)       /*!< PWM trigger ADC while counter up count to CMPDAT \hideinitializer */
N#define PWM_TRIGGER_DAC_COMPARE_DOWN_COUNT_POINT            (0x1000000UL)     /*!< PWM trigger ADC while counter down count to CMPDAT \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Fail brake Control Constant Definitions                                                                */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_FB_EDGE_ACMP0                        (PWM_BRKCTL0_1_CPO0EBEN_Msk)    /*!< Comparator 0 as edge-detect fault brake source */
N#define PWM_FB_EDGE_ACMP1                        (PWM_BRKCTL0_1_CPO1EBEN_Msk)    /*!< Comparator 1 as edge-detect fault brake source */
N#define PWM_FB_EDGE_BKP0                         (PWM_BRKCTL0_1_BRKP0EEN_Msk)    /*!< BKP0 pin as edge-detect fault brake source */
N#define PWM_FB_EDGE_BKP1                         (PWM_BRKCTL0_1_BRKP1EEN_Msk)    /*!< BKP1 pin as edge-detect fault brake source */
N#define PWM_FB_EDGE_SYS_CSS                      (PWM_BRKCTL0_1_SYSEBEN_Msk | PWM_FAILBRK_CSSBRKEN_Msk)    /*!< System fail condition: clock security system detection as edge-detect fault brake source */
N#define PWM_FB_EDGE_SYS_BOD                      (PWM_BRKCTL0_1_SYSEBEN_Msk | PWM_FAILBRK_BODBRKEN_Msk)    /*!< System fail condition: brown-out detection as edge-detect fault brake source */
N#define PWM_FB_EDGE_SYS_RAM                      (PWM_BRKCTL0_1_SYSEBEN_Msk | PWM_FAILBRK_RAMBRKEN_Msk)    /*!< System fail condition: SRAM parity error detection as edge-detect fault brake source */
N#define PWM_FB_EDGE_SYS_COR                      (PWM_BRKCTL0_1_SYSEBEN_Msk | PWM_FAILBRK_CORBRKEN_Msk)    /*!< System fail condition: core lockup detection as edge-detect fault brake source */
N
N#define PWM_FB_LEVEL_ACMP0                       (PWM_BRKCTL0_1_CPO0LBEN_Msk)    /*!< Comparator 0 as level-detect fault brake source */
N#define PWM_FB_LEVEL_ACMP1                       (PWM_BRKCTL0_1_CPO1LBEN_Msk)    /*!< Comparator 1 as level-detect fault brake source */
N#define PWM_FB_LEVEL_BKP0                        (PWM_BRKCTL0_1_BRKP0LEN_Msk)    /*!< BKP0 pin as level-detect fault brake source */
N#define PWM_FB_LEVEL_BKP1                        (PWM_BRKCTL0_1_BRKP1LEN_Msk)    /*!< BKP1 pin as level-detect fault brake source */
N#define PWM_FB_LEVEL_SYS_CSS                     (PWM_BRKCTL0_1_SYSLBEN_Msk | PWM_FAILBRK_CSSBRKEN_Msk)    /*!< System fail condition: clock security system detection as level-detect fault brake source */
N#define PWM_FB_LEVEL_SYS_BOD                     (PWM_BRKCTL0_1_SYSLBEN_Msk | PWM_FAILBRK_BODBRKEN_Msk)    /*!< System fail condition: brown-out detection as level-detect fault brake source */
N#define PWM_FB_LEVEL_SYS_RAM                     (PWM_BRKCTL0_1_SYSLBEN_Msk | PWM_FAILBRK_RAMBRKEN_Msk)    /*!< System fail condition: SRAM parity error detection as level-detect fault brake source */
N#define PWM_FB_LEVEL_SYS_COR                     (PWM_BRKCTL0_1_SYSLBEN_Msk | PWM_FAILBRK_CORBRKEN_Msk)    /*!< System fail condition: core lockup detection as level-detect fault brake source */
N
N#define PWM_FB_EDGE                              (0UL)    /*!< edge-detect fault brake */
N#define PWM_FB_LEVEL                             (8UL)    /*!< level-detect fault brake */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Capture Control Constant Definitions                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_CAPTURE_INT_RISING_LATCH             (1UL)        /*!< PWM capture interrupt if channel has rising transition */
N#define PWM_CAPTURE_INT_FALLING_LATCH            (0x100UL)    /*!< PWM capture interrupt if channel has falling transition */
N
N#define PWM_CAPTURE_PDMA_RISING_LATCH            (0x2UL)      /*!< PWM capture rising latched data transfer by PDMA */
N#define PWM_CAPTURE_PDMA_FALLING_LATCH           (0x4UL)      /*!< PWM capture falling latched data transfer by PDMA */
N#define PWM_CAPTURE_PDMA_RISING_FALLING_LATCH    (0x6UL)      /*!< PWM capture rising and falling latched data transfer by PDMA */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Duty Interrupt Type Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_DUTY_INT_DOWN_COUNT_MATCH_CMP        (PWM_INTEN0_CMPDIEN0_Msk)   /*!< PWM duty interrupt triggered if down count match comparator */
N#define PWM_DUTY_INT_UP_COUNT_MATCH_CMP          (PWM_INTEN0_CMPUIEN0_Msk)   /*!< PWM duty interrupt triggered if up down match comparator */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Interrupt Flag Accumulator Constant Definitions                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_IFA_EVEN_ZERO_POINT                  (0UL)         /*!< PWM counter equal to zero in even channel  \hideinitializer */
N#define PWM_IFA_EVEN_PERIOD_POINT                (1UL)         /*!< PWM counter equal to period in even channel \hideinitializer */
N#define PWM_IFA_EVEN_COMPARE_UP_COUNT_POINT      (2UL)         /*!< PWM counter up count to comparator value in even channel \hideinitializer */
N#define PWM_IFA_EVEN_COMPARE_DOWN_COUNT_POINT    (3UL)         /*!< PWM counter down count to comparator value in even channel \hideinitializer */
N#define PWM_IFA_ODD_ZERO_POINT                   (4UL)         /*!< PWM counter equal to zero in odd channel  \hideinitializer */
N#define PWM_IFA_ODD_PERIOD_POINT                 (5UL)         /*!< PWM counter equal to period in odd channel \hideinitializer */
N#define PWM_IFA_ODD_COMPARE_UP_COUNT_POINT       (6UL)         /*!< PWM counter up count to comparator value in odd channel \hideinitializer */
N#define PWM_IFA_ODD_COMPARE_DOWN_COUNT_POINT     (7UL)         /*!< PWM counter down count to comparator value in odd channel \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Load Mode Constant Definitions                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_LOAD_MODE_IMMEDIATE                  (PWM_CTL0_IMMLDEN0_Msk)    /*!< PWM immediately load mode \hideinitializer */
N#define PWM_LOAD_MODE_WINDOW                     (PWM_CTL0_WINLDEN0_Msk)    /*!< PWM window load mode \hideinitializer */
N#define PWM_LOAD_MODE_CENTER                     (PWM_CTL0_CTRLD0_Msk)      /*!< PWM center load mode \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Synchronize Control Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_SYNC_OUT_FROM_SYNCIN_SWSYNC          (0UL)    /*!< Synchronize source from SYNC_IN or SWSYNC  \hideinitializer */
N#define PWM_SYNC_OUT_FROM_COUNT_TO_ZERO          (1UL)    /*!< Synchronize source from counter equal to 0  \hideinitializer */
N#define PWM_SYNC_OUT_FROM_COUNT_TO_COMPARATOR    (2UL)    /*!< Synchronize source from counter equal to CMPDAT1, CMPDAT3, CMPDAT5 \hideinitializer */
N#define PWM_SYNC_OUT_DISABLE                     (3UL)    /*!< SYNC_OUT will not be generated \hideinitializer */
N#define PWM_PHS_DIR_DECREMENT                    (0UL)    /*!< PWM counter count decrement  \hideinitializer */
N#define PWM_PHS_DIR_INCREMENT                    (1UL)    /*!< PWM counter count increment  \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Noise Filter Clock Divide Select Constant Definitions                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_NF_CLK_DIV_1                         (0UL)    /*!< Noise filter clock is HCLK divide by 1 \hideinitializer */
N#define PWM_NF_CLK_DIV_2                         (1UL)    /*!< Noise filter clock is HCLK divide by 2 \hideinitializer */
N#define PWM_NF_CLK_DIV_4                         (2UL)    /*!< Noise filter clock is HCLK divide by 4 \hideinitializer */
N#define PWM_NF_CLK_DIV_8                         (3UL)    /*!< Noise filter clock is HCLK divide by 8 \hideinitializer */
N#define PWM_NF_CLK_DIV_16                        (4UL)    /*!< Noise filter clock is HCLK divide by 16 \hideinitializer */
N#define PWM_NF_CLK_DIV_32                        (5UL)    /*!< Noise filter clock is HCLK divide by 32 \hideinitializer */
N#define PWM_NF_CLK_DIV_64                        (6UL)    /*!< Noise filter clock is HCLK divide by 64 \hideinitializer */
N#define PWM_NF_CLK_DIV_128                       (7UL)    /*!< Noise filter clock is HCLK divide by 128 \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Clock Source Select Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_CLKSRC_PWM_CLK                       (0UL)    /*!< PWM Clock source selects to PWM0_CLK or PWM1_CLK \hideinitializer */
N#define PWM_CLKSRC_TIMER0                        (1UL)    /*!< PWM Clock source selects to TIMER0 overflow \hideinitializer */
N#define PWM_CLKSRC_TIMER1                        (2UL)    /*!< PWM Clock source selects to TIMER1 overflow \hideinitializer */
N#define PWM_CLKSRC_TIMER2                        (3UL)    /*!< PWM Clock source selects to TIMER2 overflow \hideinitializer */
N#define PWM_CLKSRC_TIMER3                        (4UL)    /*!< PWM Clock source selects to TIMER3 overflow \hideinitializer */
N
N
N/*@}*/ /* end of group PWM_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup PWM_EXPORTED_FUNCTIONS PWM Exported Functions
N  @{
N*/
N
N/**
N * @brief This macro enable complementary mode
N * @param[in] pwm The pointer of the specified PWM module
N * @return None
N * @details This macro is used to enable complementary mode of PWM module.
N * \hideinitializer
N */
N#define PWM_ENABLE_COMPLEMENTARY_MODE(pwm) ((pwm)->CTL1 = (pwm)->CTL1 | PWM_CTL1_OUTMODEn_Msk)
N
N/**
N * @brief This macro disable complementary mode, and enable independent mode.
N * @param[in] pwm The pointer of the specified PWM module
N * @return None
N * @details This macro is used to disable complementary mode of PWM module.
N * \hideinitializer
N */
N#define PWM_DISABLE_COMPLEMENTARY_MODE(pwm) ((pwm)->CTL1 = (pwm)->CTL1 & ~PWM_CTL1_OUTMODEn_Msk)
N
N/**
N * @brief This macro enable group mode
N * @param[in] pwm The pointer of the specified PWM module
N * @return None
N * @details This macro is used to enable group mode of PWM module.
N * \hideinitializer
N */
N#define PWM_ENABLE_GROUP_MODE(pwm) ((pwm)->CTL0 = (pwm)->CTL0 | PWM_CTL0_GROUPEN_Msk)
N
N/**
N * @brief This macro disable group mode
N * @param[in] pwm The pointer of the specified PWM module
N * @return None
N * @details This macro is used to disable group mode of PWM module.
N * \hideinitializer
N */
N#define PWM_DISABLE_GROUP_MODE(pwm) ((pwm)->CTL0 = (pwm)->CTL0 & ~PWM_CTL0_GROUPEN_Msk)
N
N/**
N * @brief Enable timer synchronous mode of specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @return None
N * @details This macro is used to enable timer synchronous mode of specified channel(s).
N * \hideinitializer
N */
N#define PWM_ENABLE_TIMER_SYNC(pwm, u32ChannelMask) ((pwm)->SSCTL |= (u32ChannelMask))
N
N/**
N * @brief Disable timer synchronous mode of specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @return None
N * @details This macro is used to disable timer synchronous mode of specified channel(s).
N * \hideinitializer
N */
N#define PWM_DISABLE_TIMER_SYNC(pwm, u32ChannelMask) \
N    do{ \
N        int i;\
N        for(i = 0; i < 6; i++) { \
N            if((u32ChannelMask) & (1 << i)) \
N                (pwm)->SSCTL &= ~(1UL << i); \
N        } \
N    }while(0)
X#define PWM_DISABLE_TIMER_SYNC(pwm, u32ChannelMask)     do{         int i;        for(i = 0; i < 6; i++) {             if((u32ChannelMask) & (1 << i))                 (pwm)->SSCTL &= ~(1UL << i);         }     }while(0)
N
N/**
N * @brief This macro enable output inverter of specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @return None
N * @details This macro is used to enable output inverter of specified channel(s).
N * \hideinitializer
N */
N#define PWM_ENABLE_OUTPUT_INVERTER(pwm, u32ChannelMask) ((pwm)->POLCTL = (u32ChannelMask))
N
N/**
N * @brief This macro get captured rising data
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @return None
N * @details This macro is used to get captured rising data of specified channel.
N * \hideinitializer
N */
N#define PWM_GET_CAPTURE_RISING_DATA(pwm, u32ChannelNum) (*(__IO uint32_t *) (&((pwm)->RCAPDAT0) + 2 * (u32ChannelNum)))
N
N/**
N * @brief This macro get captured falling data
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @return None
N * @details This macro is used to get captured falling data of specified channel.
N * \hideinitializer
N */
N#define PWM_GET_CAPTURE_FALLING_DATA(pwm, u32ChannelNum) (*(__IO uint32_t *) (&((pwm)->FCAPDAT0) + 2 * (u32ChannelNum)))
N
N/**
N * @brief This macro mask output logic to high or low
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @param[in] u32LevelMask Output logic to high or low
N * @return None
N * @details This macro is used to mask output logic to high or low of specified channel(s).
N * @note If u32ChannelMask parameter is 0, then mask function will be disabled.
N * \hideinitializer
N */
N#define PWM_MASK_OUTPUT(pwm, u32ChannelMask, u32LevelMask) \
N    { \
N        (pwm)->MSKEN = (u32ChannelMask); \
N        (pwm)->MSK = (u32LevelMask); \
N    }
X#define PWM_MASK_OUTPUT(pwm, u32ChannelMask, u32LevelMask)     {         (pwm)->MSKEN = (u32ChannelMask);         (pwm)->MSK = (u32LevelMask);     }
N
N/**
N * @brief This macro set the prescaler of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @param[in] u32Prescaler Clock prescaler of specified channel. Valid values are between 1 ~ 0xFFF
N * @return None
N * @details This macro is used to set the prescaler of specified channel.
N * @note Every even channel N, and channel (N + 1) share a prescaler. So if channel 0 prescaler changed,
N *       channel 1 will also be affected.
N * \hideinitializer
N */
N#define PWM_SET_PRESCALER(pwm, u32ChannelNum, u32Prescaler) (*(__IO uint32_t *) (&((pwm)->CLKPSC0_1) + ((u32ChannelNum) >> 1)) = (u32Prescaler))
N
N/**
N * @brief This macro set the comparator of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @param[in] u32CMR Comparator of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @details This macro is used to set the comparator of specified channel.
N * @note This new setting will take effect on next PWM period.
N * \hideinitializer
N */
N#define PWM_SET_CMR(pwm, u32ChannelNum, u32CMR) ((pwm)->CMPDAT[(u32ChannelNum)]= (u32CMR))
N
N/**
N * @brief This macro set the free trigger comparator of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @param[in] u32FTCMR Free trigger comparator of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @details This macro is used to set the free trigger comparator of specified channel.
N * @note This new setting will take effect on next PWM period.
N * \hideinitializer
N */
N#define PWM_SET_FTCMR(pwm, u32ChannelNum, u32FTCMR) (*(__IO uint32_t *) (&((pwm)->FTCMPDAT0_1) + ((u32ChannelNum) >> 1)) = (u32FTCMR))
N
N/**
N * @brief This macro set the period of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @param[in] u32CNR Period of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @details This macro is used to set the period of specified channel.
N * @note This new setting will take effect on next PWM period.
N * @note PWM counter will stop if period length set to 0.
N * \hideinitializer
N */
N#define PWM_SET_CNR(pwm, u32ChannelNum, u32CNR)  ((pwm)->PERIOD[(u32ChannelNum)] = (u32CNR))
N
N/**
N * @brief This macro set the PWM aligned type
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @param[in] u32AlignedType PWM aligned type, valid values are:
N *              - \ref PWM_EDGE_ALIGNED
N *              - \ref PWM_CENTER_ALIGNED
N * @return None
N * @details This macro is used to set the PWM aligned type of specified channel(s).
N * \hideinitializer
N */
N#define PWM_SET_ALIGNED_TYPE(pwm, u32ChannelMask, u32AlignedType) \
N   do{ \
N        int i; \
N        for(i = 0; i < 6; i++) { \
N            if((u32ChannelMask) & (1 << i)) \
N                (pwm)->CTL1 = (((pwm)->CTL1 & ~(3UL << (2 * i))) | ((u32AlignedType) << ( 2 * i))); \
N        } \
N    }while(0)
X#define PWM_SET_ALIGNED_TYPE(pwm, u32ChannelMask, u32AlignedType)    do{         int i;         for(i = 0; i < 6; i++) {             if((u32ChannelMask) & (1 << i))                 (pwm)->CTL1 = (((pwm)->CTL1 & ~(3UL << (2 * i))) | ((u32AlignedType) << ( 2 * i)));         }     }while(0)
N
N/**
N * @brief Set load window of window loading mode for specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @return None
N * @details This macro is used to set load window of window loading mode for specified channel(s).
N * \hideinitializer
N */
N#define PWM_SET_LOAD_WINDOW(pwm, u32ChannelMask) ((pwm)->LOAD |= (u32ChannelMask))
N
N/**
N * @brief Trigger synchronous event from specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are 0, 2, 4
N *                           Bit 0 represents channel 0, bit 1 represents channel 2 and bit 2 represents channel 4
N * @return None
N * @details This macro is used to trigger synchronous event from specified channel(s).
N * \hideinitializer
N */
N#define PWM_TRIGGER_SYNC(pwm, u32ChannelNum) ((pwm)->SWSYNC |= (1 << ((u32ChannelNum) >> 1)))
N
N/**
N * @brief Clear counter of specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @return None
N * @details This macro is used to clear counter of specified channel(s).
N * \hideinitializer
N */
N#define PWM_CLR_COUNTER(pwm, u32ChannelMask) ((pwm)->CNTCLR |= (u32ChannelMask))
N
N/**
N * @brief Set output level at zero, compare up, period(center) and compare down of specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @param[in] u32ZeroLevel output level at zero point, valid values are:
N *              - \ref PWM_OUTPUT_NOTHING
N *              - \ref PWM_OUTPUT_LOW
N *              - \ref PWM_OUTPUT_HIGH
N *              - \ref PWM_OUTPUT_TOGGLE
N * @param[in] u32CmpUpLevel output level at compare up point, valid values are:
N *              - \ref PWM_OUTPUT_NOTHING
N *              - \ref PWM_OUTPUT_LOW
N *              - \ref PWM_OUTPUT_HIGH
N *              - \ref PWM_OUTPUT_TOGGLE
N * @param[in] u32PeriodLevel output level at period(center) point, valid values are:
N *              - \ref PWM_OUTPUT_NOTHING
N *              - \ref PWM_OUTPUT_LOW
N *              - \ref PWM_OUTPUT_HIGH
N *              - \ref PWM_OUTPUT_TOGGLE
N * @param[in] u32CmpDownLevel output level at compare down point, valid values are:
N *              - \ref PWM_OUTPUT_NOTHING
N *              - \ref PWM_OUTPUT_LOW
N *              - \ref PWM_OUTPUT_HIGH
N *              - \ref PWM_OUTPUT_TOGGLE
N * @return None
N * @details This macro is used to Set output level at zero, compare up, period(center) and compare down of specified channel(s).
N * \hideinitializer
N */
N#define PWM_SET_OUTPUT_LEVEL(pwm, u32ChannelMask, u32ZeroLevel, u32CmpUpLevel, u32PeriodLevel, u32CmpDownLevel) \
N   do{ \
N        int i; \
N        for(i = 0; i < 6; i++) { \
N            if((u32ChannelMask) & (1 << i)) { \
N                (pwm)->WGCTL0 = (((pwm)->WGCTL0 & ~(3UL << (2 * i))) | ((u32ZeroLevel) << (2 * i))); \
N                (pwm)->WGCTL0 = (((pwm)->WGCTL0 & ~(3UL << (PWM_WGCTL0_PRDPCTLn_Pos + (2 * i)))) | ((u32PeriodLevel) << (PWM_WGCTL0_PRDPCTLn_Pos + (2 * i)))); \
N                (pwm)->WGCTL1 = (((pwm)->WGCTL1 & ~(3UL << (2 * i))) | ((u32CmpUpLevel) << (2 * i))); \
N                (pwm)->WGCTL1 = (((pwm)->WGCTL1 & ~(3UL << (PWM_WGCTL1_CMPDCTLn_Pos + (2 * i)))) | ((u32CmpDownLevel) << (PWM_WGCTL1_CMPDCTLn_Pos + (2 * i)))); \
N            } \
N        } \
N    }while(0)
X#define PWM_SET_OUTPUT_LEVEL(pwm, u32ChannelMask, u32ZeroLevel, u32CmpUpLevel, u32PeriodLevel, u32CmpDownLevel)    do{         int i;         for(i = 0; i < 6; i++) {             if((u32ChannelMask) & (1 << i)) {                 (pwm)->WGCTL0 = (((pwm)->WGCTL0 & ~(3UL << (2 * i))) | ((u32ZeroLevel) << (2 * i)));                 (pwm)->WGCTL0 = (((pwm)->WGCTL0 & ~(3UL << (PWM_WGCTL0_PRDPCTLn_Pos + (2 * i)))) | ((u32PeriodLevel) << (PWM_WGCTL0_PRDPCTLn_Pos + (2 * i))));                 (pwm)->WGCTL1 = (((pwm)->WGCTL1 & ~(3UL << (2 * i))) | ((u32CmpUpLevel) << (2 * i)));                 (pwm)->WGCTL1 = (((pwm)->WGCTL1 & ~(3UL << (PWM_WGCTL1_CMPDCTLn_Pos + (2 * i)))) | ((u32CmpDownLevel) << (PWM_WGCTL1_CMPDCTLn_Pos + (2 * i))));             }         }     }while(0)
N
N/**
N * @brief Trigger brake event from specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 2 and bit 2 represents channel 4
N * @param[in] u32BrakeType Type of brake trigger. PWM_FB_EDGE of this macro is only supported in M45xD/M45xC.
N *              - \ref PWM_FB_EDGE
N *              - \ref PWM_FB_LEVEL
N * @return None
N * @details This macro is used to trigger brake event from specified channel(s).
N * \hideinitializer
N */
N#define PWM_TRIGGER_BRAKE(pwm, u32ChannelMask, u32BrakeType) ((pwm)->SWBRK |= ((u32ChannelMask) << (u32BrakeType)))
N
N/**
N * @brief Set Dead zone clock source
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @param[in] u32AfterPrescaler Dead zone clock source is from prescaler output. Valid values are TRUE (after prescaler) or FALSE (before prescaler).
N * @return None
N * @details This macro is used to set Dead zone clock source. Every two channels share the same setting.
N * @note The write-protection function should be disabled before using this function.
N * @note This function is only supported in M45xD/M45xC.
N * \hideinitializer
N */
N#define PWM_SET_DEADZONE_CLK_SRC(pwm, u32ChannelNum, u32AfterPrescaler) \
N    (*(__IO uint32_t *) (&((pwm)->DTCTL0_1) + ((u32ChannelNum) >> 1)) = (*(__IO uint32_t *) (&((pwm)->DTCTL0_1) + ((u32ChannelNum) >> 1)) & ~PWM_DTCTL0_1_DTCKSEL_Msk) | \
N    ((u32AfterPrescaler) << PWM_DTCTL0_1_DTCKSEL_Pos))
X#define PWM_SET_DEADZONE_CLK_SRC(pwm, u32ChannelNum, u32AfterPrescaler)     (*(__IO uint32_t *) (&((pwm)->DTCTL0_1) + ((u32ChannelNum) >> 1)) = (*(__IO uint32_t *) (&((pwm)->DTCTL0_1) + ((u32ChannelNum) >> 1)) & ~PWM_DTCTL0_1_DTCKSEL_Msk) |     ((u32AfterPrescaler) << PWM_DTCTL0_1_DTCKSEL_Pos))
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define PWM functions prototype                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
Nuint32_t PWM_ConfigCaptureChannel(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32UnitTimeNsec, uint32_t u32CaptureEdge);
Nuint32_t PWM_ConfigOutputChannel(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Frequency, uint32_t u32DutyCycle);
Nvoid PWM_Start(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_Stop(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_ForceStop(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition);
Nvoid PWM_DisableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition);
Nuint32_t PWM_GetADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableDACTrigger(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition);
Nvoid PWM_DisableDACTrigger(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearDACTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition);
Nuint32_t PWM_GetDACTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableFaultBrake(PWM_T *pwm, uint32_t u32ChannelMask, uint32_t u32LevelMask, uint32_t u32BrakeSource);
Nvoid PWM_EnableCapture(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_DisableCapture(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_DisableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnablePDMA(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32RisingFirst, uint32_t u32Mode);
Nvoid PWM_DisablePDMA(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Duration);
Nvoid PWM_DisableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nvoid PWM_DisableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nvoid PWM_ClearCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nuint32_t PWM_GetCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntDutyType);
Nvoid PWM_DisableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableFaultBrakeInt(PWM_T *pwm, uint32_t u32BrakeSource);
Nvoid PWM_DisableFaultBrakeInt(PWM_T *pwm, uint32_t u32BrakeSource);
Nvoid PWM_ClearFaultBrakeIntFlag(PWM_T *pwm, uint32_t u32BrakeSource);
Nuint32_t PWM_GetFaultBrakeIntFlag(PWM_T *pwm, uint32_t u32BrakeSource);
Nvoid PWM_EnablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum,  uint32_t u32IntPeriodType);
Nvoid PWM_DisablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableZeroInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_DisableZeroInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearZeroIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetZeroIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableAcc(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntFlagCnt, uint32_t u32IntAccSrc);
Nvoid PWM_DisableAcc(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableAccInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_DisableAccInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearAccInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetAccInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearFTDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetFTDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableLoadMode(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32LoadMode);
Nvoid PWM_DisableLoadMode(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32LoadMode);
Nvoid PWM_ConfigSyncPhase(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32SyncSrc, uint32_t u32Direction, uint32_t u32StartPhase);
Nvoid PWM_EnableSyncPhase(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_DisableSyncPhase(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableSyncNoiseFilter(PWM_T *pwm, uint32_t u32ClkCnt, uint32_t u32ClkDivSel);
Nvoid PWM_DisableSyncNoiseFilter(PWM_T *pwm);
Nvoid PWM_EnableSyncPinInverse(PWM_T *pwm);
Nvoid PWM_DisableSyncPinInverse(PWM_T *pwm);
Nvoid PWM_SetClockSource(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32ClkSrcSel);
Nvoid PWM_EnableBrakeNoiseFilter(PWM_T *pwm, uint32_t u32BrakePinNum, uint32_t u32ClkCnt, uint32_t u32ClkDivSel);
Nvoid PWM_DisableBrakeNoiseFilter(PWM_T *pwm, uint32_t u32BrakePinNum);
Nvoid PWM_EnableBrakePinInverse(PWM_T *pwm, uint32_t u32BrakePinNum);
Nvoid PWM_DisableBrakePinInverse(PWM_T *pwm, uint32_t u32BrakePinNum);
Nvoid PWM_SetBrakePinSource(PWM_T *pwm, uint32_t u32BrakePinNum, uint32_t u32SelAnotherModule);
Nuint32_t PWM_GetWrapAroundFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearWrapAroundFlag(PWM_T *pwm, uint32_t u32ChannelNum);
N
N
N/*@}*/ /* end of group PWM_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group PWM_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__PWM_H__
N
N/*** (C) COPYRIGHT 2014~2015 Nuvoton Technology Corp. ***/
L 17114 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N#include "pdma.h"
L 1 "..\..\..\..\Library\StdDriver\inc\pdma.h" 1
N/**************************************************************************//**
N * @file     pdma.h
N * @version  V1.00
N * $Revision: 15 $
N * $Date: 15/08/11 10:26a $
N * @brief    M451 series PDMA driver header file
N *
N * @note
N * Copyright (C) 2014~2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __PDMA_H__
N#define __PDMA_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup PDMA_Driver PDMA Driver
N  @{
N*/
N
N/** @addtogroup PDMA_EXPORTED_CONSTANTS PDMA Exported Constants
N  @{
N*/
N#define PDMA_CH_MAX    12   /*!< Specify Maximum Channels of PDMA  \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Operation Mode Constant Definitions                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_OP_STOP        0x00000000UL            /*!<DMA Stop Mode  \hideinitializer */
N#define PDMA_OP_BASIC       0x00000001UL            /*!<DMA Basic Mode  \hideinitializer */
N#define PDMA_OP_SCATTER     0x00000002UL            /*!<DMA Scatter-gather Mode  \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Data Width Constant Definitions                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_WIDTH_8        0x00000000UL            /*!<DMA Transfer Width 8-bit  \hideinitializer */
N#define PDMA_WIDTH_16       0x00001000UL            /*!<DMA Transfer Width 16-bit  \hideinitializer */
N#define PDMA_WIDTH_32       0x00002000UL            /*!<DMA Transfer Width 32-bit  \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Address Attribute Constant Definitions                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_SAR_INC        0x00000000UL            /*!<DMA SAR increment  \hideinitializer */
N#define PDMA_SAR_FIX        0x00000300UL            /*!<DMA SAR fix address  \hideinitializer */
N#define PDMA_DAR_INC        0x00000000UL            /*!<DMA DAR increment  \hideinitializer */
N#define PDMA_DAR_FIX        0x00000C00UL            /*!<DMA DAR fix address  \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Burst Mode Constant Definitions                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_REQ_SINGLE     0x00000004UL            /*!<DMA Single Request  \hideinitializer */
N#define PDMA_REQ_BURST      0x00000000UL            /*!<DMA Burst Request  \hideinitializer */
N
N#define PDMA_BURST_128      0x00000000UL            /*!<DMA Burst 128 Transfers  \hideinitializer */
N#define PDMA_BURST_64       0x00000010UL            /*!<DMA Burst 64 Transfers  \hideinitializer */
N#define PDMA_BURST_32       0x00000020UL            /*!<DMA Burst 32 Transfers  \hideinitializer */
N#define PDMA_BURST_16       0x00000030UL            /*!<DMA Burst 16 Transfers  \hideinitializer */
N#define PDMA_BURST_8        0x00000040UL            /*!<DMA Burst 8 Transfers  \hideinitializer */
N#define PDMA_BURST_4        0x00000050UL            /*!<DMA Burst 4 Transfers  \hideinitializer */
N#define PDMA_BURST_2        0x00000060UL            /*!<DMA Burst 2 Transfers  \hideinitializer */
N#define PDMA_BURST_1        0x00000070UL            /*!<DMA Burst 1 Transfers  \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Peripheral Transfer Mode Constant Definitions                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_SPI0_TX        0x00000001UL            /*!<DMA Connect to SPI1 TX  \hideinitializer */
N#define PDMA_SPI1_TX        0x00000002UL            /*!<DMA Connect to SPI2 TX  \hideinitializer */
N#define PDMA_SPI2_TX        0x00000003UL            /*!<DMA Connect to SPI3 TX  \hideinitializer */
N#define PDMA_UART0_TX       0x00000004UL            /*!<DMA Connect to UART0 TX  \hideinitializer */
N#define PDMA_UART1_TX       0x00000005UL            /*!<DMA Connect to UART1 TX  \hideinitializer */
N#define PDMA_UART2_TX       0x00000006UL            /*!<DMA Connect to UART2 TX  \hideinitializer */
N#define PDMA_UART3_TX       0x00000007UL            /*!<DMA Connect to UART3 TX  \hideinitializer */
N#define PDMA_DAC_TX         0x00000008UL            /*!<DMA Connect to DAC TX  \hideinitializer */
N#define PDMA_ADC_RX         0x00000009UL            /*!<DMA Connect to ADC RX  \hideinitializer */
N#define PDMA_PWM0_P1_RX     0x0000000BUL            /*!<DMA Connect to PWM0 P1 RX  \hideinitializer */
N#define PDMA_PWM0_P2_RX     0x0000000CUL            /*!<DMA Connect to PWM0 P2 RX  \hideinitializer */
N#define PDMA_PWM0_P3_RX     0x0000000DUL            /*!<DMA Connect to PWM0 P3 RX  \hideinitializer */
N#define PDMA_PWM1_P1_RX     0x0000000EUL            /*!<DMA Connect to PWM1 P1 RX  \hideinitializer */
N#define PDMA_PWM1_P2_RX     0x0000000FUL            /*!<DMA Connect to PWM1 P2 RX  \hideinitializer */
N#define PDMA_PWM1_P3_RX     0x00000010UL            /*!<DMA Connect to PWM1 P3 RX  \hideinitializer */
N#define PDMA_SPI0_RX        0x00000011UL            /*!<DMA Connect to SPI0 RX  \hideinitializer */
N#define PDMA_SPI1_RX        0x00000012UL            /*!<DMA Connect to SPI1 RX  \hideinitializer */
N#define PDMA_SPI2_RX        0x00000013UL            /*!<DMA Connect to SPI2 RX  \hideinitializer */
N#define PDMA_UART0_RX       0x00000014UL            /*!<DMA Connect to UART0 RX  \hideinitializer */
N#define PDMA_UART1_RX       0x00000015UL            /*!<DMA Connect to UART1 RX  \hideinitializer */
N#define PDMA_UART2_RX       0x00000016UL            /*!<DMA Connect to UART2 RX  \hideinitializer */
N#define PDMA_UART3_RX       0x00000017UL            /*!<DMA Connect to UART3 RX  \hideinitializer */
N#define PDMA_MEM            0x0000001FUL            /*!<DMA Connect to Memory  \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Interrupt Type Constant Definitions                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_INT_TRANS_DONE 0x00000000UL            /*!<Transfer Done Interrupt  \hideinitializer */
N#define PDMA_INT_TEMPTY     0x00000001UL            /*!<Table Empty Interrupt  \hideinitializer */
N#define PDMA_INT_TIMEOUT    0x00000002UL            /*!<Timeout Interrupt(M45xD/M45xC Only)  \hideinitializer */
N
N
N/*@}*/ /* end of group PDMA_EXPORTED_CONSTANTS */
N
N/** @addtogroup PDMA_EXPORTED_FUNCTIONS PDMA Exported Functions
N  @{
N*/
N
N/**
N * @brief       Get PDMA Interrupt Status
N *
N * @param[in]   None
N *
N * @return      None
N *
N * @details     This macro gets the interrupt status.
N */
N#define PDMA_GET_INT_STATUS() ((uint32_t)(PDMA->INTSTS))
N
N/**
N * @brief       Get Transfer Done Interrupt Status
N *
N * @param[in]   None
N *
N * @return      None
N *
N * @details     Get the transfer done Interrupt status.
N */
N#define PDMA_GET_TD_STS() ((uint32_t)(PDMA->TDSTS))
N
N/**
N * @brief       Clear Transfer Done Interrupt Status
N *
N * @param[in]   u32Mask     The channel mask
N *
N * @return      None
N *
N * @details     Clear the transfer done Interrupt status.
N */
N#define PDMA_CLR_TD_FLAG(u32Mask) ((uint32_t)(PDMA->TDSTS = (u32Mask)))
N
N/**
N * @brief       Get Target Abort Interrupt Status
N *
N * @param[in]   None
N *
N * @return      None
N *
N * @details     Get the target abort Interrupt status.
N */
N#define PDMA_GET_ABORT_STS() ((uint32_t)(PDMA->ABTSTS))
N
N/**
N * @brief       Clear Target Abort Interrupt Status
N *
N * @param[in]   u32Mask     The channel mask
N *
N * @return      None
N *
N * @details     Clear the target abort Interrupt status.
N */
N#define PDMA_CLR_ABORT_FLAG(u32Mask) ((uint32_t)(PDMA->ABTSTS = (u32Mask)))
N
N/**
N * @brief       Get Scatter-Gather Table Empty Interrupt Status
N *
N * @param[in]   None
N *
N * @return      None
N *
N * @details     Get the scatter-gather table empty Interrupt status.
N */
N#define PDMA_GET_EMPTY_STS() ((uint32_t)(PDMA->SCATSTS))
N
N/**
N * @brief       Clear Scatter-Gather Table Empty Interrupt Status
N *
N * @param[in]   u32Mask     The channel mask
N *
N * @return      None
N *
N * @details     Clear the scatter-gather table empty Interrupt status.
N */
N#define PDMA_CLR_EMPTY_FLAG(u32Mask) ((uint32_t)(PDMA->SCATSTS = (u32Mask)))
N
N/**
N * @brief       Clear Timeout Interrupt Status
N *
N * @param[in]   u32Ch     The selected channel
N *
N * @return      None
N *
N * @details     Clear the selected channel timeout interrupt status.
N * @note        This function is only supported in M45xD/M45xC.
N */
N#define PDMA_CLR_TMOUT_FLAG(u32Ch) ((uint32_t)(PDMA->INTSTS = (1 << ((u32Ch) + 8))))
N
N/**
N * @brief       Check Channel Status
N *
N * @param[in]   u32Ch     The selected channel
N *
N * @retval      0 Idle state
N * @retval      1 Busy state
N *
N * @details     Check the selected channel is busy or not.
N */
N#define PDMA_IS_CH_BUSY(u32Ch) ((uint32_t)(PDMA->TRGSTS & (1 << (u32Ch)))? 1 : 0)
N
N/**
N * @brief       Set Source Address
N *
N * @param[in]   u32Ch     The selected channel
N * @param[in]   u32Addr   The selected address
N *
N * @return      None
N *
N * @details     This macro set the selected channel source address.
N */
N#define PDMA_SET_SRC_ADDR(u32Ch, u32Addr) ((uint32_t)(PDMA->DSCT[(u32Ch)].SA = (u32Addr)))
N
N/**
N * @brief       Set Destination Address
N *
N * @param[in]   u32Ch     The selected channel
N * @param[in]   u32Addr   The selected address
N *
N * @return      None
N *
N * @details     This macro set the selected channel destination address.
N */
N#define PDMA_SET_DST_ADDR(u32Ch, u32Addr) ((uint32_t)(PDMA->DSCT[(u32Ch)].DA = (u32Addr)))
N
N/**
N * @brief       Set Transfer Count
N *
N * @param[in]   u32Ch          The selected channel
N * @param[in]   u32TransCount  Transfer Count
N *
N * @return      None
N *
N * @details     This macro set the selected channel transfer count.
N */
N#define PDMA_SET_TRANS_CNT(u32Ch, u32TransCount) ((uint32_t)(PDMA->DSCT[(u32Ch)].CTL=(PDMA->DSCT[(u32Ch)].CTL&~PDMA_DSCT_CTL_TXCNT_Msk)|((u32TransCount-1) << PDMA_DSCT_CTL_TXCNT_Pos)))
N
N/**
N * @brief       Set Scatter-gather descriptor Address
N *
N * @param[in]   u32Ch     The selected channel
N * @param[in]   u32Addr   The descriptor address
N *
N * @return      None
N *
N * @details     This macro set the selected channel scatter-gather descriptor address.
N */
N#define PDMA_SET_SCATTER_DESC(u32Ch, u32Addr) ((uint32_t)(PDMA->DSCT[(u32Ch)].NEXT = (u32Addr) - (PDMA->SCATBA)))
N
N/**
N * @brief       Stop the channel
N *
N * @param[in]   u32Ch     The selected channel
N *
N * @return      None
N *
N * @details     This macro stop the selected channel.
N */
N#define PDMA_STOP(u32Ch) ((uint32_t)(PDMA->STOP = (1 << (u32Ch))))
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define PWM functions prototype                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
Nvoid PDMA_Open(uint32_t u32Mask);
Nvoid PDMA_Close(void);
Nvoid PDMA_SetTransferCnt(uint32_t u32Ch, uint32_t u32Width, uint32_t u32TransCount);
Nvoid PDMA_SetTransferAddr(uint32_t u32Ch, uint32_t u32SrcAddr, uint32_t u32SrcCtrl, uint32_t u32DstAddr, uint32_t u32DstCtrl);
Nvoid PDMA_SetTransferMode(uint32_t u32Ch, uint32_t u32Peripheral, uint32_t u32ScatterEn, uint32_t u32DescAddr);
Nvoid PDMA_SetBurstType(uint32_t u32Ch, uint32_t u32BurstType, uint32_t u32BurstSize);
Nvoid PDMA_EnableTimeout(uint32_t u32Mask);
Nvoid PDMA_DisableTimeout(uint32_t u32Mask);
Nvoid PDMA_SetTimeOut(uint32_t u32Ch, uint32_t u32OnOff, uint32_t u32TimeOutCnt);
Nvoid PDMA_Trigger(uint32_t u32Ch);
Nvoid PDMA_EnableInt(uint32_t u32Ch, uint32_t u32Mask);
Nvoid PDMA_DisableInt(uint32_t u32Ch, uint32_t u32Mask);
N
N
N/*@}*/ /* end of group PDMA_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group PDMA_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__PDMA_H__
N
N/*** (C) COPYRIGHT 2014~2015 Nuvoton Technology Corp. ***/
L 17115 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N#include "tk.h"
L 1 "..\..\..\..\Library\StdDriver\inc\tk.h" 1
N/**************************************************************************//**
N * @file     tk.h
N * @version  V1.00
N * $Revision: 6 $
N * $Date: 15/08/24 4:52p $
N * @brief    M451 Series TK Driver Header File
N *
N * @note
N * Copyright (C) 2014~2015 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __TK_H__
N#define __TK_H__
N
N#include "M451Series.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup TK_Driver TK Driver
N  @{
N*/
N
N/** @addtogroup TK_EXPORTED_CONSTANTS TK Exported Constants
N  @{
N*/
N
N#define TK_SCAN_MODE_SINGLE                 (0UL)  /*!< Touch key single scan mode */
N#define TK_SCAN_MODE_PERIODIC               (TK_CTL_TMRTRGEN_Msk)  /*!< Touch key periodic scan mode */
N#define TK_SCAN_MODE_ALL_KEY                (TK_REFCTL_SCANALL_Msk)  /*!< Touch key all keys scan mode */
N#define TK_SCAN_MODE_PERIODIC_ALL_KEY       (TK_CTL_TMRTRGEN_Msk | TK_REFCTL_SCANALL_Msk)  /*!< Touch key periodic with all keys scan mode */
N
N#define TK_SENSE_PULSE_1                    (0UL << TK_REFCTL_SENPTCTL_Pos)  /*!< Touch key sensing pulse width is 1us */
N#define TK_SENSE_PULSE_2                    (1UL << TK_REFCTL_SENPTCTL_Pos)  /*!< Touch key sensing pulse width is 2us */
N#define TK_SENSE_PULSE_4                    (2UL << TK_REFCTL_SENPTCTL_Pos)  /*!< Touch key sensing pulse width is 4us */
N#define TK_SENSE_PULSE_8                    (3UL << TK_REFCTL_SENPTCTL_Pos)  /*!< Touch key sensing pulse width is 8us */
N
N#define TK_SENSE_CNT_128                    (0UL << TK_REFCTL_SENTCTL_Pos)  /*!< Touch key sensing count is 128 */
N#define TK_SENSE_CNT_255                    (1UL << TK_REFCTL_SENTCTL_Pos)  /*!< Touch key sensing count is 255 */
N#define TK_SENSE_CNT_511                    (2UL << TK_REFCTL_SENTCTL_Pos)  /*!< Touch key sensing count is 511 */
N#define TK_SENSE_CNT_1023                   (3UL << TK_REFCTL_SENTCTL_Pos)  /*!< Touch key sensing count is 1023 */
N
N#define TK_AVCCH_1_DIV_16                   (0UL << TK_CTL_AVCCHSEL_Pos)  /*!< Touch key AVCCH voltage is 1/16 VDD */
N#define TK_AVCCH_1_DIV_8                    (1UL << TK_CTL_AVCCHSEL_Pos)  /*!< Touch key AVCCH voltage is 1/8 VDD */
N#define TK_AVCCH_3_DIV_16                   (2UL << TK_CTL_AVCCHSEL_Pos)  /*!< Touch key AVCCH voltage is 3/16 VDD */
N#define TK_AVCCH_1_DIV_4                    (3UL << TK_CTL_AVCCHSEL_Pos)  /*!< Touch key AVCCH voltage is 1/4 VDD */
N#define TK_AVCCH_5_DIV_16                   (4UL << TK_CTL_AVCCHSEL_Pos)  /*!< Touch key AVCCH voltage is 5/16 VDD */
N#define TK_AVCCH_3_DIV_8                    (5UL << TK_CTL_AVCCHSEL_Pos)  /*!< Touch key AVCCH voltage is 3/8 VDD */
N#define TK_AVCCH_7_DIV_16                   (6UL << TK_CTL_AVCCHSEL_Pos)  /*!< Touch key AVCCH voltage is 7/16 VDD */
N#define TK_AVCCH_1_DIV_2                    (7UL << TK_CTL_AVCCHSEL_Pos)  /*!< Touch key AVCCH voltage is 1/2 VDD */
N
N#define TK_CAP_BANK_POL_SEL_GND             (0UL << TK_POLCTL_CBPOLSEL_Pos)  /*!< Touch key capacitor bank polarity is GND */
N#define TK_CAP_BANK_POL_SEL_AVCCH           (1UL << TK_POLCTL_CBPOLSEL_Pos)  /*!< Touch key capacitor bank polarity is AVCCH */
N#define TK_CAP_BANK_POL_SEL_VDD             (2UL << TK_POLCTL_CBPOLSEL_Pos)  /*!< Touch key capacitor bank polarity is VDD */
N
N#define TK_TKn_POL_SEL_GND                  (0UL)  /*!< Touch key polarity is GND */
N#define TK_TKn_POL_SEL_AVCCH                (1UL)  /*!< Touch key polarity is AVCCH */
N#define TK_TKn_POL_SEL_VDD                  (2UL)  /*!< Touch key polarity is VDD */
N
N#define TK_INT_EN_SCAN_COMPLETE             (TK_INTEN_SCINTEN_Msk)  /*!< Touch key enable scan complete interrupt */
N#define TK_INT_EN_SCAN_COMPLETE_EDGE_TH     (TK_INTEN_SCTHIEN_Msk)  /*!< Touch key enable scan complete with threshold interrupt of edge trigger mode */
N#define TK_INT_EN_SCAN_COMPLETE_LEVEL_TH    (TK_INTEN_THIMOD_Msk | TK_INTEN_SCTHIEN_Msk)  /*!< Touch key enable scan complete with threshold interrupt of level trigger mode */
N
N#define TK_INT_SCAN_COMPLETE                (TK_STATUS_SCIF_Msk)  /*!< Touch key scan complete interrupt */
N#define TK_INT_SCAN_COMPLETE_TH_ALL         (0x1FFFF02UL)  /*!< Touch key scan complete or all touch keys threshold control interrupt */
N#define TK_INT_SCAN_TH_ALL                  (0x1FFFF00UL)  /*!< ALL Touch key threshold control interrupt */
N#define TK_INT_SCAN_TH_TK0                  (TK_STATUS_TKIF0_Msk)  /*!< Touch key 0 threshold control interrupt */
N#define TK_INT_SCAN_TH_TK1                  (TK_STATUS_TKIF1_Msk)  /*!< Touch key 1 threshold control interrupt */
N#define TK_INT_SCAN_TH_TK2                  (TK_STATUS_TKIF2_Msk)  /*!< Touch key 2 threshold control interrupt */
N#define TK_INT_SCAN_TH_TK3                  (TK_STATUS_TKIF3_Msk)  /*!< Touch key 3 threshold control interrupt */
N#define TK_INT_SCAN_TH_TK4                  (TK_STATUS_TKIF4_Msk)  /*!< Touch key 4 threshold control interrupt */
N#define TK_INT_SCAN_TH_TK5                  (TK_STATUS_TKIF5_Msk)  /*!< Touch key 5 threshold control interrupt */
N#define TK_INT_SCAN_TH_TK6                  (TK_STATUS_TKIF6_Msk)  /*!< Touch key 6 threshold control interrupt */
N#define TK_INT_SCAN_TH_TK7                  (TK_STATUS_TKIF7_Msk)  /*!< Touch key 7 threshold control interrupt */
N#define TK_INT_SCAN_TH_TK8                  (TK_STATUS_TKIF8_Msk)  /*!< Touch key 8 threshold control interrupt */
N#define TK_INT_SCAN_TH_TK9                  (TK_STATUS_TKIF9_Msk)  /*!< Touch key 9 threshold control interrupt */
N#define TK_INT_SCAN_TH_TK10                 (TK_STATUS_TKIF10_Msk)  /*!< Touch key 10 threshold control interrupt */
N#define TK_INT_SCAN_TH_TK11                 (TK_STATUS_TKIF11_Msk)  /*!< Touch key 11 threshold control interrupt */
N#define TK_INT_SCAN_TH_TK12                 (TK_STATUS_TKIF12_Msk)  /*!< Touch key 12 threshold control interrupt */
N#define TK_INT_SCAN_TH_TK13                 (TK_STATUS_TKIF13_Msk)  /*!< Touch key 13 threshold control interrupt */
N#define TK_INT_SCAN_TH_TK14                 (TK_STATUS_TKIF14_Msk)  /*!< Touch key 14 threshold control interrupt */
N#define TK_INT_SCAN_TH_TK15                 (TK_STATUS_TKIF15_Msk)  /*!< Touch key 15 threshold control interrupt */
N#define TK_INT_SCAN_TH_TK16                 (TK_STATUS_TKIF16_Msk)  /*!< Touch key 16 threshold control interrupt */
N
N
N/*@}*/ /* end of group TK_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup TK_EXPORTED_FUNCTIONS TK Exported Functions
N  @{
N*/
N
N/**
N * @brief Enable scan key(s)
N * @param[in] u32Mask Combination of enabled scan keys. Each bit corresponds to a touch key.
N *                           Bit 0 represents touch key 0, bit 1 represents touch key 1...
N * @return None
N * @note Touch key 16 is the default reference key, so touch key 16 is enabled.
N * \hideinitializer
N */
N#define TK_ENABLE_SCAN_KEY(u32Mask) (TK->CTL |= (u32Mask))
N
N/**
N * @brief Disable scan key(s)
N * @param[in] u32Mask Combination of disabled scan keys. Each bit corresponds to a touch key.
N *                           Bit 0 represents touch key 0, bit 1 represents touch key 1...
N * @return None
N * \hideinitializer
N */
N#define TK_DISABLE_SCAN_KEY(u32Mask) (TK->CTL &= ~(u32Mask))
N
N/**
N * @brief Enable reference key(s)
N * @param[in] u32Mask Combination of enabled reference keys. Each bit corresponds to a touch key.
N *                           Bit 0 represents touch key 0, bit 1 represents touch key 1...
N * @return None
N * @note Touch key 16 is the default reference key, so touch key 16 is enabled.
N * \hideinitializer
N */
N#define TK_ENABLE_REF_KEY(u32Mask) (TK->REFCTL |= (u32Mask))
N
N/**
N * @brief Disable reference key(s)
N * @param[in] u32Mask Combination of disabled reference keys. Each bit corresponds to a touch key.
N *                           Bit 0 represents touch key 0, bit 1 represents touch key 1...
N * @return None
N * @note It must enable a reference key and touch key 16 is the default reference key.
N *       If no any one touch key as reference key except touch key 16, then reference Touch key 16 can't be disable.
N * \hideinitializer
N */
N#define TK_DISABLE_REF_KEY(u32Mask) (TK->REFCTL &= ~(u32Mask))
N
N/**
N * @brief Initiate enabled key(s) scan immediately.
N * @param None
N * @return None
N * \hideinitializer
N */
N#define TK_START_SCAN() (TK->CTL |= TK_CTL_SCAN_Msk)
N
N/**
N * @brief Set touch key Sensing pulse width.
N * @param[in] u32PulseWidth Sensing pulse width.
N *              - \ref TK_SENSE_PULSE_1
N *              - \ref TK_SENSE_PULSE_2
N *              - \ref TK_SENSE_PULSE_4
N *              - \ref TK_SENSE_PULSE_8
N * @return None
N * \hideinitializer
N */
N#define TK_SET_PULSE_WIDTH(u32PulseWidth) (TK->REFCTL = (TK->REFCTL & ~TK_REFCTL_SENPTCTL_Msk) | (u32PulseWidth))
N
N/**
N * @brief Set touch key Sensing count.
N * @param[in] u32SenseCnt Sensing count.
N *              - \ref TK_SENSE_CNT_128
N *              - \ref TK_SENSE_CNT_255
N *              - \ref TK_SENSE_CNT_511
N *              - \ref TK_SENSE_CNT_1023
N * @return None
N * \hideinitializer
N */
N#define TK_SET_SENSING_CNT(u32SenseCnt) (TK->REFCTL = (TK->REFCTL & ~TK_REFCTL_SENTCTL_Msk) | (u32SenseCnt))
N
N
N/**
N * @brief Set touch key AVCCH voltage.
N * @param[in] u32AVCCHSel voltage selection.
N *              - \ref TK_AVCCH_1_DIV_16
N *              - \ref TK_AVCCH_1_DIV_8
N *              - \ref TK_AVCCH_3_DIV_16
N *              - \ref TK_AVCCH_1_DIV_4
N *              - \ref TK_AVCCH_5_DIV_16
N *              - \ref TK_AVCCH_3_DIV_8
N *              - \ref TK_AVCCH_7_DIV_16
N *              - \ref TK_AVCCH_1_DIV_2
N * @return None
N * \hideinitializer
N */
N#define TK_SET_AVCCH(u32AVCCHSel) (TK->CTL = (TK->CTL & ~TK_CTL_AVCCHSEL_Msk) | (u32AVCCHSel))
N
N/**
N * @brief Get touch key complement capacitor bank data.
N * @param[in] u32TKNum Touch key number. The valid value is 0~16.
N * @return Complement capacitor bank data
N * \hideinitializer
N */
N#define TK_GET_COMP_CAP_BANK_DATA(u32TKNum) (((*(__IO uint32_t *) (&(TK->CCBDAT0) + ((u32TKNum) >> 2))) >> ((u32TKNum) % 4 * 8) & TK_CCBDAT0_CCBDAT0_Msk))
N
N/**
N * @brief Get touch key sensing result data.
N * @param[in] u32TKNum Touch key number. The valid value is 0~16.
N * @return Sensing result data
N * \hideinitializer
N */
N#define TK_GET_SENSE_DATA(u32TKNum) (((*(__IO uint32_t *) (&(TK->DAT0) + ((u32TKNum) >> 2))) >> ((u32TKNum) % 4 * 8) & TK_DAT0_TKDAT0_Msk))
N
N/**
N * @brief Get touch key busy status.
N * @param None
N * @retval 0 Touch key is scan completed or stopped.
N * @retval 1 Touch key is busy.
N * \hideinitializer
N */
N#define TK_IS_BUSY() ((TK->STATUS & TK_STATUS_BUSY_Msk) ? 1: 0)
N
N/**
N * @brief Get touch key interrupt flag.
N * @param[in] u32Mask Interrupt flag type selection.
N *              - \ref TK_INT_SCAN_COMPLETE
N *              - \ref TK_INT_SCAN_COMPLETE_TH_ALL
N *              - \ref TK_INT_SCAN_TH_ALL
N *              - \ref TK_INT_SCAN_TH_TK0
N *              - \ref TK_INT_SCAN_TH_TK1
N *              - \ref TK_INT_SCAN_TH_TK2
N *              - \ref TK_INT_SCAN_TH_TK3
N *              - \ref TK_INT_SCAN_TH_TK4
N *              - \ref TK_INT_SCAN_TH_TK5
N *              - \ref TK_INT_SCAN_TH_TK6
N *              - \ref TK_INT_SCAN_TH_TK7
N *              - \ref TK_INT_SCAN_TH_TK8
N *              - \ref TK_INT_SCAN_TH_TK9
N *              - \ref TK_INT_SCAN_TH_TK10
N *              - \ref TK_INT_SCAN_TH_TK11
N *              - \ref TK_INT_SCAN_TH_TK12
N *              - \ref TK_INT_SCAN_TH_TK13
N *              - \ref TK_INT_SCAN_TH_TK14
N *              - \ref TK_INT_SCAN_TH_TK15
N *              - \ref TK_INT_SCAN_TH_TK16
N * @retval 0 Touch key has no interrupt.
N * @retval 1 Touch key is scan completed or threshold control event occurs.
N * \hideinitializer
N */
N#define TK_GET_INT_STATUS(u32Mask) ((TK->STATUS & (u32Mask)) ? 1: 0)
N
N/**
N * @brief Clear touch key interrupt flag.
N * @param[in] u32Mask Interrupt flag type selection.
N *              - \ref TK_INT_SCAN_COMPLETE
N *              - \ref TK_INT_SCAN_COMPLETE_TH_ALL
N *              - \ref TK_INT_SCAN_TH_ALL
N *              - \ref TK_INT_SCAN_TH_TK0
N *              - \ref TK_INT_SCAN_TH_TK1
N *              - \ref TK_INT_SCAN_TH_TK2
N *              - \ref TK_INT_SCAN_TH_TK3
N *              - \ref TK_INT_SCAN_TH_TK4
N *              - \ref TK_INT_SCAN_TH_TK5
N *              - \ref TK_INT_SCAN_TH_TK6
N *              - \ref TK_INT_SCAN_TH_TK7
N *              - \ref TK_INT_SCAN_TH_TK8
N *              - \ref TK_INT_SCAN_TH_TK9
N *              - \ref TK_INT_SCAN_TH_TK10
N *              - \ref TK_INT_SCAN_TH_TK11
N *              - \ref TK_INT_SCAN_TH_TK12
N *              - \ref TK_INT_SCAN_TH_TK13
N *              - \ref TK_INT_SCAN_TH_TK14
N *              - \ref TK_INT_SCAN_TH_TK15
N *              - \ref TK_INT_SCAN_TH_TK16
N * @return None
N * \hideinitializer
N */
N#define TK_CLR_INT_FLAG(u32Mask) (TK->STATUS = (u32Mask))
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define TK functions prototype                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
Nvoid TK_Open(void);
Nvoid TK_Close(void);
Nvoid TK_SetScanMode(uint32_t u32Mode);
Nvoid TK_ConfigSensitivity(uint32_t u32PulseWidth, uint32_t u32SenseCnt, uint32_t u32AVCCHSel);
Nvoid TK_SetCapBankPol(uint32_t u32CapBankPolSel);
Nvoid TK_EnableTkPolarity(uint32_t u32Mask);
Nvoid TK_DisableTkPolarity(uint32_t u32Mask);
Nvoid TK_SetCompCapBankData(uint32_t u32TKNum, uint32_t u32CapData);
Nvoid TK_SetTkPol(uint32_t u32Mask, uint32_t u32PolSel);
Nvoid TK_SetRefKeyCapBankData(uint32_t u32CapData);
Nvoid TK_SetScanThreshold(uint32_t u32TKNum, uint32_t u32HighLevel, uint32_t u32LowLevel);
Nvoid TK_EnableInt(uint32_t u32Msk);
Nvoid TK_DisableInt(uint32_t u32Msk);
N
N
N/*@}*/ /* end of group TK_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group TK_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__TK_H__
N
N/*** (C) COPYRIGHT 2014~2015 Nuvoton Technology Corp. ***/
L 17116 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N#include "otg.h"
L 1 "..\..\..\..\Library\StdDriver\inc\otg.h" 1
N/**************************************************************************//**
N * @file     otg.h
N * @version  V0.10
N * $Revision: 3 $
N * $Date: 15/08/11 10:26a $
N * @brief    M451 Series OTG Driver Header File
N *
N * @note
N * Copyright (C) 2014~2015 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __OTG_H__
N#define __OTG_H__
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Include related headers                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#include "M451Series.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup OTG_Driver OTG Driver
N  @{
N*/
N
N
N/** @addtogroup OTG_EXPORTED_CONSTANTS OTG Exported Constants
N  @{
N*/
N
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* OTG constant definitions                                                                                */
N/*---------------------------------------------------------------------------------------------------------*/
N#define OTG_VBUS_EN_ACTIVE_HIGH      (0UL) /*!< USB VBUS power switch enable signal is active high. */
N#define OTG_VBUS_EN_ACTIVE_LOW       (1UL) /*!< USB VBUS power switch enable signal is active low. */
N#define OTG_VBUS_ST_VALID_HIGH       (0UL) /*!< USB VBUS power switch valid status is high. */
N#define OTG_VBUS_ST_VALID_LOW        (1UL) /*!< USB VBUS power switch valid status is low. */
N
N
N/*@}*/ /* end of group OTG_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup OTG_EXPORTED_FUNCTIONS OTG Exported Functions
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Macros and functions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N
N
N/**
N  * @brief This macro is used to enable OTG function
N  * @param None
N  * @return None
N  * @details This macro will set OTGEN bit of OTG_CTL register to enable OTG function.
N  */
N#define OTG_ENABLE() (OTG->CTL |= OTG_CTL_OTGEN_Msk)
N
N/**
N  * @brief This macro is used to disable OTG function
N  * @param None
N  * @return None
N  * @details This macro will clear OTGEN bit of OTG_CTL register to disable OTG function.
N  */
N#define OTG_DISABLE() (OTG->CTL &= ~OTG_CTL_OTGEN_Msk)
N
N/**
N  * @brief This macro is used to enable USB PHY
N  * @param None
N  * @return None
N  * @details When the USB role is selected as OTG device, use this macro to enable USB PHY.
N  *          This macro will set OTGPHYEN bit of OTG_PHYCTL register to enable USB PHY.
N  */
N#define OTG_ENABLE_PHY() (OTG->PHYCTL |= OTG_PHYCTL_OTGPHYEN_Msk)
N
N/**
N  * @brief This macro is used to disable USB PHY
N  * @param None
N  * @return None
N  * @details This macro will clear OTGPHYEN bit of OTG_PHYCTL register to disable USB PHY.
N  */
N#define OTG_DISABLE_PHY() (OTG->PHYCTL &= ~OTG_PHYCTL_OTGPHYEN_Msk)
N
N/**
N  * @brief This macro is used to enable ID detection function
N  * @param None
N  * @return None
N  * @details This macro will set IDDETEN bit of OTG_PHYCTL register to enable ID detection function.
N  */
N#define OTG_ENABLE_ID_DETECT() (OTG->PHYCTL |= OTG_PHYCTL_IDDETEN_Msk)
N
N/**
N  * @brief This macro is used to disable ID detection function
N  * @param None
N  * @return None
N  * @details This macro will clear IDDETEN bit of OTG_PHYCTL register to disable ID detection function.
N  */
N#define OTG_DISABLE_ID_DETECT() (OTG->PHYCTL &= ~OTG_PHYCTL_IDDETEN_Msk)
N
N/**
N  * @brief This macro is used to enable OTG wake-up function
N  * @param None
N  * @return None
N  * @details This macro will set WKEN bit of OTG_CTL register to enable OTG wake-up function.
N  */
N#define OTG_ENABLE_WAKEUP() (OTG->CTL |= OTG_CTL_WKEN_Msk)
N
N/**
N  * @brief This macro is used to disable OTG wake-up function
N  * @param None
N  * @return None
N  * @details This macro will clear WKEN bit of OTG_CTL register to disable OTG wake-up function.
N  */
N#define OTG_DISABLE_WAKEUP() (OTG->CTL &= ~OTG_CTL_WKEN_Msk)
N
N/**
N  * @brief This macro is used to set the polarity of USB_VBUS_EN pin
N  * @param[in] u32Pol The polarity selection. Valid values are listed below.
N  *                    - \ref OTG_VBUS_EN_ACTIVE_HIGH
N  *                    - \ref OTG_VBUS_EN_ACTIVE_LOW
N  * @return None
N  * @details This macro is used to set the polarity of external USB VBUS power switch enable signal.
N  */
N#define OTG_SET_VBUS_EN_POL(u32Pol) (OTG->PHYCTL = (OTG->PHYCTL & (~OTG_PHYCTL_VBENPOL_Msk)) | ((u32Pol)<<OTG_PHYCTL_VBENPOL_Pos))
N
N/**
N  * @brief This macro is used to set the polarity of USB_VBUS_ST pin
N  * @param[in] u32Pol The polarity selection. Valid values are listed below.
N  *                    - \ref OTG_VBUS_ST_VALID_HIGH
N  *                    - \ref OTG_VBUS_ST_VALID_LOW
N  * @return None
N  * @details This macro is used to set the polarity of external USB VBUS power switch status signal.
N  */
N#define OTG_SET_VBUS_STS_POL(u32Pol) (OTG->PHYCTL = (OTG->PHYCTL & (~OTG_PHYCTL_VBSTSPOL_Msk)) | ((u32Pol)<<OTG_PHYCTL_VBSTSPOL_Pos))
N
N/**
N  * @brief This macro is used to enable OTG related interrupts
N  * @param[in] u32Mask The combination of interrupt source. Each bit corresponds to a interrupt source. Valid values are listed below.
N  *                    - \ref OTG_INTEN_ROLECHGIEN_Msk
N  *                    - \ref OTG_INTEN_VBEIEN_Msk
N  *                    - \ref OTG_INTEN_SRPFIEN_Msk
N  *                    - \ref OTG_INTEN_HNPFIEN_Msk
N  *                    - \ref OTG_INTEN_GOIDLEIEN_Msk
N  *                    - \ref OTG_INTEN_IDCHGIEN_Msk
N  *                    - \ref OTG_INTEN_PDEVIEN_Msk
N  *                    - \ref OTG_INTEN_HOSTIEN_Msk
N  *                    - \ref OTG_INTEN_BVLDCHGIEN_Msk
N  *                    - \ref OTG_INTEN_AVLDCHGIEN_Msk
N  *                    - \ref OTG_INTEN_VBCHGIEN_Msk
N  *                    - \ref OTG_INTEN_SECHGIEN_Msk
N  *                    - \ref OTG_INTEN_SRPDETIEN_Msk
N  * @return None
N  * @details This macro will enable OTG related interrupts specified by u32Mask parameter.
N  */
N#define OTG_ENABLE_INT(u32Mask) (OTG->INTEN |= (u32Mask))
N
N/**
N  * @brief This macro is used to disable OTG related interrupts
N  * @param[in] u32Mask The combination of interrupt source. Each bit corresponds to a interrupt source. Valid values are listed below.
N  *                    - \ref OTG_INTEN_ROLECHGIEN_Msk
N  *                    - \ref OTG_INTEN_VBEIEN_Msk
N  *                    - \ref OTG_INTEN_SRPFIEN_Msk
N  *                    - \ref OTG_INTEN_HNPFIEN_Msk
N  *                    - \ref OTG_INTEN_GOIDLEIEN_Msk
N  *                    - \ref OTG_INTEN_IDCHGIEN_Msk
N  *                    - \ref OTG_INTEN_PDEVIEN_Msk
N  *                    - \ref OTG_INTEN_HOSTIEN_Msk
N  *                    - \ref OTG_INTEN_BVLDCHGIEN_Msk
N  *                    - \ref OTG_INTEN_AVLDCHGIEN_Msk
N  *                    - \ref OTG_INTEN_VBCHGIEN_Msk
N  *                    - \ref OTG_INTEN_SECHGIEN_Msk
N  *                    - \ref OTG_INTEN_SRPDETIEN_Msk
N  * @return None
N  * @details This macro will disable OTG related interrupts specified by u32Mask parameter.
N  */
N#define OTG_DISABLE_INT(u32Mask) (OTG->INTEN &= ~(u32Mask))
N
N/**
N  * @brief This macro is used to get OTG related interrupt flags
N  * @param[in] u32Mask The combination of interrupt source. Each bit corresponds to a interrupt source. Valid values are listed below.
N  *                    - \ref OTG_INTSTS_ROLECHGIF_Msk
N  *                    - \ref OTG_INTSTS_VBEIF_Msk
N  *                    - \ref OTG_INTSTS_SRPFIF_Msk
N  *                    - \ref OTG_INTSTS_HNPFIF_Msk
N  *                    - \ref OTG_INTSTS_GOIDLEIF_Msk
N  *                    - \ref OTG_INTSTS_IDCHGIF_Msk
N  *                    - \ref OTG_INTSTS_PDEVIF_Msk
N  *                    - \ref OTG_INTSTS_HOSTIF_Msk
N  *                    - \ref OTG_INTSTS_BVLDCHGIF_Msk
N  *                    - \ref OTG_INTSTS_AVLDCHGIF_Msk
N  *                    - \ref OTG_INTSTS_VBCHGIF_Msk
N  *                    - \ref OTG_INTSTS_SECHGIF_Msk
N  *                    - \ref OTG_INTSTS_SRPDETIF_Msk
N  * @return Interrupt flags of selected sources.
N  * @details This macro will return OTG related interrupt flags specified by u32Mask parameter.
N  */
N#define OTG_GET_INT_FLAG(u32Mask) (OTG->INTSTS & (u32Mask))
N
N/**
N  * @brief This macro is used to clear OTG related interrupt flags
N  * @param[in] u32Mask The combination of interrupt source. Each bit corresponds to a interrupt source. Valid values are listed below.
N  *                    - \ref OTG_INTSTS_ROLECHGIF_Msk
N  *                    - \ref OTG_INTSTS_VBEIF_Msk
N  *                    - \ref OTG_INTSTS_SRPFIF_Msk
N  *                    - \ref OTG_INTSTS_HNPFIF_Msk
N  *                    - \ref OTG_INTSTS_GOIDLEIF_Msk
N  *                    - \ref OTG_INTSTS_IDCHGIF_Msk
N  *                    - \ref OTG_INTSTS_PDEVIF_Msk
N  *                    - \ref OTG_INTSTS_HOSTIF_Msk
N  *                    - \ref OTG_INTSTS_BVLDCHGIF_Msk
N  *                    - \ref OTG_INTSTS_AVLDCHGIF_Msk
N  *                    - \ref OTG_INTSTS_VBCHGIF_Msk
N  *                    - \ref OTG_INTSTS_SECHGIF_Msk
N  *                    - \ref OTG_INTSTS_SRPDETIF_Msk
N  * @return None
N  * @details This macro will clear OTG related interrupt flags specified by u32Mask parameter.
N  */
N#define OTG_CLR_INT_FLAG(u32Mask) (OTG->INTSTS = (u32Mask))
N
N/**
N  * @brief This macro is used to get OTG related status
N  * @param[in] u32Mask The combination of user specified source. Valid values are listed below.
N  *                    - \ref OTG_STATUS_OVERCUR_Msk
N  *                    - \ref OTG_STATUS_IDSTS_Msk
N  *                    - \ref OTG_STATUS_SESSEND_Msk
N  *                    - \ref OTG_STATUS_BVLD_Msk
N  *                    - \ref OTG_STATUS_AVLD_Msk
N  *                    - \ref OTG_STATUS_VBUSVLD_Msk
N  * @return The user specified status.
N  * @details This macro will return OTG related status specified by u32Mask parameter.
N  */
N#define OTG_GET_STATUS(u32Mask) (OTG->STATUS & (u32Mask))
N
N
N
N/*@}*/ /* end of group OTG_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group OTG_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif //__OTG_H__
N
N/*** (C) COPYRIGHT 2014~2015 Nuvoton Technology Corp. ***/
L 17117 "..\..\..\..\Library\Device\Nuvoton\M451Series\Include\M451Series.h" 2
N
Ntypedef volatile unsigned char  vu8;
Ntypedef volatile unsigned long  vu32;
Ntypedef volatile unsigned short vu16;
N#define M8(adr)  (*((vu8  *) (adr)))
N#define M16(adr) (*((vu16 *) (adr)))
N#define M32(adr) (*((vu32 *) (adr)))
N
N#define outpw(port,value)   (*((volatile unsigned int *)(port))=(value))
N#define inpw(port)          (*((volatile unsigned int *)(port)))
N#define outpb(port,value)   (*((volatile unsigned char *)(port))=(value))
N#define inpb(port)          (*((volatile unsigned char *)(port)))
N#define outps(port,value)   (*((volatile unsigned short *)(port))=(value))
N#define inps(port)          (*((volatile unsigned short *)(port)))
N
N#define outp32(port,value)  (*((volatile unsigned int *)(port))=(value))
N#define inp32(port)         (*((volatile unsigned int *)(port)))
N#define outp8(port,value)   (*((volatile unsigned char *)(port))=(value))
N#define inp8(port)          (*((volatile unsigned char *)(port)))
N#define outp16(port,value)  (*((volatile unsigned short *)(port))=(value))
N#define inp16(port)         (*((volatile unsigned short *)(port)))
N
N/*@}*/ /* end of group PeripheralDecl */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif  /* __M451SERIES_H__ */
N
N/*** (C) COPYRIGHT 2014~2015 Nuvoton Technology Corp. ***/
N
N
N
L 13 "..\..\..\..\Library\StdDriver\src\clk.c" 2
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup CLK_Driver CLK Driver
N  @{
N*/
N
N/** @addtogroup CLK_EXPORTED_FUNCTIONS CLK Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Disable clock divider output function
N  * @param      None
N  * @return     None
N  * @details    This function disable clock divider output function.
N  */
Nvoid CLK_DisableCKO(void)
N{
N    /* Disable CKO clock source */
N    CLK_DisableModuleClock(CLKO_MODULE);
X    CLK_DisableModuleClock(((((1) & 0x03) << 30)|((((6)) & 0x1f) << 0) | (((1) & 0x03) << 28)|(((3) & 0x07) << 25)|(((28) & 0x1f) << 20)| (((0x0) & 0x03) << 18)|(((0x0) & 0xff) << 10)|(((0x0) & 0x1f) << 5)));
N}
N
N/**
N  * @brief      This function enable clock divider output module clock,
N  *             enable clock divider output function and set frequency selection.
N  * @param[in]  u32ClkSrc is frequency divider function clock source. Including :
N  *             - \ref CLK_CLKSEL1_CLKOSEL_HXT
N  *             - \ref CLK_CLKSEL1_CLKOSEL_LXT
N  *             - \ref CLK_CLKSEL1_CLKOSEL_HCLK
N  *             - \ref CLK_CLKSEL1_CLKOSEL_HIRC
N  * @param[in]  u32ClkDiv is divider output frequency selection. It could be 0~15.
N  * @param[in]  u32ClkDivBy1En is clock divided by one enabled.
N  * @return     None
N  * @details    Output selected clock to CKO. The output clock frequency is divided by u32ClkDiv. \n
N  *             The formula is: \n
N  *                 CKO frequency = (Clock source frequency) / 2^(u32ClkDiv + 1) \n
N  *             This function is just used to set CKO clock.
N  *             User must enable I/O for CKO clock output pin by themselves. \n
N  */
Nvoid CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En)
N{
N    /* CKO = clock source / 2^(u32ClkDiv + 1) */
N    CLK->CLKOCTL = CLK_CLKOCTL_CLKOEN_Msk | u32ClkDiv | (u32ClkDivBy1En << CLK_CLKOCTL_DIV1EN_Pos);
X    ((CLK_T *) ((0x40000000UL) + 0x00200))->CLKOCTL = (0x1ul << (4)) | u32ClkDiv | (u32ClkDivBy1En << (5));
N
N    /* Enable CKO clock source */
N    CLK_EnableModuleClock(CLKO_MODULE);
X    CLK_EnableModuleClock(((((1) & 0x03) << 30)|((((6)) & 0x1f) << 0) | (((1) & 0x03) << 28)|(((3) & 0x07) << 25)|(((28) & 0x1f) << 20)| (((0x0) & 0x03) << 18)|(((0x0) & 0xff) << 10)|(((0x0) & 0x1f) << 5)));
N
N    /* Select CKO clock source */
N    CLK_SetModuleClock(CLKO_MODULE, u32ClkSrc, 0);
X    CLK_SetModuleClock(((((1) & 0x03) << 30)|((((6)) & 0x1f) << 0) | (((1) & 0x03) << 28)|(((3) & 0x07) << 25)|(((28) & 0x1f) << 20)| (((0x0) & 0x03) << 18)|(((0x0) & 0xff) << 10)|(((0x0) & 0x1f) << 5)), u32ClkSrc, 0);
N}
N
N/**
N  * @brief      Enter to Power-down mode
N  * @param      None
N  * @return     None
N  * @details    This function is used to let system enter to Power-down mode. \n
N  *             The register write-protection function should be disabled before using this function. 
N  */
Nvoid CLK_PowerDown(void)
N{
N    /* Set the processor uses deep sleep as its low power mode */
N    SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SCR |= (1UL << 2);
N
N    /* Set system Power-down enabled and Power-down entry condition */
N    CLK->PWRCTL |= (CLK_PWRCTL_PDEN_Msk | CLK_PWRCTL_PDWTCPU_Msk);
X    ((CLK_T *) ((0x40000000UL) + 0x00200))->PWRCTL |= ((0x1ul << (7)) | (0x1ul << (8)));
N
N    /* Chip enter Power-down mode after CPU run WFI instruction */
N    __WFI();
X    __wfi();
N}
N
N/**
N  * @brief      Enter to Idle mode
N  * @param      None
N  * @return     None
N  * @details    This function let system enter to Idle mode. \n
N  *             The register write-protection function should be disabled before using this function.
N  */
Nvoid CLK_Idle(void)
N{
N    /* Set the processor uses sleep as its low power mode */
N    SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SCR &= ~(1UL << 2);
N
N    /* Set chip in idle mode because of WFI command */
N    CLK->PWRCTL &= ~CLK_PWRCTL_PDEN_Msk;
X    ((CLK_T *) ((0x40000000UL) + 0x00200))->PWRCTL &= ~(0x1ul << (7));
N
N    /* Chip enter idle mode after CPU run WFI instruction */
N    __WFI();
X    __wfi();
N}
N
N/**
N  * @brief      Get external high speed crystal clock frequency
N  * @param      None
N  * @return     External high frequency crystal frequency
N  * @details    This function get external high frequency crystal frequency. The frequency unit is Hz.
N  */
Nuint32_t CLK_GetHXTFreq(void)
N{
N    if(CLK->PWRCTL & CLK_PWRCTL_HXTEN_Msk)
X    if(((CLK_T *) ((0x40000000UL) + 0x00200))->PWRCTL & (0x1ul << (0)))
N        return __HXT;
X        return (12000000UL);
N    else
N        return 0;
N}
N
N
N/**
N  * @brief      Get external low speed crystal clock frequency
N  * @param      None
N  * @return     External low speed crystal clock frequency
N  * @details    This function get external low frequency crystal frequency. The frequency unit is Hz.
N  */
Nuint32_t CLK_GetLXTFreq(void)
N{
N    if(CLK->PWRCTL & CLK_PWRCTL_LXTEN_Msk)
X    if(((CLK_T *) ((0x40000000UL) + 0x00200))->PWRCTL & (0x1ul << (1)))
N        return __LXT;
X        return (32768UL);
N    else
N        return 0;
N}
N
N/**
N  * @brief      Get PCLK0 frequency
N  * @param      None
N  * @return     PCLK0 frequency
N  * @details    This function get PCLK0 frequency. The frequency unit is Hz.
N  */
Nuint32_t CLK_GetPCLK0Freq(void)
N{
N    SystemCoreClockUpdate();
N    if(CLK->CLKSEL0 & CLK_CLKSEL0_PCLK0SEL_Msk)
X    if(((CLK_T *) ((0x40000000UL) + 0x00200))->CLKSEL0 & (0x1ul << (6)))
N        return SystemCoreClock / 2;
N    else
N        return SystemCoreClock;
N}
N
N
N/**
N  * @brief      Get PCLK1 frequency
N  * @param      None
N  * @return     PCLK1 frequency
N  * @details    This function get PCLK1 frequency. The frequency unit is Hz.
N  */
Nuint32_t CLK_GetPCLK1Freq(void)
N{
N    SystemCoreClockUpdate();
N    if(CLK->CLKSEL0 & CLK_CLKSEL0_PCLK1SEL_Msk)
X    if(((CLK_T *) ((0x40000000UL) + 0x00200))->CLKSEL0 & (0x1ul << (7)))
N        return SystemCoreClock / 2;
N    else
N        return SystemCoreClock;
N}
N
N
N/**
N  * @brief      Get HCLK frequency
N  * @param      None
N  * @return     HCLK frequency
N  * @details    This function get HCLK frequency. The frequency unit is Hz.
N  */
Nuint32_t CLK_GetHCLKFreq(void)
N{
N    SystemCoreClockUpdate();
N    return SystemCoreClock;
N}
N
N
N/**
N  * @brief      Get CPU frequency
N  * @param      None
N  * @return     CPU frequency
N  * @details    This function get CPU frequency. The frequency unit is Hz.
N  */
Nuint32_t CLK_GetCPUFreq(void)
N{
N    SystemCoreClockUpdate();
N    return SystemCoreClock;
N}
N
N
N/**
N  * @brief      Set HCLK frequency
N  * @param[in]  u32Hclk is HCLK frequency. The range of u32Hclk is 25 MHz ~ 72 MHz.
N  * @return     HCLK frequency
N  * @details    This function is used to set HCLK frequency. The frequency unit is Hz. \n
N  *             It would configure PLL frequency to 50MHz ~ 144MHz,
N  *             set HCLK clock divider as 2 and switch HCLK clock source to PLL. \n
N  *             The register write-protection function should be disabled before using this function.
N  */
Nuint32_t CLK_SetCoreClock(uint32_t u32Hclk)
N{
N    uint32_t u32HIRCSTB;
N
N    /* Read HIRC clock source stable flag */
N    u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
X    u32HIRCSTB = ((CLK_T *) ((0x40000000UL) + 0x00200))->STATUS & (0x1ul << (4));
N
N    /* The range of u32Hclk is 25 MHz ~ 72 MHz */
N    if(u32Hclk > FREQ_72MHZ)
X    if(u32Hclk > 72000000)
N        u32Hclk = FREQ_72MHZ;
X        u32Hclk = 72000000;
N    if(u32Hclk < FREQ_25MHZ)
X    if(u32Hclk < 25000000)
N        u32Hclk = FREQ_25MHZ;
X        u32Hclk = 25000000;
N
N    /* Switch HCLK clock source to HIRC clock for safe */
N    CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
X    ((CLK_T *) ((0x40000000UL) + 0x00200))->PWRCTL |= (0x1ul << (2));
N    CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
X    CLK_WaitClockReady((0x1ul << (4)));
N    CLK->CLKSEL0 |= CLK_CLKSEL0_HCLKSEL_Msk;
X    ((CLK_T *) ((0x40000000UL) + 0x00200))->CLKSEL0 |= (0x7ul << (0));
N    CLK->CLKDIV0 &= (~CLK_CLKDIV0_HCLKDIV_Msk);
X    ((CLK_T *) ((0x40000000UL) + 0x00200))->CLKDIV0 &= (~(0xful << (0)));
N
N    /* Configure PLL setting if HXT clock is enabled */
N    if(CLK->PWRCTL & CLK_PWRCTL_HXTEN_Msk)
X    if(((CLK_T *) ((0x40000000UL) + 0x00200))->PWRCTL & (0x1ul << (0)))
N        u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HXT, (u32Hclk << 1));
X        u32Hclk = CLK_EnablePLL(0x00000000UL, (u32Hclk << 1));
N
N    /* Configure PLL setting if HXT clock is not enabled */
N    else
N    {
N        u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HIRC, (u32Hclk << 1));
X        u32Hclk = CLK_EnablePLL(0x00080000UL, (u32Hclk << 1));
N
N        /* Read HIRC clock source stable flag */
N        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
X        u32HIRCSTB = ((CLK_T *) ((0x40000000UL) + 0x00200))->STATUS & (0x1ul << (4));
N    }
N
N    /* Select HCLK clock source to PLL,
N       Select HCLK clock source divider as 2
N       and update system core clock
N    */
N    CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_PLL, CLK_CLKDIV0_HCLK(2));
X    CLK_SetHCLK((0x02UL<<(0)), (((2)-1) << (0)));
N
N    /* Disable HIRC if HIRC is disabled before setting core clock */
N    if(u32HIRCSTB == 0)
N        CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
X        ((CLK_T *) ((0x40000000UL) + 0x00200))->PWRCTL &= ~(0x1ul << (2));
N
N    /* Return actually HCLK frequency is PLL frequency divide 2 */
N    return u32Hclk >> 1;
N}
N
N/**
N  * @brief      This function set HCLK clock source and HCLK clock divider
N  * @param[in]  u32ClkSrc is HCLK clock source. Including :
N  *             - \ref CLK_CLKSEL0_HCLKSEL_HXT
N  *             - \ref CLK_CLKSEL0_HCLKSEL_LXT
N  *             - \ref CLK_CLKSEL0_HCLKSEL_PLL
N  *             - \ref CLK_CLKSEL0_HCLKSEL_LIRC
N  *             - \ref CLK_CLKSEL0_HCLKSEL_HIRC
N  * @param[in]  u32ClkDiv is HCLK clock divider. Including :
N  *             - \ref CLK_CLKDIV0_HCLK(x)
N  * @return     None
N  * @details    This function set HCLK clock source and HCLK clock divider. \n
N  *             The register write-protection function should be disabled before using this function.
N  */
Nvoid CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
N{
N    uint32_t u32HIRCSTB;
N
N    /* Read HIRC clock source stable flag */
N    u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
X    u32HIRCSTB = ((CLK_T *) ((0x40000000UL) + 0x00200))->STATUS & (0x1ul << (4));
N
N    /* Switch to HIRC for Safe. Avoid HCLK too high when applying new divider. */
N    CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
X    ((CLK_T *) ((0x40000000UL) + 0x00200))->PWRCTL |= (0x1ul << (2));
N    CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
X    CLK_WaitClockReady((0x1ul << (4)));
N    CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | CLK_CLKSEL0_HCLKSEL_HIRC;
X    ((CLK_T *) ((0x40000000UL) + 0x00200))->CLKSEL0 = (((CLK_T *) ((0x40000000UL) + 0x00200))->CLKSEL0 & (~(0x7ul << (0)))) | (0x07UL<<(0));
N
N    /* Apply new Divider */
N    CLK->CLKDIV0 = (CLK->CLKDIV0 & (~CLK_CLKDIV0_HCLKDIV_Msk)) | u32ClkDiv;
X    ((CLK_T *) ((0x40000000UL) + 0x00200))->CLKDIV0 = (((CLK_T *) ((0x40000000UL) + 0x00200))->CLKDIV0 & (~(0xful << (0)))) | u32ClkDiv;
N
N    /* Switch HCLK to new HCLK source */
N    CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | u32ClkSrc;
X    ((CLK_T *) ((0x40000000UL) + 0x00200))->CLKSEL0 = (((CLK_T *) ((0x40000000UL) + 0x00200))->CLKSEL0 & (~(0x7ul << (0)))) | u32ClkSrc;
N
N    /* Update System Core Clock */
N    SystemCoreClockUpdate();
N
N    /* Disable HIRC if HIRC is disabled before switching HCLK source */
N    if(u32HIRCSTB == 0)
N        CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
X        ((CLK_T *) ((0x40000000UL) + 0x00200))->PWRCTL &= ~(0x1ul << (2));
N}
N
N/**
N  * @brief      This function set selected module clock source and module clock divider
N  * @param[in]  u32ModuleIdx is module index.
N  * @param[in]  u32ClkSrc is module clock source.
N  * @param[in]  u32ClkDiv is module clock divider.
N  * @return     None
N  * @details    Valid parameter combinations listed in following table:
N  *
N  * |Module index        |Clock source                           |Divider                  |
N  * | :----------------  | :-----------------------------------  | :---------------------- |
N  * |\ref WDT_MODULE     |\ref CLK_CLKSEL1_WDTSEL_LXT            | x                       |
N  * |\ref WDT_MODULE     |\ref CLK_CLKSEL1_WDTSEL_PCLK0_DIV2048  | x                       |
N  * |\ref WDT_MODULE     |\ref CLK_CLKSEL1_WDTSEL_LIRC           | x                       |
N  * |\ref RTC_MODULE     |\ref CLK_CLKSEL3_RTCSEL_LXT            | x                       |
N  * |\ref RTC_MODULE     |\ref CLK_CLKSEL3_RTCSEL_LIRC           | x                       |
N  * |\ref TMR0_MODULE    |\ref CLK_CLKSEL1_TMR0SEL_HXT           | x                       |
N  * |\ref TMR0_MODULE    |\ref CLK_CLKSEL1_TMR0SEL_LXT           | x                       |
N  * |\ref TMR0_MODULE    |\ref CLK_CLKSEL1_TMR0SEL_PCLK0         | x                       |
N  * |\ref TMR0_MODULE    |\ref CLK_CLKSEL1_TMR0SEL_EXT_TRG       | x                       |
N  * |\ref TMR0_MODULE    |\ref CLK_CLKSEL1_TMR0SEL_LIRC          | x                       |
N  * |\ref TMR0_MODULE    |\ref CLK_CLKSEL1_TMR0SEL_HIRC          | x                       |
N  * |\ref TMR1_MODULE    |\ref CLK_CLKSEL1_TMR1SEL_HXT           | x                       |
N  * |\ref TMR1_MODULE    |\ref CLK_CLKSEL1_TMR1SEL_LXT           | x                       |
N  * |\ref TMR1_MODULE    |\ref CLK_CLKSEL1_TMR1SEL_PCLK0         | x                       |
N  * |\ref TMR1_MODULE    |\ref CLK_CLKSEL1_TMR1SEL_EXT_TRG       | x                       |
N  * |\ref TMR1_MODULE    |\ref CLK_CLKSEL1_TMR1SEL_LIRC          | x                       |
N  * |\ref TMR1_MODULE    |\ref CLK_CLKSEL1_TMR1SEL_HIRC          | x                       |
N  * |\ref TMR2_MODULE    |\ref CLK_CLKSEL1_TMR2SEL_HXT           | x                       |
N  * |\ref TMR2_MODULE    |\ref CLK_CLKSEL1_TMR2SEL_LXT           | x                       |
N  * |\ref TMR2_MODULE    |\ref CLK_CLKSEL1_TMR2SEL_PCLK1         | x                       |
N  * |\ref TMR2_MODULE    |\ref CLK_CLKSEL1_TMR2SEL_EXT_TRG       | x                       |
N  * |\ref TMR2_MODULE    |\ref CLK_CLKSEL1_TMR2SEL_LIRC          | x                       |
N  * |\ref TMR2_MODULE    |\ref CLK_CLKSEL1_TMR2SEL_HIRC          | x                       |
N  * |\ref TMR3_MODULE    |\ref CLK_CLKSEL1_TMR3SEL_HXT           | x                       |
N  * |\ref TMR3_MODULE    |\ref CLK_CLKSEL1_TMR3SEL_LXT           | x                       |
N  * |\ref TMR3_MODULE    |\ref CLK_CLKSEL1_TMR3SEL_PCLK1         | x                       |
N  * |\ref TMR3_MODULE    |\ref CLK_CLKSEL1_TMR3SEL_EXT_TRG       | x                       |
N  * |\ref TMR3_MODULE    |\ref CLK_CLKSEL1_TMR3SEL_LIRC          | x                       |
N  * |\ref TMR3_MODULE    |\ref CLK_CLKSEL1_TMR3SEL_HIRC          | x                       |
N  * |\ref CLKO_MODULE    |\ref CLK_CLKSEL1_CLKOSEL_HXT           | x                       |
N  * |\ref CLKO_MODULE    |\ref CLK_CLKSEL1_CLKOSEL_LXT           | x                       |
N  * |\ref CLKO_MODULE    |\ref CLK_CLKSEL1_CLKOSEL_HCLK          | x                       |
N  * |\ref CLKO_MODULE    |\ref CLK_CLKSEL1_CLKOSEL_HIRC          | x                       |
N  * |\ref SPI0_MODULE    |\ref CLK_CLKSEL2_SPI0SEL_HXT           | x                       |
N  * |\ref SPI0_MODULE    |\ref CLK_CLKSEL2_SPI0SEL_PLL           | x                       |
N  * |\ref SPI0_MODULE    |\ref CLK_CLKSEL2_SPI0SEL_PCLK0         | x                       |
N  * |\ref SPI0_MODULE    |\ref CLK_CLKSEL2_SPI0SEL_HIRC          | x                       |
N  * |\ref SPI1_MODULE    |\ref CLK_CLKSEL2_SPI1SEL_HXT           | x                       |
N  * |\ref SPI1_MODULE    |\ref CLK_CLKSEL2_SPI1SEL_PLL           | x                       |
N  * |\ref SPI1_MODULE    |\ref CLK_CLKSEL2_SPI1SEL_PCLK1         | x                       |
N  * |\ref SPI1_MODULE    |\ref CLK_CLKSEL2_SPI1SEL_HIRC          | x                       |
N  * |\ref SPI2_MODULE    |\ref CLK_CLKSEL2_SPI2SEL_HXT           | x                       |
N  * |\ref SPI2_MODULE    |\ref CLK_CLKSEL2_SPI2SEL_PLL           | x                       |
N  * |\ref SPI2_MODULE    |\ref CLK_CLKSEL2_SPI2SEL_PCLK0         | x                       |
N  * |\ref SPI2_MODULE    |\ref CLK_CLKSEL2_SPI2SEL_HIRC          | x                       |
N  * |\ref UART0_MODULE   |\ref CLK_CLKSEL1_UARTSEL_HXT           |\ref CLK_CLKDIV0_UART(x) |
N  * |\ref UART0_MODULE   |\ref CLK_CLKSEL1_UARTSEL_PLL           |\ref CLK_CLKDIV0_UART(x) |
N  * |\ref UART0_MODULE   |\ref CLK_CLKSEL1_UARTSEL_LXT           |\ref CLK_CLKDIV0_UART(x) |
N  * |\ref UART0_MODULE   |\ref CLK_CLKSEL1_UARTSEL_HIRC          |\ref CLK_CLKDIV0_UART(x) |
N  * |\ref UART1_MODULE   |\ref CLK_CLKSEL1_UARTSEL_HXT           |\ref CLK_CLKDIV0_UART(x) |
N  * |\ref UART1_MODULE   |\ref CLK_CLKSEL1_UARTSEL_PLL           |\ref CLK_CLKDIV0_UART(x) |
N  * |\ref UART1_MODULE   |\ref CLK_CLKSEL1_UARTSEL_LXT           |\ref CLK_CLKDIV0_UART(x) |
N  * |\ref UART1_MODULE   |\ref CLK_CLKSEL1_UARTSEL_HIRC          |\ref CLK_CLKDIV0_UART(x) |
N  * |\ref UART2_MODULE   |\ref CLK_CLKSEL1_UARTSEL_HXT           |\ref CLK_CLKDIV0_UART(x) |
N  * |\ref UART2_MODULE   |\ref CLK_CLKSEL1_UARTSEL_PLL           |\ref CLK_CLKDIV0_UART(x) |
N  * |\ref UART2_MODULE   |\ref CLK_CLKSEL1_UARTSEL_LXT           |\ref CLK_CLKDIV0_UART(x) |
N  * |\ref UART2_MODULE   |\ref CLK_CLKSEL1_UARTSEL_HIRC          |\ref CLK_CLKDIV0_UART(x) |
N  * |\ref UART3_MODULE   |\ref CLK_CLKSEL1_UARTSEL_HXT           |\ref CLK_CLKDIV0_UART(x) |
N  * |\ref UART3_MODULE   |\ref CLK_CLKSEL1_UARTSEL_LXT           |\ref CLK_CLKDIV0_UART(x) |
N  * |\ref UART3_MODULE   |\ref CLK_CLKSEL1_UARTSEL_PLL           |\ref CLK_CLKDIV0_UART(x) |
N  * |\ref UART3_MODULE   |\ref CLK_CLKSEL1_UARTSEL_HIRC          |\ref CLK_CLKDIV0_UART(x) |
N  * |\ref USBH_MODULE    | x                                     |\ref CLK_CLKDIV0_USB(x)  |
N  * |\ref USBD_MODULE    | x                                     |\ref CLK_CLKDIV0_USB(x)  |
N  * |\ref OTG_MODULE     | x                                     |\ref CLK_CLKDIV0_USB(x)  |
N  * |\ref EADC_MODULE    | x                                     |\ref CLK_CLKDIV0_EADC(x) |
N  * |\ref SC0_MODULE     |\ref CLK_CLKSEL3_SC0SEL_HXT            |\ref CLK_CLKDIV1_SC0(x)  |
N  * |\ref SC0_MODULE     |\ref CLK_CLKSEL3_SC0SEL_PLL            |\ref CLK_CLKDIV1_SC0(x)  |
N  * |\ref SC0_MODULE     |\ref CLK_CLKSEL3_SC0SEL_PCLK0          |\ref CLK_CLKDIV1_SC0(x)  |
N  * |\ref SC0_MODULE     |\ref CLK_CLKSEL3_SC0SEL_HIRC           |\ref CLK_CLKDIV1_SC0(x)  |
N  * |\ref PWM0_MODULE    |\ref CLK_CLKSEL2_PWM0SEL_PLL           | x                       |
N  * |\ref PWM0_MODULE    |\ref CLK_CLKSEL2_PWM0SEL_PCLK0         | x                       |
N  * |\ref PWM1_MODULE    |\ref CLK_CLKSEL2_PWM1SEL_PLL           | x                       |
N  * |\ref PWM1_MODULE    |\ref CLK_CLKSEL2_PWM1SEL_PCLK1         | x                       |
N  * |\ref WWDT_MODULE    |\ref CLK_CLKSEL1_WWDTSEL_PCLK0_DIV2048 | x                       |
N  * |\ref WWDT_MODULE    |\ref CLK_CLKSEL1_WWDTSEL_LIRC          | x                       |
N  */
Nvoid CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv)
N{
N    uint32_t u32sel = 0, u32div = 0;
N
N    if(MODULE_CLKDIV_Msk(u32ModuleIdx) != MODULE_NoMsk)
X    if((((u32ModuleIdx) >>10) & 0xff) != 0x0)
N    {
N        /* Get clock divider control register address */
N        u32div = (uint32_t)&CLK->CLKDIV0 + ((MODULE_CLKDIV(u32ModuleIdx)) * 4);
X        u32div = (uint32_t)&((CLK_T *) ((0x40000000UL) + 0x00200))->CLKDIV0 + (((((u32ModuleIdx) >>18) & 0x3)) * 4);
N        /* Apply new divider */
N        M32(u32div) = (M32(u32div) & (~(MODULE_CLKDIV_Msk(u32ModuleIdx) << MODULE_CLKDIV_Pos(u32ModuleIdx)))) | u32ClkDiv;
X        (*((vu32 *) (u32div))) = ((*((vu32 *) (u32div))) & (~((((u32ModuleIdx) >>10) & 0xff) << (((u32ModuleIdx) >>5 ) & 0x1f)))) | u32ClkDiv;
N    }
N
N    if(MODULE_CLKSEL_Msk(u32ModuleIdx) != MODULE_NoMsk)
X    if((((u32ModuleIdx) >>25) & 0x7) != 0x0)
N    {
N        /* Get clock select control register address */
N        u32sel = (uint32_t)&CLK->CLKSEL0 + ((MODULE_CLKSEL(u32ModuleIdx)) * 4);
X        u32sel = (uint32_t)&((CLK_T *) ((0x40000000UL) + 0x00200))->CLKSEL0 + (((((u32ModuleIdx) >>28) & 0x3)) * 4);
N        /* Set new clock selection setting */
N        M32(u32sel) = (M32(u32sel) & (~(MODULE_CLKSEL_Msk(u32ModuleIdx) << MODULE_CLKSEL_Pos(u32ModuleIdx)))) | u32ClkSrc;
X        (*((vu32 *) (u32sel))) = ((*((vu32 *) (u32sel))) & (~((((u32ModuleIdx) >>25) & 0x7) << (((u32ModuleIdx) >>20) & 0x1f)))) | u32ClkSrc;
N    }
N}
N
N
N/**
N  * @brief      Set SysTick clock source
N  * @param[in]  u32ClkSrc is module clock source. Including:
N  *             - \ref CLK_CLKSEL0_STCLKSEL_HXT
N  *             - \ref CLK_CLKSEL0_STCLKSEL_LXT
N  *             - \ref CLK_CLKSEL0_STCLKSEL_HXT_DIV2
N  *             - \ref CLK_CLKSEL0_STCLKSEL_HCLK_DIV2
N  *             - \ref CLK_CLKSEL0_STCLKSEL_HIRC_DIV2
N  * @return     None
N  * @details    This function set SysTick clock source. \n
N  *             The register write-protection function should be disabled before using this function.
N  */
Nvoid CLK_SetSysTickClockSrc(uint32_t u32ClkSrc)
N{
N    CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
X    ((CLK_T *) ((0x40000000UL) + 0x00200))->CLKSEL0 = (((CLK_T *) ((0x40000000UL) + 0x00200))->CLKSEL0 & ~(0x7ul << (3))) | u32ClkSrc;
N
N}
N
N/**
N  * @brief      Enable clock source
N  * @param[in]  u32ClkMask is clock source mask. Including :
N  *             - \ref CLK_PWRCTL_HXTEN_Msk
N  *             - \ref CLK_PWRCTL_LXTEN_Msk
N  *             - \ref CLK_PWRCTL_HIRCEN_Msk
N  *             - \ref CLK_PWRCTL_LIRCEN_Msk
N  * @return     None
N  * @details    This function enable clock source. \n
N  *             The register write-protection function should be disabled before using this function.
N  */
Nvoid CLK_EnableXtalRC(uint32_t u32ClkMask)
N{
N    CLK->PWRCTL |= u32ClkMask;
X    ((CLK_T *) ((0x40000000UL) + 0x00200))->PWRCTL |= u32ClkMask;
N}
N
N/**
N  * @brief      Disable clock source
N  * @param[in]  u32ClkMask is clock source mask. Including :
N  *             - \ref CLK_PWRCTL_HXTEN_Msk
N  *             - \ref CLK_PWRCTL_LXTEN_Msk
N  *             - \ref CLK_PWRCTL_HIRCEN_Msk
N  *             - \ref CLK_PWRCTL_LIRCEN_Msk
N  * @return     None
N  * @details    This function disable clock source. \n
N  *             The register write-protection function should be disabled before using this function.
N  */
Nvoid CLK_DisableXtalRC(uint32_t u32ClkMask)
N{
N    CLK->PWRCTL &= ~u32ClkMask;
X    ((CLK_T *) ((0x40000000UL) + 0x00200))->PWRCTL &= ~u32ClkMask;
N}
N
N/**
N  * @brief      Enable module clock
N  * @param[in]  u32ModuleIdx is module index. Including :
N  *             - \ref PDMA_MODULE
N  *             - \ref ISP_MODULE
N  *             - \ref EBI_MODULE
N  *             - \ref USBH_MODULE
N  *             - \ref CRC_MODULE
N  *             - \ref WDT_MODULE
N  *             - \ref WWDT_MODULE
N  *             - \ref RTC_MODULE
N  *             - \ref TMR0_MODULE
N  *             - \ref TMR1_MODULE
N  *             - \ref TMR2_MODULE
N  *             - \ref TMR3_MODULE
N  *             - \ref CLKO_MODULE
N  *             - \ref ACMP01_MODULE
N  *             - \ref I2C0_MODULE
N  *             - \ref I2C1_MODULE
N  *             - \ref SPI0_MODULE
N  *             - \ref SPI1_MODULE
N  *             - \ref SPI2_MODULE
N  *             - \ref UART0_MODULE
N  *             - \ref UART1_MODULE
N  *             - \ref UART2_MODULE
N  *             - \ref UART3_MODULE
N  *             - \ref CAN0_MODULE
N  *             - \ref OTG_MODULE
N  *             - \ref USBD_MODULE
N  *             - \ref EADC_MODULE
N  *             - \ref SC0_MODULE
N  *             - \ref DAC_MODULE
N  *             - \ref PWM0_MODULE
N  *             - \ref PWM1_MODULE
N  *             - \ref TK_MODULE
N  * @return     None
N  * @details    This function is used to enable module clock.
N  */
Nvoid CLK_EnableModuleClock(uint32_t u32ModuleIdx)
N{
N    *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK + (MODULE_APBCLK(u32ModuleIdx) * 4))  |= 1 << MODULE_IP_EN_Pos(u32ModuleIdx);
X    *(volatile uint32_t *)((uint32_t)&((CLK_T *) ((0x40000000UL) + 0x00200))->AHBCLK + ((((u32ModuleIdx) >>30) & 0x3) * 4))  |= 1 << (((u32ModuleIdx) >>0 ) & 0x1f);
N}
N
N/**
N  * @brief      Disable module clock
N  * @param[in]  u32ModuleIdx is module index. Including :
N  *             - \ref PDMA_MODULE
N  *             - \ref ISP_MODULE
N  *             - \ref EBI_MODULE
N  *             - \ref USBH_MODULE
N  *             - \ref CRC_MODULE
N  *             - \ref WDT_MODULE
N  *             - \ref WWDT_MODULE
N  *             - \ref RTC_MODULE
N  *             - \ref TMR0_MODULE
N  *             - \ref TMR1_MODULE
N  *             - \ref TMR2_MODULE
N  *             - \ref TMR3_MODULE
N  *             - \ref CLKO_MODULE
N  *             - \ref ACMP01_MODULE
N  *             - \ref I2C0_MODULE
N  *             - \ref I2C1_MODULE
N  *             - \ref SPI0_MODULE
N  *             - \ref SPI1_MODULE
N  *             - \ref SPI2_MODULE
N  *             - \ref UART0_MODULE
N  *             - \ref UART1_MODULE
N  *             - \ref UART2_MODULE
N  *             - \ref UART3_MODULE
N  *             - \ref CAN0_MODULE
N  *             - \ref OTG_MODULE
N  *             - \ref USBD_MODULE
N  *             - \ref EADC_MODULE
N  *             - \ref SC0_MODULE
N  *             - \ref DAC_MODULE
N  *             - \ref PWM0_MODULE
N  *             - \ref PWM1_MODULE
N  *             - \ref TK_MODULE
N  * @return     None
N  * @details    This function is used to disable module clock.
N  */
Nvoid CLK_DisableModuleClock(uint32_t u32ModuleIdx)
N{
N    *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK + (MODULE_APBCLK(u32ModuleIdx) * 4))  &= ~(1 << MODULE_IP_EN_Pos(u32ModuleIdx));
X    *(volatile uint32_t *)((uint32_t)&((CLK_T *) ((0x40000000UL) + 0x00200))->AHBCLK + ((((u32ModuleIdx) >>30) & 0x3) * 4))  &= ~(1 << (((u32ModuleIdx) >>0 ) & 0x1f));
N}
N
N
N/**
N  * @brief      Set PLL frequency
N  * @param[in]  u32PllClkSrc is PLL clock source. Including :
N  *             - \ref CLK_PLLCTL_PLLSRC_HXT
N  *             - \ref CLK_PLLCTL_PLLSRC_HIRC
N  * @param[in]  u32PllFreq is PLL frequency.
N  * @return     PLL frequency
N  * @details    This function is used to configure PLLCTL register to set specified PLL frequency. \n
N  *             The register write-protection function should be disabled before using this function.
N  */
Nuint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq)
N{
N    uint32_t u32PllSrcClk, u32NR, u32NF, u32NO, u32CLK_SRC;
N    uint32_t u32Tmp, u32Tmp2, u32Tmp3, u32Min, u32MinNF, u32MinNR;
N
N    /* Disable PLL first to avoid unstable when setting PLL */
N    CLK_DisablePLL();
N
N    /* PLL source clock is from HXT */
N    if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
X    if(u32PllClkSrc == 0x00000000UL)
N    {
N        /* Enable HXT clock */
N        CLK->PWRCTL |= CLK_PWRCTL_HXTEN_Msk;
X        ((CLK_T *) ((0x40000000UL) + 0x00200))->PWRCTL |= (0x1ul << (0));
N
N        /* Wait for HXT clock ready */
N        CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
X        CLK_WaitClockReady((0x1ul << (0)));
N
N        /* Select PLL source clock from HXT */
N        u32CLK_SRC = CLK_PLLCTL_PLLSRC_HXT;
X        u32CLK_SRC = 0x00000000UL;
N        u32PllSrcClk = __HXT;
X        u32PllSrcClk = (12000000UL);
N
N        /* u32NR start from 2 */
N        u32NR = 2;
N    }
N
N    /* PLL source clock is from HIRC */
N    else
N    {
N        /* Enable HIRC clock */
N        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
X        ((CLK_T *) ((0x40000000UL) + 0x00200))->PWRCTL |= (0x1ul << (2));
N
N        /* Wait for HIRC clock ready */
N        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
X        CLK_WaitClockReady((0x1ul << (4)));
N
N        /* Select PLL source clock from HIRC */
N        u32CLK_SRC = CLK_PLLCTL_PLLSRC_HIRC;
X        u32CLK_SRC = 0x00080000UL;
N        u32PllSrcClk = __HIRC;
X        u32PllSrcClk = (22118400UL);
N
N        /* u32NR start from 4 when FIN = 22.1184MHz to avoid calculation overflow */
N        u32NR = 4;
N    }
N
N    /* Select "NO" according to request frequency */
N    if((u32PllFreq <= FREQ_500MHZ) && (u32PllFreq > FREQ_250MHZ))
X    if((u32PllFreq <= 500000000) && (u32PllFreq > 250000000))
N    {
N        u32NO = 0;
N    }
N    else if((u32PllFreq <= FREQ_250MHZ) && (u32PllFreq > FREQ_125MHZ))
X    else if((u32PllFreq <= 250000000) && (u32PllFreq > 125000000))
N    {
N        u32NO = 1;
N        u32PllFreq = u32PllFreq << 1;
N    }
N    else if((u32PllFreq <= FREQ_125MHZ) && (u32PllFreq >= FREQ_50MHZ))
X    else if((u32PllFreq <= 125000000) && (u32PllFreq >= 50000000))
N    {
N        u32NO = 3;
N        u32PllFreq = u32PllFreq << 2;
N    }
N    else
N    {
N        /* Wrong frequency request. Just return default setting. */
N        goto lexit;
N    }
N
N    /* Find best solution */
N    u32Min = (uint32_t) - 1;
N    u32MinNR = 0;
N    u32MinNF = 0;
N    for(; u32NR <= 33; u32NR++)
N    {
N        u32Tmp = u32PllSrcClk / u32NR;
N        if((u32Tmp > 1600000) && (u32Tmp < 16000000))
N        {
N            for(u32NF = 2; u32NF <= 513; u32NF++)
N            {
N                u32Tmp2 = u32Tmp * u32NF;
N                if((u32Tmp2 >= 200000000) && (u32Tmp2 <= 500000000))
N                {
N                    u32Tmp3 = (u32Tmp2 > u32PllFreq) ? u32Tmp2 - u32PllFreq : u32PllFreq - u32Tmp2;
N                    if(u32Tmp3 < u32Min)
N                    {
N                        u32Min = u32Tmp3;
N                        u32MinNR = u32NR;
N                        u32MinNF = u32NF;
N
N                        /* Break when get good results */
N                        if(u32Min == 0)
N                            break;
N                    }
N                }
N            }
N        }
N    }
N
N    /* Enable and apply new PLL setting. */
N    CLK->PLLCTL = u32CLK_SRC | (u32NO << 14) | ((u32MinNR - 2) << 9) | (u32MinNF - 2);
X    ((CLK_T *) ((0x40000000UL) + 0x00200))->PLLCTL = u32CLK_SRC | (u32NO << 14) | ((u32MinNR - 2) << 9) | (u32MinNF - 2);
N
N    /* Wait for PLL clock stable */
N    CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
X    CLK_WaitClockReady((0x1ul << (2)));
N
N    /* Return actual PLL output clock frequency */
N    return u32PllSrcClk / ((u32NO + 1) * u32MinNR) * u32MinNF;
N
Nlexit:
N
N    /* Apply default PLL setting and return */
N    if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
X    if(u32PllClkSrc == 0x00000000UL)
N        CLK->PLLCTL = CLK_PLLCTL_72MHz_HXT; /* 72MHz */
X        ((CLK_T *) ((0x40000000UL) + 0x00200))->PLLCTL = (0x00000000UL | (((2)-2)<<9) | ((48)-2) | 0xC000UL);  
N    else
N        CLK->PLLCTL = CLK_PLLCTL_72MHz_HIRC; /* 71.8848MHz */
X        ((CLK_T *) ((0x40000000UL) + 0x00200))->PLLCTL = (0x00080000UL | (((4)-2)<<9) | ((52)-2) | 0xC000UL);  
N
N    /* Wait for PLL clock stable */
N    CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
X    CLK_WaitClockReady((0x1ul << (2)));
N
N    return CLK_GetPLLClockFreq();
N
N}
N
N/**
N  * @brief      Disable PLL
N  * @param      None
N  * @return     None
N  * @details    This function set PLL in Power-down mode. \n
N  *             The register write-protection function should be disabled before using this function.
N  */
Nvoid CLK_DisablePLL(void)
N{
N    CLK->PLLCTL |= CLK_PLLCTL_PD_Msk;
X    ((CLK_T *) ((0x40000000UL) + 0x00200))->PLLCTL |= (0x1ul << (16));
N}
N
N
N/**
N  * @brief      This function check selected clock source status
N  * @param[in]  u32ClkMask is selected clock source. Including :
N  *             - \ref CLK_STATUS_HXTSTB_Msk
N  *             - \ref CLK_STATUS_LXTSTB_Msk
N  *             - \ref CLK_STATUS_HIRCSTB_Msk
N  *             - \ref CLK_STATUS_LIRCSTB_Msk
N  *             - \ref CLK_STATUS_PLLSTB_Msk
N  * @retval     0  clock is not stable
N  * @retval     1  clock is stable
N  * @details    To wait for clock ready by specified clock source stable flag or timeout (~300ms)
N  */
Nuint32_t CLK_WaitClockReady(uint32_t u32ClkMask)
N{    
N    int32_t i32TimeOutCnt = 2160000;
N
N    while((CLK->STATUS & u32ClkMask) != u32ClkMask)
X    while((((CLK_T *) ((0x40000000UL) + 0x00200))->STATUS & u32ClkMask) != u32ClkMask)
N    {
N        if(i32TimeOutCnt-- <= 0)
N            return 0;
N    }
N
N    return 1;
N}
N
N/**
N  * @brief      Enable System Tick counter
N  * @param[in]  u32ClkSrc is System Tick clock source. Including:
N  *             - \ref CLK_CLKSEL0_STCLKSEL_HXT
N  *             - \ref CLK_CLKSEL0_STCLKSEL_LXT
N  *             - \ref CLK_CLKSEL0_STCLKSEL_HXT_DIV2
N  *             - \ref CLK_CLKSEL0_STCLKSEL_HCLK_DIV2
N  *             - \ref CLK_CLKSEL0_STCLKSEL_HIRC_DIV2
N  *             - \ref CLK_CLKSEL0_STCLKSEL_HCLK
N  * @param[in]  u32Count is System Tick reload value. It could be 0~0xFFFFFF.
N  * @return     None
N  * @details    This function set System Tick clock source, reload value, enable System Tick counter and interrupt. \n
N  *             The register write-protection function should be disabled before using this function. 
N  */
Nvoid CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count) 
N{
N    /* Set System Tick counter disabled */
N    SysTick->CTRL = 0;    
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = 0;    
N
N    /* Set System Tick clock source */
N    if( u32ClkSrc == CLK_CLKSEL0_STCLKSEL_HCLK )         
X    if( u32ClkSrc == (0x01UL<<2) )         
N        SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
X        ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL |= (1UL << 2);
N    else
N        CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc; 
X        ((CLK_T *) ((0x40000000UL) + 0x00200))->CLKSEL0 = (((CLK_T *) ((0x40000000UL) + 0x00200))->CLKSEL0 & ~(0x7ul << (3))) | u32ClkSrc; 
N
N    /* Set System Tick reload value */
N    SysTick->LOAD = u32Count;   
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD = u32Count;   
N    
N    /* Clear System Tick current value and counter flag */
N    SysTick->VAL = 0;           
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL = 0;           
N    
N    /* Set System Tick interrupt enabled and counter enabled */    
N    SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;       
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL |= (1UL << 1) | (1UL << 0);       
N}
N
N/**
N  * @brief      Disable System Tick counter
N  * @param      None 
N  * @return     None
N  * @details    This function disable System Tick counter.
N  */
Nvoid CLK_DisableSysTick(void) 
N{    
N    /* Set System Tick counter disabled */
N	SysTick->CTRL = 0;    
X	((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = 0;    
N}
N
N
N/*@}*/ /* end of group CLK_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group CLK_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N/*** (C) COPYRIGHT 2014~2015 Nuvoton Technology Corp. ***/
