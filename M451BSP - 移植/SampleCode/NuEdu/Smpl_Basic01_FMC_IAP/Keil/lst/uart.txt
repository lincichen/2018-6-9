; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\uart.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\uart.d --cpu=Cortex-M4.fp --apcs=interwork -L6969W -I..\..\..\..\Library\Device\Nuvoton\M451Series\Include -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\Library\NuEdu\inc -I.\zmodem -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -DDEBUG_ENABLE_SEMIHOST --omf_browse=.\obj\uart.crf ..\..\..\..\Library\StdDriver\src\uart.c]
                          THUMB

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;357      */
;;;358    __STATIC_INLINE uint32_t CLK_GetPLLClockFreq(void)
000000  b508              PUSH     {r3,lr}
;;;359    {
;;;360        uint32_t u32PllFreq = 0, u32PllReg;
;;;361        uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;362        uint8_t au8NoTbl[4] = {1, 2, 2, 4};
000002  a012              ADR      r0,|L1.76|
000004  6800              LDR      r0,[r0,#0]
;;;363    
;;;364        u32PllReg = CLK->PLLCTL;
000006  9000              STR      r0,[sp,#0]
000008  f04f4080          MOV      r0,#0x40000000
00000c  f8d01240          LDR      r1,[r0,#0x240]
;;;365    
;;;366        if(u32PllReg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk))
000010  f4112fa0          TST      r1,#0x50000
000014  d001              BEQ      |L1.26|
;;;367            return 0;           /* PLL is in power down mode or fix low */
000016  2000              MOVS     r0,#0
                  |L1.24|
;;;368    
;;;369        if(u32PllReg & CLK_PLLCTL_PLLSRC_HIRC)
;;;370            u32FIN = __HIRC;    /* PLL source clock from HIRC */
;;;371        else
;;;372            u32FIN = __HXT;     /* PLL source clock from HXT */
;;;373    
;;;374        if(u32PllReg & CLK_PLLCTL_BP_Msk)
;;;375            return u32FIN;      /* PLL is in bypass mode */
;;;376    
;;;377        /* PLL is output enabled in normal work mode */
;;;378        u32NO = au8NoTbl[((u32PllReg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
;;;379        u32NF = ((u32PllReg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2;
;;;380        u32NR = ((u32PllReg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 2;
;;;381    
;;;382        /* u32FIN is shifted 2 bits to avoid overflow */
;;;383        u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
;;;384    
;;;385        return u32PllFreq;
;;;386    }
000018  bd08              POP      {r3,pc}
                  |L1.26|
00001a  0308              LSLS     r0,r1,#12             ;369
00001c  d501              BPL      |L1.34|
00001e  480c              LDR      r0,|L1.80|
000020  e000              B        |L1.36|
                  |L1.34|
000022  480c              LDR      r0,|L1.84|
                  |L1.36|
000024  038a              LSLS     r2,r1,#14             ;374
000026  d4f7              BMI      |L1.24|
000028  f3c10208          UBFX     r2,r1,#0,#9           ;379
00002c  f3c13381          UBFX     r3,r1,#14,#2          ;378
000030  0880              LSRS     r0,r0,#2              ;383
000032  1c92              ADDS     r2,r2,#2              ;383
000034  f81d3003          LDRB     r3,[sp,r3]            ;378
000038  f3c12144          UBFX     r1,r1,#9,#5           ;380
00003c  4350              MULS     r0,r2,r0              ;383
00003e  1c89              ADDS     r1,r1,#2              ;383
000040  fb11f103          SMULBB   r1,r1,r3              ;383
000044  fbb0f0f1          UDIV     r0,r0,r1              ;383
000048  0080              LSLS     r0,r0,#2              ;383
00004a  bd08              POP      {r3,pc}
;;;387    
                          ENDP

                  |L1.76|
00004c  01020204          DCB      1,2,2,4
                  |L1.80|
                          DCD      0x01518000
                  |L1.84|
                          DCD      0x00b71b00

                          AREA ||i.NVIC_DisableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_DisableIRQ PROC
;;;1464    */
;;;1465   __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1466   {
;;;1467     NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01180          STR      r1,[r0,#0x180]
;;;1468   }
000014  4770              BX       lr
;;;1469   
                          ENDP


                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1451    */
;;;1452   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1453   {
;;;1454   /*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
;;;1455     NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1456   }
000014  4770              BX       lr
;;;1457   
                          ENDP


                          AREA ||i.UART_ClearIntFlag||, CODE, READONLY, ALIGN=2

                  UART_ClearIntFlag PROC
;;;43     
;;;44     void UART_ClearIntFlag(UART_T* uart , uint32_t u32InterruptFlag)
000000  054a              LSLS     r2,r1,#21
;;;45     {
000002  d503              BPL      |L4.12|
;;;46     
;;;47         if(u32InterruptFlag & UART_INTSTS_RLSINT_Msk)   /* Clear Receive Line Status Interrupt */
;;;48         {
;;;49             uart->FIFOSTS = UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_FEF_Msk;
000004  2260              MOVS     r2,#0x60
000006  6182              STR      r2,[r0,#0x18]
;;;50             uart->FIFOSTS = UART_FIFOSTS_ADDRDETF_Msk;
000008  2208              MOVS     r2,#8
00000a  6182              STR      r2,[r0,#0x18]
                  |L4.12|
;;;51         }
;;;52     
;;;53         if(u32InterruptFlag & UART_INTSTS_MODEMINT_Msk)  /* Clear Modem Status Interrupt */
00000c  050a              LSLS     r2,r1,#20
00000e  d503              BPL      |L4.24|
;;;54             uart->MODEMSTS |= UART_MODEMSTS_CTSDETF_Msk;
000010  6942              LDR      r2,[r0,#0x14]
000012  f0420201          ORR      r2,r2,#1
000016  6142              STR      r2,[r0,#0x14]
                  |L4.24|
;;;55     
;;;56         if(u32InterruptFlag & UART_INTSTS_BUFERRINT_Msk)   /* Clear Buffer Error Interrupt */
000018  048a              LSLS     r2,r1,#18
00001a  d501              BPL      |L4.32|
;;;57         {
;;;58             uart->FIFOSTS = UART_FIFOSTS_RXOVIF_Msk | UART_FIFOSTS_TXOVIF_Msk;
00001c  4a09              LDR      r2,|L4.68|
00001e  6182              STR      r2,[r0,#0x18]
                  |L4.32|
;;;59         }
;;;60     
;;;61         if(u32InterruptFlag & UART_INTSTS_CTSWKIF_Msk)   /* Clear CTS Wake-up Interrupt */
000020  03ca              LSLS     r2,r1,#15
000022  d502              BPL      |L4.42|
;;;62         {
;;;63             uart->INTSTS = UART_INTSTS_CTSWKIF_Msk;
000024  f44f3280          MOV      r2,#0x10000
000028  61c2              STR      r2,[r0,#0x1c]
                  |L4.42|
;;;64         }
;;;65     
;;;66         if(u32InterruptFlag & UART_INTSTS_DATWKIF_Msk)   /* Clear Data Wake-up Interrupt */
00002a  038a              LSLS     r2,r1,#14
00002c  d502              BPL      |L4.52|
;;;67         {
;;;68             uart->INTSTS = UART_INTSTS_DATWKIF_Msk;
00002e  f44f3200          MOV      r2,#0x20000
000032  61c2              STR      r2,[r0,#0x1c]
                  |L4.52|
;;;69         }
;;;70     
;;;71         if(u32InterruptFlag & UART_INTSTS_LININT_Msk)   /* Clear LIN Bus Interrupt */
000034  0409              LSLS     r1,r1,#16
000036  d504              BPL      |L4.66|
;;;72         {
;;;73             uart->INTSTS = UART_INTSTS_LINIF_Msk;
000038  2180              MOVS     r1,#0x80
00003a  61c1              STR      r1,[r0,#0x1c]
;;;74             uart->LINSTS = UART_LINSTS_BITEF_Msk    | UART_LINSTS_BRKDETF_Msk  |
00003c  f240310f          MOV      r1,#0x30f
000040  6381              STR      r1,[r0,#0x38]
                  |L4.66|
;;;75                            UART_LINSTS_SLVSYNCF_Msk | UART_LINSTS_SLVIDPEF_Msk |
;;;76                            UART_LINSTS_SLVHEF_Msk   | UART_LINSTS_SLVHDETF_Msk ;
;;;77         }
;;;78     }
000042  4770              BX       lr
;;;79     
                          ENDP

                  |L4.68|
                          DCD      0x01000001

                          AREA ||i.UART_Close||, CODE, READONLY, ALIGN=1

                  UART_Close PROC
;;;89      */
;;;90     void UART_Close(UART_T* uart)
000000  2100              MOVS     r1,#0
;;;91     {
;;;92         uart->INTEN = 0;
000002  6041              STR      r1,[r0,#4]
;;;93     }
000004  4770              BX       lr
;;;94     
                          ENDP


                          AREA ||i.UART_DisableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_DisableFlowCtrl PROC
;;;104     */
;;;105    void UART_DisableFlowCtrl(UART_T* uart)
000000  6841              LDR      r1,[r0,#4]
;;;106    {
;;;107        uart->INTEN &= ~(UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk);
000002  f4215140          BIC      r1,r1,#0x3000
000006  6041              STR      r1,[r0,#4]
;;;108    }
000008  4770              BX       lr
;;;109    
                          ENDP


                          AREA ||i.UART_DisableInt||, CODE, READONLY, ALIGN=2

                  UART_DisableInt PROC
;;;129     */
;;;130    void UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag)
000000  6842              LDR      r2,[r0,#4]
;;;131    {
;;;132        /* Disable UART specified interrupt */
;;;133        UART_DISABLE_INT(uart, u32InterruptFlag);
000002  438a              BICS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
;;;134    
;;;135        /* Disable NVIC UART IRQ */
;;;136        if(uart == UART0)
000006  4909              LDR      r1,|L7.44|
000008  4288              CMP      r0,r1
00000a  d101              BNE      |L7.16|
;;;137            NVIC_DisableIRQ(UART0_IRQn);
00000c  2024              MOVS     r0,#0x24
00000e  e00a              B        |L7.38|
                  |L7.16|
;;;138        else if(uart == UART1)
000010  4907              LDR      r1,|L7.48|
000012  4288              CMP      r0,r1
000014  d101              BNE      |L7.26|
;;;139            NVIC_DisableIRQ(UART1_IRQn);
000016  2025              MOVS     r0,#0x25
000018  e005              B        |L7.38|
                  |L7.26|
;;;140        else if(uart == UART2)
00001a  4906              LDR      r1,|L7.52|
00001c  4288              CMP      r0,r1
00001e  d101              BNE      |L7.36|
;;;141            NVIC_DisableIRQ(UART2_IRQn);
000020  2030              MOVS     r0,#0x30
000022  e000              B        |L7.38|
                  |L7.36|
;;;142        else
;;;143            NVIC_DisableIRQ(UART3_IRQn);
000024  2031              MOVS     r0,#0x31
                  |L7.38|
000026  f7ffbffe          B.W      NVIC_DisableIRQ
;;;144    }
;;;145    
                          ENDP

00002a  0000              DCW      0x0000
                  |L7.44|
                          DCD      0x40070000
                  |L7.48|
                          DCD      0x40071000
                  |L7.52|
                          DCD      0x40072000

                          AREA ||i.UART_EnableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_EnableFlowCtrl PROC
;;;155     */
;;;156    void UART_EnableFlowCtrl(UART_T* uart)
000000  6901              LDR      r1,[r0,#0x10]
;;;157    {
;;;158        /* Set RTS pin output is low level active */
;;;159        uart->MODEM |= UART_MODEM_RTSACTLV_Msk;
000002  f4417100          ORR      r1,r1,#0x200
000006  6101              STR      r1,[r0,#0x10]
;;;160    
;;;161        /* Set CTS pin input is low level active */
;;;162        uart->MODEMSTS |= UART_MODEMSTS_CTSACTLV_Msk;
000008  6941              LDR      r1,[r0,#0x14]
00000a  f4417180          ORR      r1,r1,#0x100
00000e  6141              STR      r1,[r0,#0x14]
;;;163    
;;;164        /* Set RTS and CTS auto flow control enable */
;;;165        uart->INTEN |= UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk;
000010  6841              LDR      r1,[r0,#4]
000012  f4415140          ORR      r1,r1,#0x3000
000016  6041              STR      r1,[r0,#4]
;;;166    }
000018  4770              BX       lr
;;;167    
                          ENDP


                          AREA ||i.UART_EnableInt||, CODE, READONLY, ALIGN=2

                  UART_EnableInt PROC
;;;187     */
;;;188    void UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag)
000000  6842              LDR      r2,[r0,#4]
;;;189    {
;;;190    
;;;191        /* Enable UART specified interrupt */
;;;192        UART_ENABLE_INT(uart, u32InterruptFlag);
000002  430a              ORRS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
;;;193    
;;;194        /* Enable NVIC UART IRQ */
;;;195        if(uart == UART0)
000006  4909              LDR      r1,|L9.44|
000008  4288              CMP      r0,r1
00000a  d101              BNE      |L9.16|
;;;196            NVIC_EnableIRQ(UART0_IRQn);
00000c  2024              MOVS     r0,#0x24
00000e  e00a              B        |L9.38|
                  |L9.16|
;;;197        else if(uart == UART1)
000010  4907              LDR      r1,|L9.48|
000012  4288              CMP      r0,r1
000014  d101              BNE      |L9.26|
;;;198            NVIC_EnableIRQ(UART1_IRQn);
000016  2025              MOVS     r0,#0x25
000018  e005              B        |L9.38|
                  |L9.26|
;;;199        else if(uart == UART2)
00001a  4906              LDR      r1,|L9.52|
00001c  4288              CMP      r0,r1
00001e  d101              BNE      |L9.36|
;;;200            NVIC_EnableIRQ(UART2_IRQn);
000020  2030              MOVS     r0,#0x30
000022  e000              B        |L9.38|
                  |L9.36|
;;;201        else
;;;202            NVIC_EnableIRQ(UART3_IRQn);
000024  2031              MOVS     r0,#0x31
                  |L9.38|
000026  f7ffbffe          B.W      NVIC_EnableIRQ
;;;203    
;;;204    }
;;;205    
                          ENDP

00002a  0000              DCW      0x0000
                  |L9.44|
                          DCD      0x40070000
                  |L9.48|
                          DCD      0x40071000
                  |L9.52|
                          DCD      0x40072000

                          AREA ||i.UART_Open||, CODE, READONLY, ALIGN=2

                  UART_Open PROC
;;;216     */
;;;217    void UART_Open(UART_T* uart, uint32_t u32baudrate)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;218    {
000004  4604              MOV      r4,r0
;;;219        uint8_t u8UartClkSrcSel, u8UartClkDivNum;
;;;220        uint32_t u32ClkTbl[4] = {__HXT, 0, __LXT, __HIRC};
000006  481d              LDR      r0,|L10.124|
000008  460d              MOV      r5,r1                 ;218
00000a  c80f              LDM      r0,{r0-r3}
00000c  e88d000f          STM      sp,{r0-r3}
;;;221        uint32_t u32Baud_Div = 0;
;;;222    
;;;223        /* Get UART clock source selection */
;;;224        u8UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UARTSEL_Msk) >> CLK_CLKSEL1_UARTSEL_Pos;
000010  f04f4080          MOV      r0,#0x40000000
000014  f8d01214          LDR      r1,[r0,#0x214]
;;;225    
;;;226        /* Get UART clock divider number */
;;;227        u8UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UARTDIV_Msk) >> CLK_CLKDIV0_UARTDIV_Pos;
000018  f8d00220          LDR      r0,[r0,#0x220]
00001c  f3c16601          UBFX     r6,r1,#24,#2          ;224
000020  f3c02703          UBFX     r7,r0,#8,#4
;;;228    
;;;229        /* Select UART function */
;;;230        uart->FUNCSEL = UART_FUNCSEL_UART;
000024  2000              MOVS     r0,#0
000026  6320              STR      r0,[r4,#0x30]
;;;231    
;;;232        /* Set UART line configuration */
;;;233        uart->LINE = UART_WORD_LEN_8 | UART_PARITY_NONE | UART_STOP_BIT_1;
000028  2003              MOVS     r0,#3
00002a  60e0              STR      r0,[r4,#0xc]
;;;234    
;;;235        /* Set UART Rx and RTS trigger level */
;;;236        uart->FIFO &= ~(UART_FIFO_RFITL_Msk | UART_FIFO_RTSTRGLV_Msk);
00002c  68a0              LDR      r0,[r4,#8]
00002e  4914              LDR      r1,|L10.128|
000030  4008              ANDS     r0,r0,r1
000032  60a0              STR      r0,[r4,#8]
000034  46e8              MOV      r8,sp                 ;220
;;;237    
;;;238        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;239        if(u8UartClkSrcSel == 1)
000036  2e01              CMP      r6,#1
000038  d102              BNE      |L10.64|
;;;240            u32ClkTbl[u8UartClkSrcSel] = CLK_GetPLLClockFreq();
00003a  f7fffffe          BL       CLK_GetPLLClockFreq
00003e  9001              STR      r0,[sp,#4]
                  |L10.64|
;;;241    
;;;242        /* Set UART baud rate */
;;;243        if(u32baudrate != 0)
000040  2d00              CMP      r5,#0
000042  d018              BEQ      |L10.118|
;;;244        {
;;;245            u32Baud_Div = UART_BAUD_MODE2_DIVIDER((u32ClkTbl[u8UartClkSrcSel]) / (u8UartClkDivNum + 1), u32baudrate);
000044  f8580026          LDR      r0,[r8,r6,LSL #2]
000048  1c7f              ADDS     r7,r7,#1
00004a  fbb0f1f7          UDIV     r1,r0,r7
00004e  eb010055          ADD      r0,r1,r5,LSR #1
000052  fbb0f0f5          UDIV     r0,r0,r5
000056  1e80              SUBS     r0,r0,#2
;;;246    
;;;247            if(u32Baud_Div > 0xFFFF)
000058  f5b03f80          CMP      r0,#0x10000
00005c  d308              BCC      |L10.112|
;;;248                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u8UartClkSrcSel]) / (u8UartClkDivNum + 1), u32baudrate));
00005e  eb0100c5          ADD      r0,r1,r5,LSL #3
000062  fbb0f0f5          UDIV     r0,r0,r5
000066  f06f0101          MVN      r1,#1
00006a  eb011010          ADD      r0,r1,r0,LSR #4
00006e  e001              B        |L10.116|
                  |L10.112|
;;;249            else
;;;250                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
000070  f0405040          ORR      r0,r0,#0x30000000
                  |L10.116|
000074  6260              STR      r0,[r4,#0x24]
                  |L10.118|
;;;251        }
;;;252    }
000076  e8bd81ff          POP      {r0-r8,pc}
;;;253    
                          ENDP

00007a  0000              DCW      0x0000
                  |L10.124|
                          DCD      ||.constdata||
                  |L10.128|
                          DCD      0xfff0ff0f

                          AREA ||i.UART_Read||, CODE, READONLY, ALIGN=1

                  UART_Read PROC
;;;265     */
;;;266    uint32_t UART_Read(UART_T* uart, uint8_t *pu8RxBuf, uint32_t u32ReadBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;267    {
000002  4604              MOV      r4,r0
;;;268        uint32_t  u32Count, u32delayno;
;;;269    
;;;270        for(u32Count = 0; u32Count < u32ReadBytes; u32Count++)
000004  2000              MOVS     r0,#0
;;;271        {
;;;272            u32delayno = 0;
;;;273    
;;;274            while(uart->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk)   /* Check RX empty => failed */
;;;275            {
;;;276                u32delayno++;
;;;277                if(u32delayno >= 0x40000000)
000006  f04f4580          MOV      r5,#0x40000000
00000a  e00c              B        |L11.38|
                  |L11.12|
00000c  2300              MOVS     r3,#0                 ;272
00000e  e004              B        |L11.26|
                  |L11.16|
000010  1c5b              ADDS     r3,r3,#1              ;274
000012  42ab              CMP      r3,r5
000014  d301              BCC      |L11.26|
;;;278                    return FALSE;
000016  2000              MOVS     r0,#0
;;;279            }
;;;280            pu8RxBuf[u32Count] = uart->DAT;    /* Get Data from UART RX  */
;;;281        }
;;;282    
;;;283        return u32Count;
;;;284    
;;;285    }
000018  bd70              POP      {r4-r6,pc}
                  |L11.26|
00001a  69a6              LDR      r6,[r4,#0x18]         ;274
00001c  0476              LSLS     r6,r6,#17             ;274
00001e  d4f7              BMI      |L11.16|
000020  6823              LDR      r3,[r4,#0]            ;280
000022  540b              STRB     r3,[r1,r0]            ;280
000024  1c40              ADDS     r0,r0,#1              ;280
                  |L11.38|
000026  4290              CMP      r0,r2                 ;270
000028  d3f0              BCC      |L11.12|
00002a  bd70              POP      {r4-r6,pc}
;;;286    
                          ENDP


                          AREA ||i.UART_SelectIrDAMode||, CODE, READONLY, ALIGN=2

                  UART_SelectIrDAMode PROC
;;;378     */
;;;379    void UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction)
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;380    {
000004  4604              MOV      r4,r0
;;;381        uint8_t u8UartClkSrcSel, u8UartClkDivNum;
;;;382        uint32_t u32ClkTbl[4] = {__HXT, 0, __LXT, __HIRC};
000006  481e              LDR      r0,|L12.128|
000008  4691              MOV      r9,r2                 ;380
00000a  460d              MOV      r5,r1                 ;380
00000c  c80f              LDM      r0,{r0-r3}
00000e  e88d000f          STM      sp,{r0-r3}
;;;383        uint32_t u32Baud_Div;
;;;384    
;;;385        /* Select IrDA function mode */
;;;386        uart->FUNCSEL = UART_FUNCSEL_IrDA;
000012  2002              MOVS     r0,#2
000014  6320              STR      r0,[r4,#0x30]
;;;387    
;;;388        /* Get UART clock source selection */
;;;389        u8UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UARTSEL_Msk) >> CLK_CLKSEL1_UARTSEL_Pos;
000016  0740              LSLS     r0,r0,#29
000018  f8d01214          LDR      r1,[r0,#0x214]
;;;390    
;;;391        /* Get UART clock divider number */
;;;392        u8UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UARTDIV_Msk) >> CLK_CLKDIV0_UARTDIV_Pos;
00001c  f8d00220          LDR      r0,[r0,#0x220]
000020  f3c16601          UBFX     r6,r1,#24,#2          ;389
000024  f3c02703          UBFX     r7,r0,#8,#4
000028  46e8              MOV      r8,sp                 ;382
;;;393    
;;;394        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;395        if(u8UartClkSrcSel == 1)
00002a  2e01              CMP      r6,#1
00002c  d102              BNE      |L12.52|
;;;396            u32ClkTbl[u8UartClkSrcSel] = CLK_GetPLLClockFreq();
00002e  f7fffffe          BL       CLK_GetPLLClockFreq
000032  9001              STR      r0,[sp,#4]
                  |L12.52|
;;;397    
;;;398        /* Set UART IrDA baud rate in mode 0 */
;;;399        if(u32Buadrate != 0)
000034  b185              CBZ      r5,|L12.88|
;;;400        {
;;;401            u32Baud_Div = UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u8UartClkSrcSel]) / (u8UartClkDivNum + 1), u32Buadrate);
000036  f8580026          LDR      r0,[r8,r6,LSL #2]
00003a  1c7f              ADDS     r7,r7,#1
00003c  fbb0f0f7          UDIV     r0,r0,r7
000040  eb0000c5          ADD      r0,r0,r5,LSL #3
000044  fbb0f0f5          UDIV     r0,r0,r5
000048  f06f0101          MVN      r1,#1
00004c  eb011010          ADD      r0,r1,r0,LSR #4
;;;402    
;;;403            if(u32Baud_Div < 0xFFFF)
000050  0c09              LSRS     r1,r1,#16
000052  4288              CMP      r0,r1
000054  d200              BCS      |L12.88|
;;;404                uart->BAUD = (UART_BAUD_MODE0 | u32Baud_Div);
000056  6260              STR      r0,[r4,#0x24]
                  |L12.88|
;;;405        }
;;;406    
;;;407        /* Configure IrDA relative settings */
;;;408        if(u32Direction == UART_IRDA_RXEN)
;;;409        {
;;;410            uart->IRDA |= UART_IRDA_RXINV_Msk;     //Rx signal is inverse
;;;411            uart->IRDA &= ~UART_IRDA_TXEN_Msk;
;;;412        }
;;;413        else
;;;414        {
;;;415            uart->IRDA &= ~UART_IRDA_TXINV_Msk;    //Tx signal is not inverse
000058  6aa0              LDR      r0,[r4,#0x28]
00005a  f1b90f00          CMP      r9,#0                 ;408
00005e  d008              BEQ      |L12.114|
000060  f0200020          BIC      r0,r0,#0x20
000064  62a0              STR      r0,[r4,#0x28]
;;;416            uart->IRDA |= UART_IRDA_TXEN_Msk;
000066  6aa0              LDR      r0,[r4,#0x28]
000068  f0400002          ORR      r0,r0,#2
                  |L12.108|
00006c  62a0              STR      r0,[r4,#0x28]         ;411
;;;417        }
;;;418    
;;;419    }
00006e  e8bd87ff          POP      {r0-r10,pc}
                  |L12.114|
000072  f0400040          ORR      r0,r0,#0x40           ;410
000076  62a0              STR      r0,[r4,#0x28]         ;410
000078  6aa0              LDR      r0,[r4,#0x28]         ;411
00007a  f0200002          BIC      r0,r0,#2              ;411
00007e  e7f5              B        |L12.108|
;;;420    
                          ENDP

                  |L12.128|
                          DCD      ||.constdata||+0x20

                          AREA ||i.UART_SelectLINMode||, CODE, READONLY, ALIGN=1

                  UART_SelectLINMode PROC
;;;459     */
;;;460    void UART_SelectLINMode(UART_T* uart, uint32_t u32Mode, uint32_t u32BreakLength)
000000  2301              MOVS     r3,#1
;;;461    {
;;;462        /* Select LIN function mode */
;;;463        uart->FUNCSEL = UART_FUNCSEL_LIN;
000002  6303              STR      r3,[r0,#0x30]
;;;464    
;;;465        /* Select LIN function setting : Tx enable, Rx enable and break field length */
;;;466        uart->ALTCTL &= ~(UART_ALTCTL_LINTXEN_Msk | UART_ALTCTL_LINRXEN_Msk | UART_ALTCTL_BRKFL_Msk);
000004  6ac3              LDR      r3,[r0,#0x2c]
000006  f02303cf          BIC      r3,r3,#0xcf
00000a  62c3              STR      r3,[r0,#0x2c]
;;;467        uart->ALTCTL |= (u32Mode | (u32BreakLength << UART_ALTCTL_BRKFL_Pos));
00000c  6ac3              LDR      r3,[r0,#0x2c]
00000e  4311              ORRS     r1,r1,r2
000010  430b              ORRS     r3,r3,r1
000012  62c3              STR      r3,[r0,#0x2c]
;;;468    }
000014  4770              BX       lr
;;;469    
                          ENDP


                          AREA ||i.UART_SelectRS485Mode||, CODE, READONLY, ALIGN=2

                  UART_SelectRS485Mode PROC
;;;435     */
;;;436    void UART_SelectRS485Mode(UART_T* uart, uint32_t u32Mode, uint32_t u32Addr)
000000  b510              PUSH     {r4,lr}
;;;437    {
;;;438        /* Select UART RS485 function mode */
;;;439        uart->FUNCSEL = UART_FUNCSEL_RS485;
000002  2303              MOVS     r3,#3
000004  6303              STR      r3,[r0,#0x30]
;;;440    
;;;441        /* Set RS585 configuration */
;;;442        uart->ALTCTL &= ~(UART_ALTCTL_RS485NMM_Msk | UART_ALTCTL_RS485AUD_Msk | UART_ALTCTL_RS485AAD_Msk | UART_ALTCTL_ADDRMV_Msk);
000006  6ac3              LDR      r3,[r0,#0x2c]
000008  4c04              LDR      r4,|L14.28|
00000a  4023              ANDS     r3,r3,r4
00000c  62c3              STR      r3,[r0,#0x2c]
;;;443        uart->ALTCTL |= (u32Mode | (u32Addr << UART_ALTCTL_ADDRMV_Pos));
00000e  6ac3              LDR      r3,[r0,#0x2c]
000010  ea416102          ORR      r1,r1,r2,LSL #24
000014  430b              ORRS     r3,r3,r1
000016  62c3              STR      r3,[r0,#0x2c]
;;;444    }
000018  bd10              POP      {r4,pc}
;;;445    
                          ENDP

00001a  0000              DCW      0x0000
                  |L14.28|
                          DCD      0x00fff8ff

                          AREA ||i.UART_SetLine_Config||, CODE, READONLY, ALIGN=2

                  UART_SetLine_Config PROC
;;;313     */
;;;314    void UART_SetLine_Config(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;315    {
000004  460c              MOV      r4,r1
;;;316        uint8_t u8UartClkSrcSel, u8UartClkDivNum;
;;;317        uint32_t u32ClkTbl[4] = {__HXT, 0, __LXT, __HIRC};
000006  491d              LDR      r1,|L15.124|
000008  469a              MOV      r10,r3                ;315
00000a  4691              MOV      r9,r2                 ;315
00000c  4605              MOV      r5,r0                 ;315
00000e  c90f              LDM      r1,{r0-r3}
000010  f8ddb038          LDR      r11,[sp,#0x38]
000014  e88d000f          STM      sp,{r0-r3}
;;;318        uint32_t u32Baud_Div = 0;
;;;319    
;;;320        /* Get UART clock source selection */
;;;321        u8UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UARTSEL_Msk) >> CLK_CLKSEL1_UARTSEL_Pos;
000018  f04f4080          MOV      r0,#0x40000000
00001c  f8d01214          LDR      r1,[r0,#0x214]
;;;322    
;;;323        /* Get UART clock divider number */
;;;324        u8UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UARTDIV_Msk) >> CLK_CLKDIV0_UARTDIV_Pos;
000020  f8d00220          LDR      r0,[r0,#0x220]
000024  f3c16601          UBFX     r6,r1,#24,#2          ;321
000028  f3c02703          UBFX     r7,r0,#8,#4
00002c  46e8              MOV      r8,sp                 ;317
;;;325    
;;;326        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;327        if(u8UartClkSrcSel == 1)
00002e  2e01              CMP      r6,#1
000030  d102              BNE      |L15.56|
;;;328            u32ClkTbl[u8UartClkSrcSel] = CLK_GetPLLClockFreq();
000032  f7fffffe          BL       CLK_GetPLLClockFreq
000036  9001              STR      r0,[sp,#4]
                  |L15.56|
;;;329    
;;;330        /* Set UART baud rate */
;;;331        if(u32baudrate != 0)
000038  b1c4              CBZ      r4,|L15.108|
;;;332        {
;;;333            u32Baud_Div = UART_BAUD_MODE2_DIVIDER((u32ClkTbl[u8UartClkSrcSel]) / (u8UartClkDivNum + 1), u32baudrate);
00003a  f8580026          LDR      r0,[r8,r6,LSL #2]
00003e  1c7f              ADDS     r7,r7,#1
000040  fbb0f1f7          UDIV     r1,r0,r7
000044  eb010054          ADD      r0,r1,r4,LSR #1
000048  fbb0f0f4          UDIV     r0,r0,r4
00004c  1e80              SUBS     r0,r0,#2
;;;334    
;;;335            if(u32Baud_Div > 0xFFFF)
00004e  f5b03f80          CMP      r0,#0x10000
000052  d308              BCC      |L15.102|
;;;336                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u8UartClkSrcSel]) / (u8UartClkDivNum + 1), u32baudrate));
000054  eb0100c4          ADD      r0,r1,r4,LSL #3
000058  fbb0f0f4          UDIV     r0,r0,r4
00005c  f06f0101          MVN      r1,#1
000060  eb011010          ADD      r0,r1,r0,LSR #4
000064  e001              B        |L15.106|
                  |L15.102|
;;;337            else
;;;338                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
000066  f0405040          ORR      r0,r0,#0x30000000
                  |L15.106|
00006a  6268              STR      r0,[r5,#0x24]         ;336
                  |L15.108|
;;;339        }
;;;340    
;;;341        /* Set UART line configuration */
;;;342        uart->LINE = u32data_width | u32parity | u32stop_bits;
00006c  ea49000a          ORR      r0,r9,r10
000070  ea40000b          ORR      r0,r0,r11
000074  60e8              STR      r0,[r5,#0xc]
;;;343    }
000076  e8bd9fff          POP      {r0-r12,pc}
;;;344    
                          ENDP

00007a  0000              DCW      0x0000
                  |L15.124|
                          DCD      ||.constdata||+0x10

                          AREA ||i.UART_SetTimeoutCnt||, CODE, READONLY, ALIGN=1

                  UART_SetTimeoutCnt PROC
;;;355     */
;;;356    void UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC)
000000  6a02              LDR      r2,[r0,#0x20]
;;;357    {
;;;358        /* Set time-out interrupt comparator */
;;;359        uart->TOUT = (uart->TOUT & ~UART_TOUT_TOIC_Msk) | (u32TOC);
000002  f02202ff          BIC      r2,r2,#0xff
000006  430a              ORRS     r2,r2,r1
000008  6202              STR      r2,[r0,#0x20]
;;;360    
;;;361        /* Set time-out counter enable */
;;;362        uart->INTEN |= UART_INTEN_TOCNTEN_Msk;
00000a  6841              LDR      r1,[r0,#4]
00000c  f4416100          ORR      r1,r1,#0x800
000010  6041              STR      r1,[r0,#4]
;;;363    }
000012  4770              BX       lr
;;;364    
                          ENDP


                          AREA ||i.UART_Write||, CODE, READONLY, ALIGN=1

                  UART_Write PROC
;;;481     */
;;;482    uint32_t UART_Write(UART_T* uart, uint8_t *pu8TxBuf, uint32_t u32WriteBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;483    {
000002  4604              MOV      r4,r0
;;;484        uint32_t  u32Count, u32delayno;
;;;485    
;;;486        for(u32Count = 0; u32Count != u32WriteBytes; u32Count++)
000004  2000              MOVS     r0,#0
;;;487        {
;;;488            u32delayno = 0;
;;;489            while((uart->FIFOSTS & UART_FIFOSTS_TXEMPTYF_Msk) == 0)   /* Wait Tx empty and Time-out manner */
;;;490            {
;;;491                u32delayno++;
;;;492                if(u32delayno >= 0x40000000)
000006  f04f4580          MOV      r5,#0x40000000
00000a  e00c              B        |L17.38|
                  |L17.12|
00000c  2300              MOVS     r3,#0                 ;488
00000e  e004              B        |L17.26|
                  |L17.16|
000010  1c5b              ADDS     r3,r3,#1              ;489
000012  42ab              CMP      r3,r5
000014  d301              BCC      |L17.26|
;;;493                    return FALSE;
000016  2000              MOVS     r0,#0
;;;494            }
;;;495            uart->DAT = pu8TxBuf[u32Count];    /* Send UART Data from buffer */
;;;496        }
;;;497    
;;;498        return u32Count;
;;;499    
;;;500    }
000018  bd70              POP      {r4-r6,pc}
                  |L17.26|
00001a  69a6              LDR      r6,[r4,#0x18]         ;489
00001c  00f6              LSLS     r6,r6,#3              ;489
00001e  d5f7              BPL      |L17.16|
000020  5c0b              LDRB     r3,[r1,r0]            ;495
000022  6023              STR      r3,[r4,#0]            ;495
000024  1c40              ADDS     r0,r0,#1              ;495
                  |L17.38|
000026  4290              CMP      r0,r2                 ;486
000028  d1f0              BNE      |L17.12|
00002a  bd70              POP      {r4-r6,pc}
;;;501    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x01518000
                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x01518000
                          DCD      0x00b71b00
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x01518000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REV16|
#line 114 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___6_uart_c_f12f5b44____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REVSH|
#line 128
|__asm___6_uart_c_f12f5b44____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
