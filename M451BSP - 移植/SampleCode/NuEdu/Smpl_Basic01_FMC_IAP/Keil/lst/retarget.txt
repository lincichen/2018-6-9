; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\retarget.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\retarget.d --cpu=Cortex-M4.fp --apcs=interwork -L6969W -I..\..\..\..\Library\Device\Nuvoton\M451Series\Include -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\Library\NuEdu\inc -I.\zmodem -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -DDEBUG_ENABLE_SEMIHOST --omf_browse=.\obj\retarget.crf ..\..\..\..\Library\StdDriver\src\retarget.c]
                          THUMB

                          AREA ||i.GetChar||, CODE, READONLY, ALIGN=1

                  GetChar PROC
;;;505     */
;;;506    char GetChar(void)
000000  b538              PUSH     {r3-r5,lr}
;;;507    {
;;;508    #ifdef DEBUG_ENABLE_SEMIHOST
;;;509    # if defined (__CC_ARM)
;;;510        int nRet;
;;;511        while(SH_DoCommand(0x101, 0, &nRet) != 0)
000002  f2401401          MOV      r4,#0x101
000006  e009              B        |L1.28|
                  |L1.8|
;;;512        {
;;;513            if(nRet != 0)
000008  9800              LDR      r0,[sp,#0]
00000a  b138              CBZ      r0,|L1.28|
;;;514            {
;;;515                SH_DoCommand(0x07, 0, &nRet);
00000c  466a              MOV      r2,sp
00000e  2100              MOVS     r1,#0
000010  2007              MOVS     r0,#7
000012  f7fffffe          BL       SH_DoCommand
;;;516                return (char)nRet;
000016  9800              LDR      r0,[sp,#0]
000018  b2c0              UXTB     r0,r0
;;;517            }
;;;518        }
;;;519    # else
;;;520        int nRet;
;;;521        while(SH_DoCommand(0x7, 0, &nRet) != 0)
;;;522        {
;;;523            if(nRet != 0)
;;;524                return (char)nRet;
;;;525        }
;;;526    # endif
;;;527        return (0);
;;;528    #else
;;;529    
;;;530        while(1)
;;;531        {
;;;532            if((DEBUG_PORT->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk) == 0)
;;;533            {
;;;534                return (DEBUG_PORT->DAT);
;;;535            }
;;;536        }
;;;537    
;;;538    #endif
;;;539    }
00001a  bd38              POP      {r3-r5,pc}
                  |L1.28|
00001c  466a              MOV      r2,sp                 ;511
00001e  2100              MOVS     r1,#0                 ;511
000020  4620              MOV      r0,r4                 ;511
000022  f7fffffe          BL       SH_DoCommand
000026  2800              CMP      r0,#0                 ;511
000028  d1ee              BNE      |L1.8|
00002a  bd38              POP      {r3-r5,pc}
;;;540    
                          ENDP


                          AREA ||i.Hard_Fault_Handler||, CODE, READONLY, ALIGN=2

                  Hard_Fault_Handler PROC
                  ||__tagsym$$used||
;;;62      */
;;;63     void Hard_Fault_Handler(uint32_t stack[])
000000  4604              MOV      r4,r0
;;;64     {
;;;65         printf("In Hard Fault Handler\n");
000002  a003              ADR      r0,|L2.16|
000004  f7fffffe          BL       __2printf
;;;66     
;;;67         stackDump(stack);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       stackDump
                  |L2.14|
;;;68         // Replace while(1) with chip reset if WDT is not enabled for end product
;;;69         while(1);
00000e  e7fe              B        |L2.14|
;;;70         //SYS->IPRST0 = SYS_IPRST0_CHIPRST_Msk;
;;;71     }
;;;72     
                          ENDP

                  |L2.16|
000010  496e2048          DCB      "In Hard Fault Handler\n",0
000014  61726420
000018  4661756c
00001c  74204861
000020  6e646c65
000024  720a00  
000027  00                DCB      0

                          AREA ||i.IsDebugFifoEmpty||, CODE, READONLY, ALIGN=2

                  IsDebugFifoEmpty PROC
;;;566    
;;;567    int IsDebugFifoEmpty(void)
000000  4802              LDR      r0,|L3.12|
;;;568    {
;;;569        return ((DEBUG_PORT->FIFOSTS & UART_FIFOSTS_TXEMPTYF_Msk) != 0);
000002  6980              LDR      r0,[r0,#0x18]
000004  f3c07000          UBFX     r0,r0,#28,#1
;;;570    }
000008  4770              BX       lr
;;;571    
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      0x40070000

                          AREA ||i.SendChar||, CODE, READONLY, ALIGN=2

                  SendChar PROC
;;;469     */
;;;470    void SendChar(int ch)
000000  b570              PUSH     {r4-r6,lr}
;;;471    {
;;;472    #if defined(DEBUG_ENABLE_SEMIHOST)
;;;473        g_buf[g_buf_len++] = ch;
000002  4c11              LDR      r4,|L4.72|
000004  4e0f              LDR      r6,|L4.68|
;;;474        g_buf[g_buf_len] = '\0';
000006  2500              MOVS     r5,#0
000008  7821              LDRB     r1,[r4,#0]            ;473  ; g_buf_len
00000a  5470              STRB     r0,[r6,r1]            ;473
00000c  1c49              ADDS     r1,r1,#1              ;473
00000e  b2c9              UXTB     r1,r1                 ;473
000010  7021              STRB     r1,[r4,#0]            ;473
000012  5475              STRB     r5,[r6,r1]
000014  1c49              ADDS     r1,r1,#1
;;;475        if(g_buf_len + 1 >= sizeof(g_buf) || ch == '\n' || ch == '\0')
000016  2910              CMP      r1,#0x10
000018  d203              BCS      |L4.34|
00001a  280a              CMP      r0,#0xa
00001c  d001              BEQ      |L4.34|
00001e  2800              CMP      r0,#0
000020  d10f              BNE      |L4.66|
                  |L4.34|
;;;476        {
;;;477            /* Send the char */
;;;478            if(SH_DoCommand(0x04, (int)g_buf, NULL) != 0)
000022  2200              MOVS     r2,#0
000024  4907              LDR      r1,|L4.68|
000026  2004              MOVS     r0,#4
000028  f7fffffe          BL       SH_DoCommand
00002c  b940              CBNZ     r0,|L4.64|
;;;479            {
;;;480                g_buf_len = 0;
;;;481                return;
;;;482            }
;;;483            else
;;;484            {
;;;485                int i;
;;;486    
;;;487                for(i = 0; i < g_buf_len; i++)
00002e  2300              MOVS     r3,#0
000030  e003              B        |L4.58|
                  |L4.50|
;;;488                    SendChar_ToUART(g_buf[i]);
000032  5cf0              LDRB     r0,[r6,r3]
000034  f7fffffe          BL       SendChar_ToUART
000038  1c5b              ADDS     r3,r3,#1
                  |L4.58|
00003a  7820              LDRB     r0,[r4,#0]            ;487  ; g_buf_len
00003c  4283              CMP      r3,r0                 ;487
00003e  dbf8              BLT      |L4.50|
                  |L4.64|
;;;489                g_buf_len = 0;
000040  7025              STRB     r5,[r4,#0]
                  |L4.66|
;;;490            }
;;;491        }
;;;492    #else
;;;493        SendChar_ToUART(ch);
;;;494    #endif
;;;495    }
000042  bd70              POP      {r4-r6,pc}
;;;496    
                          ENDP

                  |L4.68|
                          DCD      ||.bss||
                  |L4.72|
                          DCD      ||.data||

                          AREA ||i.SendChar_ToUART||, CODE, READONLY, ALIGN=2

                  SendChar_ToUART PROC
;;;392    #ifndef NONBLOCK_PRINTF
;;;393    void SendChar_ToUART(int ch)
000000  4906              LDR      r1,|L5.28|
                  |L5.2|
;;;394    {
;;;395        while(DEBUG_PORT->FIFOSTS & UART_FIFOSTS_TXFULL_Msk);
000002  698a              LDR      r2,[r1,#0x18]
000004  0212              LSLS     r2,r2,#8
000006  d4fc              BMI      |L5.2|
;;;396        
;;;397        DEBUG_PORT->DAT = ch;
000008  6008              STR      r0,[r1,#0]
;;;398        if(ch == '\n')
00000a  280a              CMP      r0,#0xa
00000c  d104              BNE      |L5.24|
                  |L5.14|
;;;399        {
;;;400            while(DEBUG_PORT->FIFOSTS & UART_FIFOSTS_TXFULL_Msk);
00000e  6988              LDR      r0,[r1,#0x18]
000010  0200              LSLS     r0,r0,#8
000012  d4fc              BMI      |L5.14|
;;;401            DEBUG_PORT->DAT = '\r';
000014  200d              MOVS     r0,#0xd
000016  6008              STR      r0,[r1,#0]
                  |L5.24|
;;;402        }
;;;403    }
000018  4770              BX       lr
;;;404    
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      0x40070000

                          AREA ||i._sys_exit||, CODE, READONLY, ALIGN=2

                  _sys_exit PROC
;;;664    # else
;;;665    void _sys_exit(int return_code)
000000  2200              MOVS     r2,#0
;;;666    {
;;;667    
;;;668        /* Check if link with ICE */
;;;669        if(SH_DoCommand(0x18, 0x20026, NULL) == 0)
000002  4905              LDR      r1,|L6.24|
000004  2018              MOVS     r0,#0x18
000006  f7fffffe          BL       SH_DoCommand
00000a  e001              B        |L6.16|
                  |L6.12|
;;;670        {
;;;671            /* Make sure all message is print out */
;;;672            while(IsDebugFifoEmpty() == 0);
00000c  f7fffffe          BL       IsDebugFifoEmpty
                  |L6.16|
000010  2800              CMP      r0,#0
000012  d0fb              BEQ      |L6.12|
                  |L6.20|
;;;673        }
;;;674    label:
;;;675        goto label;  /* endless loop */
000014  e7fe              B        |L6.20|
;;;676    }
;;;677    # endif
                          ENDP

000016  0000              DCW      0x0000
                  |L6.24|
                          DCD      0x00020026

                          AREA ||i._ttywrch||, CODE, READONLY, ALIGN=1

                  _ttywrch PROC
;;;581    
;;;582    void _ttywrch(int ch)
000000  f7ffbffe          B.W      SendChar
;;;583    {
;;;584        SendChar(ch);
;;;585        return;
;;;586    }
;;;587    
                          ENDP


                          AREA ||i.ferror||, CODE, READONLY, ALIGN=1

                  ferror PROC
;;;644    
;;;645    int ferror(FILE *stream)
000000  f04f30ff          MOV      r0,#0xffffffff
;;;646    {
;;;647        return EOF;
;;;648    }
000004  4770              BX       lr
;;;649    
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=1

                  fgetc PROC
;;;624    
;;;625    int fgetc(FILE *stream)
000000  f7ffbffe          B.W      GetChar
;;;626    {
;;;627        return (GetChar());
;;;628    }
;;;629    
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;606    
;;;607    int fputc(int ch, FILE *stream)
000000  b510              PUSH     {r4,lr}
;;;608    {
000002  4604              MOV      r4,r0
;;;609        SendChar(ch);
000004  f7fffffe          BL       SendChar
;;;610        return ch;
000008  4620              MOV      r0,r4
;;;611    }
00000a  bd10              POP      {r4,pc}
;;;612    
                          ENDP


                          AREA ||i.kbhit||, CODE, READONLY, ALIGN=2

                  kbhit PROC
;;;551    
;;;552    int kbhit(void)
000000  4802              LDR      r0,|L11.12|
;;;553    {
;;;554        return !((DEBUG_PORT->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk) == 0);
000002  6980              LDR      r0,[r0,#0x18]
000004  f3c03080          UBFX     r0,r0,#14,#1
;;;555    }
000008  4770              BX       lr
;;;556    /**
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
                          DCD      0x40070000

                          AREA ||i.stackDump||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  stackDump PROC
;;;44      */
;;;45     static void stackDump(uint32_t stack[])
000000  b510              PUSH     {r4,lr}
;;;46     {   
000002  4604              MOV      r4,r0
;;;47         printf("r0  = 0x%x\n", stack[r0]);
000004  6801              LDR      r1,[r0,#0]
000006  a010              ADR      r0,|L12.72|
000008  f7fffffe          BL       __2printf
;;;48         printf("r1  = 0x%x\n", stack[r1]);
00000c  a011              ADR      r0,|L12.84|
00000e  6861              LDR      r1,[r4,#4]
000010  f7fffffe          BL       __2printf
;;;49         printf("r2  = 0x%x\n", stack[r2]);
000014  a012              ADR      r0,|L12.96|
000016  68a1              LDR      r1,[r4,#8]
000018  f7fffffe          BL       __2printf
;;;50         printf("r3  = 0x%x\n", stack[r3]);
00001c  a013              ADR      r0,|L12.108|
00001e  68e1              LDR      r1,[r4,#0xc]
000020  f7fffffe          BL       __2printf
;;;51         printf("r12 = 0x%x\n", stack[r12]);
000024  a014              ADR      r0,|L12.120|
000026  6921              LDR      r1,[r4,#0x10]
000028  f7fffffe          BL       __2printf
;;;52         printf("lr  = 0x%x\n", stack[lr]);
00002c  a015              ADR      r0,|L12.132|
00002e  6961              LDR      r1,[r4,#0x14]
000030  f7fffffe          BL       __2printf
;;;53         printf("pc  = 0x%x\n", stack[pc]);
000034  a016              ADR      r0,|L12.144|
000036  69a1              LDR      r1,[r4,#0x18]
000038  f7fffffe          BL       __2printf
;;;54         printf("psr = 0x%x\n", stack[psr]);
00003c  69e1              LDR      r1,[r4,#0x1c]
00003e  e8bd4010          POP      {r4,lr}
000042  a016              ADR      r0,|L12.156|
000044  f7ffbffe          B.W      __2printf
;;;55     }
;;;56     
                          ENDP

                  |L12.72|
000048  72302020          DCB      "r0  = 0x%x\n",0
00004c  3d203078
000050  25780a00
                  |L12.84|
000054  72312020          DCB      "r1  = 0x%x\n",0
000058  3d203078
00005c  25780a00
                  |L12.96|
000060  72322020          DCB      "r2  = 0x%x\n",0
000064  3d203078
000068  25780a00
                  |L12.108|
00006c  72332020          DCB      "r3  = 0x%x\n",0
000070  3d203078
000074  25780a00
                  |L12.120|
000078  72313220          DCB      "r12 = 0x%x\n",0
00007c  3d203078
000080  25780a00
                  |L12.132|
000084  6c722020          DCB      "lr  = 0x%x\n",0
000088  3d203078
00008c  25780a00
                  |L12.144|
000090  70632020          DCB      "pc  = 0x%x\n",0
000094  3d203078
000098  25780a00
                  |L12.156|
00009c  70737220          DCB      "psr = 0x%x\n",0
0000a0  3d203078
0000a4  25780a00

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_buf
                          %        16

                          AREA ||.data||, DATA, ALIGN=0

                  g_buf_len
000000  00                DCB      0x00

                          AREA ||area_number.17||, DATA, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.data||
                  __stdout
                          DCD      0x00000000

                          AREA ||area_number.18||, DATA, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.data||
                  __stdin
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\retarget.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_retarget_c_d5a1b03f____REV16|
#line 114 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_retarget_c_d5a1b03f____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_retarget_c_d5a1b03f____REVSH|
#line 128
|__asm___10_retarget_c_d5a1b03f____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |HardFault_Handler|
#line 234 "..\\..\\..\\..\\Library\\StdDriver\\src\\retarget.c"
|HardFault_Handler| PROC
#line 235

 MOV R0, LR
 LSLS R0, #29  
 BMI SP_is_PSP  
 MRS R0, MSP  
 B SP_Read_Ready
SP_is_PSP
 MRS R0, PSP  

SP_Read_Ready
 LDR R1, [R0, #24]  
 LDRH R3, [R1]  
 LDR R2, =0xBEAB  
 CMP R3, R2  
 BNE HardFault_Handler_Ret  

 ADDS R1, #4  
 STR R1, [R0, #24]  

 BX LR  
HardFault_Handler_Ret

 
 MOVS r0, #4
 MOV r1, LR
 TST r0, r1  
 BEQ Stack_Use_MSP  
 MRS R0, PSP 
 B Get_LR_and_Branch
Stack_Use_MSP
 MRS R0, MSP 
Get_LR_and_Branch
 MOV R1, LR 
 LDR R2,= |Hard_Fault_Handler|  
 BX R2

 B .

 ALIGN
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |SH_DoCommand|
#line 286
|SH_DoCommand| PROC
#line 287

 BKPT 0xAB  
 
 
 B SH_ICE

SH_HardFault  
 MOVS R0, #0  
 BX lr  

SH_ICE  
 
 CMP R2, #0
 BEQ SH_End
 STR R0, [R2]  

SH_End
 MOVS R0, #1  
 BX lr  
	ENDP

;*** End   embedded assembler ***
