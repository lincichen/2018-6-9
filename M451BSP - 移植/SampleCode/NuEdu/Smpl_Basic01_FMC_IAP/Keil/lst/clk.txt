; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\clk.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\clk.d --cpu=Cortex-M4.fp --apcs=interwork -L6969W -I..\..\..\..\Library\Device\Nuvoton\M451Series\Include -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\Library\NuEdu\inc -I.\zmodem -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -DDEBUG_ENABLE_SEMIHOST --omf_browse=.\obj\clk.crf ..\..\..\..\Library\StdDriver\src\clk.c]
                          THUMB

                          AREA ||i.CLK_DisableCKO||, CODE, READONLY, ALIGN=2

                  CLK_DisableCKO PROC
;;;31       */
;;;32     void CLK_DisableCKO(void)
000000  4801              LDR      r0,|L1.8|
;;;33     {
;;;34         /* Disable CKO clock source */
;;;35         CLK_DisableModuleClock(CLKO_MODULE);
000002  f7ffbffe          B.W      CLK_DisableModuleClock
;;;36     }
;;;37     
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x57c00006

                          AREA ||i.CLK_DisableModuleClock||, CODE, READONLY, ALIGN=1

                  CLK_DisableModuleClock PROC
;;;525      */
;;;526    void CLK_DisableModuleClock(uint32_t u32ModuleIdx)
000000  0f81              LSRS     r1,r0,#30
;;;527    {
;;;528        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK + (MODULE_APBCLK(u32ModuleIdx) * 4))  &= ~(1 << MODULE_IP_EN_Pos(u32ModuleIdx));
000002  0089              LSLS     r1,r1,#2
000004  f1014180          ADD      r1,r1,#0x40000000
000008  f8d12204          LDR      r2,[r1,#0x204]
00000c  f000031f          AND      r3,r0,#0x1f
000010  2001              MOVS     r0,#1
000012  4098              LSLS     r0,r0,r3
000014  4382              BICS     r2,r2,r0
000016  f8c12204          STR      r2,[r1,#0x204]
;;;529    }
00001a  4770              BX       lr
;;;530    
                          ENDP


                          AREA ||i.CLK_DisablePLL||, CODE, READONLY, ALIGN=1

                  CLK_DisablePLL PROC
;;;665      */
;;;666    void CLK_DisablePLL(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;667    {
;;;668        CLK->PLLCTL |= CLK_PLLCTL_PD_Msk;
000004  f8d01240          LDR      r1,[r0,#0x240]
000008  f4413180          ORR      r1,r1,#0x10000
00000c  f8c01240          STR      r1,[r0,#0x240]
;;;669    }
000010  4770              BX       lr
;;;670    
                          ENDP


                          AREA ||i.CLK_DisableSysTick||, CODE, READONLY, ALIGN=1

                  CLK_DisableSysTick PROC
;;;737      */
;;;738    void CLK_DisableSysTick(void) 
000000  f04f21e0          MOV      r1,#0xe000e000
;;;739    {    
;;;740        /* Set System Tick counter disabled */
;;;741    	SysTick->CTRL = 0;    
000004  2000              MOVS     r0,#0
000006  6108              STR      r0,[r1,#0x10]
;;;742    }
000008  4770              BX       lr
;;;743    
                          ENDP


                          AREA ||i.CLK_DisableXtalRC||, CODE, READONLY, ALIGN=1

                  CLK_DisableXtalRC PROC
;;;439      */
;;;440    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  f04f4180          MOV      r1,#0x40000000
;;;441    {
;;;442        CLK->PWRCTL &= ~u32ClkMask;
000004  f8d12200          LDR      r2,[r1,#0x200]
000008  4382              BICS     r2,r2,r0
00000a  f8c12200          STR      r2,[r1,#0x200]
;;;443    }
00000e  4770              BX       lr
;;;444    
                          ENDP


                          AREA ||i.CLK_EnableCKO||, CODE, READONLY, ALIGN=2

                  CLK_EnableCKO PROC
;;;54       */
;;;55     void CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En)
000000  b530              PUSH     {r4,r5,lr}
;;;56     {
000002  4604              MOV      r4,r0
;;;57         /* CKO = clock source / 2^(u32ClkDiv + 1) */
;;;58         CLK->CLKOCTL = CLK_CLKOCTL_CLKOEN_Msk | u32ClkDiv | (u32ClkDivBy1En << CLK_CLKOCTL_DIV1EN_Pos);
000004  ea411042          ORR      r0,r1,r2,LSL #5
000008  f0400110          ORR      r1,r0,#0x10
00000c  f04f4080          MOV      r0,#0x40000000
000010  f8c01260          STR      r1,[r0,#0x260]
;;;59     
;;;60         /* Enable CKO clock source */
;;;61         CLK_EnableModuleClock(CLKO_MODULE);
000014  4d05              LDR      r5,|L6.44|
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       CLK_EnableModuleClock
;;;62     
;;;63         /* Select CKO clock source */
;;;64         CLK_SetModuleClock(CLKO_MODULE, u32ClkSrc, 0);
00001c  4621              MOV      r1,r4
00001e  4628              MOV      r0,r5
000020  e8bd4030          POP      {r4,r5,lr}
000024  2200              MOVS     r2,#0
000026  f7ffbffe          B.W      CLK_SetModuleClock
;;;65     }
;;;66     
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0x57c00006

                          AREA ||i.CLK_EnableModuleClock||, CODE, READONLY, ALIGN=1

                  CLK_EnableModuleClock PROC
;;;482      */
;;;483    void CLK_EnableModuleClock(uint32_t u32ModuleIdx)
000000  0f81              LSRS     r1,r0,#30
;;;484    {
;;;485        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK + (MODULE_APBCLK(u32ModuleIdx) * 4))  |= 1 << MODULE_IP_EN_Pos(u32ModuleIdx);
000002  0089              LSLS     r1,r1,#2
000004  f1014180          ADD      r1,r1,#0x40000000
000008  f8d12204          LDR      r2,[r1,#0x204]
00000c  f000031f          AND      r3,r0,#0x1f
000010  2001              MOVS     r0,#1
000012  4098              LSLS     r0,r0,r3
000014  4302              ORRS     r2,r2,r0
000016  f8c12204          STR      r2,[r1,#0x204]
;;;486    }
00001a  4770              BX       lr
;;;487    
                          ENDP


                          AREA ||i.CLK_EnablePLL||, CODE, READONLY, ALIGN=2

                  CLK_EnablePLL PROC
;;;541      */
;;;542    uint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;543    {
000004  460c              MOV      r4,r1
000006  4606              MOV      r6,r0
;;;544        uint32_t u32PllSrcClk, u32NR, u32NF, u32NO, u32CLK_SRC;
;;;545        uint32_t u32Tmp, u32Tmp2, u32Tmp3, u32Min, u32MinNF, u32MinNR;
;;;546    
;;;547        /* Disable PLL first to avoid unstable when setting PLL */
;;;548        CLK_DisablePLL();
000008  f7fffffe          BL       CLK_DisablePLL
;;;549    
;;;550        /* PLL source clock is from HXT */
;;;551        if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;552        {
;;;553            /* Enable HXT clock */
;;;554            CLK->PWRCTL |= CLK_PWRCTL_HXTEN_Msk;
00000c  f04f4b80          MOV      r11,#0x40000000
;;;555    
;;;556            /* Wait for HXT clock ready */
;;;557            CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;558    
;;;559            /* Select PLL source clock from HXT */
;;;560            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HXT;
;;;561            u32PllSrcClk = __HXT;
000010  4f52              LDR      r7,|L8.348|
;;;562    
;;;563            /* u32NR start from 2 */
;;;564            u32NR = 2;
;;;565        }
;;;566    
;;;567        /* PLL source clock is from HIRC */
;;;568        else
;;;569        {
;;;570            /* Enable HIRC clock */
;;;571            CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
;;;572    
;;;573            /* Wait for HIRC clock ready */
;;;574            CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
;;;575    
;;;576            /* Select PLL source clock from HIRC */
;;;577            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HIRC;
;;;578            u32PllSrcClk = __HIRC;
000012  f8df814c          LDR      r8,|L8.352|
000016  f8db1200          LDR      r1,[r11,#0x200]       ;571
00001a  4658              MOV      r0,r11                ;571
00001c  b19e              CBZ      r6,|L8.70|
00001e  f0410104          ORR      r1,r1,#4              ;571
000022  f8c01200          STR      r1,[r0,#0x200]        ;571
000026  2010              MOVS     r0,#0x10              ;574
000028  f7fffffe          BL       CLK_WaitClockReady
00002c  f44f2000          MOV      r0,#0x80000           ;577
000030  46c1              MOV      r9,r8
;;;579    
;;;580            /* u32NR start from 4 when FIN = 22.1184MHz to avoid calculation overflow */
;;;581            u32NR = 4;
000032  2104              MOVS     r1,#4
000034  9000              STR      r0,[sp,#0]
                  |L8.54|
;;;582        }
;;;583    
;;;584        /* Select "NO" according to request frequency */
;;;585        if((u32PllFreq <= FREQ_500MHZ) && (u32PllFreq > FREQ_250MHZ))
000036  484b              LDR      r0,|L8.356|
000038  4a4b              LDR      r2,|L8.360|
00003a  4420              ADD      r0,r0,r4
00003c  4290              CMP      r0,r2
00003e  d80e              BHI      |L8.94|
;;;586        {
;;;587            u32NO = 0;
000040  f04f0a00          MOV      r10,#0
000044  e01c              B        |L8.128|
                  |L8.70|
000046  f0410101          ORR      r1,r1,#1              ;554
00004a  f8c01200          STR      r1,[r0,#0x200]        ;554
00004e  2001              MOVS     r0,#1                 ;557
000050  f7fffffe          BL       CLK_WaitClockReady
000054  2000              MOVS     r0,#0                 ;560
000056  46b9              MOV      r9,r7                 ;561
000058  2102              MOVS     r1,#2                 ;564
00005a  9000              STR      r0,[sp,#0]            ;564
00005c  e7eb              B        |L8.54|
                  |L8.94|
;;;588        }
;;;589        else if((u32PllFreq <= FREQ_250MHZ) && (u32PllFreq > FREQ_125MHZ))
00005e  4843              LDR      r0,|L8.364|
000060  4a43              LDR      r2,|L8.368|
000062  4420              ADD      r0,r0,r4
000064  4290              CMP      r0,r2
000066  d803              BHI      |L8.112|
;;;590        {
;;;591            u32NO = 1;
000068  f04f0a01          MOV      r10,#1
;;;592            u32PllFreq = u32PllFreq << 1;
00006c  0064              LSLS     r4,r4,#1
00006e  e007              B        |L8.128|
                  |L8.112|
;;;593        }
;;;594        else if((u32PllFreq <= FREQ_125MHZ) && (u32PllFreq >= FREQ_50MHZ))
000070  4840              LDR      r0,|L8.372|
000072  4a41              LDR      r2,|L8.376|
000074  4420              ADD      r0,r0,r4
000076  4290              CMP      r0,r2
000078  d842              BHI      |L8.256|
;;;595        {
;;;596            u32NO = 3;
00007a  f04f0a03          MOV      r10,#3
;;;597            u32PllFreq = u32PllFreq << 2;
00007e  00a4              LSLS     r4,r4,#2
                  |L8.128|
;;;598        }
;;;599        else
;;;600        {
;;;601            /* Wrong frequency request. Just return default setting. */
;;;602            goto lexit;
;;;603        }
;;;604    
;;;605        /* Find best solution */
;;;606        u32Min = (uint32_t) - 1;
;;;607        u32MinNR = 0;
000080  2500              MOVS     r5,#0
000082  f04f32ff          MOV      r2,#0xffffffff        ;606
;;;608        u32MinNF = 0;
000086  462f              MOV      r7,r5
;;;609        for(; u32NR <= 33; u32NR++)
000088  e022              B        |L8.208|
                  |L8.138|
;;;610        {
;;;611            u32Tmp = u32PllSrcClk / u32NR;
00008a  fbb9fcf1          UDIV     r12,r9,r1
;;;612            if((u32Tmp > 1600000) && (u32Tmp < 16000000))
00008e  483b              LDR      r0,|L8.380|
000090  4b3b              LDR      r3,|L8.384|
000092  4460              ADD      r0,r0,r12
000094  4298              CMP      r0,r3
000096  d21a              BCS      |L8.206|
;;;613            {
;;;614                for(u32NF = 2; u32NF <= 513; u32NF++)
;;;615                {
;;;616                    u32Tmp2 = u32Tmp * u32NF;
;;;617                    if((u32Tmp2 >= 200000000) && (u32Tmp2 <= 500000000))
000098  f8dfe0e8          LDR      lr,|L8.388|
00009c  f8df80e8          LDR      r8,|L8.392|
0000a0  2602              MOVS     r6,#2                 ;614
                  |L8.162|
0000a2  fb0cf006          MUL      r0,r12,r6             ;616
0000a6  eb00030e          ADD      r3,r0,lr
0000aa  4543              CMP      r3,r8
0000ac  d80a              BHI      |L8.196|
;;;618                    {
;;;619                        u32Tmp3 = (u32Tmp2 > u32PllFreq) ? u32Tmp2 - u32PllFreq : u32PllFreq - u32Tmp2;
0000ae  42a0              CMP      r0,r4
0000b0  d901              BLS      |L8.182|
0000b2  1b03              SUBS     r3,r0,r4
0000b4  e000              B        |L8.184|
                  |L8.182|
0000b6  1a23              SUBS     r3,r4,r0
                  |L8.184|
;;;620                        if(u32Tmp3 < u32Min)
0000b8  4293              CMP      r3,r2
0000ba  d203              BCS      |L8.196|
;;;621                        {
;;;622                            u32Min = u32Tmp3;
0000bc  001a              MOVS     r2,r3
;;;623                            u32MinNR = u32NR;
0000be  460d              MOV      r5,r1
;;;624                            u32MinNF = u32NF;
0000c0  4637              MOV      r7,r6
;;;625    
;;;626                            /* Break when get good results */
;;;627                            if(u32Min == 0)
0000c2  d004              BEQ      |L8.206|
                  |L8.196|
0000c4  f2402001          MOV      r0,#0x201             ;614
0000c8  1c76              ADDS     r6,r6,#1              ;614
0000ca  4286              CMP      r6,r0                 ;614
0000cc  d9e9              BLS      |L8.162|
                  |L8.206|
0000ce  1c49              ADDS     r1,r1,#1              ;614
                  |L8.208|
0000d0  2921              CMP      r1,#0x21              ;609
0000d2  d9da              BLS      |L8.138|
;;;628                                break;
;;;629                        }
;;;630                    }
;;;631                }
;;;632            }
;;;633        }
;;;634    
;;;635        /* Enable and apply new PLL setting. */
;;;636        CLK->PLLCTL = u32CLK_SRC | (u32NO << 14) | ((u32MinNR - 2) << 9) | (u32MinNF - 2);
0000d4  9800              LDR      r0,[sp,#0]
0000d6  ea40318a          ORR      r1,r0,r10,LSL #14
0000da  482c              LDR      r0,|L8.396|
0000dc  eb002045          ADD      r0,r0,r5,LSL #9
0000e0  4301              ORRS     r1,r1,r0
0000e2  1eb8              SUBS     r0,r7,#2
0000e4  4301              ORRS     r1,r1,r0
0000e6  f8cb1240          STR      r1,[r11,#0x240]
;;;637    
;;;638        /* Wait for PLL clock stable */
;;;639        CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
0000ea  2004              MOVS     r0,#4
0000ec  f7fffffe          BL       CLK_WaitClockReady
;;;640    
;;;641        /* Return actual PLL output clock frequency */
;;;642        return u32PllSrcClk / ((u32NO + 1) * u32MinNR) * u32MinNF;
0000f0  f10a0001          ADD      r0,r10,#1
0000f4  4368              MULS     r0,r5,r0
0000f6  fbb9f0f0          UDIV     r0,r9,r0
0000fa  4378              MULS     r0,r7,r0
                  |L8.252|
;;;643    
;;;644    lexit:
;;;645    
;;;646        /* Apply default PLL setting and return */
;;;647        if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;648            CLK->PLLCTL = CLK_PLLCTL_72MHz_HXT; /* 72MHz */
;;;649        else
;;;650            CLK->PLLCTL = CLK_PLLCTL_72MHz_HIRC; /* 71.8848MHz */
;;;651    
;;;652        /* Wait for PLL clock stable */
;;;653        CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
;;;654    
;;;655        return CLK_GetPLLClockFreq();
;;;656    
;;;657    }
0000fc  e8bd8ff8          POP      {r3-r11,pc}
                  |L8.256|
000100  b17e              CBZ      r6,|L8.290|
000102  4923              LDR      r1,|L8.400|
                  |L8.260|
000104  f8cb1240          STR      r1,[r11,#0x240]       ;650
000108  2004              MOVS     r0,#4                 ;653
00010a  f7fffffe          BL       CLK_WaitClockReady
00010e  a021              ADR      r0,|L8.404|
000110  6800              LDR      r0,[r0,#0]            ;653
000112  9000              STR      r0,[sp,#0]            ;653
000114  f8db1240          LDR      r1,[r11,#0x240]       ;653
000118  f4112fa0          TST      r1,#0x50000           ;653
00011c  d004              BEQ      |L8.296|
00011e  2000              MOVS     r0,#0                 ;653
000120  e7ec              B        |L8.252|
                  |L8.290|
000122  f24c012e          MOV      r1,#0xc02e            ;648
000126  e7ed              B        |L8.260|
                  |L8.296|
000128  0308              LSLS     r0,r1,#12             ;648
00012a  d501              BPL      |L8.304|
00012c  4640              MOV      r0,r8                 ;648
00012e  e000              B        |L8.306|
                  |L8.304|
000130  4638              MOV      r0,r7                 ;648
                  |L8.306|
000132  038a              LSLS     r2,r1,#14             ;648
000134  d4e2              BMI      |L8.252|
000136  f3c10208          UBFX     r2,r1,#0,#9           ;648
00013a  f3c13381          UBFX     r3,r1,#14,#2          ;648
00013e  0880              LSRS     r0,r0,#2              ;648
000140  1c92              ADDS     r2,r2,#2              ;648
000142  f81d3003          LDRB     r3,[sp,r3]            ;648
000146  f3c12144          UBFX     r1,r1,#9,#5           ;648
00014a  4350              MULS     r0,r2,r0              ;648
00014c  1c89              ADDS     r1,r1,#2              ;648
00014e  fb11f103          SMULBB   r1,r1,r3              ;648
000152  fbb0f0f1          UDIV     r0,r0,r1              ;648
000156  0080              LSLS     r0,r0,#2              ;648
000158  e7d0              B        |L8.252|
;;;658    
                          ENDP

00015a  0000              DCW      0x0000
                  |L8.348|
                          DCD      0x00b71b00
                  |L8.352|
                          DCD      0x01518000
                  |L8.356|
                          DCD      0xf1194d7f
                  |L8.360|
                          DCD      0x0ee6b27f
                  |L8.364|
                          DCD      0xf88ca6bf
                  |L8.368|
                          DCD      0x0773593f
                  |L8.372|
                          DCD      0xfd050f80
                  |L8.376|
                          DCD      0x047868c0
                  |L8.380|
                          DCD      0xffe795ff
                  |L8.384|
                          DCD      0x00dbb9ff
                  |L8.388|
                          DCD      0xf4143e00
                  |L8.392|
                          DCD      0x11e1a300
                  |L8.396|
                          DCD      0xfffffc00
                  |L8.400|
                          DCD      0x0008c432
                  |L8.404|
000194  01020204          DCB      1,2,2,4

                          AREA ||i.CLK_EnableSysTick||, CODE, READONLY, ALIGN=1

                  CLK_EnableSysTick PROC
;;;710      */
;;;711    void CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count) 
000000  b530              PUSH     {r4,r5,lr}
;;;712    {
;;;713        /* Set System Tick counter disabled */
;;;714        SysTick->CTRL = 0;    
000002  f04f22e0          MOV      r2,#0xe000e000
000006  2500              MOVS     r5,#0
000008  6115              STR      r5,[r2,#0x10]
;;;715    
;;;716        /* Set System Tick clock source */
;;;717        if( u32ClkSrc == CLK_CLKSEL0_STCLKSEL_HCLK )         
00000a  2804              CMP      r0,#4
00000c  d00f              BEQ      |L9.46|
;;;718            SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
;;;719        else
;;;720            CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc; 
00000e  f04f4380          MOV      r3,#0x40000000
000012  f8d34210          LDR      r4,[r3,#0x210]
000016  f0240438          BIC      r4,r4,#0x38
00001a  4304              ORRS     r4,r4,r0
00001c  f8c34210          STR      r4,[r3,#0x210]
                  |L9.32|
;;;721    
;;;722        /* Set System Tick reload value */
;;;723        SysTick->LOAD = u32Count;   
000020  6151              STR      r1,[r2,#0x14]
;;;724        
;;;725        /* Clear System Tick current value and counter flag */
;;;726        SysTick->VAL = 0;           
000022  6195              STR      r5,[r2,#0x18]
;;;727        
;;;728        /* Set System Tick interrupt enabled and counter enabled */    
;;;729        SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;       
000024  6910              LDR      r0,[r2,#0x10]
000026  f0400003          ORR      r0,r0,#3
00002a  6110              STR      r0,[r2,#0x10]
;;;730    }
00002c  bd30              POP      {r4,r5,pc}
                  |L9.46|
00002e  6910              LDR      r0,[r2,#0x10]         ;718
000030  f0400004          ORR      r0,r0,#4              ;718
000034  6110              STR      r0,[r2,#0x10]         ;718
000036  e7f3              B        |L9.32|
;;;731    
                          ENDP


                          AREA ||i.CLK_EnableXtalRC||, CODE, READONLY, ALIGN=1

                  CLK_EnableXtalRC PROC
;;;423      */
;;;424    void CLK_EnableXtalRC(uint32_t u32ClkMask)
000000  f04f4180          MOV      r1,#0x40000000
;;;425    {
;;;426        CLK->PWRCTL |= u32ClkMask;
000004  f8d12200          LDR      r2,[r1,#0x200]
000008  4302              ORRS     r2,r2,r0
00000a  f8c12200          STR      r2,[r1,#0x200]
;;;427    }
00000e  4770              BX       lr
;;;428    
                          ENDP


                          AREA ||i.CLK_GetCPUFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetCPUFreq PROC
;;;184      */
;;;185    uint32_t CLK_GetCPUFreq(void)
000000  b510              PUSH     {r4,lr}
;;;186    {
;;;187        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;188        return SystemCoreClock;
000006  4801              LDR      r0,|L11.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;189    }
00000a  bd10              POP      {r4,pc}
;;;190    
                          ENDP

                  |L11.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHCLKFreq PROC
;;;171      */
;;;172    uint32_t CLK_GetHCLKFreq(void)
000000  b510              PUSH     {r4,lr}
;;;173    {
;;;174        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;175        return SystemCoreClock;
000006  4801              LDR      r0,|L12.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;176    }
00000a  bd10              POP      {r4,pc}
;;;177    
                          ENDP

                  |L12.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHXTFreq PROC
;;;110      */
;;;111    uint32_t CLK_GetHXTFreq(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;112    {
;;;113        if(CLK->PWRCTL & CLK_PWRCTL_HXTEN_Msk)
000004  f8d00200          LDR      r0,[r0,#0x200]
000008  07c0              LSLS     r0,r0,#31
00000a  d000              BEQ      |L13.14|
;;;114            return __HXT;
00000c  4800              LDR      r0,|L13.16|
                  |L13.14|
;;;115        else
;;;116            return 0;
;;;117    }
00000e  4770              BX       lr
;;;118    
                          ENDP

                  |L13.16|
                          DCD      0x00b71b00

                          AREA ||i.CLK_GetLXTFreq||, CODE, READONLY, ALIGN=1

                  CLK_GetLXTFreq PROC
;;;125      */
;;;126    uint32_t CLK_GetLXTFreq(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;127    {
;;;128        if(CLK->PWRCTL & CLK_PWRCTL_LXTEN_Msk)
000004  f8d00200          LDR      r0,[r0,#0x200]
000008  0780              LSLS     r0,r0,#30
00000a  d502              BPL      |L14.18|
;;;129            return __LXT;
00000c  f44f4000          MOV      r0,#0x8000
;;;130        else
;;;131            return 0;
;;;132    }
000010  4770              BX       lr
                  |L14.18|
000012  2000              MOVS     r0,#0                 ;131
000014  4770              BX       lr
;;;133    
                          ENDP


                          AREA ||i.CLK_GetPCLK0Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK0Freq PROC
;;;139      */
;;;140    uint32_t CLK_GetPCLK0Freq(void)
000000  b510              PUSH     {r4,lr}
;;;141    {
;;;142        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;143        if(CLK->CLKSEL0 & CLK_CLKSEL0_PCLK0SEL_Msk)
000006  f04f4080          MOV      r0,#0x40000000
00000a  f8d00210          LDR      r0,[r0,#0x210]
00000e  0641              LSLS     r1,r0,#25
;;;144            return SystemCoreClock / 2;
000010  4802              LDR      r0,|L15.28|
;;;145        else
;;;146            return SystemCoreClock;
000012  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000014  d500              BPL      |L15.24|
000016  0840              LSRS     r0,r0,#1              ;144
                  |L15.24|
;;;147    }
000018  bd10              POP      {r4,pc}
;;;148    
                          ENDP

00001a  0000              DCW      0x0000
                  |L15.28|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK1Freq PROC
;;;155      */
;;;156    uint32_t CLK_GetPCLK1Freq(void)
000000  b510              PUSH     {r4,lr}
;;;157    {
;;;158        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;159        if(CLK->CLKSEL0 & CLK_CLKSEL0_PCLK1SEL_Msk)
000006  f04f4080          MOV      r0,#0x40000000
00000a  f8d00210          LDR      r0,[r0,#0x210]
00000e  0601              LSLS     r1,r0,#24
;;;160            return SystemCoreClock / 2;
000010  4802              LDR      r0,|L16.28|
;;;161        else
;;;162            return SystemCoreClock;
000012  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000014  d500              BPL      |L16.24|
000016  0840              LSRS     r0,r0,#1              ;160
                  |L16.24|
;;;163    }
000018  bd10              POP      {r4,pc}
;;;164    
                          ENDP

00001a  0000              DCW      0x0000
                  |L16.28|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_Idle||, CODE, READONLY, ALIGN=2

                  CLK_Idle PROC
;;;92       */
;;;93     void CLK_Idle(void)
000000  4806              LDR      r0,|L17.28|
;;;94     {
;;;95         /* Set the processor uses sleep as its low power mode */
;;;96         SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
000002  6801              LDR      r1,[r0,#0]
000004  f0210104          BIC      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;97     
;;;98         /* Set chip in idle mode because of WFI command */
;;;99         CLK->PWRCTL &= ~CLK_PWRCTL_PDEN_Msk;
00000a  0680              LSLS     r0,r0,#26
00000c  f8d01200          LDR      r1,[r0,#0x200]
000010  f0210180          BIC      r1,r1,#0x80
000014  f8c01200          STR      r1,[r0,#0x200]
;;;100    
;;;101        /* Chip enter idle mode after CPU run WFI instruction */
;;;102        __WFI();
000018  bf30              WFI      
;;;103    }
00001a  4770              BX       lr
;;;104    
                          ENDP

                  |L17.28|
                          DCD      0xe000ed10

                          AREA ||i.CLK_PowerDown||, CODE, READONLY, ALIGN=2

                  CLK_PowerDown PROC
;;;73       */
;;;74     void CLK_PowerDown(void)
000000  4806              LDR      r0,|L18.28|
;;;75     {
;;;76         /* Set the processor uses deep sleep as its low power mode */
;;;77         SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000002  6801              LDR      r1,[r0,#0]
000004  f0410104          ORR      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;78     
;;;79         /* Set system Power-down enabled and Power-down entry condition */
;;;80         CLK->PWRCTL |= (CLK_PWRCTL_PDEN_Msk | CLK_PWRCTL_PDWTCPU_Msk);
00000a  0680              LSLS     r0,r0,#26
00000c  f8d01200          LDR      r1,[r0,#0x200]
000010  f44171c0          ORR      r1,r1,#0x180
000014  f8c01200          STR      r1,[r0,#0x200]
;;;81     
;;;82         /* Chip enter Power-down mode after CPU run WFI instruction */
;;;83         __WFI();
000018  bf30              WFI      
;;;84     }
00001a  4770              BX       lr
;;;85     
                          ENDP

                  |L18.28|
                          DCD      0xe000ed10

                          AREA ||i.CLK_SetCoreClock||, CODE, READONLY, ALIGN=2

                  CLK_SetCoreClock PROC
;;;200      */
;;;201    uint32_t CLK_SetCoreClock(uint32_t u32Hclk)
000000  b570              PUSH     {r4-r6,lr}
;;;202    {
;;;203        uint32_t u32HIRCSTB;
;;;204    
;;;205        /* Read HIRC clock source stable flag */
;;;206        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000002  f04f4580          MOV      r5,#0x40000000
000006  4604              MOV      r4,r0                 ;202
000008  f8d50250          LDR      r0,[r5,#0x250]
00000c  f0000610          AND      r6,r0,#0x10
;;;207    
;;;208        /* The range of u32Hclk is 25 MHz ~ 72 MHz */
;;;209        if(u32Hclk > FREQ_72MHZ)
000010  481d              LDR      r0,|L19.136|
000012  4284              CMP      r4,r0
000014  d802              BHI      |L19.28|
;;;210            u32Hclk = FREQ_72MHZ;
;;;211        if(u32Hclk < FREQ_25MHZ)
000016  481d              LDR      r0,|L19.140|
000018  4284              CMP      r4,r0
00001a  d200              BCS      |L19.30|
                  |L19.28|
00001c  4604              MOV      r4,r0                 ;210
                  |L19.30|
;;;212            u32Hclk = FREQ_25MHZ;
;;;213    
;;;214        /* Switch HCLK clock source to HIRC clock for safe */
;;;215        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00001e  f8d50200          LDR      r0,[r5,#0x200]
000022  f0400004          ORR      r0,r0,#4
000026  f8c50200          STR      r0,[r5,#0x200]
;;;216        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00002a  2010              MOVS     r0,#0x10
00002c  f5057500          ADD      r5,r5,#0x200
000030  f7fffffe          BL       CLK_WaitClockReady
;;;217        CLK->CLKSEL0 |= CLK_CLKSEL0_HCLKSEL_Msk;
000034  6928              LDR      r0,[r5,#0x10]
000036  f0400007          ORR      r0,r0,#7
00003a  6128              STR      r0,[r5,#0x10]
;;;218        CLK->CLKDIV0 &= (~CLK_CLKDIV0_HCLKDIV_Msk);
00003c  6a28              LDR      r0,[r5,#0x20]
00003e  f020000f          BIC      r0,r0,#0xf
000042  6228              STR      r0,[r5,#0x20]
;;;219    
;;;220        /* Configure PLL setting if HXT clock is enabled */
;;;221        if(CLK->PWRCTL & CLK_PWRCTL_HXTEN_Msk)
000044  6828              LDR      r0,[r5,#0]
000046  f5a57500          SUB      r5,r5,#0x200
00004a  07c0              LSLS     r0,r0,#31
;;;222            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HXT, (u32Hclk << 1));
;;;223    
;;;224        /* Configure PLL setting if HXT clock is not enabled */
;;;225        else
;;;226        {
;;;227            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HIRC, (u32Hclk << 1));
00004c  ea4f0144          LSL      r1,r4,#1
000050  d004              BEQ      |L19.92|
000052  2000              MOVS     r0,#0                 ;222
000054  f7fffffe          BL       CLK_EnablePLL
000058  4604              MOV      r4,r0                 ;222
00005a  e008              B        |L19.110|
                  |L19.92|
00005c  f44f2000          MOV      r0,#0x80000
000060  f7fffffe          BL       CLK_EnablePLL
000064  4604              MOV      r4,r0
;;;228    
;;;229            /* Read HIRC clock source stable flag */
;;;230            u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000066  f8d50250          LDR      r0,[r5,#0x250]
00006a  f0000610          AND      r6,r0,#0x10
                  |L19.110|
;;;231        }
;;;232    
;;;233        /* Select HCLK clock source to PLL,
;;;234           Select HCLK clock source divider as 2
;;;235           and update system core clock
;;;236        */
;;;237        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_PLL, CLK_CLKDIV0_HCLK(2));
00006e  2101              MOVS     r1,#1
000070  2002              MOVS     r0,#2
000072  f7fffffe          BL       CLK_SetHCLK
;;;238    
;;;239        /* Disable HIRC if HIRC is disabled before setting core clock */
;;;240        if(u32HIRCSTB == 0)
000076  b92e              CBNZ     r6,|L19.132|
;;;241            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000078  f8d50200          LDR      r0,[r5,#0x200]
00007c  f0200004          BIC      r0,r0,#4
000080  f8c50200          STR      r0,[r5,#0x200]
                  |L19.132|
;;;242    
;;;243        /* Return actually HCLK frequency is PLL frequency divide 2 */
;;;244        return u32Hclk >> 1;
000084  0860              LSRS     r0,r4,#1
;;;245    }
000086  bd70              POP      {r4-r6,pc}
;;;246    
                          ENDP

                  |L19.136|
                          DCD      0x044aa200
                  |L19.140|
                          DCD      0x017d7840

                          AREA ||i.CLK_SetHCLK||, CODE, READONLY, ALIGN=1

                  CLK_SetHCLK PROC
;;;260      */
;;;261    void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;262    {
;;;263        uint32_t u32HIRCSTB;
;;;264    
;;;265        /* Read HIRC clock source stable flag */
;;;266        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000004  f04f4480          MOV      r4,#0x40000000
000008  4607              MOV      r7,r0                 ;262
00000a  f8d40250          LDR      r0,[r4,#0x250]
00000e  460e              MOV      r6,r1                 ;262
000010  f0000510          AND      r5,r0,#0x10
;;;267    
;;;268        /* Switch to HIRC for Safe. Avoid HCLK too high when applying new divider. */
;;;269        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
000014  f8d40200          LDR      r0,[r4,#0x200]
000018  f0400004          ORR      r0,r0,#4
00001c  f8c40200          STR      r0,[r4,#0x200]
;;;270        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000020  2010              MOVS     r0,#0x10
000022  f5047400          ADD      r4,r4,#0x200
000026  f7fffffe          BL       CLK_WaitClockReady
;;;271        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | CLK_CLKSEL0_HCLKSEL_HIRC;
00002a  6920              LDR      r0,[r4,#0x10]
00002c  f0400007          ORR      r0,r0,#7
000030  6120              STR      r0,[r4,#0x10]
;;;272    
;;;273        /* Apply new Divider */
;;;274        CLK->CLKDIV0 = (CLK->CLKDIV0 & (~CLK_CLKDIV0_HCLKDIV_Msk)) | u32ClkDiv;
000032  6a20              LDR      r0,[r4,#0x20]
000034  f020000f          BIC      r0,r0,#0xf
000038  4330              ORRS     r0,r0,r6
00003a  6220              STR      r0,[r4,#0x20]
;;;275    
;;;276        /* Switch HCLK to new HCLK source */
;;;277        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | u32ClkSrc;
00003c  6920              LDR      r0,[r4,#0x10]
00003e  f0200007          BIC      r0,r0,#7
000042  4338              ORRS     r0,r0,r7
000044  6120              STR      r0,[r4,#0x10]
000046  f5a47400          SUB      r4,r4,#0x200
;;;278    
;;;279        /* Update System Core Clock */
;;;280        SystemCoreClockUpdate();
00004a  f7fffffe          BL       SystemCoreClockUpdate
;;;281    
;;;282        /* Disable HIRC if HIRC is disabled before switching HCLK source */
;;;283        if(u32HIRCSTB == 0)
00004e  2d00              CMP      r5,#0
000050  d105              BNE      |L20.94|
;;;284            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000052  f8d40200          LDR      r0,[r4,#0x200]
000056  f0200004          BIC      r0,r0,#4
00005a  f8c40200          STR      r0,[r4,#0x200]
                  |L20.94|
;;;285    }
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;286    
                          ENDP


                          AREA ||i.CLK_SetModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_SetModuleClock PROC
;;;372      */
;;;373    void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b570              PUSH     {r4-r6,lr}
;;;374    {
;;;375        uint32_t u32sel = 0, u32div = 0;
;;;376    
;;;377        if(MODULE_CLKDIV_Msk(u32ModuleIdx) != MODULE_NoMsk)
000002  f4103f7f          TST      r0,#0x3fc00
000006  d00d              BEQ      |L21.36|
;;;378        {
;;;379            /* Get clock divider control register address */
;;;380            u32div = (uint32_t)&CLK->CLKDIV0 + ((MODULE_CLKDIV(u32ModuleIdx)) * 4);
000008  4c10              LDR      r4,|L21.76|
00000a  f3c04381          UBFX     r3,r0,#18,#2
00000e  eb040383          ADD      r3,r4,r3,LSL #2
;;;381            /* Apply new divider */
;;;382            M32(u32div) = (M32(u32div) & (~(MODULE_CLKDIV_Msk(u32ModuleIdx) << MODULE_CLKDIV_Pos(u32ModuleIdx)))) | u32ClkDiv;
000012  681c              LDR      r4,[r3,#0]
000014  f3c02587          UBFX     r5,r0,#10,#8
000018  f3c01644          UBFX     r6,r0,#5,#5
00001c  40b5              LSLS     r5,r5,r6
00001e  43ac              BICS     r4,r4,r5
000020  4314              ORRS     r4,r4,r2
000022  601c              STR      r4,[r3,#0]
                  |L21.36|
;;;383        }
;;;384    
;;;385        if(MODULE_CLKSEL_Msk(u32ModuleIdx) != MODULE_NoMsk)
000024  0e42              LSRS     r2,r0,#25
000026  0752              LSLS     r2,r2,#29
000028  d00e              BEQ      |L21.72|
;;;386        {
;;;387            /* Get clock select control register address */
;;;388            u32sel = (uint32_t)&CLK->CLKSEL0 + ((MODULE_CLKSEL(u32ModuleIdx)) * 4);
00002a  4b08              LDR      r3,|L21.76|
00002c  f3c07201          UBFX     r2,r0,#28,#2
000030  3b10              SUBS     r3,r3,#0x10
000032  eb030282          ADD      r2,r3,r2,LSL #2
;;;389            /* Set new clock selection setting */
;;;390            M32(u32sel) = (M32(u32sel) & (~(MODULE_CLKSEL_Msk(u32ModuleIdx) << MODULE_CLKSEL_Pos(u32ModuleIdx)))) | u32ClkSrc;
000036  6813              LDR      r3,[r2,#0]
000038  f3c06442          UBFX     r4,r0,#25,#3
00003c  f3c05004          UBFX     r0,r0,#20,#5
000040  4084              LSLS     r4,r4,r0
000042  43a3              BICS     r3,r3,r4
000044  430b              ORRS     r3,r3,r1
000046  6013              STR      r3,[r2,#0]
                  |L21.72|
;;;391        }
;;;392    }
000048  bd70              POP      {r4-r6,pc}
;;;393    
                          ENDP

00004a  0000              DCW      0x0000
                  |L21.76|
                          DCD      0x40000220

                          AREA ||i.CLK_SetSysTickClockSrc||, CODE, READONLY, ALIGN=1

                  CLK_SetSysTickClockSrc PROC
;;;406      */
;;;407    void CLK_SetSysTickClockSrc(uint32_t u32ClkSrc)
000000  f04f4180          MOV      r1,#0x40000000
;;;408    {
;;;409        CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
000004  f8d12210          LDR      r2,[r1,#0x210]
000008  f0220238          BIC      r2,r2,#0x38
00000c  4302              ORRS     r2,r2,r0
00000e  f8c12210          STR      r2,[r1,#0x210]
;;;410    
;;;411    }
000012  4770              BX       lr
;;;412    
                          ENDP


                          AREA ||i.CLK_WaitClockReady||, CODE, READONLY, ALIGN=2

                  CLK_WaitClockReady PROC
;;;683      */
;;;684    uint32_t CLK_WaitClockReady(uint32_t u32ClkMask)
000000  b510              PUSH     {r4,lr}
;;;685    {    
000002  4604              MOV      r4,r0
;;;686        int32_t i32TimeOutCnt = 2160000;
000004  4908              LDR      r1,|L23.40|
;;;687    
;;;688        while((CLK->STATUS & u32ClkMask) != u32ClkMask)
000006  f04f4280          MOV      r2,#0x40000000
00000a  e005              B        |L23.24|
                  |L23.12|
;;;689        {
;;;690            if(i32TimeOutCnt-- <= 0)
00000c  1e0b              SUBS     r3,r1,#0
00000e  f1a10101          SUB      r1,r1,#1
000012  dc01              BGT      |L23.24|
;;;691                return 0;
000014  2000              MOVS     r0,#0
;;;692        }
;;;693    
;;;694        return 1;
;;;695    }
000016  bd10              POP      {r4,pc}
                  |L23.24|
000018  f8d23250          LDR      r3,[r2,#0x250]        ;688
00001c  ea340003          BICS     r0,r4,r3              ;688
000020  d1f4              BNE      |L23.12|
000022  2001              MOVS     r0,#1                 ;694
000024  bd10              POP      {r4,pc}
;;;696    
                          ENDP

000026  0000              DCW      0x0000
                  |L23.40|
                          DCD      0x0020f580

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REV16|
#line 114 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_clk_c_9b5832dc____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REVSH|
#line 128
|__asm___5_clk_c_9b5832dc____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
